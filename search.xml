<?xml version="1.0" encoding="utf-8"?>
<search> 
  
  
    
    <entry>
      <title>深入理解Go-sync.Map原理</title>
      <link href="/posts/29628/"/>
      <url>/posts/29628/</url>
      
        <content type="html"><![CDATA[<blockquote><p> Map is like a Go map[interface{}]interface{} but is safe for concurrent use</p><p> by multiple goroutines without additional locking or coordination.</p><p> Loads, stores, and deletes run in amortized constant time.</p></blockquote><p>上面一段是官方对<code>sync.Map</code> 的描述，从描述中看，<code>sync.Map</code> 跟<code>map</code> 很像，<code>sync.Map</code> 的底层实现也是依靠了<code>map</code>，但是<code>sync.Map</code> 相对于 <code>map</code> 来说，是并发安全的。</p><a id="more"></a><h1 id="结构概览"><a href="#结构概览" class="headerlink" title="结构概览"></a>结构概览</h1><h2 id="sync-Map"><a href="#sync-Map" class="headerlink" title="sync.Map"></a>sync.Map</h2><p>sync.Map的结构体了</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> Map <span class="keyword">struct</span> &#123;</span><br><span class="line">mu Mutex</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 后面是readOnly结构体，依靠map实现，仅仅只用来读</span></span><br><span class="line">read atomic.Value <span class="comment">// readOnly</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 这个map主要用来写的，部分时候也承担读的能力</span></span><br><span class="line">dirty <span class="keyword">map</span>[<span class="keyword">interface</span>&#123;&#125;]*entry</span><br><span class="line"></span><br><span class="line"><span class="comment">// 记录自从上次更新了read之后，从read读取key失败的次数</span></span><br><span class="line">misses <span class="keyword">int</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="readOnly"><a href="#readOnly" class="headerlink" title="readOnly"></a>readOnly</h2><p>sync.Map.read属性所对应的结构体了，这里不太明白为什么不把readOnly结构体的属性直接放入到sync.Map结构体里</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> readOnly <span class="keyword">struct</span> &#123;</span><br><span class="line">  <span class="comment">// 读操作所对应的map</span></span><br><span class="line">m       <span class="keyword">map</span>[<span class="keyword">interface</span>&#123;&#125;]*entry</span><br><span class="line">  <span class="comment">// dirty是否包含m中不存在的key</span></span><br><span class="line">amended <span class="keyword">bool</span> <span class="comment">// true if the dirty map contains some key not in m.</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="entry"><a href="#entry" class="headerlink" title="entry"></a>entry</h2><p>entry就是unsafe.Pointer，记录的是数据存储的真实地址</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> entry <span class="keyword">struct</span> &#123;</span><br><span class="line">p unsafe.Pointer <span class="comment">// *interface&#123;&#125;</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="结构示意图"><a href="#结构示意图" class="headerlink" title="结构示意图"></a>结构示意图</h2><p>通过上面的结构体，我们可以简单画出来一个结构示意图</p><p><img src="http://note-1253518569.cossh.myqcloud.com/20190908162253.png" alt></p><h1 id="流程分析"><a href="#流程分析" class="headerlink" title="流程分析"></a>流程分析</h1><p>我们通过下面的动图（也可以手动debug），看一下在我们执行<code>Store</code> <code>Load</code> <code>Delete</code> 的时候，这个结构体的变换是如何的，先增加一点我们的认知</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">m := sync.Map&#123;&#125;</span><br><span class="line">m.Store(<span class="string">"test1"</span>, <span class="string">"test1"</span>)</span><br><span class="line">m.Store(<span class="string">"test2"</span>, <span class="string">"test2"</span>)</span><br><span class="line">m.Store(<span class="string">"test3"</span>, <span class="string">"test3"</span>)</span><br><span class="line">m.Load(<span class="string">"test1"</span>)</span><br><span class="line">m.Load(<span class="string">"test2"</span>)</span><br><span class="line">m.Load(<span class="string">"test3"</span>)</span><br><span class="line">m.Store(<span class="string">"test4"</span>, <span class="string">"test4"</span>)</span><br><span class="line">m.Delete(<span class="string">"test"</span>)</span><br><span class="line">m.Load(<span class="string">"test"</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>以上面代码为例，我们看一下m的结构变换</p><p><img src="http://note-1253518569.cossh.myqcloud.com/20190908174811.gif" alt></p><h1 id="源码分析"><a href="#源码分析" class="headerlink" title="源码分析"></a>源码分析</h1><h2 id="新增key"><a href="#新增key" class="headerlink" title="新增key"></a>新增key</h2><p>新增一个key value，通过<code>Store</code>方法来实现</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(m *Map)</span> <span class="title">Store</span><span class="params">(key, value <span class="keyword">interface</span>&#123;&#125;)</span></span> &#123;</span><br><span class="line">read, _ := m.read.Load().(readOnly)</span><br><span class="line">  <span class="comment">// 如果这个key存在，通过tryStore更新</span></span><br><span class="line"><span class="keyword">if</span> e, ok := read.m[key]; ok &amp;&amp; e.tryStore(&amp;value) &#123;</span><br><span class="line"><span class="keyword">return</span></span><br><span class="line">&#125;</span><br><span class="line">  <span class="comment">// 走到这里有两种情况，1. key不存在 2. key对应的值被标记为expunged，read中的entry拷贝到dirty时，会将key标记为expunged，需要手动解锁</span></span><br><span class="line">m.mu.Lock()</span><br><span class="line">read, _ = m.read.Load().(readOnly)</span><br><span class="line"><span class="keyword">if</span> e, ok := read.m[key]; ok &#123;</span><br><span class="line">    <span class="comment">// 第二种情况，先解锁，然后添加到dirty</span></span><br><span class="line"><span class="keyword">if</span> e.unexpungeLocked() &#123;</span><br><span class="line"><span class="comment">// The entry was previously expunged, which implies that there is a</span></span><br><span class="line"><span class="comment">// non-nil dirty map and this entry is not in it.</span></span><br><span class="line">m.dirty[key] = e</span><br><span class="line">&#125;</span><br><span class="line">e.storeLocked(&amp;value)</span><br><span class="line">&#125; <span class="keyword">else</span> <span class="keyword">if</span> e, ok := m.dirty[key]; ok &#123;</span><br><span class="line">    <span class="comment">// m中没有，但是dirty中存在，更新dirty中的值</span></span><br><span class="line">e.storeLocked(&amp;value)</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    <span class="comment">// 如果amend==false，说明dirty和read是一致的，但是我们需要新加key到dirty里面，所以更新read.amended</span></span><br><span class="line"><span class="keyword">if</span> !read.amended &#123;</span><br><span class="line"><span class="comment">// We're adding the first new key to the dirty map.</span></span><br><span class="line"><span class="comment">// Make sure it is allocated and mark the read-only map as incomplete.</span></span><br><span class="line">      <span class="comment">// 这一步会将read中所有的key标记为 expunged</span></span><br><span class="line">m.dirtyLocked()</span><br><span class="line">m.read.Store(readOnly&#123;m: read.m, amended: <span class="literal">true</span>&#125;)</span><br><span class="line">&#125;</span><br><span class="line">m.dirty[key] = newEntry(value)</span><br><span class="line">&#125;</span><br><span class="line">m.mu.Unlock()</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="tryLock"><a href="#tryLock" class="headerlink" title="tryLock"></a>tryLock</h3><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(e *entry)</span> <span class="title">tryStore</span><span class="params">(i *<span class="keyword">interface</span>&#123;&#125;)</span> <span class="title">bool</span></span> &#123;</span><br><span class="line">p := atomic.LoadPointer(&amp;e.p)</span><br><span class="line">  <span class="comment">// 这个entry是key对应的entry，p是key对应的值，如果p被设置为expunged，不能直接更新存储</span></span><br><span class="line"><span class="keyword">if</span> p == expunged &#123;</span><br><span class="line"><span class="keyword">return</span> <span class="literal">false</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">for</span> &#123;</span><br><span class="line">    <span class="comment">// 原子更新</span></span><br><span class="line"><span class="keyword">if</span> atomic.CompareAndSwapPointer(&amp;e.p, p, unsafe.Pointer(i)) &#123;</span><br><span class="line"><span class="keyword">return</span> <span class="literal">true</span></span><br><span class="line">&#125;</span><br><span class="line">p = atomic.LoadPointer(&amp;e.p)</span><br><span class="line"><span class="keyword">if</span> p == expunged &#123;</span><br><span class="line"><span class="keyword">return</span> <span class="literal">false</span></span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>tryLock会对key对应的值，进行判断，是否被设置为了expunged，这种情况下不能直接更新</p><h3 id="dirtyLock"><a href="#dirtyLock" class="headerlink" title="dirtyLock"></a>dirtyLock</h3><p>这里就是设置 expunged 标志的地方了，而这个函数正是将read中的数据同步到dirty的操作</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(m *Map)</span> <span class="title">dirtyLocked</span><span class="params">()</span></span> &#123;</span><br><span class="line">  <span class="comment">// dirty != nil 说明dirty在上次read同步dirty数据后，已经有了修改了，这时候read的数据不一定准确，不能同步</span></span><br><span class="line"><span class="keyword">if</span> m.dirty != <span class="literal">nil</span> &#123;</span><br><span class="line"><span class="keyword">return</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">read, _ := m.read.Load().(readOnly)</span><br><span class="line">m.dirty = <span class="built_in">make</span>(<span class="keyword">map</span>[<span class="keyword">interface</span>&#123;&#125;]*entry, <span class="built_in">len</span>(read.m))</span><br><span class="line"><span class="keyword">for</span> k, e := <span class="keyword">range</span> read.m &#123;</span><br><span class="line">    <span class="comment">// 这里调用tryExpungeLocked 来给entry，即key对应的值 设置标志位</span></span><br><span class="line"><span class="keyword">if</span> !e.tryExpungeLocked() &#123;</span><br><span class="line">m.dirty[k] = e</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="tryExpungeLocked"><a href="#tryExpungeLocked" class="headerlink" title="tryExpungeLocked"></a>tryExpungeLocked</h3><p>通过原子操作，给entry，key对应的值设置 expunged 标志</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(e *entry)</span> <span class="title">tryExpungeLocked</span><span class="params">()</span> <span class="params">(isExpunged <span class="keyword">bool</span>)</span></span> &#123;</span><br><span class="line">p := atomic.LoadPointer(&amp;e.p)</span><br><span class="line"><span class="keyword">for</span> p == <span class="literal">nil</span> &#123;</span><br><span class="line"><span class="keyword">if</span> atomic.CompareAndSwapPointer(&amp;e.p, <span class="literal">nil</span>, expunged) &#123;</span><br><span class="line"><span class="keyword">return</span> <span class="literal">true</span></span><br><span class="line">&#125;</span><br><span class="line">p = atomic.LoadPointer(&amp;e.p)</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> p == expunged</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="unexpungeLocked"><a href="#unexpungeLocked" class="headerlink" title="unexpungeLocked"></a>unexpungeLocked</h3><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(e *entry)</span> <span class="title">unexpungeLocked</span><span class="params">()</span> <span class="params">(wasExpunged <span class="keyword">bool</span>)</span></span> &#123;</span><br><span class="line"><span class="keyword">return</span> atomic.CompareAndSwapPointer(&amp;e.p, expunged, <span class="literal">nil</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>根据上面分析，我们发现，在新增的时候，分为四种情况：</p><ol><li>key原先就存在于read中，获取key所对应内存地址，原子性修改</li><li>key存在，但是key所对应的值被标记为 expunged，解锁，解除标记，并更新dirty中的key，与read中进行同步，然后修改key对应的值</li><li>read中没有key，但是dirty中存在这个key，直接修改dirty中key的值</li><li>read和dirty中都没有值，先判断自从read上次同步dirty的内容后有没有再修改过dirty的内容，没有的话，先同步read和dirty的值，然后添加新的key value到dirty上面</li></ol><p>当出现第四种情况的时候，很容易产生一个困惑：既然read.amended == false，表示数据没有修改，为什么还要将read的数据同步到dirty里面呢？</p><p>这个答案在<code>Load</code> 函数里面会有答案，因为，read同步dirty的数据的时候，是直接把dirty指向map的指针交给了read.m，然后将dirty的指针设置为nil，所以，同步之后，dirty就为nil</p><p>下面看看具体的实现</p><h2 id="读取（Load）"><a href="#读取（Load）" class="headerlink" title="读取（Load）"></a>读取（Load）</h2><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(m *Map)</span> <span class="title">Load</span><span class="params">(key <span class="keyword">interface</span>&#123;&#125;)</span> <span class="params">(value <span class="keyword">interface</span>&#123;&#125;, ok <span class="keyword">bool</span>)</span></span> &#123;</span><br><span class="line">read, _ := m.read.Load().(readOnly)</span><br><span class="line">e, ok := read.m[key]</span><br><span class="line">  <span class="comment">// 如果read的map中没有，且存在修改</span></span><br><span class="line"><span class="keyword">if</span> !ok &amp;&amp; read.amended &#123;</span><br><span class="line">m.mu.Lock()</span><br><span class="line"><span class="comment">// Avoid reporting a spurious miss if m.dirty got promoted while we were</span></span><br><span class="line"><span class="comment">// blocked on m.mu. (If further loads of the same key will not miss, it's</span></span><br><span class="line"><span class="comment">// not worth copying the dirty map for this key.)</span></span><br><span class="line">    <span class="comment">// 再查找一次，有可能刚刚将dirty升级为read了</span></span><br><span class="line">read, _ = m.read.Load().(readOnly)</span><br><span class="line">e, ok = read.m[key]</span><br><span class="line"><span class="keyword">if</span> !ok &amp;&amp; read.amended &#123;</span><br><span class="line">      <span class="comment">// 如果amended 还是处于修改状态，则去dirty中查找</span></span><br><span class="line">e, ok = m.dirty[key]</span><br><span class="line"><span class="comment">// Regardless of whether the entry was present, record a miss: this key</span></span><br><span class="line"><span class="comment">// will take the slow path until the dirty map is promoted to the read</span></span><br><span class="line"><span class="comment">// map.</span></span><br><span class="line">      <span class="comment">// 增加misses的计数，在计数达到一定规则的时候，触发升级dirty为read</span></span><br><span class="line">m.missLocked()</span><br><span class="line">&#125;</span><br><span class="line">m.mu.Unlock()</span><br><span class="line">&#125;</span><br><span class="line">  <span class="comment">// read dirty中都没有找到</span></span><br><span class="line"><span class="keyword">if</span> !ok &#123;</span><br><span class="line"><span class="keyword">return</span> <span class="literal">nil</span>, <span class="literal">false</span></span><br><span class="line">&#125;</span><br><span class="line">  <span class="comment">// 找到了，通过load判断具体返回内容</span></span><br><span class="line"><span class="keyword">return</span> e.load()</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(e *entry)</span> <span class="title">load</span><span class="params">()</span> <span class="params">(value <span class="keyword">interface</span>&#123;&#125;, ok <span class="keyword">bool</span>)</span></span> &#123;</span><br><span class="line">p := atomic.LoadPointer(&amp;e.p)</span><br><span class="line">  <span class="comment">// 如果p为nil或者expunged标识，则key不存在</span></span><br><span class="line"><span class="keyword">if</span> p == <span class="literal">nil</span> || p == expunged &#123;</span><br><span class="line"><span class="keyword">return</span> <span class="literal">nil</span>, <span class="literal">false</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> *(*<span class="keyword">interface</span>&#123;&#125;)(p), <span class="literal">true</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>为什么找到了p，但是p对应的值为nil呢？这个答案在后面解析<code>Delete</code>函数的时候会被揭晓</p><h3 id="missLocked"><a href="#missLocked" class="headerlink" title="missLocked"></a>missLocked</h3><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(m *Map)</span> <span class="title">missLocked</span><span class="params">()</span></span> &#123;</span><br><span class="line">m.misses++</span><br><span class="line"><span class="keyword">if</span> m.misses &lt; <span class="built_in">len</span>(m.dirty) &#123;</span><br><span class="line"><span class="keyword">return</span></span><br><span class="line">&#125;</span><br><span class="line">  <span class="comment">// 直接把dirty的指针给read.m，并且设置dirty为nil，这里也就是 Store 函数的最后会调用 m.dirtyLocked的原因</span></span><br><span class="line">m.read.Store(readOnly&#123;m: m.dirty&#125;)</span><br><span class="line">m.dirty = <span class="literal">nil</span></span><br><span class="line">m.misses = <span class="number">0</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="删除（Delete）"><a href="#删除（Delete）" class="headerlink" title="删除（Delete）"></a>删除（Delete）</h2><p>这里的删除并不是简单的将key从map中删除</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(m *Map)</span> <span class="title">Delete</span><span class="params">(key <span class="keyword">interface</span>&#123;&#125;)</span></span> &#123;</span><br><span class="line">read, _ := m.read.Load().(readOnly)</span><br><span class="line">e, ok := read.m[key]</span><br><span class="line">  <span class="comment">// read中没有这个key，但是Map被标识修改了，那么去dirty里面看看</span></span><br><span class="line"><span class="keyword">if</span> !ok &amp;&amp; read.amended &#123;</span><br><span class="line">m.mu.Lock()</span><br><span class="line">read, _ = m.read.Load().(readOnly)</span><br><span class="line">e, ok = read.m[key]</span><br><span class="line"><span class="keyword">if</span> !ok &amp;&amp; read.amended &#123;</span><br><span class="line">      <span class="comment">// 调用delete删除dirty的map，delete会判断key是否存在的</span></span><br><span class="line"><span class="built_in">delete</span>(m.dirty, key)</span><br><span class="line">&#125;</span><br><span class="line">m.mu.Unlock()</span><br><span class="line">&#125;</span><br><span class="line">  <span class="comment">// 如果read中存在，则假删除</span></span><br><span class="line"><span class="keyword">if</span> ok &#123;</span><br><span class="line">e.<span class="built_in">delete</span>()</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(e *entry)</span> <span class="title">delete</span><span class="params">()</span> <span class="params">(hadValue <span class="keyword">bool</span>)</span></span> &#123;</span><br><span class="line"><span class="keyword">for</span> &#123;</span><br><span class="line">p := atomic.LoadPointer(&amp;e.p)</span><br><span class="line">    <span class="comment">// 已经是被删除了，不需要管了</span></span><br><span class="line"><span class="keyword">if</span> p == <span class="literal">nil</span> || p == expunged &#123;</span><br><span class="line"><span class="keyword">return</span> <span class="literal">false</span></span><br><span class="line">&#125;</span><br><span class="line">    <span class="comment">// 原子性 将key的值设置为nil</span></span><br><span class="line"><span class="keyword">if</span> atomic.CompareAndSwapPointer(&amp;e.p, p, <span class="literal">nil</span>) &#123;</span><br><span class="line"><span class="keyword">return</span> <span class="literal">true</span></span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>根据上面的逻辑可以看出，删除的时候，存在以下几种情况</p><ol><li>read中没有，且Map存在修改，则尝试删除dirty中的map中的key</li><li>read中没有，且Map不存在修改，那就是没有这个key，无需操作</li><li>read中有，尝试将key对应的值设置为nil，后面读取的时候就知道被删了，因为dirty中map的值跟read的map中的值指向的都是同一个地址空间，所以，修改了read也就是修改了dirty</li></ol><h2 id="遍历（Range）"><a href="#遍历（Range）" class="headerlink" title="遍历（Range）"></a>遍历（Range）</h2><p>遍历的逻辑就比较简单了，Map只有两种状态，被修改过和没有修改过</p><p>修改过：将dirty的指针交给read，read就是最新的数据了，然后遍历read的map</p><p>没有修改过：遍历read的map就好了</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(m *Map)</span> <span class="title">Range</span><span class="params">(f <span class="keyword">func</span>(key, value <span class="keyword">interface</span>&#123;&#125;)</span> <span class="title">bool</span>)</span> &#123;</span><br><span class="line">read, _ := m.read.Load().(readOnly)</span><br><span class="line"><span class="keyword">if</span> read.amended &#123;</span><br><span class="line">m.mu.Lock()</span><br><span class="line">read, _ = m.read.Load().(readOnly)</span><br><span class="line"><span class="keyword">if</span> read.amended &#123;</span><br><span class="line">read = readOnly&#123;m: m.dirty&#125;</span><br><span class="line">m.read.Store(read)</span><br><span class="line">m.dirty = <span class="literal">nil</span></span><br><span class="line">m.misses = <span class="number">0</span></span><br><span class="line">&#125;</span><br><span class="line">m.mu.Unlock()</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> k, e := <span class="keyword">range</span> read.m &#123;</span><br><span class="line">v, ok := e.load()</span><br><span class="line"><span class="keyword">if</span> !ok &#123;</span><br><span class="line"><span class="keyword">continue</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span> !f(k, v) &#123;</span><br><span class="line"><span class="keyword">break</span></span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="适用场景"><a href="#适用场景" class="headerlink" title="适用场景"></a>适用场景</h2><p>在官方介绍的时候，也对适用场景做了说明</p><blockquote><p>The Map type is optimized for two common use cases: </p><p>(1) when the entry for a given key is only ever written once but read many times, as in caches that only grow,</p><p> (2) when multiple goroutines read, write, and overwrite entries for disjoint sets of keys. </p><p>In these two cases, use of a Map may significantly reduce lock contention compared to a Go map paired with a separate Mutex or RWMutex.</p></blockquote><p>通过对源码的分析来理解一下产生这两条规则的原因：</p><p>读多写少：读多写少的环境下，都是从read的map去读取，不需要加锁，而写多读少的情况下，需要加锁，其次，存在将read数据同步到dirty的操作的可能性，大量的拷贝操作会大大的降低性能</p><p>读写不同的key：sync.Map是针对key的值的原子操作，相当于加锁加载 key上，所以，多个key的读写是可以同时并发的</p>]]></content>
      
      
      <categories>
          
          <category> Go </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Go </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>深入理解Go-runtime.SetFinalizer原理剖析</title>
      <link href="/posts/23555/"/>
      <url>/posts/23555/</url>
      
        <content type="html"><![CDATA[<p>finalizer是与对象关联的一个函数，通过<code>runtime.SetFinalizer</code> 来设置，它在对象被GC的时候，这个finalizer会被调用，以完成对象生命中最后一程。由于finalizer的存在，导致了对象在三色标记中，不可能被标为白色对象，也就是垃圾，所以，这个对象的生命也会得以延续一个GC周期。正如defer一样，我们也可以通过 Finalizer 完成一些类似于资源释放的操作</p><a id="more"></a><h1 id="结构概览"><a href="#结构概览" class="headerlink" title="结构概览"></a>结构概览</h1><h2 id="heap"><a href="#heap" class="headerlink" title="heap"></a>heap</h2><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> mspan <span class="keyword">struct</span> &#123;</span><br><span class="line"><span class="comment">// 当前span上所有对象的special串成链表</span></span><br><span class="line"><span class="comment">// special中有个offset，就是数据对象在span上的offset，通过offset，将数据对象和special关联起来</span></span><br><span class="line">specials    *special   <span class="comment">// linked list of special records sorted by offset.</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="special"><a href="#special" class="headerlink" title="special"></a>special</h2><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> special <span class="keyword">struct</span> &#123;</span><br><span class="line">next   *special <span class="comment">// linked list in span</span></span><br><span class="line"><span class="comment">// 数据对象在span上的offset</span></span><br><span class="line">offset <span class="keyword">uint16</span>   <span class="comment">// span offset of object</span></span><br><span class="line">kind   <span class="keyword">byte</span>     <span class="comment">// kind of special</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>##specialfinalizer</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> specialfinalizer <span class="keyword">struct</span> &#123;</span><br><span class="line">special special</span><br><span class="line">fn      *funcval <span class="comment">// May be a heap pointer.</span></span><br><span class="line"><span class="comment">// return的数据的大小</span></span><br><span class="line">nret    <span class="keyword">uintptr</span></span><br><span class="line"><span class="comment">// 第一个参数的类型</span></span><br><span class="line">fint    *_type   <span class="comment">// May be a heap pointer, but always live.</span></span><br><span class="line"><span class="comment">// 与finalizer关联的数据对象的指针类型</span></span><br><span class="line">ot      *ptrtype <span class="comment">// May be a heap pointer, but always live.</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="finalizer"><a href="#finalizer" class="headerlink" title="finalizer"></a>finalizer</h2><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> finalizer <span class="keyword">struct</span> &#123;</span><br><span class="line">fn   *funcval       <span class="comment">// function to call (may be a heap pointer)</span></span><br><span class="line">arg  unsafe.Pointer <span class="comment">// ptr to object (may be a heap pointer)</span></span><br><span class="line">nret <span class="keyword">uintptr</span>        <span class="comment">// bytes of return values from fn</span></span><br><span class="line">fint *_type         <span class="comment">// type of first argument of fn</span></span><br><span class="line">ot   *ptrtype       <span class="comment">// type of ptr to object (may be a heap pointer)</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="全局变量"><a href="#全局变量" class="headerlink" title="全局变量"></a>全局变量</h2><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> finlock mutex  <span class="comment">// protects the following variables</span></span><br><span class="line"><span class="comment">// 运行finalizer的g，只有一个g，不用的时候休眠，需要的时候再唤醒</span></span><br><span class="line"><span class="keyword">var</span> fing *g        <span class="comment">// goroutine that runs finalizers</span></span><br><span class="line"><span class="comment">// finalizer的全局队列，这里是已经设置的finalizer串成的链表</span></span><br><span class="line"><span class="keyword">var</span> finq *finblock <span class="comment">// list of finalizers that are to be executed</span></span><br><span class="line"><span class="comment">// 已经释放的finblock的链表，用finc缓存起来，以后需要使用的时候可以直接取走，避免再走一遍内存分配了</span></span><br><span class="line"><span class="keyword">var</span> finc *finblock <span class="comment">// cache of free blocks</span></span><br><span class="line"><span class="keyword">var</span> finptrmask [_FinBlockSize / sys.PtrSize / <span class="number">8</span>]<span class="keyword">byte</span></span><br><span class="line"><span class="keyword">var</span> fingwait <span class="keyword">bool</span>  <span class="comment">// fing的标志位，通过 fingwait和fingwake，来确定是否需要唤醒fing</span></span><br><span class="line"><span class="keyword">var</span> fingwake <span class="keyword">bool</span></span><br><span class="line"><span class="comment">// 所有的blocks串成的链表</span></span><br><span class="line"><span class="keyword">var</span> allfin *finblock <span class="comment">// list of all blocks</span></span><br></pre></td></tr></table></figure><h1 id="源码分析"><a href="#源码分析" class="headerlink" title="源码分析"></a>源码分析</h1><h2 id="创建finalizer"><a href="#创建finalizer" class="headerlink" title="创建finalizer"></a>创建finalizer</h2><h3 id="main"><a href="#main" class="headerlink" title="main"></a>main</h3><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line"><span class="comment">// i 就是后面说的 数据对象</span></span><br><span class="line"><span class="keyword">var</span> i = <span class="number">3</span></span><br><span class="line"><span class="comment">// 这里的func 就是后面一直说的 finalizer</span></span><br><span class="line">runtime.SetFinalizer(&amp;i, <span class="function"><span class="keyword">func</span><span class="params">(i *<span class="keyword">int</span>)</span></span> &#123;</span><br><span class="line">fmt.Println(i, *i, <span class="string">"set finalizer"</span>)</span><br><span class="line">&#125;)</span><br><span class="line">time.Sleep(time.Second * <span class="number">5</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="SetFinalizer"><a href="#SetFinalizer" class="headerlink" title="SetFinalizer"></a>SetFinalizer</h3><p>根据 数据对象 ，生成一个special对象，并绑定到 数据对象 所在的span，串联到span.specials上，并且确保fing的存在</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">SetFinalizer</span><span class="params">(obj <span class="keyword">interface</span>&#123;&#125;, finalizer <span class="keyword">interface</span>&#123;&#125;)</span></span> &#123;</span><br><span class="line"><span class="keyword">if</span> debug.sbrk != <span class="number">0</span> &#123;</span><br><span class="line"><span class="comment">// debug.sbrk never frees memory, so no finalizers run</span></span><br><span class="line"><span class="comment">// (and we don't have the data structures to record them).</span></span><br><span class="line"><span class="keyword">return</span></span><br><span class="line">&#125;</span><br><span class="line">e := efaceOf(&amp;obj)</span><br><span class="line">etyp := e._type</span><br><span class="line"><span class="comment">// ---- 省略数据校验的逻辑 ---</span></span><br><span class="line">ot := (*ptrtype)(unsafe.Pointer(etyp))</span><br><span class="line"></span><br><span class="line"><span class="comment">// find the containing object</span></span><br><span class="line"><span class="comment">// 在内存中找不到分配的地址时 base==0，setFinalizer 是在内存回收的时候调用，没有分配就不会回收</span></span><br><span class="line">base, _, _ := findObject(<span class="keyword">uintptr</span>(e.data), <span class="number">0</span>, <span class="number">0</span>)</span><br><span class="line"></span><br><span class="line">f := efaceOf(&amp;finalizer)</span><br><span class="line">ftyp := f._type</span><br><span class="line"><span class="comment">// 如果 finalizer type == nil，尝试移除（没有的话，就不需要移除了）</span></span><br><span class="line"><span class="keyword">if</span> ftyp == <span class="literal">nil</span> &#123;</span><br><span class="line"><span class="comment">// switch to system stack and remove finalizer</span></span><br><span class="line">systemstack(<span class="function"><span class="keyword">func</span><span class="params">()</span></span> &#123;</span><br><span class="line">removefinalizer(e.data)</span><br><span class="line">&#125;)</span><br><span class="line"><span class="keyword">return</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// --- 对finalizer参数数量及类型进行校验 --</span></span><br><span class="line"><span class="keyword">if</span> ftyp.kind&amp;kindMask != kindFunc &#123;</span><br><span class="line">throw(<span class="string">"runtime.SetFinalizer: second argument is "</span> + ftyp.<span class="keyword">string</span>() + <span class="string">", not a function"</span>)</span><br><span class="line">&#125;</span><br><span class="line">ft := (*functype)(unsafe.Pointer(ftyp))</span><br><span class="line"><span class="keyword">if</span> ft.dotdotdot() &#123;</span><br><span class="line">throw(<span class="string">"runtime.SetFinalizer: cannot pass "</span> + etyp.<span class="keyword">string</span>() + <span class="string">" to finalizer "</span> + ftyp.<span class="keyword">string</span>() + <span class="string">" because dotdotdot"</span>)</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span> ft.inCount != <span class="number">1</span> &#123;</span><br><span class="line">throw(<span class="string">"runtime.SetFinalizer: cannot pass "</span> + etyp.<span class="keyword">string</span>() + <span class="string">" to finalizer "</span> + ftyp.<span class="keyword">string</span>())</span><br><span class="line">&#125;</span><br><span class="line">fint := ft.in()[<span class="number">0</span>]</span><br><span class="line"><span class="keyword">switch</span> &#123;</span><br><span class="line"><span class="keyword">case</span> fint == etyp:</span><br><span class="line"><span class="comment">// ok - same type</span></span><br><span class="line"><span class="keyword">goto</span> okarg</span><br><span class="line"><span class="keyword">case</span> fint.kind&amp;kindMask == kindPtr:</span><br><span class="line"><span class="keyword">if</span> (fint.uncommon() == <span class="literal">nil</span> || etyp.uncommon() == <span class="literal">nil</span>) &amp;&amp; (*ptrtype)(unsafe.Pointer(fint)).elem == ot.elem &#123;</span><br><span class="line"><span class="comment">// ok - not same type, but both pointers,</span></span><br><span class="line"><span class="comment">// one or the other is unnamed, and same element type, so assignable.</span></span><br><span class="line"><span class="keyword">goto</span> okarg</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">case</span> fint.kind&amp;kindMask == kindInterface:</span><br><span class="line">ityp := (*interfacetype)(unsafe.Pointer(fint))</span><br><span class="line"><span class="keyword">if</span> <span class="built_in">len</span>(ityp.mhdr) == <span class="number">0</span> &#123;</span><br><span class="line"><span class="comment">// ok - satisfies empty interface</span></span><br><span class="line"><span class="keyword">goto</span> okarg</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span> _, ok := assertE2I2(ityp, *efaceOf(&amp;obj)); ok &#123;</span><br><span class="line"><span class="keyword">goto</span> okarg</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">throw(<span class="string">"runtime.SetFinalizer: cannot pass "</span> + etyp.<span class="keyword">string</span>() + <span class="string">" to finalizer "</span> + ftyp.<span class="keyword">string</span>())</span><br><span class="line">okarg:</span><br><span class="line"><span class="comment">// compute size needed for return parameters</span></span><br><span class="line"><span class="comment">// 计算返回参数的大小并进行对齐</span></span><br><span class="line">nret := <span class="keyword">uintptr</span>(<span class="number">0</span>)</span><br><span class="line"><span class="keyword">for</span> _, t := <span class="keyword">range</span> ft.out() &#123;</span><br><span class="line">nret = round(nret, <span class="keyword">uintptr</span>(t.align)) + <span class="keyword">uintptr</span>(t.size)</span><br><span class="line">&#125;</span><br><span class="line">nret = round(nret, sys.PtrSize)</span><br><span class="line"></span><br><span class="line"><span class="comment">// make sure we have a finalizer goroutine</span></span><br><span class="line"><span class="comment">// 确保 finalizer 有一个 goroutine</span></span><br><span class="line">createfing()</span><br><span class="line"></span><br><span class="line">systemstack(<span class="function"><span class="keyword">func</span><span class="params">()</span></span> &#123;</span><br><span class="line"><span class="comment">// 却换到g0，添加finalizer，并且不能重复设置</span></span><br><span class="line"><span class="keyword">if</span> !addfinalizer(e.data, (*funcval)(f.data), nret, fint, ot) &#123;</span><br><span class="line">throw(<span class="string">"runtime.SetFinalizer: finalizer already set"</span>)</span><br><span class="line">&#125;</span><br><span class="line">&#125;)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这里逻辑没什么复杂的，只是在参数、类型的判断等上面，比较的麻烦</p><h3 id="removefinalizer"><a href="#removefinalizer" class="headerlink" title="removefinalizer"></a>removefinalizer</h3><p>通过removespecial，找到数据对象p所对应的special对象，如果找到的话，释放mheap上对应的内存</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">removefinalizer</span><span class="params">(p unsafe.Pointer)</span></span> &#123;</span><br><span class="line"><span class="comment">// 根据数据p找到对应的special对象</span></span><br><span class="line">s := (*specialfinalizer)(unsafe.Pointer(removespecial(p, _KindSpecialFinalizer)))</span><br><span class="line"><span class="keyword">if</span> s == <span class="literal">nil</span> &#123;</span><br><span class="line"><span class="keyword">return</span> <span class="comment">// there wasn't a finalizer to remove</span></span><br><span class="line">&#125;</span><br><span class="line">lock(&amp;mheap_.speciallock)</span><br><span class="line"><span class="comment">// 释放找到的special所对应的内存</span></span><br><span class="line">mheap_.specialfinalizeralloc.free(unsafe.Pointer(s))</span><br><span class="line">unlock(&amp;mheap_.speciallock)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这里的函数，虽然叫removefinalizer， 但是这里暂时跟finalizer结构体没有关系，都是在跟special结构体打交道，后面的addfinalizer也是一样的</p><h3 id="removespecial"><a href="#removespecial" class="headerlink" title="removespecial"></a>removespecial</h3><p>遍历数据所在的span的specials，如果找到了指定数据p的special的话，就从specials中移除，并返回</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">removespecial</span><span class="params">(p unsafe.Pointer, kind <span class="keyword">uint8</span>)</span> *<span class="title">special</span></span> &#123;</span><br><span class="line"><span class="comment">// 找到数据p所在的span</span></span><br><span class="line">span := spanOfHeap(<span class="keyword">uintptr</span>(p))</span><br><span class="line"><span class="keyword">if</span> span == <span class="literal">nil</span> &#123;</span><br><span class="line">throw(<span class="string">"removespecial on invalid pointer"</span>)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Ensure that the span is swept.</span></span><br><span class="line"><span class="comment">// Sweeping accesses the specials list w/o locks, so we have</span></span><br><span class="line"><span class="comment">// to synchronize with it. And it's just much safer.</span></span><br><span class="line">mp := acquirem()</span><br><span class="line"><span class="comment">// 保证span被清扫过了</span></span><br><span class="line">span.ensureSwept()</span><br><span class="line"><span class="comment">// 获取数据p的偏移量，根据偏移量去寻找p对应的special</span></span><br><span class="line">offset := <span class="keyword">uintptr</span>(p) - span.base()</span><br><span class="line"></span><br><span class="line">lock(&amp;span.speciallock)</span><br><span class="line">t := &amp;span.specials</span><br><span class="line"><span class="comment">// 遍历span.specials这个链表</span></span><br><span class="line"><span class="keyword">for</span> &#123;</span><br><span class="line">s := *t</span><br><span class="line"><span class="keyword">if</span> s == <span class="literal">nil</span> &#123;</span><br><span class="line"><span class="keyword">break</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// This function is used for finalizers only, so we don't check for</span></span><br><span class="line"><span class="comment">// "interior" specials (p must be exactly equal to s-&gt;offset).</span></span><br><span class="line"><span class="keyword">if</span> offset == <span class="keyword">uintptr</span>(s.offset) &amp;&amp; kind == s.kind &#123;</span><br><span class="line"><span class="comment">// 找到了，修改指针，将当前找到的special移除</span></span><br><span class="line">*t = s.next</span><br><span class="line">unlock(&amp;span.speciallock)</span><br><span class="line">releasem(mp)</span><br><span class="line"><span class="keyword">return</span> s</span><br><span class="line">&#125;</span><br><span class="line">t = &amp;s.next</span><br><span class="line">&#125;</span><br><span class="line">unlock(&amp;span.speciallock)</span><br><span class="line">releasem(mp)</span><br><span class="line"><span class="comment">// 没有找到，就返回nil</span></span><br><span class="line"><span class="keyword">return</span> <span class="literal">nil</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="addfinalizer"><a href="#addfinalizer" class="headerlink" title="addfinalizer"></a>addfinalizer</h3><p>正好跟removefinalizer相反，这个就是根据数据对象p，创建对应的special，然后添加到span.specials链表上面</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">addfinalizer</span><span class="params">(p unsafe.Pointer, f *funcval, nret <span class="keyword">uintptr</span>, fint *_type, ot *ptrtype)</span> <span class="title">bool</span></span> &#123;</span><br><span class="line">lock(&amp;mheap_.speciallock)</span><br><span class="line"><span class="comment">// 分配出来一块内存供finalizer使用</span></span><br><span class="line">s := (*specialfinalizer)(mheap_.specialfinalizeralloc.alloc())</span><br><span class="line">unlock(&amp;mheap_.speciallock)</span><br><span class="line">s.special.kind = _KindSpecialFinalizer</span><br><span class="line">s.fn = f</span><br><span class="line">s.nret = nret</span><br><span class="line">s.fint = fint</span><br><span class="line">s.ot = ot</span><br><span class="line"><span class="keyword">if</span> addspecial(p, &amp;s.special) &#123;</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> <span class="literal">true</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// There was an old finalizer</span></span><br><span class="line"><span class="comment">// 没有添加成功，是因为p已经有了一个special对象了</span></span><br><span class="line">lock(&amp;mheap_.speciallock)</span><br><span class="line">mheap_.specialfinalizeralloc.free(unsafe.Pointer(s))</span><br><span class="line">unlock(&amp;mheap_.speciallock)</span><br><span class="line"><span class="keyword">return</span> <span class="literal">false</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="addspecial"><a href="#addspecial" class="headerlink" title="addspecial"></a>addspecial</h3><p>这里是添加special的主逻辑</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">addspecial</span><span class="params">(p unsafe.Pointer, s *special)</span> <span class="title">bool</span></span> &#123;</span><br><span class="line">span := spanOfHeap(<span class="keyword">uintptr</span>(p))</span><br><span class="line"><span class="keyword">if</span> span == <span class="literal">nil</span> &#123;</span><br><span class="line">throw(<span class="string">"addspecial on invalid pointer"</span>)</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 同 removerspecial一样，确保这个span已经清扫过了</span></span><br><span class="line">mp := acquirem()</span><br><span class="line">span.ensureSwept()</span><br><span class="line"></span><br><span class="line">offset := <span class="keyword">uintptr</span>(p) - span.base()</span><br><span class="line">kind := s.kind</span><br><span class="line"></span><br><span class="line">lock(&amp;span.speciallock)</span><br><span class="line"></span><br><span class="line"><span class="comment">// Find splice point, check for existing record.</span></span><br><span class="line">t := &amp;span.specials</span><br><span class="line"><span class="keyword">for</span> &#123;</span><br><span class="line">x := *t</span><br><span class="line"><span class="keyword">if</span> x == <span class="literal">nil</span> &#123;</span><br><span class="line"><span class="keyword">break</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span> offset == <span class="keyword">uintptr</span>(x.offset) &amp;&amp; kind == x.kind &#123;</span><br><span class="line"><span class="comment">// 已经存在了，不能在增加了，一个数据对象，只能绑定一个finalizer</span></span><br><span class="line">unlock(&amp;span.speciallock)</span><br><span class="line">releasem(mp)</span><br><span class="line"><span class="keyword">return</span> <span class="literal">false</span> <span class="comment">// already exists</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span> offset &lt; <span class="keyword">uintptr</span>(x.offset) || (offset == <span class="keyword">uintptr</span>(x.offset) &amp;&amp; kind &lt; x.kind) &#123;</span><br><span class="line"><span class="keyword">break</span></span><br><span class="line">&#125;</span><br><span class="line">t = &amp;x.next</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Splice in record, fill in offset.</span></span><br><span class="line"><span class="comment">// 添加到 specials 队列尾</span></span><br><span class="line">s.offset = <span class="keyword">uint16</span>(offset)</span><br><span class="line">s.next = *t</span><br><span class="line">*t = s</span><br><span class="line">unlock(&amp;span.speciallock)</span><br><span class="line">releasem(mp)</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> <span class="literal">true</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="createfing"><a href="#createfing" class="headerlink" title="createfing"></a>createfing</h3><p>这个函数是保证，创建了finalizer之后，有一个goroutine去运行，这里只运行一次，这个goroutine会由全局变量 fing 记录</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">createfing</span><span class="params">()</span></span> &#123;</span><br><span class="line"><span class="comment">// start the finalizer goroutine exactly once</span></span><br><span class="line"><span class="comment">// 进创建一个goroutine，进行时刻监控运行</span></span><br><span class="line"><span class="keyword">if</span> fingCreate == <span class="number">0</span> &amp;&amp; atomic.Cas(&amp;fingCreate, <span class="number">0</span>, <span class="number">1</span>) &#123;</span><br><span class="line"><span class="comment">// 开启一个goroutine运行</span></span><br><span class="line"><span class="keyword">go</span> runfinq()</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="执行finalizer"><a href="#执行finalizer" class="headerlink" title="执行finalizer"></a>执行finalizer</h2><p>在上面的 <code>createfing</code> 的会尝试创建一个goroutine去执行，接下来就分析一下执行流程吧</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">runfinq</span><span class="params">()</span></span> &#123;</span><br><span class="line"><span class="keyword">var</span> (</span><br><span class="line">frame    unsafe.Pointer</span><br><span class="line">framecap <span class="keyword">uintptr</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> &#123;</span><br><span class="line">lock(&amp;finlock)</span><br><span class="line"><span class="comment">// 获取finq 全局队列，并清空全局队列</span></span><br><span class="line">fb := finq</span><br><span class="line">finq = <span class="literal">nil</span></span><br><span class="line"><span class="keyword">if</span> fb == <span class="literal">nil</span> &#123;</span><br><span class="line"><span class="comment">// 如果全局队列为空，休眠当前g，等待被唤醒</span></span><br><span class="line">gp := getg()</span><br><span class="line">fing = gp</span><br><span class="line"><span class="comment">// 设置fing的状态标志位</span></span><br><span class="line">fingwait = <span class="literal">true</span></span><br><span class="line">goparkunlock(&amp;finlock, waitReasonFinalizerWait, traceEvGoBlock, <span class="number">1</span>)</span><br><span class="line"><span class="keyword">continue</span></span><br><span class="line">&#125;</span><br><span class="line">unlock(&amp;finlock)</span><br><span class="line"><span class="comment">// 循环执行runq链表里的fin数组</span></span><br><span class="line"><span class="keyword">for</span> fb != <span class="literal">nil</span> &#123;</span><br><span class="line"><span class="keyword">for</span> i := fb.cnt; i &gt; <span class="number">0</span>; i-- &#123;</span><br><span class="line">f := &amp;fb.fin[i<span class="number">-1</span>]</span><br><span class="line"><span class="comment">// 获取存储当前finalizer的返回数据的大小，如果比之前大，则分配</span></span><br><span class="line">framesz := unsafe.Sizeof((<span class="keyword">interface</span>&#123;&#125;)(<span class="literal">nil</span>)) + f.nret</span><br><span class="line"><span class="keyword">if</span> framecap &lt; framesz &#123;</span><br><span class="line"><span class="comment">// The frame does not contain pointers interesting for GC,</span></span><br><span class="line"><span class="comment">// all not yet finalized objects are stored in finq.</span></span><br><span class="line"><span class="comment">// If we do not mark it as FlagNoScan,</span></span><br><span class="line"><span class="comment">// the last finalized object is not collected.</span></span><br><span class="line">frame = mallocgc(framesz, <span class="literal">nil</span>, <span class="literal">true</span>)</span><br><span class="line">framecap = framesz</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> f.fint == <span class="literal">nil</span> &#123;</span><br><span class="line">throw(<span class="string">"missing type in runfinq"</span>)</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// frame is effectively uninitialized</span></span><br><span class="line"><span class="comment">// memory. That means we have to clear</span></span><br><span class="line"><span class="comment">// it before writing to it to avoid</span></span><br><span class="line"><span class="comment">// confusing the write barrier.</span></span><br><span class="line"><span class="comment">// 清空frame内存存储</span></span><br><span class="line">*(*[<span class="number">2</span>]<span class="keyword">uintptr</span>)(frame) = [<span class="number">2</span>]<span class="keyword">uintptr</span>&#123;&#125;</span><br><span class="line"><span class="keyword">switch</span> f.fint.kind &amp; kindMask &#123;</span><br><span class="line"><span class="keyword">case</span> kindPtr:</span><br><span class="line"><span class="comment">// direct use of pointer</span></span><br><span class="line">*(*unsafe.Pointer)(frame) = f.arg</span><br><span class="line"><span class="keyword">case</span> kindInterface:</span><br><span class="line">ityp := (*interfacetype)(unsafe.Pointer(f.fint))</span><br><span class="line"><span class="comment">// set up with empty interface</span></span><br><span class="line">(*eface)(frame)._type = &amp;f.ot.typ</span><br><span class="line">(*eface)(frame).data = f.arg</span><br><span class="line"><span class="keyword">if</span> <span class="built_in">len</span>(ityp.mhdr) != <span class="number">0</span> &#123;</span><br><span class="line"><span class="comment">// convert to interface with methods</span></span><br><span class="line"><span class="comment">// this conversion is guaranteed to succeed - we checked in SetFinalizer</span></span><br><span class="line">*(*iface)(frame) = assertE2I(ityp, *(*eface)(frame))</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">default</span>:</span><br><span class="line">throw(<span class="string">"bad kind in runfinq"</span>)</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 调用finalizer函数</span></span><br><span class="line">fingRunning = <span class="literal">true</span></span><br><span class="line">reflectcall(<span class="literal">nil</span>, unsafe.Pointer(f.fn), frame, <span class="keyword">uint32</span>(framesz), <span class="keyword">uint32</span>(framesz))</span><br><span class="line">fingRunning = <span class="literal">false</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// Drop finalizer queue heap references</span></span><br><span class="line"><span class="comment">// before hiding them from markroot.</span></span><br><span class="line"><span class="comment">// This also ensures these will be</span></span><br><span class="line"><span class="comment">// clear if we reuse the finalizer.</span></span><br><span class="line"><span class="comment">// 清空finalizer的属性</span></span><br><span class="line">f.fn = <span class="literal">nil</span></span><br><span class="line">f.arg = <span class="literal">nil</span></span><br><span class="line">f.ot = <span class="literal">nil</span></span><br><span class="line">atomic.Store(&amp;fb.cnt, i<span class="number">-1</span>)</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 将已经完成的finalizer放入finc以作缓存，避免再次分配内存</span></span><br><span class="line">next := fb.next</span><br><span class="line">lock(&amp;finlock)</span><br><span class="line">fb.next = finc</span><br><span class="line">finc = fb</span><br><span class="line">unlock(&amp;finlock)</span><br><span class="line">fb = next</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>看完上面的流程的时候，突然发现有点懵逼</p><ol><li>全局队列finq中是什么时候被插入数据 finalizer的？</li><li>g如果休眠了，那怎么被唤醒呢？</li></ol><p>先针对第一个问题分析：</p><p>插入队列的操作，要追溯到我们之前分析的GC  <a href="https://segmentfault.com/a/1190000020086769" target="_blank" rel="noopener">深入理解Go-垃圾回收机制</a> 了，在<code>sweep</code> 中有下面一段函数</p><h3 id="sweep"><a href="#sweep" class="headerlink" title="sweep"></a>sweep</h3><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(s *mspan)</span> <span class="title">sweep</span><span class="params">(preserve <span class="keyword">bool</span>)</span> <span class="title">bool</span></span> &#123;</span><br><span class="line">....</span><br><span class="line">specialp := &amp;s.specials</span><br><span class="line">special := *specialp</span><br><span class="line"><span class="keyword">for</span> special != <span class="literal">nil</span> &#123;</span><br><span class="line">....</span><br><span class="line"><span class="keyword">if</span> special.kind == _KindSpecialFinalizer || !hasFin &#123;</span><br><span class="line"><span class="comment">// Splice out special record.</span></span><br><span class="line">y := special</span><br><span class="line">special = special.next</span><br><span class="line">*specialp = special</span><br><span class="line"><span class="comment">// 加入全局finq队列的入口就在这里了</span></span><br><span class="line">freespecial(y, unsafe.Pointer(p), size)</span><br><span class="line">&#125;</span><br><span class="line">....</span><br><span class="line">&#125;</span><br><span class="line">....</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="freespecial"><a href="#freespecial" class="headerlink" title="freespecial"></a>freespecial</h3><p>在gc的时候，不仅要把special对应的内存释放掉，而且把specials整理创建对应dinalizer对象，并插入到 finq队列里面</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">freespecial</span><span class="params">(s *special, p unsafe.Pointer, size <span class="keyword">uintptr</span>)</span></span> &#123;</span><br><span class="line"><span class="keyword">switch</span> s.kind &#123;</span><br><span class="line"><span class="keyword">case</span> _KindSpecialFinalizer:</span><br><span class="line"><span class="comment">// 把这个finalizer加入到全局队列</span></span><br><span class="line">sf := (*specialfinalizer)(unsafe.Pointer(s))</span><br><span class="line">queuefinalizer(p, sf.fn, sf.nret, sf.fint, sf.ot)</span><br><span class="line">lock(&amp;mheap_.speciallock)</span><br><span class="line">mheap_.specialfinalizeralloc.free(unsafe.Pointer(sf))</span><br><span class="line">unlock(&amp;mheap_.speciallock)</span><br><span class="line"><span class="comment">// 下面两种情况不在分析范围内，省略</span></span><br><span class="line"><span class="keyword">case</span> _KindSpecialProfile:</span><br><span class="line">sp := (*specialprofile)(unsafe.Pointer(s))</span><br><span class="line">mProf_Free(sp.b, size)</span><br><span class="line">lock(&amp;mheap_.speciallock)</span><br><span class="line">mheap_.specialprofilealloc.free(unsafe.Pointer(sp))</span><br><span class="line">unlock(&amp;mheap_.speciallock)</span><br><span class="line"><span class="keyword">default</span>:</span><br><span class="line">throw(<span class="string">"bad special kind"</span>)</span><br><span class="line"><span class="built_in">panic</span>(<span class="string">"not reached"</span>)</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="queuefinalizer"><a href="#queuefinalizer" class="headerlink" title="queuefinalizer"></a>queuefinalizer</h3><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">queuefinalizer</span><span class="params">(p unsafe.Pointer, fn *funcval, nret <span class="keyword">uintptr</span>, fint *_type, ot *ptrtype)</span></span> &#123;</span><br><span class="line">lock(&amp;finlock)</span><br><span class="line"><span class="comment">// 如果finq为空或finq的内部数组已经满了，则从finc或重新分配 来获取block并插入到finq的链表头</span></span><br><span class="line"><span class="keyword">if</span> finq == <span class="literal">nil</span> || finq.cnt == <span class="keyword">uint32</span>(<span class="built_in">len</span>(finq.fin)) &#123;</span><br><span class="line"><span class="keyword">if</span> finc == <span class="literal">nil</span> &#123;</span><br><span class="line">finc = (*finblock)(persistentalloc(_FinBlockSize, <span class="number">0</span>, &amp;memstats.gc_sys))</span><br><span class="line">finc.alllink = allfin</span><br><span class="line">allfin = finc</span><br><span class="line"><span class="keyword">if</span> finptrmask[<span class="number">0</span>] == <span class="number">0</span> &#123;</span><br><span class="line"><span class="comment">// Build pointer mask for Finalizer array in block.</span></span><br><span class="line"><span class="comment">// Check assumptions made in finalizer1 array above.</span></span><br><span class="line"><span class="keyword">if</span> (unsafe.Sizeof(finalizer&#123;&#125;) != <span class="number">5</span>*sys.PtrSize ||</span><br><span class="line">unsafe.Offsetof(finalizer&#123;&#125;.fn) != <span class="number">0</span> ||</span><br><span class="line">unsafe.Offsetof(finalizer&#123;&#125;.arg) != sys.PtrSize ||</span><br><span class="line">unsafe.Offsetof(finalizer&#123;&#125;.nret) != <span class="number">2</span>*sys.PtrSize ||</span><br><span class="line">unsafe.Offsetof(finalizer&#123;&#125;.fint) != <span class="number">3</span>*sys.PtrSize ||</span><br><span class="line">unsafe.Offsetof(finalizer&#123;&#125;.ot) != <span class="number">4</span>*sys.PtrSize) &#123;</span><br><span class="line">throw(<span class="string">"finalizer out of sync"</span>)</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">for</span> i := <span class="keyword">range</span> finptrmask &#123;</span><br><span class="line">finptrmask[i] = finalizer1[i%<span class="built_in">len</span>(finalizer1)]</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 从finc中移除并获取链表头</span></span><br><span class="line">block := finc</span><br><span class="line">finc = block.next</span><br><span class="line"><span class="comment">// 将从finc获取到的链表挂载到finq的队列头，finq指向新的block</span></span><br><span class="line">block.next = finq</span><br><span class="line">finq = block</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 根据finq.cnt获取索引对应的block</span></span><br><span class="line">f := &amp;finq.fin[finq.cnt]</span><br><span class="line">atomic.Xadd(&amp;finq.cnt, +<span class="number">1</span>) <span class="comment">// Sync with markroots</span></span><br><span class="line"><span class="comment">// 设置相关属性</span></span><br><span class="line">f.fn = fn</span><br><span class="line">f.nret = nret</span><br><span class="line">f.fint = fint</span><br><span class="line">f.ot = ot</span><br><span class="line">f.arg = p</span><br><span class="line"><span class="comment">// 设置唤醒标志</span></span><br><span class="line">fingwake = <span class="literal">true</span></span><br><span class="line">unlock(&amp;finlock)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>至此，也就明白了，runq全局队列是怎么被填充的了</p><p>那么，第二个问题，当fing被休眠后，怎么被唤醒呢？</p><p>这里就需要追溯到，<a href="https://segmentfault.com/a/1190000020254937" target="_blank" rel="noopener">深入理解Go-goroutine的实现及Scheduler分析</a> 这篇文章了</p><h3 id="findrunnable"><a href="#findrunnable" class="headerlink" title="findrunnable"></a>findrunnable</h3><p>在 findrunnable 中有一段代码如下：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">findrunnable</span><span class="params">()</span> <span class="params">(gp *g, inheritTime <span class="keyword">bool</span>)</span></span> &#123;</span><br><span class="line"><span class="comment">// 通过状态位判断是否需要唤醒 fing， 通过wakefing来判断并返回fing</span></span><br><span class="line"><span class="keyword">if</span> fingwait &amp;&amp; fingwake &#123;</span><br><span class="line"><span class="keyword">if</span> gp := wakefing(); gp != <span class="literal">nil</span> &#123;</span><br><span class="line"><span class="comment">// 唤醒g，并从休眠出继续执行</span></span><br><span class="line">ready(gp, <span class="number">0</span>, <span class="literal">true</span>)</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="wakefing"><a href="#wakefing" class="headerlink" title="wakefing"></a>wakefing</h3><p>这里不仅会对状态位 fingwait fingwake做二次判断，而且，如果状态位符合唤醒要求的话，需要重置两个状态位</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">wakefing</span><span class="params">()</span> *<span class="title">g</span></span> &#123;</span><br><span class="line"><span class="keyword">var</span> res *g</span><br><span class="line">lock(&amp;finlock)</span><br><span class="line"><span class="keyword">if</span> fingwait &amp;&amp; fingwake &#123;</span><br><span class="line">fingwait = <span class="literal">false</span></span><br><span class="line">fingwake = <span class="literal">false</span></span><br><span class="line">res = fing</span><br><span class="line">&#125;</span><br><span class="line">unlock(&amp;finlock)</span><br><span class="line"><span class="keyword">return</span> res</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="参考文档"><a href="#参考文档" class="headerlink" title="参考文档"></a>参考文档</h1><ul><li>《Go语言学习笔记》–雨痕</li></ul>]]></content>
      
      
      <categories>
          
          <category> Go </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Go </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>深入理解Go-defer的原理剖析</title>
      <link href="/posts/54038/"/>
      <url>/posts/54038/</url>
      
        <content type="html"><![CDATA[<p><code>Defer</code> 也是Go里面比较特别的一个关键字了，主要就是用来保证在程序执行过程中，defer后面的函数都会被执行到，一般用来关闭连接、清理资源等。</p><a id="more"></a><h1 id="结构概览"><a href="#结构概览" class="headerlink" title="结构概览"></a>结构概览</h1><h2 id="defer"><a href="#defer" class="headerlink" title="defer"></a>defer</h2><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> _defer <span class="keyword">struct</span> &#123;</span><br><span class="line">   siz     <span class="keyword">int32</span>   <span class="comment">// 参数的大小</span></span><br><span class="line">   started <span class="keyword">bool</span>    <span class="comment">// 是否执行过了</span></span><br><span class="line">   sp      <span class="keyword">uintptr</span> <span class="comment">// sp at time of defer</span></span><br><span class="line">   pc      <span class="keyword">uintptr</span></span><br><span class="line">   fn      *funcval </span><br><span class="line">   _panic  *_panic <span class="comment">// defer中的panic</span></span><br><span class="line">   link    *_defer <span class="comment">// defer链表，函数执行流程中的defer，会通过 link这个 属性进行串联</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="panic"><a href="#panic" class="headerlink" title="panic"></a>panic</h2><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> _panic <span class="keyword">struct</span> &#123;</span><br><span class="line">   argp      unsafe.Pointer <span class="comment">// pointer to arguments of deferred call run during panic; cannot move - known to liblink</span></span><br><span class="line">   arg       <span class="keyword">interface</span>&#123;&#125;    <span class="comment">// argument to panic</span></span><br><span class="line">   link      *_panic        <span class="comment">// link to earlier panic</span></span><br><span class="line">   recovered <span class="keyword">bool</span>           <span class="comment">// whether this panic is over</span></span><br><span class="line">   aborted   <span class="keyword">bool</span>           <span class="comment">// the panic was aborted</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="g"><a href="#g" class="headerlink" title="g"></a>g</h2><p>因为 defer panic 都是绑定在 运行的g上的，所以这里说明一下g中与 defer panic相关的属性</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> g <span class="keyword">struct</span> &#123;</span><br><span class="line">   _panic         *_panic <span class="comment">// panic组成的链表</span></span><br><span class="line">   _defer         *_defer <span class="comment">// defer组成的先进后出的链表，同栈</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="源码分析"><a href="#源码分析" class="headerlink" title="源码分析"></a>源码分析</h1><h2 id="main"><a href="#main" class="headerlink" title="main"></a>main</h2><p>最开始，还是通过<code>go tool</code> 来分析一下，底层是通过什么函数来实现的吧</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line"><span class="keyword">defer</span> <span class="function"><span class="keyword">func</span><span class="params">()</span></span> &#123;</span><br><span class="line"><span class="built_in">recover</span>()</span><br><span class="line">&#125;()</span><br><span class="line"><span class="built_in">panic</span>(<span class="string">"error"</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>go build -gcflags=all=”-N -l” main.go</p><p>go tool objdump -s “main.main” main</p></blockquote><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">▶ go tool objdump -s &quot;main\.main&quot; main | grep CALL</span><br><span class="line">  main.go:4             0x4548d0                e81b00fdff              CALL runtime.deferproc(SB)              </span><br><span class="line">  main.go:7             0x4548f2                e8b90cfdff              CALL runtime.gopanic(SB)                </span><br><span class="line">  main.go:4             0x4548fa                e88108fdff              CALL runtime.deferreturn(SB)            </span><br><span class="line">  main.go:3             0x454909                e85282ffff              CALL runtime.morestack_noctxt(SB)       </span><br><span class="line">  main.go:5             0x4549a6                e8d511fdff              CALL runtime.gorecover(SB)              </span><br><span class="line">  main.go:4             0x4549b5                e8a681ffff              CALL runtime.morestack_noctxt(SB)</span><br></pre></td></tr></table></figure><p>综合反编译结果可以看出，<code>defer</code> 关键字首先会调用 <code>runtime.deferproc</code> 定义一个延迟调用对象，然后再函数结束前，调用 <code>runtime.deferreturn</code> 来完成 <code>defer</code> 定义的函数的调用</p><p><code>panic</code> 函数就会调用 <code>runtime.gopanic</code> 来实现相关的逻辑</p><p><code>recover</code> 则调用 <code>runtime.gorecover</code> 来实现 <em>recover</em> 的功能</p><h2 id="deferproc"><a href="#deferproc" class="headerlink" title="deferproc"></a>deferproc</h2><p>根据 defer 关键字后面定义的函数 <em>fn</em> 以及 参数的size，来创建一个延迟执行的 函数，并将这个延迟函数，挂在到当前g的 <em>_defer</em> 的链表上</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">deferproc</span><span class="params">(siz <span class="keyword">int32</span>, fn *funcval)</span></span> &#123; <span class="comment">// arguments of fn follow fn</span></span><br><span class="line">   sp := getcallersp()</span><br><span class="line">   argp := <span class="keyword">uintptr</span>(unsafe.Pointer(&amp;fn)) + unsafe.Sizeof(fn)</span><br><span class="line">   callerpc := getcallerpc()</span><br><span class="line">   <span class="comment">// 获取一个_defer对象， 并放入g._defer链表的头部</span></span><br><span class="line">   d := newdefer(siz)</span><br><span class="line"> <span class="comment">// 设置defer的fn pc sp等，后面调用</span></span><br><span class="line">   d.fn = fn</span><br><span class="line">   d.pc = callerpc</span><br><span class="line">   d.sp = sp</span><br><span class="line">   <span class="keyword">switch</span> siz &#123;</span><br><span class="line">   <span class="keyword">case</span> <span class="number">0</span>:</span><br><span class="line">      <span class="comment">// Do nothing.</span></span><br><span class="line">   <span class="keyword">case</span> sys.PtrSize:</span><br><span class="line">      <span class="comment">// _defer 后面的内存 存储 argp的地址信息</span></span><br><span class="line">      *(*<span class="keyword">uintptr</span>)(deferArgs(d)) = *(*<span class="keyword">uintptr</span>)(unsafe.Pointer(argp))</span><br><span class="line">   <span class="keyword">default</span>:</span><br><span class="line">      <span class="comment">// 如果不是指针类型的参数，把参数拷贝到 _defer 的后面的内存空间</span></span><br><span class="line">      memmove(deferArgs(d), unsafe.Pointer(argp), <span class="keyword">uintptr</span>(siz))</span><br><span class="line">   &#125;</span><br><span class="line">   return0()</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这个函数看起来比较简答，通过<code>newproc</code> 获取一个 <em>_defer</em> 的对象，并加入到当前g的 <em>_defer</em> 链表的头部，然后再把参数或参数的指针拷贝到 获取到的 <em>_defer</em>对象的 后面的内存空间</p><h3 id="newdefer"><a href="#newdefer" class="headerlink" title="newdefer"></a>newdefer</h3><p><code>newdefer</code> 的作用是获取一个<em>_defer</em>对象， 并推入 <em>g._defer</em>链表的头部</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">newdefer</span><span class="params">(siz <span class="keyword">int32</span>)</span> *_<span class="title">defer</span></span> &#123;</span><br><span class="line">   <span class="keyword">var</span> d *_defer</span><br><span class="line">   <span class="comment">// 根据 size 通过deferclass判断应该分配的 sizeclass，就类似于 内存分配预先确定好几个sizeclass，然后根据size确定sizeclass，找对应的缓存的内存块</span></span><br><span class="line">   sc := deferclass(<span class="keyword">uintptr</span>(siz))</span><br><span class="line">   gp := getg()</span><br><span class="line">   <span class="comment">// 如果sizeclass在既定的sizeclass范围内，去g绑定的p上找</span></span><br><span class="line">   <span class="keyword">if</span> sc &lt; <span class="keyword">uintptr</span>(<span class="built_in">len</span>(p&#123;&#125;.deferpool)) &#123;</span><br><span class="line">      pp := gp.m.p.ptr()</span><br><span class="line">      <span class="keyword">if</span> <span class="built_in">len</span>(pp.deferpool[sc]) == <span class="number">0</span> &amp;&amp; sched.deferpool[sc] != <span class="literal">nil</span> &#123;</span><br><span class="line">         <span class="comment">// 当前sizeclass的缓存数量==0，且不为nil，从sched上获取一批缓存</span></span><br><span class="line">         systemstack(<span class="function"><span class="keyword">func</span><span class="params">()</span></span> &#123;</span><br><span class="line">            lock(&amp;sched.deferlock)</span><br><span class="line">            <span class="keyword">for</span> <span class="built_in">len</span>(pp.deferpool[sc]) &lt; <span class="built_in">cap</span>(pp.deferpool[sc])/<span class="number">2</span> &amp;&amp; sched.deferpool[sc] != <span class="literal">nil</span> &#123;</span><br><span class="line">               d := sched.deferpool[sc]</span><br><span class="line">               sched.deferpool[sc] = d.link</span><br><span class="line">               d.link = <span class="literal">nil</span></span><br><span class="line">               pp.deferpool[sc] = <span class="built_in">append</span>(pp.deferpool[sc], d)</span><br><span class="line">            &#125;</span><br><span class="line">            unlock(&amp;sched.deferlock)</span><br><span class="line">         &#125;)</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="comment">// 如果从sched获取之后，sizeclass对应的缓存不为空，分配</span></span><br><span class="line">      <span class="keyword">if</span> n := <span class="built_in">len</span>(pp.deferpool[sc]); n &gt; <span class="number">0</span> &#123;</span><br><span class="line">         d = pp.deferpool[sc][n<span class="number">-1</span>]</span><br><span class="line">         pp.deferpool[sc][n<span class="number">-1</span>] = <span class="literal">nil</span></span><br><span class="line">         pp.deferpool[sc] = pp.deferpool[sc][:n<span class="number">-1</span>]</span><br><span class="line">      &#125;</span><br><span class="line">   &#125;</span><br><span class="line">   <span class="comment">// p和sched都没有找到 或者 没有对应的sizeclass，直接分配</span></span><br><span class="line">   <span class="keyword">if</span> d == <span class="literal">nil</span> &#123;</span><br><span class="line">      <span class="comment">// Allocate new defer+args.</span></span><br><span class="line">      systemstack(<span class="function"><span class="keyword">func</span><span class="params">()</span></span> &#123;</span><br><span class="line">         total := roundupsize(totaldefersize(<span class="keyword">uintptr</span>(siz)))</span><br><span class="line">         d = (*_defer)(mallocgc(total, deferType, <span class="literal">true</span>))</span><br><span class="line">      &#125;)</span><br><span class="line">   &#125;</span><br><span class="line">   d.siz = siz</span><br><span class="line">   <span class="comment">// 插入到g._defer的链表头</span></span><br><span class="line">   d.link = gp._defer</span><br><span class="line">   gp._defer = d</span><br><span class="line">   <span class="keyword">return</span> d</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>根据size获取sizeclass，对sizeclass进行分类缓存，这是内存分配时的思想</p><p>先去p上分配，然后批量从全局 sched上获取到本地缓存，这种二级缓存的思想真的是遍布在go源码的各个部分啊</p><h2 id="deferreturn"><a href="#deferreturn" class="headerlink" title="deferreturn"></a>deferreturn</h2><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">deferreturn</span><span class="params">(arg0 <span class="keyword">uintptr</span>)</span></span> &#123;</span><br><span class="line">   gp := getg()</span><br><span class="line">   <span class="comment">// 获取g defer链表的第一个defer，也是最后一个声明的defer</span></span><br><span class="line">   d := gp._defer</span><br><span class="line">   <span class="comment">// 没有defer，就不需要干什么事了</span></span><br><span class="line">   <span class="keyword">if</span> d == <span class="literal">nil</span> &#123;</span><br><span class="line">      <span class="keyword">return</span></span><br><span class="line">   &#125;</span><br><span class="line">   sp := getcallersp()</span><br><span class="line">   <span class="comment">// 如果defer的sp与callersp不匹配，说明defer不对应，有可能是调用了其他栈帧的延迟函数</span></span><br><span class="line">   <span class="keyword">if</span> d.sp != sp &#123;</span><br><span class="line">      <span class="keyword">return</span></span><br><span class="line">   &#125;</span><br><span class="line">   <span class="comment">// 根据d.siz，把原先存储的参数信息获取并存储到arg0里面</span></span><br><span class="line">   <span class="keyword">switch</span> d.siz &#123;</span><br><span class="line">   <span class="keyword">case</span> <span class="number">0</span>:</span><br><span class="line">      <span class="comment">// Do nothing.</span></span><br><span class="line">   <span class="keyword">case</span> sys.PtrSize:</span><br><span class="line">      *(*<span class="keyword">uintptr</span>)(unsafe.Pointer(&amp;arg0)) = *(*<span class="keyword">uintptr</span>)(deferArgs(d))</span><br><span class="line">   <span class="keyword">default</span>:</span><br><span class="line">      memmove(unsafe.Pointer(&amp;arg0), deferArgs(d), <span class="keyword">uintptr</span>(d.siz))</span><br><span class="line">   &#125;</span><br><span class="line">   fn := d.fn</span><br><span class="line">   d.fn = <span class="literal">nil</span></span><br><span class="line">   <span class="comment">// defer用过了就释放了，</span></span><br><span class="line">   gp._defer = d.link</span><br><span class="line">   freedefer(d)</span><br><span class="line">   <span class="comment">// 跳转到执行defer</span></span><br><span class="line">   jmpdefer(fn, <span class="keyword">uintptr</span>(unsafe.Pointer(&amp;arg0)))</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="freedefer"><a href="#freedefer" class="headerlink" title="freedefer"></a>freedefer</h3><p>释放defer用到的函数，应该跟调度器、内存分配的思想是一样的</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">freedefer</span><span class="params">(d *_defer)</span></span> &#123;</span><br><span class="line">   <span class="comment">// 判断defer的sizeclass</span></span><br><span class="line">   sc := deferclass(<span class="keyword">uintptr</span>(d.siz))</span><br><span class="line">   <span class="comment">// 超出既定的sizeclass范围的话，就是直接分配的内存，那就不管了</span></span><br><span class="line">   <span class="keyword">if</span> sc &gt;= <span class="keyword">uintptr</span>(<span class="built_in">len</span>(p&#123;&#125;.deferpool)) &#123;</span><br><span class="line">      <span class="keyword">return</span></span><br><span class="line">   &#125;</span><br><span class="line">   pp := getg().m.p.ptr()</span><br><span class="line">   <span class="comment">// p本地sizeclass对应的缓冲区满了，批量转移一半到全局sched</span></span><br><span class="line">   <span class="keyword">if</span> <span class="built_in">len</span>(pp.deferpool[sc]) == <span class="built_in">cap</span>(pp.deferpool[sc]) &#123;</span><br><span class="line">      <span class="comment">// 使用g0来转移</span></span><br><span class="line">      systemstack(<span class="function"><span class="keyword">func</span><span class="params">()</span></span> &#123;</span><br><span class="line">         <span class="keyword">var</span> first, last *_defer</span><br><span class="line">         <span class="keyword">for</span> <span class="built_in">len</span>(pp.deferpool[sc]) &gt; <span class="built_in">cap</span>(pp.deferpool[sc])/<span class="number">2</span> &#123;</span><br><span class="line">            n := <span class="built_in">len</span>(pp.deferpool[sc])</span><br><span class="line">            d := pp.deferpool[sc][n<span class="number">-1</span>]</span><br><span class="line">            pp.deferpool[sc][n<span class="number">-1</span>] = <span class="literal">nil</span></span><br><span class="line">            pp.deferpool[sc] = pp.deferpool[sc][:n<span class="number">-1</span>]</span><br><span class="line">            <span class="comment">// 先将需要转移的那批defer对象串成一个链表</span></span><br><span class="line">            <span class="keyword">if</span> first == <span class="literal">nil</span> &#123;</span><br><span class="line">               first = d</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">               last.link = d</span><br><span class="line">            &#125;</span><br><span class="line">            last = d</span><br><span class="line">         &#125;</span><br><span class="line">         lock(&amp;sched.deferlock)</span><br><span class="line">         <span class="comment">// 把这个链表放到sched.deferpool对应sizeclass的链表头</span></span><br><span class="line">         last.link = sched.deferpool[sc]</span><br><span class="line">         sched.deferpool[sc] = first</span><br><span class="line">         unlock(&amp;sched.deferlock)</span><br><span class="line">      &#125;)</span><br><span class="line">   &#125;</span><br><span class="line">   <span class="comment">// 清空当前要释放的defer的属性</span></span><br><span class="line">   d.siz = <span class="number">0</span></span><br><span class="line">   d.started = <span class="literal">false</span></span><br><span class="line">   d.sp = <span class="number">0</span></span><br><span class="line">   d.pc = <span class="number">0</span></span><br><span class="line">   d.link = <span class="literal">nil</span></span><br><span class="line"></span><br><span class="line">   pp.deferpool[sc] = <span class="built_in">append</span>(pp.deferpool[sc], d)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>二级缓存的思想，在 <a href="https://segmentfault.com/a/1190000020254937" target="_blank" rel="noopener">深入理解Go-goroutine的实现及Scheduler分析</a>， <a href="https://segmentfault.com/a/1190000020286676" target="_blank" rel="noopener">深入理解go-channel和select的原理</a>， <a href="https://segmentfault.com/a/1190000020086769" target="_blank" rel="noopener">深入理解Go-垃圾回收机制</a> 已经分析过了，就不再过多分析了</p><h2 id="gopanic"><a href="#gopanic" class="headerlink" title="gopanic"></a>gopanic</h2><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">gopanic</span><span class="params">(e <span class="keyword">interface</span>&#123;&#125;)</span></span> &#123;</span><br><span class="line">   gp := getg()</span><br><span class="line"></span><br><span class="line">   <span class="keyword">var</span> p _panic</span><br><span class="line">   p.arg = e</span><br><span class="line">   p.link = gp._panic</span><br><span class="line">   gp._panic = (*_panic)(noescape(unsafe.Pointer(&amp;p)))</span><br><span class="line"></span><br><span class="line">   atomic.Xadd(&amp;runningPanicDefers, <span class="number">1</span>)</span><br><span class="line">   <span class="comment">// 依次执行 g._defer链表的defer对象</span></span><br><span class="line">   <span class="keyword">for</span> &#123;</span><br><span class="line">      d := gp._defer</span><br><span class="line">      <span class="keyword">if</span> d == <span class="literal">nil</span> &#123;</span><br><span class="line">         <span class="keyword">break</span></span><br><span class="line">      &#125;</span><br><span class="line"></span><br><span class="line">      <span class="comment">// If defer was started by earlier panic or Goexit (and, since we're back here, that triggered a new panic),</span></span><br><span class="line">      <span class="comment">// take defer off list. The earlier panic or Goexit will not continue running.</span></span><br><span class="line">      <span class="comment">// 正常情况下，defer执行完成之后都会被移除，既然这个defer没有移除，原因只有两种： 1. 这个defer里面引发了panic 2. 这个defer里面引发了 runtime.Goexit，但是这个defer已经执行过了，需要移除，如果引发这个defer没有被移除是第一个原因，那么这个panic也需要移除，因为这个panic也执行过了，这里给panic增加标志位，以待后续移除</span></span><br><span class="line">      <span class="keyword">if</span> d.started &#123;</span><br><span class="line">         <span class="keyword">if</span> d._panic != <span class="literal">nil</span> &#123;</span><br><span class="line">            d._panic.aborted = <span class="literal">true</span></span><br><span class="line">         &#125;</span><br><span class="line">         d._panic = <span class="literal">nil</span></span><br><span class="line">         d.fn = <span class="literal">nil</span></span><br><span class="line">         gp._defer = d.link</span><br><span class="line">         freedefer(d)</span><br><span class="line">         <span class="keyword">continue</span></span><br><span class="line">      &#125;</span><br><span class="line">      d.started = <span class="literal">true</span></span><br><span class="line"></span><br><span class="line">      <span class="comment">// Record the panic that is running the defer.</span></span><br><span class="line">      <span class="comment">// If there is a new panic during the deferred call, that panic</span></span><br><span class="line">      <span class="comment">// will find d in the list and will mark d._panic (this panic) aborted.</span></span><br><span class="line">      <span class="comment">// 把当前的panic 绑定到这个defer上面，defer里面有可能panic，这种情况下就会进入到 上面d.started 的逻辑里面，然后把当前的panic终止掉，因为已经执行过了 </span></span><br><span class="line">      d._panic = (*_panic)(noescape(unsafe.Pointer(&amp;p)))</span><br><span class="line">      <span class="comment">// 执行defer.fn</span></span><br><span class="line">      p.argp = unsafe.Pointer(getargp(<span class="number">0</span>))</span><br><span class="line">      reflectcall(<span class="literal">nil</span>, unsafe.Pointer(d.fn), deferArgs(d), <span class="keyword">uint32</span>(d.siz), <span class="keyword">uint32</span>(d.siz))</span><br><span class="line">      p.argp = <span class="literal">nil</span></span><br><span class="line"></span><br><span class="line">      <span class="comment">// reflectcall did not panic. Remove d.</span></span><br><span class="line">      <span class="keyword">if</span> gp._defer != d &#123;</span><br><span class="line">         throw(<span class="string">"bad defer entry in panic"</span>)</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="comment">// 解决defer与panic的绑定关系，因为 defer函数已经执行完了，如果有panic或Goexit就不会执行到这里了</span></span><br><span class="line">      d._panic = <span class="literal">nil</span></span><br><span class="line">      d.fn = <span class="literal">nil</span></span><br><span class="line">      gp._defer = d.link</span><br><span class="line"></span><br><span class="line">      <span class="comment">// trigger shrinkage to test stack copy. See stack_test.go:TestStackPanic</span></span><br><span class="line">      <span class="comment">//GC()</span></span><br><span class="line"></span><br><span class="line">      pc := d.pc</span><br><span class="line">      sp := unsafe.Pointer(d.sp) <span class="comment">// must be pointer so it gets adjusted during stack copy</span></span><br><span class="line">      freedefer(d)</span><br><span class="line">      <span class="comment">// panic被recover了，就不需要继续panic了，继续执行剩余的代码</span></span><br><span class="line">      <span class="keyword">if</span> p.recovered &#123;</span><br><span class="line">         atomic.Xadd(&amp;runningPanicDefers, <span class="number">-1</span>)</span><br><span class="line"></span><br><span class="line">         gp._panic = p.link</span><br><span class="line">         <span class="comment">// Aborted panics are marked but remain on the g.panic list.</span></span><br><span class="line">         <span class="comment">// Remove them from the list.</span></span><br><span class="line">         <span class="comment">// 从panic链表中移除aborted的panic，下面解释</span></span><br><span class="line">         <span class="keyword">for</span> gp._panic != <span class="literal">nil</span> &amp;&amp; gp._panic.aborted &#123;</span><br><span class="line">            gp._panic = gp._panic.link</span><br><span class="line">         &#125;</span><br><span class="line">         <span class="keyword">if</span> gp._panic == <span class="literal">nil</span> &#123; <span class="comment">// must be done with signal</span></span><br><span class="line">            gp.sig = <span class="number">0</span></span><br><span class="line">         &#125;</span><br><span class="line">         <span class="comment">// Pass information about recovering frame to recovery.</span></span><br><span class="line">         gp.sigcode0 = <span class="keyword">uintptr</span>(sp)</span><br><span class="line">         gp.sigcode1 = pc</span><br><span class="line">         <span class="comment">// 调用recovery， 恢复当前g的调度执行</span></span><br><span class="line">         mcall(recovery)</span><br><span class="line">         throw(<span class="string">"recovery failed"</span>) <span class="comment">// mcall should not return</span></span><br><span class="line">      &#125;</span><br><span class="line">   &#125;</span><br><span class="line"> <span class="comment">// 打印panic信息</span></span><br><span class="line">   preprintpanics(gp._panic)</span><br><span class="line"> <span class="comment">// panic</span></span><br><span class="line">   fatalpanic(gp._panic) <span class="comment">// should not return</span></span><br><span class="line">   *(*<span class="keyword">int</span>)(<span class="literal">nil</span>) = <span class="number">0</span>      <span class="comment">// not reached</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这里解释一下 <code>gp._panic.aborted</code> 的作用，以下面为例</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">   <span class="keyword">defer</span> <span class="function"><span class="keyword">func</span><span class="params">()</span></span> &#123; <span class="comment">// defer1</span></span><br><span class="line">      <span class="built_in">recover</span>()</span><br><span class="line">   &#125;()</span><br><span class="line">   panic1()</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">panic1</span><span class="params">()</span></span> &#123;</span><br><span class="line">   <span class="keyword">defer</span> <span class="function"><span class="keyword">func</span><span class="params">()</span></span> &#123;  <span class="comment">// defer2</span></span><br><span class="line">      <span class="built_in">panic</span>(<span class="string">"error1"</span>) <span class="comment">// panic2</span></span><br><span class="line">   &#125;()</span><br><span class="line">   <span class="built_in">panic</span>(<span class="string">"error"</span>)  <span class="comment">// panic1</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ol><li><p>当执行到 <code>panic(&quot;error&quot;)</code> 时</p><p>g._defer链表： g._defer-&gt;defer2-&gt;defer1</p><p>g._panic链表：g._panic-&gt;panic1</p></li><li><p>当执行到 <code>panic(&quot;error1&quot;)</code> 时 </p><p>g._defer链表： g._defer-&gt;defer2-&gt;defer1</p><p>g._panic链表：g._panic-&gt;panic2-&gt;panic1</p></li><li><p>继续执行到 defer1 函数内部，进行recover()</p><p>此时会去恢复 panic2 引起的 <em>panic</em>， panic2.recovered = true，应该顺着g._panic链表继续处理下一个panic了，但是我们可以发现 <code>panic1</code> 已经执行过了，这也就是下面的代码的逻辑了，去掉已经执行过的panic</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> gp._panic != <span class="literal">nil</span> &amp;&amp; gp._panic.aborted &#123;</span><br><span class="line">   gp._panic = gp._panic.link</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ol><p>panic的逻辑可以梳理一下：</p><p>程序在遇到panic的时候，就不再继续执行下去了，先把当前<code>panic</code> 挂载到 <code>g._panic</code> 链表上，开始遍历当前g的<code>g._defer</code>链表，然后执行<code>_defer</code>对象定义的函数等，如果 defer函数在调用过程中又发生了 panic，则又执行到了 <code>gopanic</code>函数，最后，循环打印所有panic的信息，并退出当前g。然而，如果调用defer的过程中，遇到了recover，则继续进行调度（mcall(recovery)）。</p><h3 id="recovery"><a href="#recovery" class="headerlink" title="recovery"></a>recovery</h3><p>恢复一个被panic的g，重新进入并继续执行调度</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">recovery</span><span class="params">(gp *g)</span></span> &#123;</span><br><span class="line">   <span class="comment">// Info about defer passed in G struct.</span></span><br><span class="line">   sp := gp.sigcode0</span><br><span class="line">   pc := gp.sigcode1</span><br><span class="line">   <span class="comment">// Make the deferproc for this d return again,</span></span><br><span class="line">   <span class="comment">// this time returning 1.  The calling function will</span></span><br><span class="line">   <span class="comment">// jump to the standard return epilogue.</span></span><br><span class="line">   <span class="comment">// 记录defer返回的sp pc</span></span><br><span class="line">   gp.sched.sp = sp</span><br><span class="line">   gp.sched.pc = pc</span><br><span class="line">   gp.sched.lr = <span class="number">0</span></span><br><span class="line">   gp.sched.ret = <span class="number">1</span></span><br><span class="line">   <span class="comment">// 重新恢复执行调度</span></span><br><span class="line">   gogo(&amp;gp.sched)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="gorecover"><a href="#gorecover" class="headerlink" title="gorecover"></a>gorecover</h2><p><code>gorecovery</code> 仅仅只是设置了 <code>g._panic.recovered</code> 的标志位</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">gorecover</span><span class="params">(argp <span class="keyword">uintptr</span>)</span> <span class="title">interface</span></span>&#123;&#125; &#123;</span><br><span class="line">   gp := getg()</span><br><span class="line">   p := gp._panic</span><br><span class="line">   <span class="comment">// 需要根据 argp的地址，判断是否在defer函数中被调用</span></span><br><span class="line">   <span class="keyword">if</span> p != <span class="literal">nil</span> &amp;&amp; !p.recovered &amp;&amp; argp == <span class="keyword">uintptr</span>(p.argp) &#123;</span><br><span class="line">      <span class="comment">// 设置标志位，上面gopanic中会对这个标志位做判断</span></span><br><span class="line">      p.recovered = <span class="literal">true</span></span><br><span class="line">      <span class="keyword">return</span> p.arg</span><br><span class="line">   &#125;</span><br><span class="line">   <span class="keyword">return</span> <span class="literal">nil</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="goexit"><a href="#goexit" class="headerlink" title="goexit"></a>goexit</h2><p>我们还忽略了一个点，当我们手动调用 <code>runtime.Goexit()</code> 退出的时候，defer函数也会执行，我们分析一下这种情况</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">Goexit</span><span class="params">()</span></span> &#123;</span><br><span class="line"><span class="comment">// Run all deferred functions for the current goroutine.</span></span><br><span class="line"><span class="comment">// This code is similar to gopanic, see that implementation</span></span><br><span class="line"><span class="comment">// for detailed comments.</span></span><br><span class="line">gp := getg()</span><br><span class="line">  <span class="comment">// 遍历defer链表</span></span><br><span class="line"><span class="keyword">for</span> &#123;</span><br><span class="line">d := gp._defer</span><br><span class="line"><span class="keyword">if</span> d == <span class="literal">nil</span> &#123;</span><br><span class="line"><span class="keyword">break</span></span><br><span class="line">&#125;</span><br><span class="line">    <span class="comment">// 如果 defer已经执行过了，与defer绑定的panic 终止掉</span></span><br><span class="line"><span class="keyword">if</span> d.started &#123;</span><br><span class="line"><span class="keyword">if</span> d._panic != <span class="literal">nil</span> &#123;</span><br><span class="line">d._panic.aborted = <span class="literal">true</span></span><br><span class="line">d._panic = <span class="literal">nil</span></span><br><span class="line">&#125;</span><br><span class="line">d.fn = <span class="literal">nil</span></span><br><span class="line">      <span class="comment">// 从defer链表中移除</span></span><br><span class="line">gp._defer = d.link</span><br><span class="line">      <span class="comment">// 释放defer</span></span><br><span class="line">freedefer(d)</span><br><span class="line"><span class="keyword">continue</span></span><br><span class="line">&#125;</span><br><span class="line">    <span class="comment">// 调用defer内部函数</span></span><br><span class="line">d.started = <span class="literal">true</span></span><br><span class="line">reflectcall(<span class="literal">nil</span>, unsafe.Pointer(d.fn), deferArgs(d), <span class="keyword">uint32</span>(d.siz), <span class="keyword">uint32</span>(d.siz))</span><br><span class="line"><span class="keyword">if</span> gp._defer != d &#123;</span><br><span class="line">throw(<span class="string">"bad defer entry in Goexit"</span>)</span><br><span class="line">&#125;</span><br><span class="line">d._panic = <span class="literal">nil</span></span><br><span class="line">d.fn = <span class="literal">nil</span></span><br><span class="line">gp._defer = d.link</span><br><span class="line">freedefer(d)</span><br><span class="line"><span class="comment">// Note: we ignore recovers here because Goexit isn't a panic</span></span><br><span class="line">&#125;</span><br><span class="line">  <span class="comment">// 调用goexit0，清除当前g的属性，重新进入调度</span></span><br><span class="line">goexit1()</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="图示解析"><a href="#图示解析" class="headerlink" title="图示解析"></a>图示解析</h2><p>源码这一块阅读起来难度并不是很大，如果还有什么疑惑，希望下面的一副动图能解开你的疑惑</p><p><img src="http://note-1253518569.cossh.myqcloud.com/20190905214602.gif" alt></p><p>作图作的略拙劣，见谅</p><p>步骤解析：</p><ol><li>L3: 生成一个defer1，放到g._defer链表上</li><li>L11: 生成一个defer2，挂载到g._defer链表上</li><li>L14: panic1 调用 gopanic，将当前panic放到g._panic链表上</li><li>L14: 因为panic1，从g._defer 链表头部提取到defer2，开始执行</li><li>L12: 执行defer2，又一个panic，挂载到g._panic链表上</li><li>L12: 因为panic2，从g._defer链表头部提取到defer2，发现defer2已经执行过了移出链表，，且defer2是因为panic1而触发的，跳过defer2，并abort panic1</li><li>L12: 继续提取g._defer链表的下一个，提取到defer1</li><li>L5: defer1 执行recover，recover掉panic2，移除链表，判断下一个panic，即panic1，panic1已经被defer2 aborted掉了，移除panic1</li><li>defer1 执行完了，移除defer1</li></ol><h1 id="关联文档"><a href="#关联文档" class="headerlink" title="关联文档"></a>关联文档</h1><ul><li>二级缓存，sizeclass:  <a href="https://segmentfault.com/a/1190000020086769" target="_blank" rel="noopener">深入理解Go-垃圾回收机制</a></li><li>gogo goexit0 调度: <a href="https://segmentfault.com/a/1190000020254937" target="_blank" rel="noopener">深入理解Go-goroutine的实现及Scheduler分析</a></li></ul><h1 id="参考文档"><a href="#参考文档" class="headerlink" title="参考文档"></a>参考文档</h1><ul><li>《Go语言学习笔记》–雨痕</li></ul>]]></content>
      
      
      <categories>
          
          <category> Go </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Go </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>深入理解go-channel和select的原理</title>
      <link href="/posts/8685/"/>
      <url>/posts/8685/</url>
      
        <content type="html"><![CDATA[<p>Go最吸引人的两个地方，除了goroutine，也就是channel了，同时，我一直很纳闷，select到底是怎么实现的？跟我之前的文章一样，部分无关的代码直接省略</p><a id="more"></a><h1 id="结构概览"><a href="#结构概览" class="headerlink" title="结构概览"></a>结构概览</h1><h2 id="hchan"><a href="#hchan" class="headerlink" title="hchan"></a>hchan</h2><p>这个就是channel的结构体了</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> hchan <span class="keyword">struct</span> &#123;</span><br><span class="line">   qcount   <span class="keyword">uint</span>           <span class="comment">// 队列中数据总量</span></span><br><span class="line">   dataqsiz <span class="keyword">uint</span>           <span class="comment">// 环形队列的大小，&gt; 0表示有缓冲，= 0表示无缓冲</span></span><br><span class="line">   buf      unsafe.Pointer <span class="comment">// 指向元素数组的指针</span></span><br><span class="line">   elemsize <span class="keyword">uint16</span>         <span class="comment">// 单个元素的大小</span></span><br><span class="line">   closed   <span class="keyword">uint32</span>         <span class="comment">// 表明是否close了</span></span><br><span class="line">   elemtype *_type  <span class="comment">// 元素类型，后面写interface的时候再具体介绍</span></span><br><span class="line">   sendx    <span class="keyword">uint</span>    <span class="comment">// send数组的索引, c &lt;- i</span></span><br><span class="line">   recvx    <span class="keyword">uint</span>    <span class="comment">// receive 数组的索引 &lt;- c</span></span><br><span class="line">   recvq    waitq   <span class="comment">// 等待recv 数据的goroutine的链表</span></span><br><span class="line">   sendq    waitq   <span class="comment">// 等待send数据的goroutine链表</span></span><br><span class="line">   lock mutex</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="waitq"><a href="#waitq" class="headerlink" title="waitq"></a>waitq</h2><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> waitq <span class="keyword">struct</span> &#123;</span><br><span class="line">   first *sudog</span><br><span class="line">   last  *sudog</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="sudog"><a href="#sudog" class="headerlink" title="sudog"></a>sudog</h2><p>sudog 代表了一个在等待中的g</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> sudog <span class="keyword">struct</span> &#123;</span><br><span class="line">   g *g</span><br><span class="line"></span><br><span class="line">   <span class="comment">// isSelect indicates g is participating in a select, so</span></span><br><span class="line">   <span class="comment">// g.selectDone must be CAS'd to win the wake-up race.</span></span><br><span class="line">   isSelect <span class="keyword">bool</span></span><br><span class="line">   next     *sudog</span><br><span class="line">   prev     *sudog</span><br><span class="line">   elem     unsafe.Pointer <span class="comment">// 数据元素， c &lt;- 1, 此时就是 1</span></span><br><span class="line"></span><br><span class="line">   <span class="comment">// The following fields are never accessed concurrently.</span></span><br><span class="line">   <span class="comment">// For channels, waitlink is only accessed by g.</span></span><br><span class="line">   <span class="comment">// For semaphores, all fields (including the ones above)</span></span><br><span class="line">   <span class="comment">// are only accessed when holding a semaRoot lock.</span></span><br><span class="line"></span><br><span class="line">   acquiretime <span class="keyword">int64</span></span><br><span class="line">   releasetime <span class="keyword">int64</span></span><br><span class="line">   ticket      <span class="keyword">uint32</span></span><br><span class="line">   parent      *sudog <span class="comment">// semaRoot binary tree</span></span><br><span class="line">   waitlink    *sudog <span class="comment">// g.waiting list or semaRoot</span></span><br><span class="line">   waittail    *sudog <span class="comment">// semaRoot</span></span><br><span class="line">   c           *hchan <span class="comment">// channel</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="hcase"><a href="#hcase" class="headerlink" title="hcase"></a>hcase</h2><p>这个是 select 中一个case生成的结构体</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> scase <span class="keyword">struct</span> &#123;</span><br><span class="line">   c           *hchan         <span class="comment">// chan</span></span><br><span class="line">   elem        unsafe.Pointer <span class="comment">// data element</span></span><br><span class="line">   kind        <span class="keyword">uint16</span>  <span class="comment">// 当前case的类型，nil recv send 还是 default</span></span><br><span class="line">   pc          <span class="keyword">uintptr</span> <span class="comment">// race pc (for race detector / msan)</span></span><br><span class="line">   releasetime <span class="keyword">int64</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>通过上面的结构，我们可以看出，channel的内部实质就是一个缓冲池+两个队列（send recv），那么数据是如何交互的呢，网上有个示意图，展示的还是比较形象的</p><h2 id="图示"><a href="#图示" class="headerlink" title="图示"></a>图示</h2><h3 id="无缓冲（同步）"><a href="#无缓冲（同步）" class="headerlink" title="无缓冲（同步）"></a>无缓冲（同步）</h3><p><img src="http://note-1253518569.cossh.myqcloud.com/20190903183359.png" alt></p><h3 id="带缓冲（异步）"><a href="#带缓冲（异步）" class="headerlink" title="带缓冲（异步）"></a>带缓冲（异步）</h3><p><img src="http://note-1253518569.cossh.myqcloud.com/20190903183427.png" alt></p><p>综合 上面的结构和图示，大概可以推测出 channel 的send recv流程</p><ol><li>如果是recv（&lt;-channel ）请求，则先去判断一个sendq队列里有没有人等待这放数据<ol><li>如果sendq队列不为空且缓冲池不为空，那么这个sendq队列是在等待着放数据，recv的这个g从缓冲池拿数据，然后把sendq的第一个g携带的数据放入到buf缓冲池里面即可</li><li>如果sendq不为空但是缓冲池为空，那么这个是不带缓冲池的chan，我从sendq里面拿第一个g的数据就ok了</li><li>如果sendq为空，那就去缓冲池看看，缓冲池有数据，那就拿了就走了</li><li>如果sendq为空，缓冲池也没有数据，那就在这等着吧</li></ol></li><li>如果send，流程跟recv是一样的</li><li>如果此时 channel 被close了，唤醒所有等待的队列 （sendq 或 recvq）里面的等待的g，告诉他们channel.close = true</li></ol><p>接下来就是跟踪源码，证明及纠正猜想了</p><h1 id="源码分析"><a href="#源码分析" class="headerlink" title="源码分析"></a>源码分析</h1><h2 id="收发"><a href="#收发" class="headerlink" title="收发"></a>收发</h2><h3 id="main"><a href="#main" class="headerlink" title="main"></a>main</h3><p>我们使用 go tool 工具分析一下，channel 生成， c &lt;- i， &lt;- c 在底层都是通过什么方法实现的</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">c1 := <span class="built_in">make</span>(<span class="keyword">chan</span> <span class="keyword">int</span>)</span><br><span class="line">c2 := <span class="built_in">make</span>(<span class="keyword">chan</span> <span class="keyword">int</span>, <span class="number">2</span>)</span><br><span class="line"><span class="keyword">go</span> <span class="function"><span class="keyword">func</span><span class="params">()</span></span> &#123;</span><br><span class="line">c1 &lt;- <span class="number">1</span></span><br><span class="line">c2 &lt;- <span class="number">2</span></span><br><span class="line">&#125;()</span><br><span class="line">&lt;-c1</span><br><span class="line">&lt;-c2</span><br><span class="line"><span class="built_in">close</span>(c1)</span><br><span class="line"><span class="built_in">close</span>(c2)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>go build -gcflags=all=”-N -l” main.go</p><p>go tool objdump -s “main.main” main</p></blockquote><p>我们把 CALL 过滤出来后</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">▶ <span class="keyword">go</span> tool objdump -s <span class="string">"main\.main"</span> main | grep CALL</span><br><span class="line">  main.<span class="keyword">go</span>:<span class="number">4</span>             <span class="number">0x4548d</span>5                e806fbfaff              CALL runtime.makechan(SB)               </span><br><span class="line">  main.<span class="keyword">go</span>:<span class="number">5</span>             <span class="number">0x4548f</span>8                e8e3fafaff              CALL runtime.makechan(SB)               </span><br><span class="line">  main.<span class="keyword">go</span>:<span class="number">6</span>             <span class="number">0x454929</span>                e822a1fdff              CALL runtime.newproc(SB)                </span><br><span class="line">  main.<span class="keyword">go</span>:<span class="number">10</span>            <span class="number">0x454940</span>                e81b08fbff              CALL runtime.chanrecv1(SB)              </span><br><span class="line">  main.<span class="keyword">go</span>:<span class="number">11</span>            <span class="number">0x454957</span>                e80408fbff              CALL runtime.chanrecv1(SB)              </span><br><span class="line">  main.<span class="keyword">go</span>:<span class="number">12</span>            <span class="number">0x454965</span>                e82605fbff              CALL runtime.closechan(SB)              </span><br><span class="line">  main.<span class="keyword">go</span>:<span class="number">13</span>            <span class="number">0x454973</span>                e81805fbff              CALL runtime.closechan(SB)              </span><br><span class="line">  main.<span class="keyword">go</span>:<span class="number">3</span>             <span class="number">0x454982</span>                e8d981ffff              CALL runtime.morestack_noctxt(SB)       </span><br><span class="line">  main.<span class="keyword">go</span>:<span class="number">7</span>             <span class="number">0x454a32</span>                e899fcfaff              CALL runtime.chansend1(SB)              </span><br><span class="line">  main.<span class="keyword">go</span>:<span class="number">8</span>             <span class="number">0x454a4c</span>                e87ffcfaff              CALL runtime.chansend1(SB)              </span><br><span class="line">  main.<span class="keyword">go</span>:<span class="number">6</span>             <span class="number">0x454a5b</span>                e80081ffff              CALL runtime.morestack_noctxt(SB)</span><br></pre></td></tr></table></figure><ul><li>makechan: 创建channel的函数，有无缓冲区的都是一样的</li><li>chanrecv1: &lt;- c1 时，调用的函数</li><li>closechan: close(c1) 时调用的函数，关闭channel使用</li><li>chansend1: c1 &lt;- 1 时，也就是发送数据用到的函数</li></ul><h3 id="makechan"><a href="#makechan" class="headerlink" title="makechan"></a>makechan</h3><p>创建channel这一块主要就是给结构体和bug缓冲池分配内存，然后初始化一下hchan的结构体</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">makechan</span><span class="params">(t *chantype, size <span class="keyword">int</span>)</span> *<span class="title">hchan</span></span> &#123;</span><br><span class="line">elem := t.elem</span><br><span class="line"></span><br><span class="line"><span class="comment">// compiler checks this but be safe.</span></span><br><span class="line"><span class="comment">// 校验elem的大小限制</span></span><br><span class="line"><span class="keyword">if</span> elem.size &gt;= <span class="number">1</span>&lt;&lt;<span class="number">16</span> &#123;</span><br><span class="line">throw(<span class="string">"makechan: invalid channel element type"</span>)</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 对齐限制</span></span><br><span class="line"><span class="keyword">if</span> hchanSize%maxAlign != <span class="number">0</span> || elem.align &gt; maxAlign &#123;</span><br><span class="line">throw(<span class="string">"makechan: bad alignment"</span>)</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// size，即make(chan int, 2)中的2，默认不传为0， 判断size的上限和下限</span></span><br><span class="line"><span class="keyword">if</span> size &lt; <span class="number">0</span> || <span class="keyword">uintptr</span>(size) &gt; maxSliceCap(elem.size) || <span class="keyword">uintptr</span>(size)*elem.size &gt; maxAlloc-hchanSize &#123;</span><br><span class="line"><span class="built_in">panic</span>(plainError(<span class="string">"makechan: size out of range"</span>))</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> c *hchan</span><br><span class="line"><span class="keyword">switch</span> &#123;</span><br><span class="line"><span class="keyword">case</span> size == <span class="number">0</span> || elem.size == <span class="number">0</span>:</span><br><span class="line"><span class="comment">// 队列或者元素size为0，不分配缓冲池</span></span><br><span class="line"><span class="comment">// Queue or element size is zero.</span></span><br><span class="line">c = (*hchan)(mallocgc(hchanSize, <span class="literal">nil</span>, <span class="literal">true</span>))</span><br><span class="line"><span class="comment">// Race detector uses this location for synchronization.</span></span><br><span class="line"><span class="comment">// buf指向自身，没有分配内存</span></span><br><span class="line">c.buf = c.raceaddr()</span><br><span class="line"><span class="keyword">case</span> elem.kind&amp;kindNoPointers != <span class="number">0</span>:</span><br><span class="line"><span class="comment">// Elements do not contain pointers.</span></span><br><span class="line"><span class="comment">// Allocate hchan and buf in one call.</span></span><br><span class="line"><span class="comment">// 分配一整块内存，用于存储hchan和 buf</span></span><br><span class="line">c = (*hchan)(mallocgc(hchanSize+<span class="keyword">uintptr</span>(size)*elem.size, <span class="literal">nil</span>, <span class="literal">true</span>))</span><br><span class="line">c.buf = add(unsafe.Pointer(c), hchanSize)</span><br><span class="line"><span class="keyword">default</span>:</span><br><span class="line"><span class="comment">// Elements contain pointers.</span></span><br><span class="line"><span class="comment">// 是指针类型，那正常分配hchan结构体即可，buf单独分配</span></span><br><span class="line">c = <span class="built_in">new</span>(hchan)</span><br><span class="line">c.buf = mallocgc(<span class="keyword">uintptr</span>(size)*elem.size, elem, <span class="literal">true</span>)</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 初始化 hchan的属性</span></span><br><span class="line">c.elemsize = <span class="keyword">uint16</span>(elem.size)</span><br><span class="line">c.elemtype = elem</span><br><span class="line">c.dataqsiz = <span class="keyword">uint</span>(size)</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> c</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="chanrecv1"><a href="#chanrecv1" class="headerlink" title="chanrecv1"></a>chanrecv1</h3><p><code>chanrecv1</code> 调用了<code>chanrecv</code> 实现，<code>chanrecv</code> 监听channel并接收 channel里面的数据，并写入到 ep 里面</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">chanrecv1</span><span class="params">(c *hchan, elem unsafe.Pointer)</span></span> &#123;</span><br><span class="line">chanrecv(c, elem, <span class="literal">true</span>)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">chanrecv</span><span class="params">(c *hchan, ep unsafe.Pointer, block <span class="keyword">bool</span>)</span> <span class="params">(selected, received <span class="keyword">bool</span>)</span></span> &#123;</span><br><span class="line">lock(&amp;c.lock)</span><br><span class="line"><span class="keyword">if</span> c.closed != <span class="number">0</span> &amp;&amp; c.qcount == <span class="number">0</span> &#123;</span><br><span class="line">unlock(&amp;c.lock)</span><br><span class="line"><span class="keyword">if</span> ep != <span class="literal">nil</span> &#123;</span><br><span class="line"><span class="comment">// 清空地址里面的数据值，但不会改变类型</span></span><br><span class="line">typedmemclr(c.elemtype, ep)</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> <span class="literal">true</span>, <span class="literal">false</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> sg := c.sendq.dequeue(); sg != <span class="literal">nil</span> &#123;</span><br><span class="line"><span class="comment">// 获取一个等待send的sudog，然后判断channel是否有缓冲区，如果有无缓冲区，获取sudog里面的数据即可， 如果channel有缓冲区，则获取缓冲区的头元素，把获取到的sudog的元素添加到缓冲区的队尾</span></span><br><span class="line">recv(c, sg, ep, <span class="function"><span class="keyword">func</span><span class="params">()</span></span> &#123; unlock(&amp;c.lock) &#125;, <span class="number">3</span>)</span><br><span class="line"><span class="keyword">return</span> <span class="literal">true</span>, <span class="literal">true</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> c.qcount &gt; <span class="number">0</span> &#123;</span><br><span class="line"><span class="comment">// Receive directly from queue</span></span><br><span class="line"><span class="comment">// 缓冲区有数据，且send队列没有等待发送数据的sudog，（异步且缓冲区刚满或未满的情况），根据recvx索引，获取数据</span></span><br><span class="line">qp := chanbuf(c, c.recvx)</span><br><span class="line"><span class="comment">// 如果ep不为nil，拷贝 gp 到 ep</span></span><br><span class="line"><span class="keyword">if</span> ep != <span class="literal">nil</span> &#123;</span><br><span class="line">typedmemmove(c.elemtype, ep, qp)</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// gp地址里的数据清除</span></span><br><span class="line">typedmemclr(c.elemtype, qp)</span><br><span class="line"><span class="comment">// 更新下一次recv的索引</span></span><br><span class="line">c.recvx++</span><br><span class="line"><span class="keyword">if</span> c.recvx == c.dataqsiz &#123;</span><br><span class="line">c.recvx = <span class="number">0</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 更新 qcount计数</span></span><br><span class="line">c.qcount--</span><br><span class="line">unlock(&amp;c.lock)</span><br><span class="line"><span class="keyword">return</span> <span class="literal">true</span>, <span class="literal">true</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> !block &#123;</span><br><span class="line">unlock(&amp;c.lock)</span><br><span class="line"><span class="keyword">return</span> <span class="literal">false</span>, <span class="literal">false</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// no sender available: block on this channel.</span></span><br><span class="line"><span class="comment">// 找不到send 的sudog，缓冲区也没有数据，需要阻塞</span></span><br><span class="line">gp := getg()</span><br><span class="line"><span class="comment">// 获取一个sudog的结构，并更新这个sudog的属性</span></span><br><span class="line">mysg := acquireSudog()</span><br><span class="line">mysg.releasetime = <span class="number">0</span></span><br><span class="line"><span class="comment">// No stack splits between assigning elem and enqueuing mysg</span></span><br><span class="line"><span class="comment">// on gp.waiting where copystack can find it.</span></span><br><span class="line">mysg.elem = ep</span><br><span class="line">mysg.waitlink = <span class="literal">nil</span></span><br><span class="line">gp.waiting = mysg</span><br><span class="line">mysg.g = gp</span><br><span class="line">mysg.isSelect = <span class="literal">false</span></span><br><span class="line">mysg.c = c</span><br><span class="line">gp.param = <span class="literal">nil</span></span><br><span class="line"><span class="comment">// 把这个sudog放入到recv的队列</span></span><br><span class="line">c.recvq.enqueue(mysg)</span><br><span class="line"><span class="comment">// 休眠这个g，当g被唤醒后，从这里继续执行</span></span><br><span class="line">goparkunlock(&amp;c.lock, waitReasonChanReceive, traceEvGoBlockRecv, <span class="number">3</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment">// someone woke us up</span></span><br><span class="line"><span class="keyword">if</span> mysg != gp.waiting &#123;</span><br><span class="line">throw(<span class="string">"G waiting list is corrupted"</span>)</span><br><span class="line">&#125;</span><br><span class="line">gp.waiting = <span class="literal">nil</span></span><br><span class="line"><span class="keyword">if</span> mysg.releasetime &gt; <span class="number">0</span> &#123;</span><br><span class="line">blockevent(mysg.releasetime-t0, <span class="number">2</span>)</span><br><span class="line">&#125;</span><br><span class="line">closed := gp.param == <span class="literal">nil</span></span><br><span class="line">gp.param = <span class="literal">nil</span></span><br><span class="line">mysg.c = <span class="literal">nil</span></span><br><span class="line"><span class="comment">// 清理完sudog的属性后，把sudog释放</span></span><br><span class="line">releaseSudog(mysg)</span><br><span class="line"><span class="keyword">return</span> <span class="literal">true</span>, !closed</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>通过上面的逻辑，可以看出来数据传输的四种可能</p><ul><li>sendq队列不为空，但是buf为空（同步有阻塞g的情况）: 获取sendq队列头的sudog，并把sudog.elem数据拷贝目标地址 ep</li><li>sendq队列不为空，buf也不为空（异步有阻塞g的情况）：把buf头元素拷贝到目标地址ep， 获取sendq队列头的sudog，然后把sudog.elem的数据拷贝到buf队尾，释放sudog</li><li>sendq队列为空，但是buf不为空（异步无阻塞g的情况）：把buf头元素拷贝到目标地址ep即可</li><li>sendq队列为空，buf也为空（同步无阻塞g的情况）：这时候就需要就需要阻塞自身，获取一个sudog的结构，放到channel的recvq队列里，等待send的g来唤醒自己，并把自己的数据拷贝到目标地址</li></ul><p>这里细想一下，其实会发现一个问题，在上面L66 <code>goparkunlock(&amp;c.lock, waitReasonChanReceive, traceEvGoBlockRecv, 3)</code> 休眠g后，g被唤醒后从这里开始继续往下执行，好像没有什么逻辑显示，这个recv g获取到了数据，这个g阻塞在这里是为了等数据来的，但是下面的逻辑，竟然没有一个是操作数据的？</p><p>接下来分析的 <code>recv</code> 这个方法就能理解了</p><h4 id="recv"><a href="#recv" class="headerlink" title="recv"></a>recv</h4><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">recv</span><span class="params">(c *hchan, sg *sudog, ep unsafe.Pointer, unlockf <span class="keyword">func</span>()</span>, <span class="title">skip</span> <span class="title">int</span>)</span> &#123;</span><br><span class="line"><span class="comment">// 如果是无缓冲区的channel</span></span><br><span class="line"><span class="keyword">if</span> c.dataqsiz == <span class="number">0</span> &#123;</span><br><span class="line"><span class="keyword">if</span> ep != <span class="literal">nil</span> &#123;</span><br><span class="line"><span class="comment">// copy data from sender</span></span><br><span class="line"><span class="comment">// 直接在两个g之间进行数据拷贝</span></span><br><span class="line">recvDirect(c.elemtype, sg, ep)</span><br><span class="line">&#125;</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line"><span class="comment">// 这里是有缓冲区才会走到的逻辑</span></span><br><span class="line"><span class="comment">// Queue is full. Take the item at the</span></span><br><span class="line"><span class="comment">// head of the queue. Make the sender enqueue</span></span><br><span class="line"><span class="comment">// its item at the tail of the queue. Since the</span></span><br><span class="line"><span class="comment">// queue is full, those are both the same slot.</span></span><br><span class="line"><span class="comment">// 因为在sendq队列获取到了等待发送数据的sudog，所以说明缓冲区已经满了，根据rcvx获取buf里面队列首元素的地址</span></span><br><span class="line">qp := chanbuf(c, c.recvx)</span><br><span class="line"><span class="comment">// copy data from queue to receiver</span></span><br><span class="line"><span class="keyword">if</span> ep != <span class="literal">nil</span> &#123;</span><br><span class="line"><span class="comment">// 把buf里面的数据拷贝到ep里面</span></span><br><span class="line">typedmemmove(c.elemtype, ep, qp)</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// copy data from sender to queue</span></span><br><span class="line"><span class="comment">// 把从sendq队列获取到的sudog的数据拷贝到刚刚的buf地址里面，并更新buf里面recvx的索引，也就是表名，buf队列的首元素地址后移</span></span><br><span class="line">typedmemmove(c.elemtype, qp, sg.elem)</span><br><span class="line">c.recvx++</span><br><span class="line"><span class="keyword">if</span> c.recvx == c.dataqsiz &#123;</span><br><span class="line">c.recvx = <span class="number">0</span></span><br><span class="line">&#125;</span><br><span class="line">c.sendx = c.recvx <span class="comment">// c.sendx = (c.sendx+1) % c.dataqsiz</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 清空sudog的数据</span></span><br><span class="line">sg.elem = <span class="literal">nil</span></span><br><span class="line">gp := sg.g</span><br><span class="line">unlockf()</span><br><span class="line">gp.param = unsafe.Pointer(sg)</span><br><span class="line"><span class="keyword">if</span> sg.releasetime != <span class="number">0</span> &#123;</span><br><span class="line">sg.releasetime = cputicks()</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 唤醒sendq里面获取的sugog对应的g</span></span><br><span class="line">goready(gp, skip+<span class="number">1</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>结合上面的逻辑就发现，g在被唤醒之前，跟g相关的sudog的数据就已经被channel使用掉了，所以当g被唤醒时，无需处理跟数据传输相关的逻辑了</p><h4 id="2acquireSudog"><a href="#2acquireSudog" class="headerlink" title="2acquireSudog"></a>2acquireSudog</h4><p>获取一个sudog的结构，这里跟cache和scheduler调度待运行g的队列一样，使用了 p sched 的两级缓存，也就是本地缓存一个sudog的数组，同时在全局的 sched结构上面也维护了一个sudogcache的链表，当p本地的sudog不足或者过多的时候，就去跟全局的sched 进行平衡</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">acquireSudog</span><span class="params">()</span> *<span class="title">sudog</span></span> &#123;</span><br><span class="line"><span class="comment">// 加锁</span></span><br><span class="line">mp := acquirem()</span><br><span class="line">pp := mp.p.ptr()</span><br><span class="line"><span class="comment">// 如果当前缓存的没有sudog了，则去全局的sched中批量拉取一些sudog缓存到当前p</span></span><br><span class="line"><span class="keyword">if</span> <span class="built_in">len</span>(pp.sudogcache) == <span class="number">0</span> &#123;</span><br><span class="line">lock(&amp;sched.sudoglock)</span><br><span class="line"><span class="comment">// First, try to grab a batch from central cache.</span></span><br><span class="line"><span class="keyword">for</span> <span class="built_in">len</span>(pp.sudogcache) &lt; <span class="built_in">cap</span>(pp.sudogcache)/<span class="number">2</span> &amp;&amp; sched.sudogcache != <span class="literal">nil</span> &#123;</span><br><span class="line">s := sched.sudogcache</span><br><span class="line">sched.sudogcache = s.next</span><br><span class="line">s.next = <span class="literal">nil</span></span><br><span class="line">pp.sudogcache = <span class="built_in">append</span>(pp.sudogcache, s)</span><br><span class="line">&#125;</span><br><span class="line">unlock(&amp;sched.sudoglock)</span><br><span class="line"><span class="comment">// If the central cache is empty, allocate a new one.</span></span><br><span class="line"><span class="keyword">if</span> <span class="built_in">len</span>(pp.sudogcache) == <span class="number">0</span> &#123;</span><br><span class="line">pp.sudogcache = <span class="built_in">append</span>(pp.sudogcache, <span class="built_in">new</span>(sudog))</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 从本地缓存的sudog里面，获取第一个返回，并更新sudogcache slice</span></span><br><span class="line">n := <span class="built_in">len</span>(pp.sudogcache)</span><br><span class="line">s := pp.sudogcache[n<span class="number">-1</span>]</span><br><span class="line">pp.sudogcache[n<span class="number">-1</span>] = <span class="literal">nil</span></span><br><span class="line">pp.sudogcache = pp.sudogcache[:n<span class="number">-1</span>]</span><br><span class="line"><span class="keyword">if</span> s.elem != <span class="literal">nil</span> &#123;</span><br><span class="line">throw(<span class="string">"acquireSudog: found s.elem != nil in cache"</span>)</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 去锁</span></span><br><span class="line">releasem(mp)</span><br><span class="line"><span class="keyword">return</span> s</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="releaseSudog"><a href="#releaseSudog" class="headerlink" title="releaseSudog"></a>releaseSudog</h4><p><code>releaseSudog</code> 就是释放当前使用的sudog，并平衡p本地缓存的sudog和全局队列的sudog</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">releaseSudog</span><span class="params">(s *sudog)</span></span> &#123;</span><br><span class="line">mp := acquirem() <span class="comment">// avoid rescheduling to another P</span></span><br><span class="line">pp := mp.p.ptr()</span><br><span class="line"><span class="comment">// 如果 p本地缓存的sudog的数量超出这个slice的最大长度，则平衡一般的sudog到全局的sched上面</span></span><br><span class="line"><span class="keyword">if</span> <span class="built_in">len</span>(pp.sudogcache) == <span class="built_in">cap</span>(pp.sudogcache) &#123;</span><br><span class="line"><span class="comment">// Transfer half of local cache to the central cache.</span></span><br><span class="line"><span class="keyword">var</span> first, last *sudog</span><br><span class="line"><span class="keyword">for</span> <span class="built_in">len</span>(pp.sudogcache) &gt; <span class="built_in">cap</span>(pp.sudogcache)/<span class="number">2</span> &#123;</span><br><span class="line">n := <span class="built_in">len</span>(pp.sudogcache)</span><br><span class="line">p := pp.sudogcache[n<span class="number">-1</span>]</span><br><span class="line">pp.sudogcache[n<span class="number">-1</span>] = <span class="literal">nil</span></span><br><span class="line">pp.sudogcache = pp.sudogcache[:n<span class="number">-1</span>]</span><br><span class="line"><span class="keyword">if</span> first == <span class="literal">nil</span> &#123;</span><br><span class="line">first = p</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">last.next = p</span><br><span class="line">&#125;</span><br><span class="line">last = p</span><br><span class="line">&#125;</span><br><span class="line">lock(&amp;sched.sudoglock)</span><br><span class="line">last.next = sched.sudogcache</span><br><span class="line">sched.sudogcache = first</span><br><span class="line">unlock(&amp;sched.sudoglock)</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 把释放的sudog放到本地缓存的slice里面</span></span><br><span class="line">pp.sudogcache = <span class="built_in">append</span>(pp.sudogcache, s)</span><br><span class="line">releasem(mp)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="chansend1"><a href="#chansend1" class="headerlink" title="chansend1"></a>chansend1</h3><p>发送逻辑跟接收的逻辑差不多</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">chansend1</span><span class="params">(c *hchan, elem unsafe.Pointer)</span></span> &#123;</span><br><span class="line">chansend(c, elem, <span class="literal">true</span>, getcallerpc())</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">chansend</span><span class="params">(c *hchan, ep unsafe.Pointer, block <span class="keyword">bool</span>, callerpc <span class="keyword">uintptr</span>)</span> <span class="title">bool</span></span> &#123;</span><br><span class="line">lock(&amp;c.lock)</span><br><span class="line"><span class="comment">// 从recvq队列获取一个 sudog</span></span><br><span class="line"><span class="keyword">if</span> sg := c.recvq.dequeue(); sg != <span class="literal">nil</span> &#123;</span><br><span class="line"><span class="comment">// Found a waiting receiver. We pass the value we want to send</span></span><br><span class="line"><span class="comment">// directly to the receiver, bypassing the channel buffer (if any).</span></span><br><span class="line">send(c, sg, ep, <span class="function"><span class="keyword">func</span><span class="params">()</span></span> &#123; unlock(&amp;c.lock) &#125;, <span class="number">3</span>)</span><br><span class="line"><span class="keyword">return</span> <span class="literal">true</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 如果qcount &lt; dataqsiz，说明这个channel是带buf的channel，而且buf没有满，直接把数据ep添加到buf队尾即可</span></span><br><span class="line"><span class="keyword">if</span> c.qcount &lt; c.dataqsiz &#123;</span><br><span class="line"><span class="comment">// Space is available in the channel buffer. Enqueue the element to send.</span></span><br><span class="line">qp := chanbuf(c, c.sendx)</span><br><span class="line">typedmemmove(c.elemtype, qp, ep)</span><br><span class="line">c.sendx++</span><br><span class="line"><span class="keyword">if</span> c.sendx == c.dataqsiz &#123;</span><br><span class="line">c.sendx = <span class="number">0</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 更新qcount</span></span><br><span class="line">c.qcount++</span><br><span class="line">unlock(&amp;c.lock)</span><br><span class="line"><span class="keyword">return</span> <span class="literal">true</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> !block &#123;</span><br><span class="line">unlock(&amp;c.lock)</span><br><span class="line"><span class="keyword">return</span> <span class="literal">false</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Block on the channel. Some receiver will complete our operation for us.</span></span><br><span class="line"><span class="comment">// 走到这里说明，buf满了或者没有buf，而且recvq队列为空，就需要阻塞当前的g，等待有其他的g接收数据</span></span><br><span class="line">gp := getg()</span><br><span class="line"><span class="comment">// 获取一个sudog，并初始化相关属性</span></span><br><span class="line">mysg := acquireSudog()</span><br><span class="line">mysg.releasetime = <span class="number">0</span></span><br><span class="line"><span class="keyword">if</span> t0 != <span class="number">0</span> &#123;</span><br><span class="line">mysg.releasetime = <span class="number">-1</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// No stack splits between assigning elem and enqueuing mysg</span></span><br><span class="line"><span class="comment">// on gp.waiting where copystack can find it.</span></span><br><span class="line">mysg.elem = ep</span><br><span class="line">mysg.waitlink = <span class="literal">nil</span></span><br><span class="line">mysg.g = gp</span><br><span class="line">mysg.isSelect = <span class="literal">false</span></span><br><span class="line">mysg.c = c</span><br><span class="line">gp.waiting = mysg</span><br><span class="line">gp.param = <span class="literal">nil</span></span><br><span class="line"><span class="comment">// 把sudog入队sendq</span></span><br><span class="line">c.sendq.enqueue(mysg)</span><br><span class="line"><span class="comment">// 休眠当前g，等待其他的g recv数据，recv数据后，唤醒这个g</span></span><br><span class="line">goparkunlock(&amp;c.lock, waitReasonChanSend, traceEvGoBlockSend, <span class="number">3</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment">// someone woke us up.</span></span><br><span class="line"><span class="keyword">if</span> mysg != gp.waiting &#123;</span><br><span class="line">throw(<span class="string">"G waiting list is corrupted"</span>)</span><br><span class="line">&#125;</span><br><span class="line">gp.waiting = <span class="literal">nil</span></span><br><span class="line"><span class="keyword">if</span> gp.param == <span class="literal">nil</span> &#123;</span><br><span class="line"><span class="keyword">if</span> c.closed == <span class="number">0</span> &#123;</span><br><span class="line">throw(<span class="string">"chansend: spurious wakeup"</span>)</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">panic</span>(plainError(<span class="string">"send on closed channel"</span>))</span><br><span class="line">&#125;</span><br><span class="line">gp.param = <span class="literal">nil</span></span><br><span class="line"><span class="keyword">if</span> mysg.releasetime &gt; <span class="number">0</span> &#123;</span><br><span class="line">blockevent(mysg.releasetime-t0, <span class="number">2</span>)</span><br><span class="line">&#125;</span><br><span class="line">mysg.c = <span class="literal">nil</span></span><br><span class="line"><span class="comment">// 释放sudog</span></span><br><span class="line">releaseSudog(mysg)</span><br><span class="line"><span class="keyword">return</span> <span class="literal">true</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="send"><a href="#send" class="headerlink" title="send"></a>send</h4><p><code>send</code>  跟 <code>recv</code> 的逻辑也是大致相同的，而且因为从recvq里面拿到了一个sudog，所以说明缓冲区为空，那么<code>send</code>方法就不需要考虑往缓冲区添加数据了，<code>send</code>比<code>recv</code>更加简单，只需要交换数据、唤醒g即可</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">send</span><span class="params">(c *hchan, sg *sudog, ep unsafe.Pointer, unlockf <span class="keyword">func</span>()</span>, <span class="title">skip</span> <span class="title">int</span>)</span> &#123;</span><br><span class="line"><span class="keyword">if</span> sg.elem != <span class="literal">nil</span> &#123;</span><br><span class="line">sendDirect(c.elemtype, sg, ep)</span><br><span class="line">sg.elem = <span class="literal">nil</span></span><br><span class="line">&#125;</span><br><span class="line">gp := sg.g</span><br><span class="line">unlockf()</span><br><span class="line">gp.param = unsafe.Pointer(sg)</span><br><span class="line"><span class="keyword">if</span> sg.releasetime != <span class="number">0</span> &#123;</span><br><span class="line">sg.releasetime = cputicks()</span><br><span class="line">&#125;</span><br><span class="line">goready(gp, skip+<span class="number">1</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="closechan"><a href="#closechan" class="headerlink" title="closechan"></a>closechan</h3><p>收发数据已经结束了，最后就是关闭channel了</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">closechan</span><span class="params">(c *hchan)</span></span> &#123;</span><br><span class="line"><span class="comment">// nil chan 检查</span></span><br><span class="line"><span class="keyword">if</span> c == <span class="literal">nil</span> &#123;</span><br><span class="line"><span class="built_in">panic</span>(plainError(<span class="string">"close of nil channel"</span>))</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">lock(&amp;c.lock)</span><br><span class="line"><span class="comment">// closed chan 检查</span></span><br><span class="line"><span class="keyword">if</span> c.closed != <span class="number">0</span> &#123;</span><br><span class="line">unlock(&amp;c.lock)</span><br><span class="line"><span class="built_in">panic</span>(plainError(<span class="string">"close of closed channel"</span>))</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 设置c为closed状态</span></span><br><span class="line">c.closed = <span class="number">1</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> glist *g</span><br><span class="line"></span><br><span class="line"><span class="comment">// release all readers</span></span><br><span class="line"><span class="comment">// 遍历 recvq，清除sudog的数据，并把recvq中sudog对应的g串成一个链表</span></span><br><span class="line"><span class="keyword">for</span> &#123;</span><br><span class="line">sg := c.recvq.dequeue()</span><br><span class="line"><span class="keyword">if</span> sg == <span class="literal">nil</span> &#123;</span><br><span class="line"><span class="keyword">break</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span> sg.elem != <span class="literal">nil</span> &#123;</span><br><span class="line">typedmemclr(c.elemtype, sg.elem)</span><br><span class="line">sg.elem = <span class="literal">nil</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span> sg.releasetime != <span class="number">0</span> &#123;</span><br><span class="line">sg.releasetime = cputicks()</span><br><span class="line">&#125;</span><br><span class="line">gp := sg.g</span><br><span class="line">gp.param = <span class="literal">nil</span></span><br><span class="line">gp.schedlink.set(glist)</span><br><span class="line">glist = gp</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// release all writers (they will panic)</span></span><br><span class="line"><span class="comment">// 遍历sendq，清除sudog的数据，并把sendq中的sudog中的g和recvq中的sudog一起串成一个链表</span></span><br><span class="line"><span class="keyword">for</span> &#123;</span><br><span class="line">sg := c.sendq.dequeue()</span><br><span class="line"><span class="keyword">if</span> sg == <span class="literal">nil</span> &#123;</span><br><span class="line"><span class="keyword">break</span></span><br><span class="line">&#125;</span><br><span class="line">sg.elem = <span class="literal">nil</span></span><br><span class="line"><span class="keyword">if</span> sg.releasetime != <span class="number">0</span> &#123;</span><br><span class="line">sg.releasetime = cputicks()</span><br><span class="line">&#125;</span><br><span class="line">gp := sg.g</span><br><span class="line">gp.param = <span class="literal">nil</span></span><br><span class="line"><span class="keyword">if</span> raceenabled &#123;</span><br><span class="line">raceacquireg(gp, c.raceaddr())</span><br><span class="line">&#125;</span><br><span class="line">gp.schedlink.set(glist)</span><br><span class="line">glist = gp</span><br><span class="line">&#125;</span><br><span class="line">unlock(&amp;c.lock)</span><br><span class="line"></span><br><span class="line"><span class="comment">// Ready all Gs now that we've dropped the channel lock.</span></span><br><span class="line"><span class="comment">// 唤醒上面收集的所有的g</span></span><br><span class="line"><span class="keyword">for</span> glist != <span class="literal">nil</span> &#123;</span><br><span class="line">gp := glist</span><br><span class="line">glist = glist.schedlink.ptr()</span><br><span class="line">gp.schedlink = <span class="number">0</span></span><br><span class="line">goready(gp, <span class="number">3</span>)</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>chan close之后，所有阻塞的recvq 和 sendq（recvq和sendq只有有一个队列存在）中的sudog，清除sudog的一些数据和状态，设置 <code>gp.param = nil</code>， 让上层逻辑知道这是因为 close chan导致的</p><p>唤醒所有的g之后，g就会 继续执行 <code>chansend</code> 或者 <code>chanrecv</code> 中剩余的逻辑，也就是释放sudog（这也就是为什么 closechan 不需要释放sudog的原因）</p><h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><p>语言的表述总是苍白的，在网上找资料的时候正好看到了两张流程图，可以结合着来看</p><p>发送流程（send）</p><p><img src="http://note-1253518569.cossh.myqcloud.com/20190904143713.png" alt></p><p>接收流程（recv）</p><p><img src="https://oscimg.oschina.net/oscnet/820d765ece5100b753e5e6c53bff08b7c2d.jpg" alt="img"></p><h2 id="select"><a href="#select" class="headerlink" title="select"></a>select</h2><h3 id="main-1"><a href="#main-1" class="headerlink" title="main"></a>main</h3><p>channel的收发流程在上面已经追踪了，流程也已经清晰了，但是跟channel一起使用的还有一个select，那select的流程又是什么呢</p><p>我们还是用go tool工具分析一下</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">c1 := <span class="built_in">make</span>(<span class="keyword">chan</span> <span class="keyword">int</span>)</span><br><span class="line">c2 := <span class="built_in">make</span>(<span class="keyword">chan</span> <span class="keyword">int</span>)</span><br><span class="line"><span class="keyword">go</span> <span class="function"><span class="keyword">func</span><span class="params">()</span></span> &#123;</span><br><span class="line">time.Sleep(time.Second)</span><br><span class="line">&lt;-c2</span><br><span class="line">c1 &lt;- <span class="number">1</span></span><br><span class="line">&#125;()</span><br><span class="line"><span class="keyword">select</span> &#123;</span><br><span class="line"><span class="keyword">case</span> v := &lt;-c1:</span><br><span class="line">fmt.Printf(<span class="string">"%d &lt;- c1"</span>, v)</span><br><span class="line"><span class="keyword">case</span> c2 &lt;- <span class="number">1</span>:</span><br><span class="line">fmt.Println(<span class="string">"c2 &lt;- 1"</span>)</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>分析结果过滤一下CALL</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">main.go:9             0x4a05c6                e81542f6ff                      CALL runtime.makechan(SB)               </span><br><span class="line">main.go:10            0x4a05ec                e8ef41f6ff                      CALL runtime.makechan(SB)               </span><br><span class="line">main.go:11            0x4a0620                e82b3bf9ff                      CALL runtime.newproc(SB)                </span><br><span class="line">main.go:16            0x4a0654                e82c94fbff                      CALL 0x459a85                           </span><br><span class="line">main.go:16            0x4a06e3                e8d8b7f9ff                      CALL runtime.selectgo(SB)               </span><br><span class="line">main.go:18            0x4a074c                e8df8df6ff                      CALL runtime.convT2E64(SB)              </span><br><span class="line">main.go:18            0x4a07ec                e8cf89ffff                      CALL fmt.Printf(SB)                     </span><br><span class="line">main.go:18            0x4a0806                e8f587fbff                      CALL runtime.gcWriteBarrier(SB)         </span><br><span class="line">main.go:20            0x4a088c                e87f8bffff                      CALL fmt.Println(SB)                    </span><br><span class="line">main.go:8             0x4a0898                e85369fbff                      CALL runtime.morestack_noctxt(SB)       </span><br><span class="line">main.go:12            0x4a0945                e8868efaff              CALL time.Sleep(SB)                     </span><br><span class="line">main.go:13            0x4a095c                e8ff4bf6ff              CALL runtime.chanrecv1(SB)              </span><br><span class="line">main.go:14            0x4a0976                e85541f6ff              CALL runtime.chansend1(SB)              </span><br><span class="line">main.go:11            0x4a0985                e86668fbff              CALL runtime.morestack_noctxt(SB)</span><br></pre></td></tr></table></figure><p>可以看出来，select 的实现是靠 <code>selectgo</code> 函数的</p><p>以为就这样吗，然后我们就开始分析 <code>selectgo</code> 函数了，不，在我手贱的时候还发现了另一种情况</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">c1 := <span class="built_in">make</span>(<span class="keyword">chan</span> <span class="keyword">int</span>)</span><br><span class="line"><span class="keyword">go</span> <span class="function"><span class="keyword">func</span><span class="params">()</span></span> &#123;</span><br><span class="line">time.Sleep(time.Second)</span><br><span class="line">c1 &lt;- <span class="number">1</span></span><br><span class="line">&#125;()</span><br><span class="line"><span class="keyword">select</span> &#123;</span><br><span class="line"><span class="keyword">case</span> &lt;-c1:</span><br><span class="line">fmt.Printf(<span class="string">"c1 &lt;- 1"</span>)</span><br><span class="line"><span class="keyword">default</span>:</span><br><span class="line">fmt.Println(<span class="string">"default"</span>)</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>分析结果如下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">main.go:9             0x49eca8                e8335bf6ff              CALL runtime.makechan(SB)               </span><br><span class="line">main.go:11            0x49eccf                e85c54f9ff              CALL runtime.newproc(SB)                </span><br><span class="line">main.go:17            0x49ece6                e83570f6ff              CALL runtime.selectnbrecv(SB)           </span><br><span class="line">main.go:18            0x49ed1c                e88f8bffff              CALL fmt.Printf(SB)                     </span><br><span class="line">main.go:22            0x49ed8f                e86c8dffff              CALL fmt.Println(SB)                    </span><br><span class="line">main.go:8             0x49ed96                e8556cfbff              CALL runtime.morestack_noctxt(SB)       </span><br><span class="line">main.go:12            0x49ee35                e87692faff              CALL time.Sleep(SB)                     </span><br><span class="line">main.go:13            0x49ee4f                e87c5cf6ff              CALL runtime.chansend1(SB)              </span><br><span class="line">main.go:11            0x49ee5e                e88d6bfbff              CALL runtime.morestack_noctxt(SB)</span><br></pre></td></tr></table></figure><p>可以看到，这里 select 的实现是依靠底层的 <code>selectnbrecv</code> 的函数的，如果，既然有 <code>selectnbrecv</code> 函数，会不会有 <code>selectnbsend</code> 函数呢，继续试验一下</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">c1 := <span class="built_in">make</span>(<span class="keyword">chan</span> <span class="keyword">int</span>)</span><br><span class="line"><span class="keyword">go</span> <span class="function"><span class="keyword">func</span><span class="params">()</span></span> &#123;</span><br><span class="line">time.Sleep(time.Second)</span><br><span class="line">&lt;- c1</span><br><span class="line">&#125;()</span><br><span class="line"><span class="keyword">select</span> &#123;</span><br><span class="line"><span class="keyword">case</span> c1 &lt;- <span class="number">1</span>:</span><br><span class="line">fmt.Printf(<span class="string">"c1 &lt;- 1"</span>)</span><br><span class="line"><span class="keyword">default</span>:</span><br><span class="line">fmt.Println(<span class="string">"default"</span>)</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>分析j结果</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">main.go:9             0x49ecb3                e8285bf6ff                      CALL runtime.makechan(SB)               </span><br><span class="line">main.go:11            0x49ecda                e85154f9ff                      CALL runtime.newproc(SB)                </span><br><span class="line">main.go:17            0x49ed05                e81670f6ff                      CALL runtime.selectnbsend(SB)           </span><br><span class="line">main.go:18            0x49ed3b                e8708bffff                      CALL fmt.Printf(SB)                     </span><br><span class="line">main.go:22            0x49edb4                e8478dffff                      CALL fmt.Println(SB)                    </span><br><span class="line">main.go:8             0x49edbb                e8306cfbff                      CALL runtime.morestack_noctxt(SB)       </span><br><span class="line">main.go:12            0x49ee65                e84692faff              CALL time.Sleep(SB)                     </span><br><span class="line">main.go:13            0x49ee7c                e8df66f6ff              CALL runtime.chanrecv1(SB)              </span><br><span class="line">main.go:11            0x49ee8b                e8606bfbff              CALL runtime.morestack_noctxt(SB)</span><br></pre></td></tr></table></figure><p>这里就是用 <code>selectnbsend</code> 函数实现了 select 语句，然后继续试验，得出结论如下：</p><ul><li>如果select语句中只有<strong>一个</strong> case在等待从channel中接收数据，则调用 <code>selectnbrecv</code>实现</li><li>如果select语句中只有<strong>一个</strong> case在等待向channel发送数据，则调用 <code>selectnbsend</code>实现</li><li>如果select语句中有多个case，在等待向一个或多个channel发送或接收数据，则调用  <code>selectgo</code> 实现</li></ul><p>好了，我们开始从 <code>selectgo</code> 开始跟踪了，但是跟踪selectgo之前，我们需要选跟踪一下 <code>reflect_rselect</code> ， 不然看着 <code>selectgo</code> 函数的参数，完全就是一脸懵逼啊</p><h3 id="reflect-rselect"><a href="#reflect-rselect" class="headerlink" title="reflect_rselect"></a>reflect_rselect</h3><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">reflect_rselect</span><span class="params">(cases []runtimeSelect)</span> <span class="params">(<span class="keyword">int</span>, <span class="keyword">bool</span>)</span></span> &#123;</span><br><span class="line"><span class="comment">// 如果没有case的select，休眠当前goroutine</span></span><br><span class="line"><span class="keyword">if</span> <span class="built_in">len</span>(cases) == <span class="number">0</span> &#123;</span><br><span class="line">block()</span><br><span class="line">&#125;</span><br><span class="line">sel := <span class="built_in">make</span>([]scase, <span class="built_in">len</span>(cases))</span><br><span class="line">order := <span class="built_in">make</span>([]<span class="keyword">uint16</span>, <span class="number">2</span>*<span class="built_in">len</span>(cases))</span><br><span class="line"><span class="keyword">for</span> i := <span class="keyword">range</span> cases &#123;</span><br><span class="line">rc := &amp;cases[i]</span><br><span class="line"><span class="keyword">switch</span> rc.dir &#123;</span><br><span class="line"><span class="keyword">case</span> selectDefault:</span><br><span class="line">sel[i] = scase&#123;kind: caseDefault&#125;</span><br><span class="line"><span class="keyword">case</span> selectSend:</span><br><span class="line"><span class="comment">// 如果是发送的话，c &lt;- 1, rc.val 就是1的地址</span></span><br><span class="line">sel[i] = scase&#123;kind: caseSend, c: rc.ch, elem: rc.val&#125;</span><br><span class="line"><span class="keyword">case</span> selectRecv:</span><br><span class="line"><span class="comment">// 如果是接收的话，v:= &lt;- c, rc.val 就是v的地址</span></span><br><span class="line">sel[i] = scase&#123;kind: caseRecv, c: rc.ch, elem: rc.val&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> selectgo(&amp;sel[<span class="number">0</span>], &amp;order[<span class="number">0</span>], <span class="built_in">len</span>(cases))</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="selectgo"><a href="#selectgo" class="headerlink" title="selectgo"></a>selectgo</h3><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br><span class="line">184</span><br><span class="line">185</span><br><span class="line">186</span><br><span class="line">187</span><br><span class="line">188</span><br><span class="line">189</span><br><span class="line">190</span><br><span class="line">191</span><br><span class="line">192</span><br><span class="line">193</span><br><span class="line">194</span><br><span class="line">195</span><br><span class="line">196</span><br><span class="line">197</span><br><span class="line">198</span><br><span class="line">199</span><br><span class="line">200</span><br><span class="line">201</span><br><span class="line">202</span><br><span class="line">203</span><br><span class="line">204</span><br><span class="line">205</span><br><span class="line">206</span><br><span class="line">207</span><br><span class="line">208</span><br><span class="line">209</span><br><span class="line">210</span><br><span class="line">211</span><br><span class="line">212</span><br><span class="line">213</span><br><span class="line">214</span><br><span class="line">215</span><br><span class="line">216</span><br><span class="line">217</span><br><span class="line">218</span><br><span class="line">219</span><br><span class="line">220</span><br><span class="line">221</span><br><span class="line">222</span><br><span class="line">223</span><br><span class="line">224</span><br><span class="line">225</span><br><span class="line">226</span><br><span class="line">227</span><br><span class="line">228</span><br><span class="line">229</span><br><span class="line">230</span><br><span class="line">231</span><br><span class="line">232</span><br><span class="line">233</span><br><span class="line">234</span><br><span class="line">235</span><br><span class="line">236</span><br><span class="line">237</span><br><span class="line">238</span><br><span class="line">239</span><br><span class="line">240</span><br><span class="line">241</span><br><span class="line">242</span><br><span class="line">243</span><br><span class="line">244</span><br><span class="line">245</span><br><span class="line">246</span><br><span class="line">247</span><br><span class="line">248</span><br><span class="line">249</span><br><span class="line">250</span><br><span class="line">251</span><br><span class="line">252</span><br><span class="line">253</span><br><span class="line">254</span><br><span class="line">255</span><br><span class="line">256</span><br><span class="line">257</span><br><span class="line">258</span><br><span class="line">259</span><br><span class="line">260</span><br><span class="line">261</span><br><span class="line">262</span><br><span class="line">263</span><br><span class="line">264</span><br><span class="line">265</span><br><span class="line">266</span><br><span class="line">267</span><br><span class="line">268</span><br><span class="line">269</span><br><span class="line">270</span><br><span class="line">271</span><br><span class="line">272</span><br><span class="line">273</span><br><span class="line">274</span><br><span class="line">275</span><br><span class="line">276</span><br><span class="line">277</span><br><span class="line">278</span><br><span class="line">279</span><br><span class="line">280</span><br><span class="line">281</span><br><span class="line">282</span><br><span class="line">283</span><br><span class="line">284</span><br><span class="line">285</span><br><span class="line">286</span><br><span class="line">287</span><br><span class="line">288</span><br><span class="line">289</span><br><span class="line">290</span><br><span class="line">291</span><br><span class="line">292</span><br><span class="line">293</span><br><span class="line">294</span><br><span class="line">295</span><br><span class="line">296</span><br><span class="line">297</span><br><span class="line">298</span><br><span class="line">299</span><br><span class="line">300</span><br><span class="line">301</span><br><span class="line">302</span><br><span class="line">303</span><br><span class="line">304</span><br><span class="line">305</span><br><span class="line">306</span><br><span class="line">307</span><br><span class="line">308</span><br><span class="line">309</span><br><span class="line">310</span><br><span class="line">311</span><br><span class="line">312</span><br><span class="line">313</span><br><span class="line">314</span><br><span class="line">315</span><br><span class="line">316</span><br><span class="line">317</span><br><span class="line">318</span><br><span class="line">319</span><br><span class="line">320</span><br><span class="line">321</span><br><span class="line">322</span><br><span class="line">323</span><br><span class="line">324</span><br><span class="line">325</span><br><span class="line">326</span><br><span class="line">327</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">selectgo</span><span class="params">(cas0 *scase, order0 *<span class="keyword">uint16</span>, ncases <span class="keyword">int</span>)</span> <span class="params">(<span class="keyword">int</span>, <span class="keyword">bool</span>)</span></span> &#123;</span><br><span class="line">cas1 := (*[<span class="number">1</span> &lt;&lt; <span class="number">16</span>]scase)(unsafe.Pointer(cas0))</span><br><span class="line">order1 := (*[<span class="number">1</span> &lt;&lt; <span class="number">17</span>]<span class="keyword">uint16</span>)(unsafe.Pointer(order0))</span><br><span class="line"><span class="comment">// order是 2*ncases长度的slice，然后把 order[0-ncases] 给 pollorder用，order[ncases-2ncases] 给lockorder用</span></span><br><span class="line">scases := cas1[:ncases:ncases]</span><br><span class="line">pollorder := order1[:ncases:ncases]</span><br><span class="line">lockorder := order1[ncases:][:ncases:ncases]</span><br><span class="line"></span><br><span class="line"><span class="comment">// Replace send/receive cases involving nil channels with</span></span><br><span class="line"><span class="comment">// caseNil so logic below can assume non-nil channel.</span></span><br><span class="line"><span class="keyword">for</span> i := <span class="keyword">range</span> scases &#123;</span><br><span class="line">cas := &amp;scases[i]</span><br><span class="line"><span class="keyword">if</span> cas.c == <span class="literal">nil</span> &amp;&amp; cas.kind != caseDefault &#123;</span><br><span class="line">*cas = scase&#123;&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// The compiler rewrites selects that statically have</span></span><br><span class="line"><span class="comment">// only 0 or 1 cases plus default into simpler constructs.</span></span><br><span class="line"><span class="comment">// The only way we can end up with such small sel.ncase</span></span><br><span class="line"><span class="comment">// values here is for a larger select in which most channels</span></span><br><span class="line"><span class="comment">// have been nilled out. The general code handles those</span></span><br><span class="line"><span class="comment">// cases correctly, and they are rare enough not to bother</span></span><br><span class="line"><span class="comment">// optimizing (and needing to test).</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// generate permuted order</span></span><br><span class="line"><span class="comment">// 确定轮询的顺序</span></span><br><span class="line"><span class="keyword">for</span> i := <span class="number">1</span>; i &lt; ncases; i++ &#123;</span><br><span class="line">j := fastrandn(<span class="keyword">uint32</span>(i + <span class="number">1</span>))</span><br><span class="line">pollorder[i] = pollorder[j]</span><br><span class="line">pollorder[j] = <span class="keyword">uint16</span>(i)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// sort the cases by Hchan address to get the locking order.</span></span><br><span class="line"><span class="comment">// simple heap sort, to guarantee n log n time and constant stack footprint.</span></span><br><span class="line"><span class="comment">// 通过hchan的地址来确定加锁顺序，使用堆排序减少时间复杂度</span></span><br><span class="line"><span class="keyword">for</span> i := <span class="number">0</span>; i &lt; ncases; i++ &#123;</span><br><span class="line">j := i</span><br><span class="line"><span class="comment">// Start with the pollorder to permute cases on the same channel.</span></span><br><span class="line">c := scases[pollorder[i]].c</span><br><span class="line"><span class="keyword">for</span> j &gt; <span class="number">0</span> &amp;&amp; scases[lockorder[(j<span class="number">-1</span>)/<span class="number">2</span>]].c.sortkey() &lt; c.sortkey() &#123;</span><br><span class="line">k := (j - <span class="number">1</span>) / <span class="number">2</span></span><br><span class="line">lockorder[j] = lockorder[k]</span><br><span class="line">j = k</span><br><span class="line">&#125;</span><br><span class="line">lockorder[j] = pollorder[i]</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">for</span> i := ncases - <span class="number">1</span>; i &gt;= <span class="number">0</span>; i-- &#123;</span><br><span class="line">o := lockorder[i]</span><br><span class="line">c := scases[o].c</span><br><span class="line">lockorder[i] = lockorder[<span class="number">0</span>]</span><br><span class="line">j := <span class="number">0</span></span><br><span class="line"><span class="keyword">for</span> &#123;</span><br><span class="line">k := j*<span class="number">2</span> + <span class="number">1</span></span><br><span class="line"><span class="keyword">if</span> k &gt;= i &#123;</span><br><span class="line"><span class="keyword">break</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span> k+<span class="number">1</span> &lt; i &amp;&amp; scases[lockorder[k]].c.sortkey() &lt; scases[lockorder[k+<span class="number">1</span>]].c.sortkey() &#123;</span><br><span class="line">k++</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span> c.sortkey() &lt; scases[lockorder[k]].c.sortkey() &#123;</span><br><span class="line">lockorder[j] = lockorder[k]</span><br><span class="line">j = k</span><br><span class="line"><span class="keyword">continue</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">break</span></span><br><span class="line">&#125;</span><br><span class="line">lockorder[j] = o</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// lock all the channels involved in the select</span></span><br><span class="line"><span class="comment">// 根据上面确定的加锁顺序 lockorder，来逐个对case进行加锁</span></span><br><span class="line">sellock(scases, lockorder)</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> (</span><br><span class="line">gp     *g</span><br><span class="line">sg     *sudog</span><br><span class="line">c      *hchan</span><br><span class="line">k      *scase</span><br><span class="line">sglist *sudog</span><br><span class="line">sgnext *sudog</span><br><span class="line">qp     unsafe.Pointer</span><br><span class="line">nextp  **sudog</span><br><span class="line">)</span><br><span class="line"></span><br><span class="line">loop:</span><br><span class="line"><span class="comment">// pass 1 - look for something already waiting</span></span><br><span class="line"><span class="keyword">var</span> dfli <span class="keyword">int</span></span><br><span class="line"><span class="keyword">var</span> dfl *scase</span><br><span class="line"><span class="keyword">var</span> casi <span class="keyword">int</span></span><br><span class="line"><span class="keyword">var</span> cas *scase</span><br><span class="line"><span class="keyword">var</span> recvOK <span class="keyword">bool</span></span><br><span class="line"><span class="keyword">for</span> i := <span class="number">0</span>; i &lt; ncases; i++ &#123;</span><br><span class="line"><span class="comment">// 根据pollorder，获取当前轮询到的case</span></span><br><span class="line">casi = <span class="keyword">int</span>(pollorder[i])</span><br><span class="line">cas = &amp;scases[casi]</span><br><span class="line">c = cas.c</span><br><span class="line"></span><br><span class="line"><span class="keyword">switch</span> cas.kind &#123;</span><br><span class="line"><span class="comment">// nil类型的case，无视，继续下一个</span></span><br><span class="line"><span class="keyword">case</span> caseNil:</span><br><span class="line"><span class="keyword">continue</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">case</span> caseRecv:</span><br><span class="line"><span class="comment">// recv类型的case，判断sendq的队列中有没有等待发送数据的sudog，如果获取到的话，跳转到 recv</span></span><br><span class="line">sg = c.sendq.dequeue()</span><br><span class="line"><span class="keyword">if</span> sg != <span class="literal">nil</span> &#123;</span><br><span class="line"><span class="keyword">goto</span> recv</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 没有sudog在sendq队列排队，然后检查buf里面是否有数据，如果buf里有，则跳转到bufrecv</span></span><br><span class="line"><span class="keyword">if</span> c.qcount &gt; <span class="number">0</span> &#123;</span><br><span class="line"><span class="keyword">goto</span> bufrecv</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 最后 sendq buf都拿不到数据，则判断这个channel是否为关闭状态了</span></span><br><span class="line"><span class="comment">// 所以 可以看出来，如果我们关闭一个带buf的channel，在关闭之后还是能把之前存储的数据读完的</span></span><br><span class="line"><span class="keyword">if</span> c.closed != <span class="number">0</span> &#123;</span><br><span class="line"><span class="keyword">goto</span> rclose</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">case</span> caseSend:</span><br><span class="line"><span class="comment">// send 类型的case，首先确认channel是否关闭</span></span><br><span class="line"><span class="keyword">if</span> c.closed != <span class="number">0</span> &#123;</span><br><span class="line"><span class="keyword">goto</span> sclose</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 然后判断，recvq队列里面有没有等待接收数据的sudog，有则跳转到 send 标签</span></span><br><span class="line">sg = c.recvq.dequeue()</span><br><span class="line"><span class="keyword">if</span> sg != <span class="literal">nil</span> &#123;</span><br><span class="line"><span class="keyword">goto</span> send</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 判断是否有空余的buf位置，可以让自己把数据放上去，如果有，则跳转到bufsend标签</span></span><br><span class="line"><span class="keyword">if</span> c.qcount &lt; c.dataqsiz &#123;</span><br><span class="line"><span class="keyword">goto</span> bufsend</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">case</span> caseDefault:</span><br><span class="line"><span class="comment">// 更新并记录 case的索引及地址</span></span><br><span class="line">dfli = casi</span><br><span class="line">dfl = cas</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 根据 dfl 来判断是否有 default，并且走到了</span></span><br><span class="line"><span class="comment">// 在所有 case遍历完成后，如果不需要等待，都会跳转到相应的标签，例如 recv bufrecv send等，如果走到这里，说明所有的case都无法直接获取或发送数据，等待另一个g的就绪</span></span><br><span class="line"><span class="keyword">if</span> dfl != <span class="literal">nil</span> &#123;</span><br><span class="line">selunlock(scases, lockorder)</span><br><span class="line">casi = dfli</span><br><span class="line">cas = dfl</span><br><span class="line"><span class="comment">// 如果有default，直接执行default</span></span><br><span class="line"><span class="keyword">goto</span> retc</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// pass 2 - enqueue on all chans</span></span><br><span class="line"><span class="comment">// 流程执行到这里，所有的case都需要等待，且没有default执行</span></span><br><span class="line">gp = getg()</span><br><span class="line"><span class="keyword">if</span> gp.waiting != <span class="literal">nil</span> &#123;</span><br><span class="line">throw(<span class="string">"gp.waiting != nil"</span>)</span><br><span class="line">&#125;</span><br><span class="line">nextp = &amp;gp.waiting</span><br><span class="line"><span class="comment">// 按照lockorder，对每个case，创建相应的sudog并放入case对应的channel的recvq或sendq队列</span></span><br><span class="line"><span class="keyword">for</span> _, casei := <span class="keyword">range</span> lockorder &#123;</span><br><span class="line">casi = <span class="keyword">int</span>(casei)</span><br><span class="line">cas = &amp;scases[casi]</span><br><span class="line"><span class="keyword">if</span> cas.kind == caseNil &#123;</span><br><span class="line"><span class="keyword">continue</span></span><br><span class="line">&#125;</span><br><span class="line">c = cas.c</span><br><span class="line"><span class="comment">// 每一个case获取一个sudog，绑定到case对应的cahnnel的sendq或recvq队列</span></span><br><span class="line">sg := acquireSudog()</span><br><span class="line">sg.g = gp</span><br><span class="line">sg.isSelect = <span class="literal">true</span></span><br><span class="line"><span class="comment">// No stack splits between assigning elem and enqueuing</span></span><br><span class="line"><span class="comment">// sg on gp.waiting where copystack can find it.</span></span><br><span class="line">sg.elem = cas.elem</span><br><span class="line">sg.releasetime = <span class="number">0</span></span><br><span class="line"><span class="keyword">if</span> t0 != <span class="number">0</span> &#123;</span><br><span class="line">sg.releasetime = <span class="number">-1</span></span><br><span class="line">&#125;</span><br><span class="line">sg.c = c</span><br><span class="line"><span class="comment">// Construct waiting list in lock order.</span></span><br><span class="line"><span class="comment">// 按照lockorder，把这些sudog，依赖sudog.waitlink串联起来</span></span><br><span class="line">*nextp = sg</span><br><span class="line">nextp = &amp;sg.waitlink</span><br><span class="line"></span><br><span class="line"><span class="keyword">switch</span> cas.kind &#123;</span><br><span class="line"><span class="keyword">case</span> caseRecv:</span><br><span class="line"><span class="comment">// 如果recv，放入到recvq队列</span></span><br><span class="line">c.recvq.enqueue(sg)</span><br><span class="line"></span><br><span class="line"><span class="keyword">case</span> caseSend:</span><br><span class="line"><span class="comment">// 如果是send，放入到sendq队列</span></span><br><span class="line">c.sendq.enqueue(sg)</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// wait for someone to wake us up</span></span><br><span class="line"><span class="comment">// 休眠等待唤醒</span></span><br><span class="line">gp.param = <span class="literal">nil</span></span><br><span class="line">gopark(selparkcommit, <span class="literal">nil</span>, waitReasonSelect, traceEvGoBlockSelect, <span class="number">1</span>)</span><br><span class="line"><span class="comment">// </span></span><br><span class="line">sellock(scases, lockorder)</span><br><span class="line"></span><br><span class="line">gp.selectDone = <span class="number">0</span></span><br><span class="line">sg = (*sudog)(gp.param)</span><br><span class="line">gp.param = <span class="literal">nil</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// pass 3 - dequeue from unsuccessful chans</span></span><br><span class="line"><span class="comment">// otherwise they stack up on quiet channels</span></span><br><span class="line"><span class="comment">// record the successful case, if any.</span></span><br><span class="line"><span class="comment">// We singly-linked up the SudoGs in lock order.</span></span><br><span class="line">casi = <span class="number">-1</span></span><br><span class="line">cas = <span class="literal">nil</span></span><br><span class="line">sglist = gp.waiting</span><br><span class="line"><span class="comment">// Clear all elem before unlinking from gp.waiting.</span></span><br><span class="line"><span class="comment">// 在解散waiting这个队列前，先把数据清空，因为执行到这列，肯定是因为另一个goroutine在recv或send 某个channel，并且拿到数据导致的，所以，执行到这里后，数据都没用了</span></span><br><span class="line"><span class="keyword">for</span> sg1 := gp.waiting; sg1 != <span class="literal">nil</span>; sg1 = sg1.waitlink &#123;</span><br><span class="line">sg1.isSelect = <span class="literal">false</span></span><br><span class="line">sg1.elem = <span class="literal">nil</span></span><br><span class="line">sg1.c = <span class="literal">nil</span></span><br><span class="line">&#125;</span><br><span class="line">gp.waiting = <span class="literal">nil</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> _, casei := <span class="keyword">range</span> lockorder &#123;</span><br><span class="line">k = &amp;scases[casei]</span><br><span class="line"><span class="keyword">if</span> k.kind == caseNil &#123;</span><br><span class="line"><span class="keyword">continue</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span> sglist.releasetime &gt; <span class="number">0</span> &#123;</span><br><span class="line">k.releasetime = sglist.releasetime</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span> sg == sglist &#123;</span><br><span class="line"><span class="comment">// sg has already been dequeued by the G that woke us up.</span></span><br><span class="line"><span class="comment">// 确定这个sudog导致的自身被唤醒</span></span><br><span class="line">casi = <span class="keyword">int</span>(casei)</span><br><span class="line">cas = k</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line"><span class="comment">// 把其他还在等待的sudog从等待队列中移除</span></span><br><span class="line">c = k.c</span><br><span class="line"><span class="keyword">if</span> k.kind == caseSend &#123;</span><br><span class="line">c.sendq.dequeueSudoG(sglist)</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">c.recvq.dequeueSudoG(sglist)</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">sgnext = sglist.waitlink</span><br><span class="line">sglist.waitlink = <span class="literal">nil</span></span><br><span class="line">releaseSudog(sglist)</span><br><span class="line">sglist = sgnext</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> cas == <span class="literal">nil</span> &#123;</span><br><span class="line"><span class="comment">// 如果cas为nil，说明有可能因为其他因素被唤醒，再循环一次</span></span><br><span class="line"><span class="keyword">goto</span> loop</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">c = cas.c</span><br><span class="line"><span class="keyword">if</span> cas.kind == caseRecv &#123;</span><br><span class="line">recvOK = <span class="literal">true</span></span><br><span class="line">&#125;</span><br><span class="line">selunlock(scases, lockorder)</span><br><span class="line"><span class="keyword">goto</span> retc</span><br><span class="line"></span><br><span class="line">bufrecv:</span><br><span class="line"><span class="comment">// can receive from buffer</span></span><br><span class="line"><span class="comment">// recv操作，并buf不为空，从buf中获取数据即可</span></span><br><span class="line">recvOK = <span class="literal">true</span></span><br><span class="line">qp = chanbuf(c, c.recvx)</span><br><span class="line"><span class="keyword">if</span> cas.elem != <span class="literal">nil</span> &#123;</span><br><span class="line">typedmemmove(c.elemtype, cas.elem, qp)</span><br><span class="line">&#125;</span><br><span class="line">typedmemclr(c.elemtype, qp)</span><br><span class="line"><span class="comment">// 更新buf中recvx的索引</span></span><br><span class="line">c.recvx++</span><br><span class="line"><span class="keyword">if</span> c.recvx == c.dataqsiz &#123;</span><br><span class="line">c.recvx = <span class="number">0</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 更新buf中数据的数量</span></span><br><span class="line">c.qcount--</span><br><span class="line"><span class="comment">// 解锁当前case</span></span><br><span class="line">selunlock(scases, lockorder)</span><br><span class="line"><span class="keyword">goto</span> retc</span><br><span class="line"></span><br><span class="line">bufsend:</span><br><span class="line"><span class="comment">// can send to buffer</span></span><br><span class="line"><span class="comment">// send操作，且buf有空余位置存储，把自己的数据拷贝到buf队尾</span></span><br><span class="line">typedmemmove(c.elemtype, chanbuf(c, c.sendx), cas.elem)</span><br><span class="line"><span class="comment">// 更新buf中sendx的索引</span></span><br><span class="line">c.sendx++</span><br><span class="line"><span class="keyword">if</span> c.sendx == c.dataqsiz &#123;</span><br><span class="line">c.sendx = <span class="number">0</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 更新buf中数据的数量</span></span><br><span class="line">c.qcount++</span><br><span class="line"><span class="comment">// 解锁当前case</span></span><br><span class="line">selunlock(scases, lockorder)</span><br><span class="line"><span class="keyword">goto</span> retc</span><br><span class="line"></span><br><span class="line">recv:</span><br><span class="line"><span class="comment">// can receive from sleeping sender (sg)</span></span><br><span class="line"><span class="comment">// recv操作，但是sendq中有sudog在等待，通过recv方法，获取数据</span></span><br><span class="line">recv(c, sg, cas.elem, <span class="function"><span class="keyword">func</span><span class="params">()</span></span> &#123; selunlock(scases, lockorder) &#125;, <span class="number">2</span>)</span><br><span class="line">recvOK = <span class="literal">true</span></span><br><span class="line"><span class="keyword">goto</span> retc</span><br><span class="line"></span><br><span class="line">rclose:</span><br><span class="line"><span class="comment">// read at end of closed channel</span></span><br><span class="line"><span class="comment">// recv 操作，但是这个channel已经close了</span></span><br><span class="line">selunlock(scases, lockorder)</span><br><span class="line">recvOK = <span class="literal">false</span></span><br><span class="line"><span class="keyword">if</span> cas.elem != <span class="literal">nil</span> &#123;</span><br><span class="line">typedmemclr(c.elemtype, cas.elem)</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">goto</span> retc</span><br><span class="line"></span><br><span class="line">send:</span><br><span class="line"><span class="comment">// can send to a sleeping receiver (sg)</span></span><br><span class="line"><span class="comment">// send操作，但是recvq队列中有在等待的sudog</span></span><br><span class="line">send(c, sg, cas.elem, <span class="function"><span class="keyword">func</span><span class="params">()</span></span> &#123; selunlock(scases, lockorder) &#125;, <span class="number">2</span>)</span><br><span class="line"><span class="keyword">goto</span> retc</span><br><span class="line"></span><br><span class="line">retc:</span><br><span class="line"><span class="comment">// 返回</span></span><br><span class="line"><span class="keyword">return</span> casi, recvOK</span><br><span class="line"></span><br><span class="line">sclose:</span><br><span class="line"><span class="comment">// send on closed channel</span></span><br><span class="line">selunlock(scases, lockorder)</span><br><span class="line"><span class="built_in">panic</span>(plainError(<span class="string">"send on closed channel"</span>))</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="selectnbrecv"><a href="#selectnbrecv" class="headerlink" title="selectnbrecv"></a>selectnbrecv</h3><p>当一个select里面只有一个 case，且这个case 是接收数据的操作的时候，select就会调用 <code>selectnbrecv</code> 函数来实现</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">selectnbrecv</span><span class="params">(elem unsafe.Pointer, c *hchan)</span> <span class="params">(selected <span class="keyword">bool</span>)</span></span> &#123;</span><br><span class="line">selected, _ = chanrecv(c, elem, <span class="literal">false</span>)</span><br><span class="line"><span class="keyword">return</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这里就会发现 <code>selectnbrecv</code> 就是调用了 <code>chanrecv</code> 来实现，也就是我们上面解析的 <code>&lt;- c1</code> 是一样的，就相当于 select 退变 成单独的 <code>&lt;- c</code> 的表达了</p><h3 id="selectnbsend"><a href="#selectnbsend" class="headerlink" title="selectnbsend"></a>selectnbsend</h3><p>同 <code>selectnbrecv</code> 一样，当select只有一个case，且这个case是发送数据到channel的，就会退变成 <code>c &lt;- 1</code> 的表达了</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">selectnbsend</span><span class="params">(c *hchan, elem unsafe.Pointer)</span> <span class="params">(selected <span class="keyword">bool</span>)</span></span> &#123;</span><br><span class="line"><span class="keyword">return</span> chansend(c, elem, <span class="literal">false</span>, getcallerpc())</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="总结-1"><a href="#总结-1" class="headerlink" title="总结"></a>总结</h3><p>所以，select的流程大致如下</p><ol><li>对每个case进行收发判断，是否需要阻塞，不需要，直接跳转执行</li><li>如果每个case的收发操作都需要阻塞等待，则判断有没有default，如果有，执行default</li><li>如果每个case的收发操作都需要徐瑟等待，且没有default，那就为每个case创建一个sudog，绑定到case对应的channel的sendq或recvq队列</li><li>如果某个sudog被临幸，然后被唤醒了，清空所有sudog的数据等属性，并把其他的sudog从队列中移除</li><li>至此，一个select操作结束</li></ol><h1 id="总结-2"><a href="#总结-2" class="headerlink" title="总结"></a>总结</h1><p>我还是很像吐槽一下，<code>selectgo</code> 函数华丽丽的写了300多行，里面还使用了若干的 <code>goto</code> 去进行跳转，真的不可以分拆一下吗，不过大神的代码，还是真的需要膜拜的</p><h1 id="参考文档"><a href="#参考文档" class="headerlink" title="参考文档"></a>参考文档</h1><ul><li><p>《Go语言学习笔记》– 雨痕</p></li><li><p><a href="http://legendtkl.com/2017/08/06/golang-channel-implement/" target="_blank" rel="noopener">Go CHannel 源码剖析</a></p></li><li><p><a href="http://legendtkl.com/2017/07/30/understanding-golang-channel/" target="_blank" rel="noopener">深入理解 Go Channel</a></p></li><li><p><a href="https://my.oschina.net/renhc/blog/2246871" target="_blank" rel="noopener">Go channel实现原理剖析</a></p></li></ul>]]></content>
      
      
      <categories>
          
          <category> Go </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Go </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>深入理解Go-goroutine的实现及调度器分析</title>
      <link href="/posts/14010/"/>
      <url>/posts/14010/</url>
      
        <content type="html"><![CDATA[<p>在学习Go的过程中，最让人惊叹的莫过于goroutine了。但是goroutine是什么，我们用<code>go</code>关键字就可以创建一个goroutine，这么多的goroutine之间，是如何调度的呢？</p><a id="more"></a><h1 id="结构概览"><a href="#结构概览" class="headerlink" title="结构概览"></a>结构概览</h1><p>在看Go源码的过程中，遍地可见g、p、m，我们首先就看一下这些关键字的结构及相互之间的关系</p><h2 id="数据结构"><a href="#数据结构" class="headerlink" title="数据结构"></a>数据结构</h2><p>这里我们仅列出来了结构体里面比较关键的一些成员</p><h3 id="G-gouroutine"><a href="#G-gouroutine" class="headerlink" title="G(gouroutine)"></a>G(gouroutine)</h3><p>goroutine是运行时的最小执行单元</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> g <span class="keyword">struct</span> &#123;</span><br><span class="line"><span class="comment">// Stack parameters.</span></span><br><span class="line"><span class="comment">// stack describes the actual stack memory: [stack.lo, stack.hi).</span></span><br><span class="line"><span class="comment">// stackguard0 is the stack pointer compared in the Go stack growth prologue.</span></span><br><span class="line"><span class="comment">// It is stack.lo+StackGuard normally, but can be StackPreempt to trigger a preemption.</span></span><br><span class="line"><span class="comment">// stackguard1 is the stack pointer compared in the C stack growth prologue.</span></span><br><span class="line"><span class="comment">// It is stack.lo+StackGuard on g0 and gsignal stacks.</span></span><br><span class="line"><span class="comment">// It is ~0 on other goroutine stacks, to trigger a call to morestackc (and crash).</span></span><br><span class="line">  <span class="comment">// 当前g使用的栈空间，stack结构包括 [lo, hi]两个成员</span></span><br><span class="line">stack       stack   <span class="comment">// offset known to runtime/cgo</span></span><br><span class="line">  <span class="comment">// 用于检测是否需要进行栈扩张，go代码使用</span></span><br><span class="line">stackguard0 <span class="keyword">uintptr</span> <span class="comment">// offset known to liblink</span></span><br><span class="line">  <span class="comment">// 用于检测是否需要进行栈扩展，原生代码使用的</span></span><br><span class="line">stackguard1 <span class="keyword">uintptr</span> <span class="comment">// offset known to liblink</span></span><br><span class="line">  <span class="comment">// 当前g所绑定的m</span></span><br><span class="line">m              *m      <span class="comment">// current m; offset known to arm liblink</span></span><br><span class="line">  <span class="comment">// 当前g的调度数据，当goroutine切换时，保存当前g的上下文，用于恢复</span></span><br><span class="line">sched          gobuf</span><br><span class="line"><span class="comment">// g当前的状态</span></span><br><span class="line">atomicstatus   <span class="keyword">uint32</span></span><br><span class="line">  <span class="comment">// 当前g的id</span></span><br><span class="line">goid           <span class="keyword">int64</span></span><br><span class="line">  <span class="comment">// 下一个g的地址，通过guintptr结构体的ptr set函数可以设置和获取下一个g，通过这个字段和sched.gfreeStack sched.gfreeNoStack 可以把 free g串成一个链表</span></span><br><span class="line">schedlink      guintptr</span><br><span class="line">  <span class="comment">// 判断g是否允许被抢占</span></span><br><span class="line">preempt        <span class="keyword">bool</span>       <span class="comment">// preemption signal, duplicates stackguard0 = stackpreempt</span></span><br><span class="line"><span class="comment">// g是否要求要回到这个M执行, 有的时候g中断了恢复会要求使用原来的M执行</span></span><br><span class="line">lockedm        muintptr</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="P-process"><a href="#P-process" class="headerlink" title="P(process)"></a>P(process)</h3><p>P是M运行G所需的资源</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> p <span class="keyword">struct</span> &#123;</span><br><span class="line">   lock mutex</span><br><span class="line"></span><br><span class="line">   id          <span class="keyword">int32</span></span><br><span class="line">   <span class="comment">// p的状态，稍后介绍</span></span><br><span class="line">   status      <span class="keyword">uint32</span> <span class="comment">// one of pidle/prunning/...</span></span><br><span class="line">   <span class="comment">// 下一个p的地址，可参考 g.schedlink</span></span><br><span class="line">   link        puintptr</span><br><span class="line">   <span class="comment">// p所关联的m</span></span><br><span class="line">   m           muintptr   <span class="comment">// back-link to associated m (nil if idle)</span></span><br><span class="line">   <span class="comment">// 内存分配的时候用的，p所属的m的mcache用的也是这个</span></span><br><span class="line">   mcache      *mcache</span><br><span class="line">  </span><br><span class="line">   <span class="comment">// Cache of goroutine ids, amortizes accesses to runtime·sched.goidgen.</span></span><br><span class="line">   <span class="comment">// 从sched中获取并缓存的id，避免每次分配goid都从sched分配</span></span><br><span class="line"> goidcache    <span class="keyword">uint64</span></span><br><span class="line"> goidcacheend <span class="keyword">uint64</span></span><br><span class="line"></span><br><span class="line">   <span class="comment">// Queue of runnable goroutines. Accessed without lock.</span></span><br><span class="line">   <span class="comment">// p 本地的runnbale的goroutine形成的队列</span></span><br><span class="line">   runqhead <span class="keyword">uint32</span></span><br><span class="line">   runqtail <span class="keyword">uint32</span></span><br><span class="line">   runq     [<span class="number">256</span>]guintptr</span><br><span class="line">   <span class="comment">// runnext, if non-nil, is a runnable G that was ready'd by</span></span><br><span class="line">   <span class="comment">// the current G and should be run next instead of what's in</span></span><br><span class="line">   <span class="comment">// runq if there's time remaining in the running G's time</span></span><br><span class="line">   <span class="comment">// slice. It will inherit the time left in the current time</span></span><br><span class="line">   <span class="comment">// slice. If a set of goroutines is locked in a</span></span><br><span class="line">   <span class="comment">// communicate-and-wait pattern, this schedules that set as a</span></span><br><span class="line">   <span class="comment">// unit and eliminates the (potentially large) scheduling</span></span><br><span class="line">   <span class="comment">// latency that otherwise arises from adding the ready'd</span></span><br><span class="line">   <span class="comment">// goroutines to the end of the run queue.</span></span><br><span class="line">   <span class="comment">// 下一个执行的g，如果是nil，则从队列中获取下一个执行的g</span></span><br><span class="line">   runnext guintptr</span><br><span class="line"></span><br><span class="line">   <span class="comment">// Available G's (status == Gdead)</span></span><br><span class="line">   <span class="comment">// 状态为 Gdead的g的列表，可以进行复用</span></span><br><span class="line">   gfree    *g</span><br><span class="line">   gfreecnt <span class="keyword">int32</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="M-machine"><a href="#M-machine" class="headerlink" title="M(machine)"></a>M(machine)</h3><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> m <span class="keyword">struct</span> &#123;</span><br><span class="line">   <span class="comment">// g0是用于调度和执行系统调用的特殊g</span></span><br><span class="line">   g0      *g     <span class="comment">// goroutine with scheduling stack</span></span><br><span class="line"> <span class="comment">// m当前运行的g</span></span><br><span class="line">   curg          *g       <span class="comment">// current running goroutine</span></span><br><span class="line">   <span class="comment">// 当前拥有的p</span></span><br><span class="line">   p             puintptr <span class="comment">// attached p for executing go code (nil if not executing go code)</span></span><br><span class="line">   <span class="comment">// 线程的 local storage</span></span><br><span class="line">   tls           [<span class="number">6</span>]<span class="keyword">uintptr</span>   <span class="comment">// thread-local storage</span></span><br><span class="line">   <span class="comment">// 唤醒m时，m会拥有这个p</span></span><br><span class="line">   nextp         puintptr</span><br><span class="line">   id            <span class="keyword">int64</span></span><br><span class="line">   <span class="comment">// 如果 !="", 继续运行curg</span></span><br><span class="line">   preemptoff    <span class="keyword">string</span> <span class="comment">// if != "", keep curg running on this m</span></span><br><span class="line">   <span class="comment">// 自旋状态，用于判断m是否工作已结束，并寻找g进行工作</span></span><br><span class="line">   spinning      <span class="keyword">bool</span> <span class="comment">// m is out of work and is actively looking for work</span></span><br><span class="line">   <span class="comment">// 用于判断m是否进行休眠状态</span></span><br><span class="line">   blocked       <span class="keyword">bool</span> <span class="comment">// m is blocked on a note</span></span><br><span class="line"> <span class="comment">// m休眠和唤醒通过这个，note里面有一个成员key，对这个key所指向的地址进行值的修改，进而达到唤醒和休眠的目的</span></span><br><span class="line">   park          note</span><br><span class="line">   <span class="comment">// 所有m组成的一个链表</span></span><br><span class="line">   alllink       *m <span class="comment">// on allm</span></span><br><span class="line">   <span class="comment">// 下一个m，通过这个字段和sched.midle 可以串成一个m的空闲链表</span></span><br><span class="line">   schedlink     muintptr</span><br><span class="line">   <span class="comment">// mcache，m拥有p的时候，会把自己的mcache给p</span></span><br><span class="line">   mcache        *mcache</span><br><span class="line">   <span class="comment">// lockedm的对应值</span></span><br><span class="line">   lockedg       guintptr</span><br><span class="line">   <span class="comment">// 待释放的m的list，通过sched.freem 串成一个链表</span></span><br><span class="line">   freelink      *m      <span class="comment">// on sched.freem</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="sched"><a href="#sched" class="headerlink" title="sched"></a>sched</h3><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> schedt <span class="keyword">struct</span> &#123;</span><br><span class="line">   <span class="comment">// 全局的go id分配</span></span><br><span class="line">   goidgen  <span class="keyword">uint64</span></span><br><span class="line">   <span class="comment">// 记录的最后一次从i/o中查询g的时间</span></span><br><span class="line">   lastpoll <span class="keyword">uint64</span></span><br><span class="line"></span><br><span class="line">   lock mutex</span><br><span class="line"></span><br><span class="line">   <span class="comment">// When increasing nmidle, nmidlelocked, nmsys, or nmfreed, be</span></span><br><span class="line">   <span class="comment">// sure to call checkdead().</span></span><br><span class="line"> <span class="comment">// m的空闲链表，结合m.schedlink 就可以组成一个空闲链表了</span></span><br><span class="line">   midle        muintptr <span class="comment">// idle m's waiting for work</span></span><br><span class="line">   nmidle       <span class="keyword">int32</span>    <span class="comment">// number of idle m's waiting for work</span></span><br><span class="line">   nmidlelocked <span class="keyword">int32</span>    <span class="comment">// number of locked m's waiting for work</span></span><br><span class="line">   <span class="comment">// 下一个m的id，也用来记录创建的m数量</span></span><br><span class="line">   mnext        <span class="keyword">int64</span>    <span class="comment">// number of m's that have been created and next M ID</span></span><br><span class="line">   <span class="comment">// 最多允许的m的数量</span></span><br><span class="line">   maxmcount    <span class="keyword">int32</span>    <span class="comment">// maximum number of m's allowed (or die)</span></span><br><span class="line">   nmsys        <span class="keyword">int32</span>    <span class="comment">// number of system m's not counted for deadlock</span></span><br><span class="line">   <span class="comment">// free掉的m的数量，exit的m的数量</span></span><br><span class="line">   nmfreed      <span class="keyword">int64</span>    <span class="comment">// cumulative number of freed m's</span></span><br><span class="line"></span><br><span class="line">   ngsys <span class="keyword">uint32</span> <span class="comment">// number of system goroutines; updated atomically</span></span><br><span class="line"></span><br><span class="line">   pidle      puintptr <span class="comment">// idle p's</span></span><br><span class="line">   npidle     <span class="keyword">uint32</span></span><br><span class="line">   nmspinning <span class="keyword">uint32</span> <span class="comment">// See "Worker thread parking/unparking" comment in proc.go.</span></span><br><span class="line"></span><br><span class="line">   <span class="comment">// Global runnable queue.</span></span><br><span class="line">   <span class="comment">// 这个就是全局的g的队列了，如果p的本地队列没有g或者太多，会跟全局队列进行平衡</span></span><br><span class="line">   <span class="comment">// 根据runqhead可以获取队列头的g，然后根据g.schedlink 获取下一个，从而形成了一个链表</span></span><br><span class="line">   runqhead guintptr</span><br><span class="line">   runqtail guintptr</span><br><span class="line">   runqsize <span class="keyword">int32</span></span><br><span class="line"></span><br><span class="line">   <span class="comment">// freem is the list of m's waiting to be freed when their</span></span><br><span class="line">   <span class="comment">// m.exited is set. Linked through m.freelink.</span></span><br><span class="line">   <span class="comment">// 等待释放的m的列表</span></span><br><span class="line">   freem *m</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在这里插一下状态的解析</p><h3 id="g-status"><a href="#g-status" class="headerlink" title="g.status"></a>g.status</h3><ul><li>_Gidle: goroutine刚刚创建还没有初始化</li><li>_Grunnable: goroutine处于运行队列中，但是还没有运行，没有自己的栈</li><li>_Grunning:  这个状态的g可能处于运行用户代码的过程中，拥有自己的m和p</li><li>_Gsyscall: 运行systemcall中</li><li>_Gwaiting: 这个状态的goroutine正在阻塞中，类似于等待channel</li><li>_Gdead: 这个状态的g没有被使用，有可能是刚刚退出，也有可能是正在初始化中</li><li>_Gcopystack: 表示g当前的栈正在被移除，新栈分配中</li></ul><h3 id="p-status"><a href="#p-status" class="headerlink" title="p.status"></a>p.status</h3><ul><li>_Pidle: 空闲状态，此时p不绑定m</li><li>_Prunning: m获取到p的时候，p的状态就是这个状态了，然后m可以使用这个p的资源运行g</li><li>_Psyscall: 当go调用原生代码，原生代码又反过来调用go的时候，使用的p就会变成此态</li><li>_Pdead: 当运行中，需要减少p的数量时，被减掉的p的状态就是这个了</li></ul><h3 id="m-status"><a href="#m-status" class="headerlink" title="m.status"></a>m.status</h3><p>m的status没有p、g的那么明确，但是在运行流程的分析中，主要有以下几个状态</p><ul><li>运行中: 拿到p，执行g的过程中</li><li>运行原生代码: 正在执行原声代码或者阻塞的syscall</li><li>休眠中: m发现无待运行的g时，进入休眠，并加入到空闲列表中</li><li>自旋中(spining): 当前工作结束，正在寻找下一个待运行的g</li></ul><p>在上面的结构中，存在很多的链表，g m p结构中还有指向对方地址的成员，那么他们的关系到底是什么样的</p><p><img src="http://note-1253518569.cossh.myqcloud.com/20190830155713.png" alt></p><p>我们可以从上图，简单的表述一下 m p g的关系</p><h1 id="流程概览"><a href="#流程概览" class="headerlink" title="流程概览"></a>流程概览</h1><p>从下图，可以简单的一窥go的整个调度流程的大概</p><p><img src="http://note-1253518569.cossh.myqcloud.com/20190830154901.png" alt></p><p>接下来我们就从源码的角度来具体的分析整个调度流程（本人汇编不照，汇编方面的就不分析了🤪）</p><h1 id="源码分析"><a href="#源码分析" class="headerlink" title="源码分析"></a>源码分析</h1><h2 id="初始化"><a href="#初始化" class="headerlink" title="初始化"></a>初始化</h2><p>go的启动流程分为4步</p><ol><li>call osinit， 这里就是设置了全局变量ncpu = cpu核心数量</li><li>call schedinit</li><li>make &amp; queue new G （runtime.newproc, go func()也是调用这个函数来创建goroutine）</li><li>call runtime·mstart</li></ol><p>其中，schedinit 就是调度器的初始化，出去schedinit 中对内存分配，垃圾回收等操作，针对调度器的初始化大致就是初始化自身，设置最大的maxmcount， 确定p的数量并初始化这些操作</p><h3 id="schedinit"><a href="#schedinit" class="headerlink" title="schedinit"></a>schedinit</h3><p>schedinit这里对当前m进行了初始化，并根据osinit获取到的cpu核数和设置的<code>GOMAXPROCS</code> 确定p的数量，并进行初始化</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">schedinit</span><span class="params">()</span></span> &#123;</span><br><span class="line"><span class="comment">// 从TLS或者专用寄存器获取当前g的指针类型</span></span><br><span class="line">_g_ := getg()</span><br><span class="line"><span class="comment">// 设置m最大的数量</span></span><br><span class="line">sched.maxmcount = <span class="number">10000</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 初始化栈的复用空间</span></span><br><span class="line">stackinit()</span><br><span class="line"><span class="comment">// 初始化当前m</span></span><br><span class="line">mcommoninit(_g_.m)</span><br><span class="line"></span><br><span class="line"><span class="comment">// osinit的时候会设置 ncpu这个全局变量，这里就是根据cpu核心数和参数GOMAXPROCS来确定p的数量</span></span><br><span class="line">procs := ncpu</span><br><span class="line"><span class="keyword">if</span> n, ok := atoi32(gogetenv(<span class="string">"GOMAXPROCS"</span>)); ok &amp;&amp; n &gt; <span class="number">0</span> &#123;</span><br><span class="line">procs = n</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 生成设定数量的p</span></span><br><span class="line"><span class="keyword">if</span> procresize(procs) != <span class="literal">nil</span> &#123;</span><br><span class="line">throw(<span class="string">"unknown runnable goroutine during bootstrap"</span>)</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="mcommoninit"><a href="#mcommoninit" class="headerlink" title="mcommoninit"></a>mcommoninit</h3><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">mcommoninit</span><span class="params">(mp *m)</span></span> &#123;</span><br><span class="line">_g_ := getg()</span><br><span class="line"></span><br><span class="line">lock(&amp;sched.lock)</span><br><span class="line"><span class="comment">// 判断mnext的值是否溢出，mnext需要赋值给m.id</span></span><br><span class="line"><span class="keyword">if</span> sched.mnext+<span class="number">1</span> &lt; sched.mnext &#123;</span><br><span class="line">throw(<span class="string">"runtime: thread ID overflow"</span>)</span><br><span class="line">&#125;</span><br><span class="line">mp.id = sched.mnext</span><br><span class="line">sched.mnext++</span><br><span class="line"><span class="comment">// 判断m的数量是否比maxmcount设定的要多，如果超出直接报异常</span></span><br><span class="line">checkmcount()</span><br><span class="line"><span class="comment">// 创建一个新的g用于处理signal，并分配栈</span></span><br><span class="line">mpreinit(mp)</span><br><span class="line"><span class="keyword">if</span> mp.gsignal != <span class="literal">nil</span> &#123;</span><br><span class="line">mp.gsignal.stackguard1 = mp.gsignal.stack.lo + _StackGuard</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Add to allm so garbage collector doesn't free g-&gt;m</span></span><br><span class="line"><span class="comment">// when it is just in a register or thread-local storage.</span></span><br><span class="line"><span class="comment">// 接下来的两行，首先将当前m放到allm的头，然后原子操作，将当前m的地址，赋值给m，这样就将当前m添加到了allm链表的头了</span></span><br><span class="line">mp.alllink = allm</span><br><span class="line"></span><br><span class="line"><span class="comment">// NumCgoCall() iterates over allm w/o schedlock,</span></span><br><span class="line"><span class="comment">// so we need to publish it safely.</span></span><br><span class="line">atomicstorep(unsafe.Pointer(&amp;allm), unsafe.Pointer(mp))</span><br><span class="line">unlock(&amp;sched.lock)</span><br><span class="line"></span><br><span class="line"><span class="comment">// Allocate memory to hold a cgo traceback if the cgo call crashes.</span></span><br><span class="line"><span class="keyword">if</span> iscgo || GOOS == <span class="string">"solaris"</span> || GOOS == <span class="string">"windows"</span> &#123;</span><br><span class="line">mp.cgoCallers = <span class="built_in">new</span>(cgoCallers)</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在这里就开始涉及到了m链表了，这个链表可以如下图表示，其他的p g链表可以参考，只是使用的结构体的字段不一样</p><h4 id="3-1-1-2-allm链表示意图"><a href="#3-1-1-2-allm链表示意图" class="headerlink" title="3.1.1.2. allm链表示意图"></a>3.1.1.2. allm链表示意图</h4><p><img src="http://note-1253518569.cossh.myqcloud.com/20190831105630.png" alt></p><h4 id="3-1-1-3-procresize"><a href="#3-1-1-3-procresize" class="headerlink" title="3.1.1.3. procresize"></a>3.1.1.3. procresize</h4><p>更改p的数量，多退少补的原则，在初始化过程中，由于最开始是没有p的，所以这里的作用就是初始化设定数量的p了</p><p><code>procesize</code> 不仅在初始化的时候会调用，当用户手动调用 <code>runtime.GOMAXPROCS</code> 的时候，会重新设定 nprocs，然后执行 <code>startTheWorld()</code>， <code>startTheWorld()</code>会是使用新的 nprocs 再次调用<code>procresize</code> 这个方法</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">procresize</span><span class="params">(nprocs <span class="keyword">int32</span>)</span> *<span class="title">p</span></span> &#123;</span><br><span class="line">old := gomaxprocs</span><br><span class="line"><span class="keyword">if</span> old &lt; <span class="number">0</span> || nprocs &lt;= <span class="number">0</span> &#123;</span><br><span class="line">throw(<span class="string">"procresize: invalid arg"</span>)</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// update statistics</span></span><br><span class="line">now := nanotime()</span><br><span class="line"><span class="keyword">if</span> sched.procresizetime != <span class="number">0</span> &#123;</span><br><span class="line">sched.totaltime += <span class="keyword">int64</span>(old) * (now - sched.procresizetime)</span><br><span class="line">&#125;</span><br><span class="line">sched.procresizetime = now</span><br><span class="line"></span><br><span class="line"><span class="comment">// Grow allp if necessary.</span></span><br><span class="line"><span class="comment">// 如果新给的p的数量比原先的p的数量多，则新建增长的p</span></span><br><span class="line"><span class="keyword">if</span> nprocs &gt; <span class="keyword">int32</span>(<span class="built_in">len</span>(allp)) &#123;</span><br><span class="line"><span class="comment">// Synchronize with retake, which could be running</span></span><br><span class="line"><span class="comment">// concurrently since it doesn't run on a P.</span></span><br><span class="line">lock(&amp;allpLock)</span><br><span class="line"><span class="comment">// 判断allp 的cap是否满足增长后的长度，满足就直接使用，不满足，则需要扩张这个slice</span></span><br><span class="line"><span class="keyword">if</span> nprocs &lt;= <span class="keyword">int32</span>(<span class="built_in">cap</span>(allp)) &#123;</span><br><span class="line">allp = allp[:nprocs]</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">nallp := <span class="built_in">make</span>([]*p, nprocs)</span><br><span class="line"><span class="comment">// Copy everything up to allp's cap so we</span></span><br><span class="line"><span class="comment">// never lose old allocated Ps.</span></span><br><span class="line"><span class="built_in">copy</span>(nallp, allp[:<span class="built_in">cap</span>(allp)])</span><br><span class="line">allp = nallp</span><br><span class="line">&#125;</span><br><span class="line">unlock(&amp;allpLock)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// initialize new P's</span></span><br><span class="line"><span class="comment">// 初始化新增的p</span></span><br><span class="line"><span class="keyword">for</span> i := <span class="keyword">int32</span>(<span class="number">0</span>); i &lt; nprocs; i++ &#123;</span><br><span class="line">pp := allp[i]</span><br><span class="line"><span class="keyword">if</span> pp == <span class="literal">nil</span> &#123;</span><br><span class="line">pp = <span class="built_in">new</span>(p)</span><br><span class="line">pp.id = i</span><br><span class="line">pp.status = _Pgcstop</span><br><span class="line">pp.sudogcache = pp.sudogbuf[:<span class="number">0</span>]</span><br><span class="line"><span class="keyword">for</span> i := <span class="keyword">range</span> pp.deferpool &#123;</span><br><span class="line">pp.deferpool[i] = pp.deferpoolbuf[i][:<span class="number">0</span>]</span><br><span class="line">&#125;</span><br><span class="line">pp.wbBuf.reset()</span><br><span class="line"><span class="comment">// allp是一个slice，直接将新增的p放到对应的索引下面就ok了</span></span><br><span class="line">atomicstorep(unsafe.Pointer(&amp;allp[i]), unsafe.Pointer(pp))</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span> pp.mcache == <span class="literal">nil</span> &#123;</span><br><span class="line"><span class="comment">// 初始化时，old=0，第一个新建的p给当前的m使用</span></span><br><span class="line"><span class="keyword">if</span> old == <span class="number">0</span> &amp;&amp; i == <span class="number">0</span> &#123;</span><br><span class="line"><span class="keyword">if</span> getg().m.mcache == <span class="literal">nil</span> &#123;</span><br><span class="line">throw(<span class="string">"missing mcache?"</span>)</span><br><span class="line">&#125;</span><br><span class="line">pp.mcache = getg().m.mcache <span class="comment">// bootstrap</span></span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line"><span class="comment">// 为p分配内存</span></span><br><span class="line">pp.mcache = allocmcache()</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// free unused P's</span></span><br><span class="line"><span class="comment">// 释放掉多余的p，当新设置的p的数量，比原先设定的p的数量少的时候，会走到这个流程</span></span><br><span class="line"><span class="comment">// 通过 runtime.GOMAXPROCS 就可以动态的修改nprocs</span></span><br><span class="line"><span class="keyword">for</span> i := nprocs; i &lt; old; i++ &#123;</span><br><span class="line">p := allp[i]</span><br><span class="line"><span class="comment">// move all runnable goroutines to the global queue</span></span><br><span class="line"><span class="comment">// 把当前p的运行队列里的g转移到全局的g的队列</span></span><br><span class="line"><span class="keyword">for</span> p.runqhead != p.runqtail &#123;</span><br><span class="line"><span class="comment">// pop from tail of local queue</span></span><br><span class="line">p.runqtail--</span><br><span class="line">gp := p.runq[p.runqtail%<span class="keyword">uint32</span>(<span class="built_in">len</span>(p.runq))].ptr()</span><br><span class="line"><span class="comment">// push onto head of global queue</span></span><br><span class="line">globrunqputhead(gp)</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 把runnext里的g也转移到全局队列</span></span><br><span class="line"><span class="keyword">if</span> p.runnext != <span class="number">0</span> &#123;</span><br><span class="line">globrunqputhead(p.runnext.ptr())</span><br><span class="line">p.runnext = <span class="number">0</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// if there's a background worker, make it runnable and put</span></span><br><span class="line"><span class="comment">// it on the global queue so it can clean itself up</span></span><br><span class="line"><span class="comment">// 如果有gc worker的话，修改g的状态，然后再把它放到全局队列中</span></span><br><span class="line"><span class="keyword">if</span> gp := p.gcBgMarkWorker.ptr(); gp != <span class="literal">nil</span> &#123;</span><br><span class="line">casgstatus(gp, _Gwaiting, _Grunnable)</span><br><span class="line">globrunqput(gp)</span><br><span class="line"><span class="comment">// This assignment doesn't race because the</span></span><br><span class="line"><span class="comment">// world is stopped.</span></span><br><span class="line">p.gcBgMarkWorker.set(<span class="literal">nil</span>)</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// sudoig的buf和cache，以及deferpool全部清空</span></span><br><span class="line"><span class="keyword">for</span> i := <span class="keyword">range</span> p.sudogbuf &#123;</span><br><span class="line">p.sudogbuf[i] = <span class="literal">nil</span></span><br><span class="line">&#125;</span><br><span class="line">p.sudogcache = p.sudogbuf[:<span class="number">0</span>]</span><br><span class="line"><span class="keyword">for</span> i := <span class="keyword">range</span> p.deferpool &#123;</span><br><span class="line"><span class="keyword">for</span> j := <span class="keyword">range</span> p.deferpoolbuf[i] &#123;</span><br><span class="line">p.deferpoolbuf[i][j] = <span class="literal">nil</span></span><br><span class="line">&#125;</span><br><span class="line">p.deferpool[i] = p.deferpoolbuf[i][:<span class="number">0</span>]</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 释放掉当前p的mcache</span></span><br><span class="line">freemcache(p.mcache)</span><br><span class="line">p.mcache = <span class="literal">nil</span></span><br><span class="line"><span class="comment">// 把当前p的gfree转移到全局</span></span><br><span class="line">gfpurge(p)</span><br><span class="line"><span class="comment">// 修改p的状态，让他自生自灭去了</span></span><br><span class="line">p.status = _Pdead</span><br><span class="line"><span class="comment">// can't free P itself because it can be referenced by an M in syscall</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Trim allp.</span></span><br><span class="line"><span class="keyword">if</span> <span class="keyword">int32</span>(<span class="built_in">len</span>(allp)) != nprocs &#123;</span><br><span class="line">lock(&amp;allpLock)</span><br><span class="line">allp = allp[:nprocs]</span><br><span class="line">unlock(&amp;allpLock)</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 判断当前g是否有p，有的话更改当前使用的p的状态，继续使用</span></span><br><span class="line">_g_ := getg()</span><br><span class="line"><span class="keyword">if</span> _g_.m.p != <span class="number">0</span> &amp;&amp; _g_.m.p.ptr().id &lt; nprocs &#123;</span><br><span class="line"><span class="comment">// continue to use the current P</span></span><br><span class="line">_g_.m.p.ptr().status = _Prunning</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line"><span class="comment">// release the current P and acquire allp[0]</span></span><br><span class="line"><span class="comment">// 如果当前g有p，但是拥有的是已经释放的p，则不再使用这个p，重新分配</span></span><br><span class="line"><span class="keyword">if</span> _g_.m.p != <span class="number">0</span> &#123;</span><br><span class="line">_g_.m.p.ptr().m = <span class="number">0</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 分配allp[0]给当前g使用</span></span><br><span class="line">_g_.m.p = <span class="number">0</span></span><br><span class="line">_g_.m.mcache = <span class="literal">nil</span></span><br><span class="line">p := allp[<span class="number">0</span>]</span><br><span class="line">p.m = <span class="number">0</span></span><br><span class="line">p.status = _Pidle</span><br><span class="line"><span class="comment">// 将p m g绑定，并把m.mcache指向p.mcache，并修改p的状态为_Prunning</span></span><br><span class="line">acquirep(p)</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">var</span> runnablePs *p</span><br><span class="line"><span class="keyword">for</span> i := nprocs - <span class="number">1</span>; i &gt;= <span class="number">0</span>; i-- &#123;</span><br><span class="line">p := allp[i]</span><br><span class="line"><span class="keyword">if</span> _g_.m.p.ptr() == p &#123;</span><br><span class="line"><span class="keyword">continue</span></span><br><span class="line">&#125;</span><br><span class="line">p.status = _Pidle</span><br><span class="line"><span class="comment">// 根据 runqempty 来判断当前p的g运行队列是否为空</span></span><br><span class="line"><span class="keyword">if</span> runqempty(p) &#123;</span><br><span class="line"><span class="comment">// g运行队列为空的p，放到 sched的pidle队列里面</span></span><br><span class="line">pidleput(p)</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line"><span class="comment">// g 运行队列不为空的p，组成一个可运行队列，并最后返回</span></span><br><span class="line">p.m.set(mget())</span><br><span class="line">p.link.set(runnablePs)</span><br><span class="line">runnablePs = p</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">stealOrder.reset(<span class="keyword">uint32</span>(nprocs))</span><br><span class="line"><span class="keyword">var</span> int32p *<span class="keyword">int32</span> = &amp;gomaxprocs <span class="comment">// make compiler check that gomaxprocs is an int32</span></span><br><span class="line">atomic.Store((*<span class="keyword">uint32</span>)(unsafe.Pointer(int32p)), <span class="keyword">uint32</span>(nprocs))</span><br><span class="line"><span class="keyword">return</span> runnablePs</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>runqempty: 这个函数比较简单，就不深究了，就是根据 p.runqtail == p.runqhead 和 p.runnext 来判断有没有待运行的g</li><li>pidleput: 将当前的p设置为 sched.pidle，然后根据p.link将空闲p串联起来，可参考上图allm的链表示意图</li></ul><h2 id="任务"><a href="#任务" class="headerlink" title="任务"></a>任务</h2><p>创建一个goroutine，只需要使用 <code>go func</code> 就可以了，编译器会将<code>go func</code> 翻译成 <code>newproc</code> 进行调用，那么新建的任务是如何调用的呢，我们从创建开始进行跟踪</p><h3 id="newproc"><a href="#newproc" class="headerlink" title="newproc"></a>newproc</h3><p><code>newproc</code> 函数获取了参数和当前g的pc信息，并通过g0调用<code>newproc1</code>去真正的执行创建或获取可用的g</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">newproc</span><span class="params">(siz <span class="keyword">int32</span>, fn *funcval)</span></span> &#123;</span><br><span class="line"><span class="comment">// 获取第一参数地址</span></span><br><span class="line">argp := add(unsafe.Pointer(&amp;fn), sys.PtrSize)</span><br><span class="line"><span class="comment">// 获取当前执行的g</span></span><br><span class="line">gp := getg()</span><br><span class="line"><span class="comment">// 获取当前g的pc</span></span><br><span class="line">pc := getcallerpc()</span><br><span class="line">systemstack(<span class="function"><span class="keyword">func</span><span class="params">()</span></span> &#123;</span><br><span class="line"><span class="comment">// 使用g0去执行newproc1函数</span></span><br><span class="line">newproc1(fn, (*<span class="keyword">uint8</span>)(argp), siz, gp, pc)</span><br><span class="line">&#125;)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="newproc1"><a href="#newproc1" class="headerlink" title="newproc1"></a>newproc1</h3><p>newporc1 的作用就是创建或者获取一个空间的g，初始化这个g，并尝试寻找一个p和m去执行g</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">newproc1</span><span class="params">(fn *funcval, argp *<span class="keyword">uint8</span>, narg <span class="keyword">int32</span>, callergp *g, callerpc <span class="keyword">uintptr</span>)</span></span> &#123;</span><br><span class="line">_g_ := getg()</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> fn == <span class="literal">nil</span> &#123;</span><br><span class="line">_g_.m.throwing = <span class="number">-1</span> <span class="comment">// do not dump full stacks</span></span><br><span class="line">throw(<span class="string">"go of nil func value"</span>)</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 加锁禁止被抢占</span></span><br><span class="line">_g_.m.locks++ <span class="comment">// disable preemption because it can be holding p in a local var</span></span><br><span class="line">siz := narg</span><br><span class="line">siz = (siz + <span class="number">7</span>) &amp;^ <span class="number">7</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// We could allocate a larger initial stack if necessary.</span></span><br><span class="line"><span class="comment">// Not worth it: this is almost always an error.</span></span><br><span class="line"><span class="comment">// 4*sizeof(uintreg): extra space added below</span></span><br><span class="line"><span class="comment">// sizeof(uintreg): caller's LR (arm) or return address (x86, in gostartcall).</span></span><br><span class="line"><span class="comment">// 如果参数过多，则直接抛出异常，栈大小是2k</span></span><br><span class="line"><span class="keyword">if</span> siz &gt;= _StackMin<span class="number">-4</span>*sys.RegSize-sys.RegSize &#123;</span><br><span class="line">throw(<span class="string">"newproc: function arguments too large for new goroutine"</span>)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">_p_ := _g_.m.p.ptr()</span><br><span class="line"><span class="comment">// 尝试获取一个空闲的g，如果获取不到，则新建一个，并添加到allg里面</span></span><br><span class="line"><span class="comment">// gfget首先会尝试从p本地获取空闲的g，如果本地没有的话，则从全局获取一堆平衡到本地p</span></span><br><span class="line">newg := gfget(_p_)</span><br><span class="line"><span class="keyword">if</span> newg == <span class="literal">nil</span> &#123;</span><br><span class="line">newg = malg(_StackMin)</span><br><span class="line">casgstatus(newg, _Gidle, _Gdead)</span><br><span class="line"><span class="comment">// 新建的g，添加到全局的 allg里面，allg是一个slice， append进去即可</span></span><br><span class="line">allgadd(newg) <span class="comment">// publishes with a g-&gt;status of Gdead so GC scanner doesn't look at uninitialized stack.</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 判断获取的g的栈是否正常</span></span><br><span class="line"><span class="keyword">if</span> newg.stack.hi == <span class="number">0</span> &#123;</span><br><span class="line">throw(<span class="string">"newproc1: newg missing stack"</span>)</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 判断g的状态是否正常</span></span><br><span class="line"><span class="keyword">if</span> readgstatus(newg) != _Gdead &#123;</span><br><span class="line">throw(<span class="string">"newproc1: new g is not Gdead"</span>)</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 预留一点空间，防止读取超出一点点</span></span><br><span class="line">totalSize := <span class="number">4</span>*sys.RegSize + <span class="keyword">uintptr</span>(siz) + sys.MinFrameSize <span class="comment">// extra space in case of reads slightly beyond frame</span></span><br><span class="line"><span class="comment">// 空间大小进行对齐</span></span><br><span class="line">totalSize += -totalSize &amp; (sys.SpAlign - <span class="number">1</span>) <span class="comment">// align to spAlign</span></span><br><span class="line">sp := newg.stack.hi - totalSize</span><br><span class="line">spArg := sp</span><br><span class="line"><span class="comment">// usesLr 为0，这里不执行</span></span><br><span class="line"><span class="keyword">if</span> usesLR &#123;</span><br><span class="line"><span class="comment">// caller's LR</span></span><br><span class="line">*(*<span class="keyword">uintptr</span>)(unsafe.Pointer(sp)) = <span class="number">0</span></span><br><span class="line">prepGoExitFrame(sp)</span><br><span class="line">spArg += sys.MinFrameSize</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span> narg &gt; <span class="number">0</span> &#123;</span><br><span class="line"><span class="comment">// 将参数拷贝入栈</span></span><br><span class="line">memmove(unsafe.Pointer(spArg), unsafe.Pointer(argp), <span class="keyword">uintptr</span>(narg))</span><br><span class="line"><span class="comment">// ... 省略 ...</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 初始化用于保存现场的区域及初始化基本状态</span></span><br><span class="line">memclrNoHeapPointers(unsafe.Pointer(&amp;newg.sched), unsafe.Sizeof(newg.sched))</span><br><span class="line">newg.sched.sp = sp</span><br><span class="line">newg.stktopsp = sp</span><br><span class="line"><span class="comment">// 这里保存了goexit的地址，在用户函数执行完成后，会根据pc来执行goexit</span></span><br><span class="line">newg.sched.pc = funcPC(goexit) + sys.PCQuantum <span class="comment">// +PCQuantum so that previous instruction is in same function</span></span><br><span class="line">newg.sched.g = guintptr(unsafe.Pointer(newg))</span><br><span class="line"><span class="comment">// 这里调整 sched 信息，pc = goexit的地址</span></span><br><span class="line">gostartcallfn(&amp;newg.sched, fn)</span><br><span class="line">newg.gopc = callerpc</span><br><span class="line">newg.ancestors = saveAncestors(callergp)</span><br><span class="line">newg.startpc = fn.fn</span><br><span class="line"><span class="keyword">if</span> _g_.m.curg != <span class="literal">nil</span> &#123;</span><br><span class="line">newg.labels = _g_.m.curg.labels</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span> isSystemGoroutine(newg) &#123;</span><br><span class="line">atomic.Xadd(&amp;sched.ngsys, +<span class="number">1</span>)</span><br><span class="line">&#125;</span><br><span class="line">newg.gcscanvalid = <span class="literal">false</span></span><br><span class="line">casgstatus(newg, _Gdead, _Grunnable)</span><br><span class="line"><span class="comment">// 如果p缓存的goid已经用完，本地再从sched批量获取一点</span></span><br><span class="line"><span class="keyword">if</span> _p_.goidcache == _p_.goidcacheend &#123;</span><br><span class="line"><span class="comment">// Sched.goidgen is the last allocated id,</span></span><br><span class="line"><span class="comment">// this batch must be [sched.goidgen+1, sched.goidgen+GoidCacheBatch].</span></span><br><span class="line"><span class="comment">// At startup sched.goidgen=0, so main goroutine receives goid=1.</span></span><br><span class="line">_p_.goidcache = atomic.Xadd64(&amp;sched.goidgen, _GoidCacheBatch)</span><br><span class="line">_p_.goidcache -= _GoidCacheBatch - <span class="number">1</span></span><br><span class="line">_p_.goidcacheend = _p_.goidcache + _GoidCacheBatch</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 分配goid</span></span><br><span class="line">newg.goid = <span class="keyword">int64</span>(_p_.goidcache)</span><br><span class="line">_p_.goidcache++</span><br><span class="line"><span class="comment">// 把新的g放到 p 的可运行g队列中</span></span><br><span class="line">runqput(_p_, newg, <span class="literal">true</span>)</span><br><span class="line"><span class="comment">// 判断是否有空闲p，且是否需要唤醒一个m来执行g</span></span><br><span class="line"><span class="keyword">if</span> atomic.Load(&amp;sched.npidle) != <span class="number">0</span> &amp;&amp; atomic.Load(&amp;sched.nmspinning) == <span class="number">0</span> &amp;&amp; mainStarted &#123;</span><br><span class="line">wakep()</span><br><span class="line">&#125;</span><br><span class="line">_g_.m.locks--</span><br><span class="line"><span class="keyword">if</span> _g_.m.locks == <span class="number">0</span> &amp;&amp; _g_.preempt &#123; <span class="comment">// restore the preemption request in case we've cleared it in newstack</span></span><br><span class="line">_g_.stackguard0 = stackPreempt</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="gfget"><a href="#gfget" class="headerlink" title="gfget"></a>gfget</h4><p>这个函数的逻辑比较简单，就是看一下p有没有空闲的g，没有则去全局的freeg队列查找，这里就涉及了p本地和全局平衡的一个交互了</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">gfget</span><span class="params">(_p_ *p)</span> *<span class="title">g</span></span> &#123;</span><br><span class="line">retry:</span><br><span class="line">gp := _p_.gfree</span><br><span class="line"><span class="comment">// 本地的g队列为空，且全局队列不为空，则从全局队列一次获取至多32个下来，如果全局队列不够就算了</span></span><br><span class="line"><span class="keyword">if</span> gp == <span class="literal">nil</span> &amp;&amp; (sched.gfreeStack != <span class="literal">nil</span> || sched.gfreeNoStack != <span class="literal">nil</span>) &#123;</span><br><span class="line">lock(&amp;sched.gflock)</span><br><span class="line"><span class="keyword">for</span> _p_.gfreecnt &lt; <span class="number">32</span> &#123;</span><br><span class="line"><span class="keyword">if</span> sched.gfreeStack != <span class="literal">nil</span> &#123;</span><br><span class="line"><span class="comment">// Prefer Gs with stacks.</span></span><br><span class="line">gp = sched.gfreeStack</span><br><span class="line">sched.gfreeStack = gp.schedlink.ptr()</span><br><span class="line">&#125; <span class="keyword">else</span> <span class="keyword">if</span> sched.gfreeNoStack != <span class="literal">nil</span> &#123;</span><br><span class="line">gp = sched.gfreeNoStack</span><br><span class="line">sched.gfreeNoStack = gp.schedlink.ptr()</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line"><span class="keyword">break</span></span><br><span class="line">&#125;</span><br><span class="line">_p_.gfreecnt++</span><br><span class="line">sched.ngfree--</span><br><span class="line">gp.schedlink.set(_p_.gfree)</span><br><span class="line">_p_.gfree = gp</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 已经从全局拿了g了，再去从头开始判断</span></span><br><span class="line">unlock(&amp;sched.gflock)</span><br><span class="line"><span class="keyword">goto</span> retry</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 如果拿到了g，则判断g是否有栈，没有栈就分配</span></span><br><span class="line"><span class="comment">// 栈的分配跟内存分配差不多，首先创建几个固定大小的栈的数组，然后到指定大小的数组里面去分配就ok了，过大则直接全局分配</span></span><br><span class="line"><span class="keyword">if</span> gp != <span class="literal">nil</span> &#123;</span><br><span class="line">_p_.gfree = gp.schedlink.ptr()</span><br><span class="line">_p_.gfreecnt--</span><br><span class="line"><span class="keyword">if</span> gp.stack.lo == <span class="number">0</span> &#123;</span><br><span class="line"><span class="comment">// Stack was deallocated in gfput. Allocate a new one.</span></span><br><span class="line">systemstack(<span class="function"><span class="keyword">func</span><span class="params">()</span></span> &#123;</span><br><span class="line">gp.stack = stackalloc(_FixedStack)</span><br><span class="line">&#125;)</span><br><span class="line">gp.stackguard0 = gp.stack.lo + _StackGuard</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line"><span class="comment">// ... 省略 ...</span></span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 注意： 如果全局没有g，p也没有g，则返回的gp还是nil</span></span><br><span class="line"><span class="keyword">return</span> gp</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="runqput"><a href="#runqput" class="headerlink" title="runqput"></a>runqput</h4><p>runqput会把g放到p的本地队列或者p.runnext，如果p的本地队列过长，则把g到全局队列，同时平衡p本地队列的一半到全局</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">runqput</span><span class="params">(_p_ *p, gp *g, next <span class="keyword">bool</span>)</span></span> &#123;</span><br><span class="line"><span class="keyword">if</span> randomizeScheduler &amp;&amp; next &amp;&amp; fastrand()%<span class="number">2</span> == <span class="number">0</span> &#123;</span><br><span class="line">next = <span class="literal">false</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 如果next为true，则放入到p.runnext里面，并把原先runnext的g交换出来</span></span><br><span class="line"><span class="keyword">if</span> next &#123;</span><br><span class="line">retryNext:</span><br><span class="line">oldnext := _p_.runnext</span><br><span class="line"><span class="keyword">if</span> !_p_.runnext.cas(oldnext, guintptr(unsafe.Pointer(gp))) &#123;</span><br><span class="line"><span class="keyword">goto</span> retryNext</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span> oldnext == <span class="number">0</span> &#123;</span><br><span class="line"><span class="keyword">return</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// Kick the old runnext out to the regular run queue.</span></span><br><span class="line">gp = oldnext.ptr()</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">retry:</span><br><span class="line">h := atomic.Load(&amp;_p_.runqhead) <span class="comment">// load-acquire, synchronize with consumers</span></span><br><span class="line">t := _p_.runqtail</span><br><span class="line"><span class="comment">// 判断p的队列的长度是否超了， runq是一个长度为256的数组，超出的话就会放到全局队列了</span></span><br><span class="line"><span class="keyword">if</span> t-h &lt; <span class="keyword">uint32</span>(<span class="built_in">len</span>(_p_.runq)) &#123;</span><br><span class="line">_p_.runq[t%<span class="keyword">uint32</span>(<span class="built_in">len</span>(_p_.runq))].set(gp)</span><br><span class="line">atomic.Store(&amp;_p_.runqtail, t+<span class="number">1</span>) <span class="comment">// store-release, makes the item available for consumption</span></span><br><span class="line"><span class="keyword">return</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 把g放到全局队列</span></span><br><span class="line"><span class="keyword">if</span> runqputslow(_p_, gp, h, t) &#123;</span><br><span class="line"><span class="keyword">return</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// the queue is not full, now the put above must succeed</span></span><br><span class="line"><span class="keyword">goto</span> retry</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="runqputslow"><a href="#runqputslow" class="headerlink" title="runqputslow"></a>runqputslow</h4><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">runqputslow</span><span class="params">(_p_ *p, gp *g, h, t <span class="keyword">uint32</span>)</span> <span class="title">bool</span></span> &#123;</span><br><span class="line"><span class="keyword">var</span> batch [<span class="built_in">len</span>(_p_.runq)/<span class="number">2</span> + <span class="number">1</span>]*g</span><br><span class="line"></span><br><span class="line"><span class="comment">// First, grab a batch from local queue.</span></span><br><span class="line">n := t - h</span><br><span class="line">n = n / <span class="number">2</span></span><br><span class="line"><span class="keyword">if</span> n != <span class="keyword">uint32</span>(<span class="built_in">len</span>(_p_.runq)/<span class="number">2</span>) &#123;</span><br><span class="line">throw(<span class="string">"runqputslow: queue is not full"</span>)</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 获取p后面的一半</span></span><br><span class="line"><span class="keyword">for</span> i := <span class="keyword">uint32</span>(<span class="number">0</span>); i &lt; n; i++ &#123;</span><br><span class="line">batch[i] = _p_.runq[(h+i)%<span class="keyword">uint32</span>(<span class="built_in">len</span>(_p_.runq))].ptr()</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span> !atomic.Cas(&amp;_p_.runqhead, h, h+n) &#123; <span class="comment">// cas-release, commits consume</span></span><br><span class="line"><span class="keyword">return</span> <span class="literal">false</span></span><br><span class="line">&#125;</span><br><span class="line">batch[n] = gp</span><br><span class="line"></span><br><span class="line"><span class="comment">// Link the goroutines.</span></span><br><span class="line"><span class="keyword">for</span> i := <span class="keyword">uint32</span>(<span class="number">0</span>); i &lt; n; i++ &#123;</span><br><span class="line">batch[i].schedlink.set(batch[i+<span class="number">1</span>])</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Now put the batch on global queue.</span></span><br><span class="line"><span class="comment">// 放到全局队列队尾</span></span><br><span class="line">lock(&amp;sched.lock)</span><br><span class="line">globrunqputbatch(batch[<span class="number">0</span>], batch[n], <span class="keyword">int32</span>(n+<span class="number">1</span>))</span><br><span class="line">unlock(&amp;sched.lock)</span><br><span class="line"><span class="keyword">return</span> <span class="literal">true</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>新建任务至此基本结束，创建完成任务后，等待调度执行就好了，从上面可以看出，任务的优先级是 p.runnext &gt; p.runq &gt; sched.runq</p><p>g从创建到执行结束并放入free队列中的状态转换大致如下图所示</p><p><img src="http://note-1253518569.cossh.myqcloud.com/20190831160849.png" alt></p><h3 id="wakep"><a href="#wakep" class="headerlink" title="wakep"></a>wakep</h3><p>当 newproc1创建完任务后，会尝试唤醒m来执行任务</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">wakep</span><span class="params">()</span></span> &#123;</span><br><span class="line"><span class="comment">// be conservative about spinning threads</span></span><br><span class="line"><span class="comment">// 一次应该只有一个m在spining，否则就退出</span></span><br><span class="line"><span class="keyword">if</span> !atomic.Cas(&amp;sched.nmspinning, <span class="number">0</span>, <span class="number">1</span>) &#123;</span><br><span class="line"><span class="keyword">return</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 调用startm来执行</span></span><br><span class="line">startm(<span class="literal">nil</span>, <span class="literal">true</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="startm"><a href="#startm" class="headerlink" title="startm"></a>startm</h3><p>调度m或者创建m来运行p，如果p==nil，就会尝试获取一个空闲p，p的队列中有g，拿到p后才能拿到g</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">startm</span><span class="params">(_p_ *p, spinning <span class="keyword">bool</span>)</span></span> &#123;</span><br><span class="line">lock(&amp;sched.lock)</span><br><span class="line"><span class="keyword">if</span> _p_ == <span class="literal">nil</span> &#123;</span><br><span class="line"><span class="comment">// 如果没有指定p, 则从sched.pidle获取空闲的p</span></span><br><span class="line">_p_ = pidleget()</span><br><span class="line"><span class="keyword">if</span> _p_ == <span class="literal">nil</span> &#123;</span><br><span class="line">unlock(&amp;sched.lock)</span><br><span class="line"><span class="comment">// 如果没有获取到p，重置nmspinning</span></span><br><span class="line"><span class="keyword">if</span> spinning &#123;</span><br><span class="line"><span class="comment">// The caller incremented nmspinning, but there are no idle Ps,</span></span><br><span class="line"><span class="comment">// so it's okay to just undo the increment and give up.</span></span><br><span class="line"><span class="keyword">if</span> <span class="keyword">int32</span>(atomic.Xadd(&amp;sched.nmspinning, <span class="number">-1</span>)) &lt; <span class="number">0</span> &#123;</span><br><span class="line">throw(<span class="string">"startm: negative nmspinning"</span>)</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span></span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 首先尝试从 sched.midle获取一个空闲的m</span></span><br><span class="line">mp := mget()</span><br><span class="line">unlock(&amp;sched.lock)</span><br><span class="line"><span class="keyword">if</span> mp == <span class="literal">nil</span> &#123;</span><br><span class="line"><span class="comment">// 如果获取不到空闲的m，则创建一个 mspining = true的m，并将p绑定到m上，直接返回</span></span><br><span class="line"><span class="keyword">var</span> fn <span class="function"><span class="keyword">func</span><span class="params">()</span></span></span><br><span class="line"><span class="function"><span class="title">if</span> <span class="title">spinning</span></span> &#123;</span><br><span class="line"><span class="comment">// The caller incremented nmspinning, so set m.spinning in the new M.</span></span><br><span class="line">fn = mspinning</span><br><span class="line">&#125;</span><br><span class="line">newm(fn, _p_)</span><br><span class="line"><span class="keyword">return</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 判断获取到的空闲m是否是spining状态</span></span><br><span class="line"><span class="keyword">if</span> mp.spinning &#123;</span><br><span class="line">throw(<span class="string">"startm: m is spinning"</span>)</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 判断获取到的m是否有p</span></span><br><span class="line"><span class="keyword">if</span> mp.nextp != <span class="number">0</span> &#123;</span><br><span class="line">throw(<span class="string">"startm: m has p"</span>)</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span> spinning &amp;&amp; !runqempty(_p_) &#123;</span><br><span class="line">throw(<span class="string">"startm: p has runnable gs"</span>)</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// The caller incremented nmspinning, so set m.spinning in the new M.</span></span><br><span class="line"><span class="comment">// 调用函数的父函数已经增加了nmspinning， 这里只需要设置m.spining就ok了，同时把p绑上来</span></span><br><span class="line">mp.spinning = spinning</span><br><span class="line">mp.nextp.set(_p_)</span><br><span class="line"><span class="comment">// 唤醒m</span></span><br><span class="line">notewakeup(&amp;mp.park)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="newm"><a href="#newm" class="headerlink" title="newm"></a>newm</h4><p>newm 通过allocm函数来创建新m</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">newm</span><span class="params">(fn <span class="keyword">func</span>()</span>, _<span class="title">p_</span> *<span class="title">p</span>)</span> &#123;</span><br><span class="line"><span class="comment">// 新建一个m</span></span><br><span class="line">mp := allocm(_p_, fn)</span><br><span class="line"><span class="comment">// 为这个新建的m绑定指定的p</span></span><br><span class="line">mp.nextp.set(_p_)</span><br><span class="line"><span class="comment">// ... 省略 ...</span></span><br><span class="line"><span class="comment">// 创建系统线程</span></span><br><span class="line">newm1(mp)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="new1m"><a href="#new1m" class="headerlink" title="new1m"></a>new1m</h4><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">newm1</span><span class="params">(mp *m)</span></span> &#123;</span><br><span class="line"><span class="comment">// runtime cgo包会把iscgo设置为true，这里不分析</span></span><br><span class="line"><span class="keyword">if</span> iscgo &#123;</span><br><span class="line"><span class="keyword">var</span> ts cgothreadstart</span><br><span class="line"><span class="keyword">if</span> _cgo_thread_start == <span class="literal">nil</span> &#123;</span><br><span class="line">throw(<span class="string">"_cgo_thread_start missing"</span>)</span><br><span class="line">&#125;</span><br><span class="line">ts.g.set(mp.g0)</span><br><span class="line">ts.tls = (*<span class="keyword">uint64</span>)(unsafe.Pointer(&amp;mp.tls[<span class="number">0</span>]))</span><br><span class="line">ts.fn = unsafe.Pointer(funcPC(mstart))</span><br><span class="line"><span class="keyword">if</span> msanenabled &#123;</span><br><span class="line">msanwrite(unsafe.Pointer(&amp;ts), unsafe.Sizeof(ts))</span><br><span class="line">&#125;</span><br><span class="line">execLock.rlock() <span class="comment">// Prevent process clone.</span></span><br><span class="line">asmcgocall(_cgo_thread_start, unsafe.Pointer(&amp;ts))</span><br><span class="line">execLock.runlock()</span><br><span class="line"><span class="keyword">return</span></span><br><span class="line">&#125;</span><br><span class="line">execLock.rlock() <span class="comment">// Prevent process clone.</span></span><br><span class="line">newosproc(mp)</span><br><span class="line">execLock.runlock()</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="newosproc"><a href="#newosproc" class="headerlink" title="newosproc"></a>newosproc</h4><p>newosproc 创建一个新的系统线程，并执行mstart_stub函数，之后调用<code>mstart</code>函数进入调度，后面在执行流程会分析</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">newosproc</span><span class="params">(mp *m)</span></span> &#123;</span><br><span class="line">stk := unsafe.Pointer(mp.g0.stack.hi)</span><br><span class="line"><span class="comment">// Initialize an attribute object.</span></span><br><span class="line"><span class="keyword">var</span> attr pthreadattr</span><br><span class="line"><span class="keyword">var</span> err <span class="keyword">int32</span></span><br><span class="line">err = pthread_attr_init(&amp;attr)</span><br><span class="line"></span><br><span class="line"><span class="comment">// Finally, create the thread. It starts at mstart_stub, which does some low-level</span></span><br><span class="line"><span class="comment">// setup and then calls mstart.</span></span><br><span class="line"><span class="keyword">var</span> oset sigset</span><br><span class="line">sigprocmask(_SIG_SETMASK, &amp;sigset_all, &amp;oset)</span><br><span class="line"><span class="comment">// 创建线程，并传入启动启动函数 mstart_stub， mstart_stub 之后调用mstart</span></span><br><span class="line">err = pthread_create(&amp;attr, funcPC(mstart_stub), unsafe.Pointer(mp))</span><br><span class="line">sigprocmask(_SIG_SETMASK, &amp;oset, <span class="literal">nil</span>)</span><br><span class="line"><span class="keyword">if</span> err != <span class="number">0</span> &#123;</span><br><span class="line">write(<span class="number">2</span>, unsafe.Pointer(&amp;failthreadcreate[<span class="number">0</span>]), <span class="keyword">int32</span>(<span class="built_in">len</span>(failthreadcreate)))</span><br><span class="line">exit(<span class="number">1</span>)</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="allocm"><a href="#allocm" class="headerlink" title="allocm"></a>allocm</h4><p>allocm这里首先会释放 sched的freem，然后再去创建m，并初始化m</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">allocm</span><span class="params">(_p_ *p, fn <span class="keyword">func</span>()</span>) *<span class="title">m</span></span> &#123;</span><br><span class="line">_g_ := getg()</span><br><span class="line">_g_.m.locks++ <span class="comment">// disable GC because it can be called from sysmon</span></span><br><span class="line"><span class="keyword">if</span> _g_.m.p == <span class="number">0</span> &#123;</span><br><span class="line">acquirep(_p_) <span class="comment">// temporarily borrow p for mallocs in this function</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Release the free M list. We need to do this somewhere and</span></span><br><span class="line"><span class="comment">// this may free up a stack we can use.</span></span><br><span class="line"><span class="comment">// 首先释放掉freem列表</span></span><br><span class="line"><span class="keyword">if</span> sched.freem != <span class="literal">nil</span> &#123;</span><br><span class="line">lock(&amp;sched.lock)</span><br><span class="line"><span class="keyword">var</span> newList *m</span><br><span class="line"><span class="keyword">for</span> freem := sched.freem; freem != <span class="literal">nil</span>; &#123;</span><br><span class="line"><span class="keyword">if</span> freem.freeWait != <span class="number">0</span> &#123;</span><br><span class="line">next := freem.freelink</span><br><span class="line">freem.freelink = newList</span><br><span class="line">newList = freem</span><br><span class="line">freem = next</span><br><span class="line"><span class="keyword">continue</span></span><br><span class="line">&#125;</span><br><span class="line">stackfree(freem.g0.stack)</span><br><span class="line">freem = freem.freelink</span><br><span class="line">&#125;</span><br><span class="line">sched.freem = newList</span><br><span class="line">unlock(&amp;sched.lock)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">mp := <span class="built_in">new</span>(m)</span><br><span class="line"><span class="comment">// 启动函数，根据startm调用来看，这个fn就是 mspinning， 会将m.mspinning设置为true</span></span><br><span class="line">mp.mstartfn = fn</span><br><span class="line"><span class="comment">// 初始化m，上面已经分析了</span></span><br><span class="line">mcommoninit(mp)</span><br><span class="line"><span class="comment">// In case of cgo or Solaris or Darwin, pthread_create will make us a stack.</span></span><br><span class="line"><span class="comment">// Windows and Plan 9 will layout sched stack on OS stack.</span></span><br><span class="line"><span class="comment">// 为新的m创建g0</span></span><br><span class="line"><span class="keyword">if</span> iscgo || GOOS == <span class="string">"solaris"</span> || GOOS == <span class="string">"windows"</span> || GOOS == <span class="string">"plan9"</span> || GOOS == <span class="string">"darwin"</span> &#123;</span><br><span class="line">mp.g0 = malg(<span class="number">-1</span>)</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">mp.g0 = malg(<span class="number">8192</span> * sys.StackGuardMultiplier)</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 为mp的g0绑定自己</span></span><br><span class="line">mp.g0.m = mp</span><br><span class="line"><span class="comment">// 如果当前的m所绑定的是参数传递过来的p，解除绑定，因为参数传递过来的p稍后要绑定新建的m</span></span><br><span class="line"><span class="keyword">if</span> _p_ == _g_.m.p.ptr() &#123;</span><br><span class="line">releasep()</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">_g_.m.locks--</span><br><span class="line"><span class="keyword">if</span> _g_.m.locks == <span class="number">0</span> &amp;&amp; _g_.preempt &#123; <span class="comment">// restore the preemption request in case we've cleared it in newstack</span></span><br><span class="line">_g_.stackguard0 = stackPreempt</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> mp</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="notewakeup"><a href="#notewakeup" class="headerlink" title="notewakeup"></a>notewakeup</h4><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">notewakeup</span><span class="params">(n *note)</span></span> &#123;</span><br><span class="line"><span class="keyword">var</span> v <span class="keyword">uintptr</span></span><br><span class="line"><span class="comment">// 设置m 为locked</span></span><br><span class="line"><span class="keyword">for</span> &#123;</span><br><span class="line">v = atomic.Loaduintptr(&amp;n.key)</span><br><span class="line"><span class="keyword">if</span> atomic.Casuintptr(&amp;n.key, v, locked) &#123;</span><br><span class="line"><span class="keyword">break</span></span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Successfully set waitm to locked.</span></span><br><span class="line"><span class="comment">// What was it before?</span></span><br><span class="line"><span class="comment">// 根据m的原先的状态，来判断后面的执行流程，0则直接返回，locked则冲突，否则认为是wating，唤醒</span></span><br><span class="line"><span class="keyword">switch</span> &#123;</span><br><span class="line"><span class="keyword">case</span> v == <span class="number">0</span>:</span><br><span class="line"><span class="comment">// Nothing was waiting. Done.</span></span><br><span class="line"><span class="keyword">case</span> v == locked:</span><br><span class="line"><span class="comment">// Two notewakeups! Not allowed.</span></span><br><span class="line">throw(<span class="string">"notewakeup - double wakeup"</span>)</span><br><span class="line"><span class="keyword">default</span>:</span><br><span class="line"><span class="comment">// Must be the waiting m. Wake it up.</span></span><br><span class="line"><span class="comment">// 唤醒系统线程</span></span><br><span class="line">semawakeup((*m)(unsafe.Pointer(v)))</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>至此的话，创建完任务g后，将g放入了p的local队列或者是全局队列，然后开始获取了一个空闲的m或者新建一个m来执行g，m, p, g 都已经准备完成了，下面就是开始调度，来运行任务g了</p><h2 id="执行"><a href="#执行" class="headerlink" title="执行"></a>执行</h2><p>在startm函数分析的过程中会，可以看到，有两种获取m的方式</p><ul><li>新建： 这时候执行newm1下的newosproc，同时最终调用mstart来执行调度</li><li>唤醒空闲m：从休眠的地方继续执行</li></ul><p>m执行g有两个起点，一个是线程启动函数 <code>mstart</code>， 另一个则是休眠被唤醒后的调度<code>schedule</code>了，我们从头开始，也就是<code>mstart</code>， <code>mstart</code> 走到最后也是 <code>schedule</code> 调度</p><h3 id="mstart"><a href="#mstart" class="headerlink" title="mstart"></a>mstart</h3><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">mstart</span><span class="params">()</span></span> &#123;</span><br><span class="line">_g_ := getg()</span><br><span class="line"></span><br><span class="line">osStack := _g_.stack.lo == <span class="number">0</span></span><br><span class="line"><span class="keyword">if</span> osStack &#123;</span><br><span class="line"><span class="comment">// Initialize stack bounds from system stack.</span></span><br><span class="line"><span class="comment">// Cgo may have left stack size in stack.hi.</span></span><br><span class="line"><span class="comment">// minit may update the stack bounds.</span></span><br><span class="line"><span class="comment">// 从系统堆栈上直接划出所需的范围</span></span><br><span class="line">size := _g_.stack.hi</span><br><span class="line"><span class="keyword">if</span> size == <span class="number">0</span> &#123;</span><br><span class="line">size = <span class="number">8192</span> * sys.StackGuardMultiplier</span><br><span class="line">&#125;</span><br><span class="line">_g_.stack.hi = <span class="keyword">uintptr</span>(noescape(unsafe.Pointer(&amp;size)))</span><br><span class="line">_g_.stack.lo = _g_.stack.hi - size + <span class="number">1024</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// Initialize stack guards so that we can start calling</span></span><br><span class="line"><span class="comment">// both Go and C functions with stack growth prologues.</span></span><br><span class="line">_g_.stackguard0 = _g_.stack.lo + _StackGuard</span><br><span class="line">_g_.stackguard1 = _g_.stackguard0</span><br><span class="line"><span class="comment">// 调用mstart1来处理</span></span><br><span class="line">mstart1()</span><br><span class="line"></span><br><span class="line"><span class="comment">// Exit this thread.</span></span><br><span class="line"><span class="keyword">if</span> GOOS == <span class="string">"windows"</span> || GOOS == <span class="string">"solaris"</span> || GOOS == <span class="string">"plan9"</span> || GOOS == <span class="string">"darwin"</span> &#123;</span><br><span class="line"><span class="comment">// Window, Solaris, Darwin and Plan 9 always system-allocate</span></span><br><span class="line"><span class="comment">// the stack, but put it in _g_.stack before mstart,</span></span><br><span class="line"><span class="comment">// so the logic above hasn't set osStack yet.</span></span><br><span class="line">osStack = <span class="literal">true</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 退出m，正常情况下mstart1调用schedule() 时，是不再返回的，所以，不用担心系统线程的频繁创建退出</span></span><br><span class="line">mexit(osStack)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="mstart1"><a href="#mstart1" class="headerlink" title="mstart1"></a>mstart1</h3><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">mstart1</span><span class="params">()</span></span> &#123;</span><br><span class="line">_g_ := getg()</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> _g_ != _g_.m.g0 &#123;</span><br><span class="line">throw(<span class="string">"bad runtime·mstart"</span>)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Record the caller for use as the top of stack in mcall and</span></span><br><span class="line"><span class="comment">// for terminating the thread.</span></span><br><span class="line"><span class="comment">// We're never coming back to mstart1 after we call schedule,</span></span><br><span class="line"><span class="comment">// so other calls can reuse the current frame.</span></span><br><span class="line"><span class="comment">// 保存调用者的pc sp等信息</span></span><br><span class="line">save(getcallerpc(), getcallersp())</span><br><span class="line">asminit()</span><br><span class="line"><span class="comment">// 初始化m的sigal的栈和mask</span></span><br><span class="line">minit()</span><br><span class="line"></span><br><span class="line"><span class="comment">// Install signal handlers; after minit so that minit can</span></span><br><span class="line"><span class="comment">// prepare the thread to be able to handle the signals.</span></span><br><span class="line"><span class="comment">// 安装sigal处理器</span></span><br><span class="line"><span class="keyword">if</span> _g_.m == &amp;m0 &#123;</span><br><span class="line">mstartm0()</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 如果设置了mstartfn，就先执行这个</span></span><br><span class="line"><span class="keyword">if</span> fn := _g_.m.mstartfn; fn != <span class="literal">nil</span> &#123;</span><br><span class="line">fn()</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> _g_.m.helpgc != <span class="number">0</span> &#123;</span><br><span class="line">_g_.m.helpgc = <span class="number">0</span></span><br><span class="line">stopm()</span><br><span class="line">&#125; <span class="keyword">else</span> <span class="keyword">if</span> _g_.m != &amp;m0 &#123;</span><br><span class="line"><span class="comment">// 获取nextp</span></span><br><span class="line">acquirep(_g_.m.nextp.ptr())</span><br><span class="line">_g_.m.nextp = <span class="number">0</span></span><br><span class="line">&#125;</span><br><span class="line">schedule()</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="acquirep"><a href="#acquirep" class="headerlink" title="acquirep"></a>acquirep</h4><p>acquirep 函数主要是改变p的状态，绑定 m p，通过吧p的mcache与m共享</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">acquirep</span><span class="params">(_p_ *p)</span></span> &#123;</span><br><span class="line"><span class="comment">// Do the part that isn't allowed to have write barriers.</span></span><br><span class="line">acquirep1(_p_)</span><br><span class="line"></span><br><span class="line"><span class="comment">// have p; write barriers now allowed</span></span><br><span class="line">_g_ := getg()</span><br><span class="line"><span class="comment">// 把p的mcache与m共享</span></span><br><span class="line">_g_.m.mcache = _p_.mcache</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="acquirep1"><a href="#acquirep1" class="headerlink" title="acquirep1"></a>acquirep1</h4><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">acquirep1</span><span class="params">(_p_ *p)</span></span> &#123;</span><br><span class="line">_g_ := getg()</span><br><span class="line"></span><br><span class="line"><span class="comment">// 让m p互相绑定</span></span><br><span class="line">_g_.m.p.set(_p_)</span><br><span class="line">_p_.m.set(_g_.m)</span><br><span class="line">_p_.status = _Prunning</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="schedule"><a href="#schedule" class="headerlink" title="schedule"></a>schedule</h4><p>开始进入到调度函数了，这是一个由schedule、execute、goroutine fn、goexit构成的逻辑循环，就算m是唤醒后，也是从设置的断点开始执行</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">schedule</span><span class="params">()</span></span> &#123;</span><br><span class="line">_g_ := getg()</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> _g_.m.locks != <span class="number">0</span> &#123;</span><br><span class="line">throw(<span class="string">"schedule: holding locks"</span>)</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 如果有lockg，停止执行当前的m</span></span><br><span class="line"><span class="keyword">if</span> _g_.m.lockedg != <span class="number">0</span> &#123;</span><br><span class="line"><span class="comment">// 解除lockedm的锁定，并执行当前g</span></span><br><span class="line">stoplockedm()</span><br><span class="line">execute(_g_.m.lockedg.ptr(), <span class="literal">false</span>) <span class="comment">// Never returns.</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// We should not schedule away from a g that is executing a cgo call,</span></span><br><span class="line"><span class="comment">// since the cgo call is using the m's g0 stack.</span></span><br><span class="line"><span class="keyword">if</span> _g_.m.incgo &#123;</span><br><span class="line">throw(<span class="string">"schedule: in cgo"</span>)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">top:</span><br><span class="line"><span class="comment">// gc 等待</span></span><br><span class="line"><span class="keyword">if</span> sched.gcwaiting != <span class="number">0</span> &#123;</span><br><span class="line">gcstopm()</span><br><span class="line"><span class="keyword">goto</span> top</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> gp *g</span><br><span class="line"><span class="keyword">var</span> inheritTime <span class="keyword">bool</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> gp == <span class="literal">nil</span> &#123;</span><br><span class="line"><span class="comment">// Check the global runnable queue once in a while to ensure fairness.</span></span><br><span class="line"><span class="comment">// Otherwise two goroutines can completely occupy the local runqueue</span></span><br><span class="line"><span class="comment">// by constantly respawning each other.</span></span><br><span class="line"><span class="comment">// 为了保证公平，每隔61次，从全局队列上获取g</span></span><br><span class="line"><span class="keyword">if</span> _g_.m.p.ptr().schedtick%<span class="number">61</span> == <span class="number">0</span> &amp;&amp; sched.runqsize &gt; <span class="number">0</span> &#123;</span><br><span class="line">lock(&amp;sched.lock)</span><br><span class="line">gp = globrunqget(_g_.m.p.ptr(), <span class="number">1</span>)</span><br><span class="line">unlock(&amp;sched.lock)</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span> gp == <span class="literal">nil</span> &#123;</span><br><span class="line"><span class="comment">// 全局队列上获取不到待运行的g，则从p local队列中获取</span></span><br><span class="line">gp, inheritTime = runqget(_g_.m.p.ptr())</span><br><span class="line"><span class="keyword">if</span> gp != <span class="literal">nil</span> &amp;&amp; _g_.m.spinning &#123;</span><br><span class="line">throw(<span class="string">"schedule: spinning with local work"</span>)</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span> gp == <span class="literal">nil</span> &#123;</span><br><span class="line"><span class="comment">// 如果p local获取不到待运行g，则开始查找，这个函数会从 全局 io poll， p locl和其他p local获取待运行的g，后面详细分析</span></span><br><span class="line">gp, inheritTime = findrunnable() <span class="comment">// blocks until work is available</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// This thread is going to run a goroutine and is not spinning anymore,</span></span><br><span class="line"><span class="comment">// so if it was marked as spinning we need to reset it now and potentially</span></span><br><span class="line"><span class="comment">// start a new spinning M.</span></span><br><span class="line"><span class="keyword">if</span> _g_.m.spinning &#123;</span><br><span class="line"><span class="comment">// 如果m是自旋状态，取消自旋</span></span><br><span class="line">resetspinning()</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> gp.lockedm != <span class="number">0</span> &#123;</span><br><span class="line"><span class="comment">// Hands off own p to the locked m,</span></span><br><span class="line"><span class="comment">// then blocks waiting for a new p.</span></span><br><span class="line"><span class="comment">// 如果g有lockedm，则休眠上交p，休眠m，等待新的m，唤醒后从这里开始执行，跳转到top</span></span><br><span class="line">startlockedm(gp)</span><br><span class="line"><span class="keyword">goto</span> top</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 开始执行这个g</span></span><br><span class="line">execute(gp, inheritTime)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h5 id="stoplockedm"><a href="#stoplockedm" class="headerlink" title="stoplockedm"></a>stoplockedm</h5><p>因为当前的m绑定了lockedg，而当前g不是指定的lockedg，所以这个m不能执行，上交当前m绑定的p，并且休眠m直到调度lockedg</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">stoplockedm</span><span class="params">()</span></span> &#123;</span><br><span class="line">_g_ := getg()</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> _g_.m.lockedg == <span class="number">0</span> || _g_.m.lockedg.ptr().lockedm.ptr() != _g_.m &#123;</span><br><span class="line">throw(<span class="string">"stoplockedm: inconsistent locking"</span>)</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span> _g_.m.p != <span class="number">0</span> &#123;</span><br><span class="line"><span class="comment">// Schedule another M to run this p.</span></span><br><span class="line"><span class="comment">// 释放当前p</span></span><br><span class="line">_p_ := releasep()</span><br><span class="line">handoffp(_p_)</span><br><span class="line">&#125;</span><br><span class="line">incidlelocked(<span class="number">1</span>)</span><br><span class="line"><span class="comment">// Wait until another thread schedules lockedg again.</span></span><br><span class="line">notesleep(&amp;_g_.m.park)</span><br><span class="line">noteclear(&amp;_g_.m.park)</span><br><span class="line">status := readgstatus(_g_.m.lockedg.ptr())</span><br><span class="line"><span class="keyword">if</span> status&amp;^_Gscan != _Grunnable &#123;</span><br><span class="line"><span class="built_in">print</span>(<span class="string">"runtime:stoplockedm: g is not Grunnable or Gscanrunnable\n"</span>)</span><br><span class="line">dumpgstatus(_g_)</span><br><span class="line">throw(<span class="string">"stoplockedm: not runnable"</span>)</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 上交了当前的p，将nextp设置为可执行的p</span></span><br><span class="line">acquirep(_g_.m.nextp.ptr())</span><br><span class="line">_g_.m.nextp = <span class="number">0</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h5 id="startlockedm"><a href="#startlockedm" class="headerlink" title="startlockedm"></a>startlockedm</h5><p>调度 lockedm去运行lockedg</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">startlockedm</span><span class="params">(gp *g)</span></span> &#123;</span><br><span class="line">_g_ := getg()</span><br><span class="line"></span><br><span class="line">mp := gp.lockedm.ptr()</span><br><span class="line"><span class="keyword">if</span> mp == _g_.m &#123;</span><br><span class="line">throw(<span class="string">"startlockedm: locked to me"</span>)</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span> mp.nextp != <span class="number">0</span> &#123;</span><br><span class="line">throw(<span class="string">"startlockedm: m has p"</span>)</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// directly handoff current P to the locked m</span></span><br><span class="line">incidlelocked(<span class="number">-1</span>)</span><br><span class="line"><span class="comment">// 移交当前p给lockedm，并设置为lockedm.nextp，以便于lockedm唤醒后，可以获取</span></span><br><span class="line">_p_ := releasep()</span><br><span class="line">mp.nextp.set(_p_)</span><br><span class="line"><span class="comment">// m被唤醒后，从m休眠的地方开始执行，也就是schedule()函数中</span></span><br><span class="line">notewakeup(&amp;mp.park)</span><br><span class="line">stopm()</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h5 id="handoffp"><a href="#handoffp" class="headerlink" title="handoffp"></a>handoffp</h5><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">handoffp</span><span class="params">(_p_ *p)</span></span> &#123;</span><br><span class="line"><span class="comment">// handoffp must start an M in any situation where</span></span><br><span class="line"><span class="comment">// findrunnable would return a G to run on _p_.</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// if it has local work, start it straight away</span></span><br><span class="line"><span class="keyword">if</span> !runqempty(_p_) || sched.runqsize != <span class="number">0</span> &#123;</span><br><span class="line"><span class="comment">// 调用startm开始调度</span></span><br><span class="line">startm(_p_, <span class="literal">false</span>)</span><br><span class="line"><span class="keyword">return</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// no local work, check that there are no spinning/idle M's,</span></span><br><span class="line"><span class="comment">// otherwise our help is not required</span></span><br><span class="line"><span class="comment">// 判断有没有正在寻找p的m以及有没有空闲的p</span></span><br><span class="line"><span class="keyword">if</span> atomic.Load(&amp;sched.nmspinning)+atomic.Load(&amp;sched.npidle) == <span class="number">0</span> &amp;&amp; atomic.Cas(&amp;sched.nmspinning, <span class="number">0</span>, <span class="number">1</span>) &#123; <span class="comment">// <span class="doctag">TODO:</span> fast atomic</span></span><br><span class="line">startm(_p_, <span class="literal">true</span>)</span><br><span class="line"><span class="keyword">return</span></span><br><span class="line">&#125;</span><br><span class="line">lock(&amp;sched.lock)</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> _p_.runSafePointFn != <span class="number">0</span> &amp;&amp; atomic.Cas(&amp;_p_.runSafePointFn, <span class="number">1</span>, <span class="number">0</span>) &#123;</span><br><span class="line">sched.safePointFn(_p_)</span><br><span class="line">sched.safePointWait--</span><br><span class="line"><span class="keyword">if</span> sched.safePointWait == <span class="number">0</span> &#123;</span><br><span class="line">notewakeup(&amp;sched.safePointNote)</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 如果 全局待运行g队列不为空，尝试使用startm进行调度</span></span><br><span class="line"><span class="keyword">if</span> sched.runqsize != <span class="number">0</span> &#123;</span><br><span class="line">unlock(&amp;sched.lock)</span><br><span class="line">startm(_p_, <span class="literal">false</span>)</span><br><span class="line"><span class="keyword">return</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// If this is the last running P and nobody is polling network,</span></span><br><span class="line"><span class="comment">// need to wakeup another M to poll network.</span></span><br><span class="line"><span class="keyword">if</span> sched.npidle == <span class="keyword">uint32</span>(gomaxprocs<span class="number">-1</span>) &amp;&amp; atomic.Load64(&amp;sched.lastpoll) != <span class="number">0</span> &#123;</span><br><span class="line">unlock(&amp;sched.lock)</span><br><span class="line">startm(_p_, <span class="literal">false</span>)</span><br><span class="line"><span class="keyword">return</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 把p放入到全局的空闲队列，放回队列就不多说了，参考allm的放回</span></span><br><span class="line">pidleput(_p_)</span><br><span class="line">unlock(&amp;sched.lock)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h5 id="execute"><a href="#execute" class="headerlink" title="execute"></a>execute</h5><p>开始执行g的代码了</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">execute</span><span class="params">(gp *g, inheritTime <span class="keyword">bool</span>)</span></span> &#123;</span><br><span class="line">_g_ := getg()</span><br><span class="line"><span class="comment">// 更改g的状态，并不允许抢占</span></span><br><span class="line">casgstatus(gp, _Grunnable, _Grunning)</span><br><span class="line">gp.waitsince = <span class="number">0</span></span><br><span class="line">gp.preempt = <span class="literal">false</span></span><br><span class="line">gp.stackguard0 = gp.stack.lo + _StackGuard</span><br><span class="line"><span class="keyword">if</span> !inheritTime &#123;</span><br><span class="line"><span class="comment">// 调度计数</span></span><br><span class="line">_g_.m.p.ptr().schedtick++</span><br><span class="line">&#125;</span><br><span class="line">_g_.m.curg = gp</span><br><span class="line">gp.m = _g_.m</span><br><span class="line"><span class="comment">// 开始执行g的代码了</span></span><br><span class="line">gogo(&amp;gp.sched)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h5 id="gogo"><a href="#gogo" class="headerlink" title="gogo"></a>gogo</h5><p>gogo函数承载的作用就是切换到g的栈，开始执行g的代码，汇编内容就不分析了，但是有一个疑问就是，gogo执行完函数后，怎么再次进入调度呢？</p><p>我们回到<code>newproc1</code>函数的L63 <code>newg.sched.pc = funcPC(goexit) + sys.PCQuantum</code> ，这里保存了pc的质地为goexit的地址，所以当执行完用户代码后，就会进入 <code>goexit</code> 函数</p><h5 id="goexit0"><a href="#goexit0" class="headerlink" title="goexit0"></a>goexit0</h5><p>goexit 在汇编层面就是调用 <code>runtime.goexit1</code>，而goexit1通过 mcall 调用了<code>goexit0</code> 所以这里直接分析了<code>goexit0</code></p><p><code>goexit0</code> 重置g的状态，并重新进行调度，这样就调度就又回到了<code>schedule()</code> 了，开始循环往复的调度</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">goexit0</span><span class="params">(gp *g)</span></span> &#123;</span><br><span class="line">_g_ := getg()</span><br><span class="line"><span class="comment">// 转换g的状态为dead，以放回空闲列表</span></span><br><span class="line">casgstatus(gp, _Grunning, _Gdead)</span><br><span class="line"><span class="keyword">if</span> isSystemGoroutine(gp) &#123;</span><br><span class="line">atomic.Xadd(&amp;sched.ngsys, <span class="number">-1</span>)</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 清空g的状态</span></span><br><span class="line">gp.m = <span class="literal">nil</span></span><br><span class="line">locked := gp.lockedm != <span class="number">0</span></span><br><span class="line">gp.lockedm = <span class="number">0</span></span><br><span class="line">_g_.m.lockedg = <span class="number">0</span></span><br><span class="line">gp.paniconfault = <span class="literal">false</span></span><br><span class="line">gp._defer = <span class="literal">nil</span> <span class="comment">// should be true already but just in case.</span></span><br><span class="line">gp._panic = <span class="literal">nil</span> <span class="comment">// non-nil for Goexit during panic. points at stack-allocated data.</span></span><br><span class="line">gp.writebuf = <span class="literal">nil</span></span><br><span class="line">gp.waitreason = <span class="number">0</span></span><br><span class="line">gp.param = <span class="literal">nil</span></span><br><span class="line">gp.labels = <span class="literal">nil</span></span><br><span class="line">gp.timer = <span class="literal">nil</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// Note that gp's stack scan is now "valid" because it has no</span></span><br><span class="line"><span class="comment">// stack.</span></span><br><span class="line">gp.gcscanvalid = <span class="literal">true</span></span><br><span class="line">dropg()</span><br><span class="line"></span><br><span class="line"><span class="comment">// 把g放回空闲列表，以备复用</span></span><br><span class="line">gfput(_g_.m.p.ptr(), gp)</span><br><span class="line"><span class="comment">// 再次进入调度循环</span></span><br><span class="line">schedule()</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>至此，单次调度结束，再次进入调度，循环往复</p><h5 id="findrunnable"><a href="#findrunnable" class="headerlink" title="findrunnable"></a>findrunnable</h5><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">findrunnable</span><span class="params">()</span> <span class="params">(gp *g, inheritTime <span class="keyword">bool</span>)</span></span> &#123;</span><br><span class="line">_g_ := getg()</span><br><span class="line"></span><br><span class="line"><span class="comment">// The conditions here and in handoffp must agree: if</span></span><br><span class="line"><span class="comment">// findrunnable would return a G to run, handoffp must start</span></span><br><span class="line"><span class="comment">// an M.</span></span><br><span class="line"></span><br><span class="line">top:</span><br><span class="line">_p_ := _g_.m.p.ptr()</span><br><span class="line"></span><br><span class="line"><span class="comment">// local runq</span></span><br><span class="line"><span class="comment">// 从p local 去获取g</span></span><br><span class="line"><span class="keyword">if</span> gp, inheritTime := runqget(_p_); gp != <span class="literal">nil</span> &#123;</span><br><span class="line"><span class="keyword">return</span> gp, inheritTime</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// global runq</span></span><br><span class="line"><span class="comment">// 从全局的待运行d队列获取</span></span><br><span class="line"><span class="keyword">if</span> sched.runqsize != <span class="number">0</span> &#123;</span><br><span class="line">lock(&amp;sched.lock)</span><br><span class="line">gp := globrunqget(_p_, <span class="number">0</span>)</span><br><span class="line">unlock(&amp;sched.lock)</span><br><span class="line"><span class="keyword">if</span> gp != <span class="literal">nil</span> &#123;</span><br><span class="line"><span class="keyword">return</span> gp, <span class="literal">false</span></span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Poll network.</span></span><br><span class="line"><span class="comment">// This netpoll is only an optimization before we resort to stealing.</span></span><br><span class="line"><span class="comment">// We can safely skip it if there are no waiters or a thread is blocked</span></span><br><span class="line"><span class="comment">// in netpoll already. If there is any kind of logical race with that</span></span><br><span class="line"><span class="comment">// blocked thread (e.g. it has already returned from netpoll, but does</span></span><br><span class="line"><span class="comment">// not set lastpoll yet), this thread will do blocking netpoll below</span></span><br><span class="line"><span class="comment">// anyway.</span></span><br><span class="line"><span class="comment">// 看看netpoll中有没有已经准备好的g</span></span><br><span class="line"><span class="keyword">if</span> netpollinited() &amp;&amp; atomic.Load(&amp;netpollWaiters) &gt; <span class="number">0</span> &amp;&amp; atomic.Load64(&amp;sched.lastpoll) != <span class="number">0</span> &#123;</span><br><span class="line"><span class="keyword">if</span> gp := netpoll(<span class="literal">false</span>); gp != <span class="literal">nil</span> &#123; <span class="comment">// non-blocking</span></span><br><span class="line"><span class="comment">// netpoll returns list of goroutines linked by schedlink.</span></span><br><span class="line">injectglist(gp.schedlink.ptr())</span><br><span class="line">casgstatus(gp, _Gwaiting, _Grunnable)</span><br><span class="line"><span class="keyword">if</span> trace.enabled &#123;</span><br><span class="line">traceGoUnpark(gp, <span class="number">0</span>)</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> gp, <span class="literal">false</span></span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Steal work from other P's.</span></span><br><span class="line"><span class="comment">// 如果sched.pidle == procs - 1，说明所有的p都是空闲的，无需遍历其他p了</span></span><br><span class="line">procs := <span class="keyword">uint32</span>(gomaxprocs)</span><br><span class="line"><span class="keyword">if</span> atomic.Load(&amp;sched.npidle) == procs<span class="number">-1</span> &#123;</span><br><span class="line"><span class="comment">// Either GOMAXPROCS=1 or everybody, except for us, is idle already.</span></span><br><span class="line"><span class="comment">// New work can appear from returning syscall/cgocall, network or timers.</span></span><br><span class="line"><span class="comment">// Neither of that submits to local run queues, so no point in stealing.</span></span><br><span class="line"><span class="keyword">goto</span> stop</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// If number of spinning M's &gt;= number of busy P's, block.</span></span><br><span class="line"><span class="comment">// This is necessary to prevent excessive CPU consumption</span></span><br><span class="line"><span class="comment">// when GOMAXPROCS&gt;&gt;1 but the program parallelism is low.</span></span><br><span class="line"><span class="comment">// 如果寻找p的m的数量，大于有g的p的数量的一般，就不再去寻找了</span></span><br><span class="line"><span class="keyword">if</span> !_g_.m.spinning &amp;&amp; <span class="number">2</span>*atomic.Load(&amp;sched.nmspinning) &gt;= procs-atomic.Load(&amp;sched.npidle) &#123;</span><br><span class="line"><span class="keyword">goto</span> stop</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 设置当前m的自旋状态</span></span><br><span class="line"><span class="keyword">if</span> !_g_.m.spinning &#123;</span><br><span class="line">_g_.m.spinning = <span class="literal">true</span></span><br><span class="line">atomic.Xadd(&amp;sched.nmspinning, <span class="number">1</span>)</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 开始窃取其他p的待运行g了</span></span><br><span class="line"><span class="keyword">for</span> i := <span class="number">0</span>; i &lt; <span class="number">4</span>; i++ &#123;</span><br><span class="line"><span class="keyword">for</span> enum := stealOrder.start(fastrand()); !enum.done(); enum.next() &#123;</span><br><span class="line"><span class="keyword">if</span> sched.gcwaiting != <span class="number">0</span> &#123;</span><br><span class="line"><span class="keyword">goto</span> top</span><br><span class="line">&#125;</span><br><span class="line">stealRunNextG := i &gt; <span class="number">2</span> <span class="comment">// first look for ready queues with more than 1 g</span></span><br><span class="line"><span class="comment">// 从其他的p偷取一般的任务数量，还会随机偷取p的runnext（过分了），偷取部分就不分析了，就是slice的操作而已</span></span><br><span class="line"><span class="keyword">if</span> gp := runqsteal(_p_, allp[enum.position()], stealRunNextG); gp != <span class="literal">nil</span> &#123;</span><br><span class="line"><span class="keyword">return</span> gp, <span class="literal">false</span></span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">stop:</span><br><span class="line"><span class="comment">// 对all做个镜像备份</span></span><br><span class="line">allpSnapshot := allp</span><br><span class="line"></span><br><span class="line"><span class="comment">// return P and block</span></span><br><span class="line">lock(&amp;sched.lock)</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> sched.runqsize != <span class="number">0</span> &#123;</span><br><span class="line">gp := globrunqget(_p_, <span class="number">0</span>)</span><br><span class="line">unlock(&amp;sched.lock)</span><br><span class="line"><span class="keyword">return</span> gp, <span class="literal">false</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span> releasep() != _p_ &#123;</span><br><span class="line">throw(<span class="string">"findrunnable: wrong p"</span>)</span><br><span class="line">&#125;</span><br><span class="line">pidleput(_p_)</span><br><span class="line">unlock(&amp;sched.lock)</span><br><span class="line"></span><br><span class="line">wasSpinning := _g_.m.spinning</span><br><span class="line"><span class="keyword">if</span> _g_.m.spinning &#123;</span><br><span class="line"><span class="comment">// 设置非自旋状态，因为找p的工作已经结束了</span></span><br><span class="line">_g_.m.spinning = <span class="literal">false</span></span><br><span class="line"><span class="keyword">if</span> <span class="keyword">int32</span>(atomic.Xadd(&amp;sched.nmspinning, <span class="number">-1</span>)) &lt; <span class="number">0</span> &#123;</span><br><span class="line">throw(<span class="string">"findrunnable: negative nmspinning"</span>)</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// check all runqueues once again</span></span><br><span class="line"><span class="keyword">for</span> _, _p_ := <span class="keyword">range</span> allpSnapshot &#123;</span><br><span class="line"><span class="keyword">if</span> !runqempty(_p_) &#123;</span><br><span class="line">lock(&amp;sched.lock)</span><br><span class="line">_p_ = pidleget()</span><br><span class="line">unlock(&amp;sched.lock)</span><br><span class="line"><span class="keyword">if</span> _p_ != <span class="literal">nil</span> &#123;</span><br><span class="line">acquirep(_p_)</span><br><span class="line"><span class="keyword">if</span> wasSpinning &#123;</span><br><span class="line">_g_.m.spinning = <span class="literal">true</span></span><br><span class="line">atomic.Xadd(&amp;sched.nmspinning, <span class="number">1</span>)</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">goto</span> top</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">break</span></span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// poll network</span></span><br><span class="line"><span class="keyword">if</span> netpollinited() &amp;&amp; atomic.Load(&amp;netpollWaiters) &gt; <span class="number">0</span> &amp;&amp; atomic.Xchg64(&amp;sched.lastpoll, <span class="number">0</span>) != <span class="number">0</span> &#123;</span><br><span class="line"><span class="keyword">if</span> _g_.m.p != <span class="number">0</span> &#123;</span><br><span class="line">throw(<span class="string">"findrunnable: netpoll with p"</span>)</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span> _g_.m.spinning &#123;</span><br><span class="line">throw(<span class="string">"findrunnable: netpoll with spinning"</span>)</span><br><span class="line">&#125;</span><br><span class="line">gp := netpoll(<span class="literal">true</span>) <span class="comment">// block until new work is available</span></span><br><span class="line">atomic.Store64(&amp;sched.lastpoll, <span class="keyword">uint64</span>(nanotime()))</span><br><span class="line"><span class="keyword">if</span> gp != <span class="literal">nil</span> &#123;</span><br><span class="line">lock(&amp;sched.lock)</span><br><span class="line">_p_ = pidleget()</span><br><span class="line">unlock(&amp;sched.lock)</span><br><span class="line"><span class="keyword">if</span> _p_ != <span class="literal">nil</span> &#123;</span><br><span class="line">acquirep(_p_)</span><br><span class="line">injectglist(gp.schedlink.ptr())</span><br><span class="line">casgstatus(gp, _Gwaiting, _Grunnable)</span><br><span class="line"><span class="keyword">if</span> trace.enabled &#123;</span><br><span class="line">traceGoUnpark(gp, <span class="number">0</span>)</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> gp, <span class="literal">false</span></span><br><span class="line">&#125;</span><br><span class="line">injectglist(gp)</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">stopm()</span><br><span class="line"><span class="keyword">goto</span> top</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这里真的是无奈啊，为了寻找一个可运行的g，也是煞费苦心，及时进入了stop 的label，还是不死心，又来了一边寻找。大致寻找过程可以总结为一下几个：</p><ul><li>从p自己的local队列中获取可运行的g</li><li>从全局队列中获取可运行的g</li><li>从netpoll中获取一个已经准备好的g</li><li>从其他p的local队列中获取可运行的g，随机偷取p的runnext，有点任性</li><li>无论如何都获取不到的话，就stopm了</li></ul><h5 id="stopm"><a href="#stopm" class="headerlink" title="stopm"></a>stopm</h5><p>stop会把当前m放到空闲列表里面，同时绑定m.nextp 与 m</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">stopm</span><span class="params">()</span></span> &#123;</span><br><span class="line">_g_ := getg()</span><br><span class="line">retry:</span><br><span class="line">lock(&amp;sched.lock)</span><br><span class="line"><span class="comment">// 把当前m放到sched.midle 的空闲列表里</span></span><br><span class="line">mput(_g_.m)</span><br><span class="line">unlock(&amp;sched.lock)</span><br><span class="line"><span class="comment">// 休眠，等待被唤醒</span></span><br><span class="line">notesleep(&amp;_g_.m.park)</span><br><span class="line">noteclear(&amp;_g_.m.park)</span><br><span class="line"><span class="comment">// 绑定p</span></span><br><span class="line">acquirep(_g_.m.nextp.ptr())</span><br><span class="line">_g_.m.nextp = <span class="number">0</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="监控"><a href="#监控" class="headerlink" title="监控"></a>监控</h2><h3 id="sysmon"><a href="#sysmon" class="headerlink" title="sysmon"></a>sysmon</h3><p>go的监控是依靠函数 sysmon 来完成的，监控主要做一下几件事</p><ul><li>释放闲置超过5分钟的span物理内存</li><li>如果超过两分钟没有执行垃圾回收，则强制执行</li><li>将长时间未处理的netpoll结果添加到任务队列</li><li>向长时间运行的g进行抢占</li><li>收回因为syscall而长时间阻塞的p</li></ul><p>监控线程并不是时刻在运行的，监控线程首次休眠20us，每次执行完后，增加一倍的休眠时间，但是最多休眠10ms</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">sysmon</span><span class="params">()</span></span> &#123;</span><br><span class="line">lock(&amp;sched.lock)</span><br><span class="line">sched.nmsys++</span><br><span class="line">checkdead()</span><br><span class="line">unlock(&amp;sched.lock)</span><br><span class="line"></span><br><span class="line"><span class="comment">// If a heap span goes unused for 5 minutes after a garbage collection,</span></span><br><span class="line"><span class="comment">// we hand it back to the operating system.</span></span><br><span class="line">scavengelimit := <span class="keyword">int64</span>(<span class="number">5</span> * <span class="number">60</span> * <span class="number">1e9</span>)</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> debug.scavenge &gt; <span class="number">0</span> &#123;</span><br><span class="line"><span class="comment">// Scavenge-a-lot for testing.</span></span><br><span class="line">forcegcperiod = <span class="number">10</span> * <span class="number">1e6</span></span><br><span class="line">scavengelimit = <span class="number">20</span> * <span class="number">1e6</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">lastscavenge := nanotime()</span><br><span class="line">nscavenge := <span class="number">0</span></span><br><span class="line"></span><br><span class="line">lasttrace := <span class="keyword">int64</span>(<span class="number">0</span>)</span><br><span class="line">idle := <span class="number">0</span> <span class="comment">// how many cycles in succession we had not wokeup somebody</span></span><br><span class="line">delay := <span class="keyword">uint32</span>(<span class="number">0</span>)</span><br><span class="line"><span class="keyword">for</span> &#123;</span><br><span class="line"><span class="comment">// 判断当前循环，应该休眠的时间</span></span><br><span class="line"><span class="keyword">if</span> idle == <span class="number">0</span> &#123; <span class="comment">// start with 20us sleep...</span></span><br><span class="line">delay = <span class="number">20</span></span><br><span class="line">&#125; <span class="keyword">else</span> <span class="keyword">if</span> idle &gt; <span class="number">50</span> &#123; <span class="comment">// start doubling the sleep after 1ms...</span></span><br><span class="line">delay *= <span class="number">2</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span> delay &gt; <span class="number">10</span>*<span class="number">1000</span> &#123; <span class="comment">// up to 10ms</span></span><br><span class="line">delay = <span class="number">10</span> * <span class="number">1000</span></span><br><span class="line">&#125;</span><br><span class="line">usleep(delay)</span><br><span class="line"><span class="comment">// STW时休眠sysmon</span></span><br><span class="line"><span class="keyword">if</span> debug.schedtrace &lt;= <span class="number">0</span> &amp;&amp; (sched.gcwaiting != <span class="number">0</span> || atomic.Load(&amp;sched.npidle) == <span class="keyword">uint32</span>(gomaxprocs)) &#123;</span><br><span class="line">lock(&amp;sched.lock)</span><br><span class="line"><span class="keyword">if</span> atomic.Load(&amp;sched.gcwaiting) != <span class="number">0</span> || atomic.Load(&amp;sched.npidle) == <span class="keyword">uint32</span>(gomaxprocs) &#123;</span><br><span class="line">atomic.Store(&amp;sched.sysmonwait, <span class="number">1</span>)</span><br><span class="line">unlock(&amp;sched.lock)</span><br><span class="line"><span class="comment">// Make wake-up period small enough</span></span><br><span class="line"><span class="comment">// for the sampling to be correct.</span></span><br><span class="line">maxsleep := forcegcperiod / <span class="number">2</span></span><br><span class="line"><span class="keyword">if</span> scavengelimit &lt; forcegcperiod &#123;</span><br><span class="line">maxsleep = scavengelimit / <span class="number">2</span></span><br><span class="line">&#125;</span><br><span class="line">shouldRelax := <span class="literal">true</span></span><br><span class="line"><span class="keyword">if</span> osRelaxMinNS &gt; <span class="number">0</span> &#123;</span><br><span class="line">next := timeSleepUntil()</span><br><span class="line">now := nanotime()</span><br><span class="line"><span class="keyword">if</span> next-now &lt; osRelaxMinNS &#123;</span><br><span class="line">shouldRelax = <span class="literal">false</span></span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span> shouldRelax &#123;</span><br><span class="line">osRelax(<span class="literal">true</span>)</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 进行休眠</span></span><br><span class="line">notetsleep(&amp;sched.sysmonnote, maxsleep)</span><br><span class="line"><span class="keyword">if</span> shouldRelax &#123;</span><br><span class="line">osRelax(<span class="literal">false</span>)</span><br><span class="line">&#125;</span><br><span class="line">lock(&amp;sched.lock)</span><br><span class="line"><span class="comment">// 唤醒后，清除休眠状态，继续执行</span></span><br><span class="line">atomic.Store(&amp;sched.sysmonwait, <span class="number">0</span>)</span><br><span class="line">noteclear(&amp;sched.sysmonnote)</span><br><span class="line">idle = <span class="number">0</span></span><br><span class="line">delay = <span class="number">20</span></span><br><span class="line">&#125;</span><br><span class="line">unlock(&amp;sched.lock)</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// trigger libc interceptors if needed</span></span><br><span class="line"><span class="keyword">if</span> *cgo_yield != <span class="literal">nil</span> &#123;</span><br><span class="line">asmcgocall(*cgo_yield, <span class="literal">nil</span>)</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// poll network if not polled for more than 10ms</span></span><br><span class="line">lastpoll := <span class="keyword">int64</span>(atomic.Load64(&amp;sched.lastpoll))</span><br><span class="line">now := nanotime()</span><br><span class="line"><span class="comment">// 如果netpoll不为空，每隔10ms检查一下是否有ok的</span></span><br><span class="line"><span class="keyword">if</span> netpollinited() &amp;&amp; lastpoll != <span class="number">0</span> &amp;&amp; lastpoll+<span class="number">10</span>*<span class="number">1000</span>*<span class="number">1000</span> &lt; now &#123;</span><br><span class="line">atomic.Cas64(&amp;sched.lastpoll, <span class="keyword">uint64</span>(lastpoll), <span class="keyword">uint64</span>(now))</span><br><span class="line"><span class="comment">// 返回了已经获取到结果的goroutine的列表</span></span><br><span class="line">gp := netpoll(<span class="literal">false</span>) <span class="comment">// non-blocking - returns list of goroutines</span></span><br><span class="line"><span class="keyword">if</span> gp != <span class="literal">nil</span> &#123;</span><br><span class="line">incidlelocked(<span class="number">-1</span>)</span><br><span class="line"><span class="comment">// 把获取到的g的列表加入到全局待运行队列中</span></span><br><span class="line">injectglist(gp)</span><br><span class="line">incidlelocked(<span class="number">1</span>)</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// retake P's blocked in syscalls</span></span><br><span class="line"><span class="comment">// and preempt long running G's</span></span><br><span class="line"><span class="comment">// 抢夺syscall长时间阻塞的p和长时间运行的g</span></span><br><span class="line"><span class="keyword">if</span> retake(now) != <span class="number">0</span> &#123;</span><br><span class="line">idle = <span class="number">0</span></span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">idle++</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// check if we need to force a GC</span></span><br><span class="line"><span class="comment">// 通过gcTrigger.test() 函数判断是否超过设定的强制触发gc的时间间隔，</span></span><br><span class="line"><span class="keyword">if</span> t := (gcTrigger&#123;kind: gcTriggerTime, now: now&#125;); t.test() &amp;&amp; atomic.Load(&amp;forcegc.idle) != <span class="number">0</span> &#123;</span><br><span class="line">lock(&amp;forcegc.lock)</span><br><span class="line">forcegc.idle = <span class="number">0</span></span><br><span class="line">forcegc.g.schedlink = <span class="number">0</span></span><br><span class="line"><span class="comment">// 把gc的g加入待运行队列，等待调度运行</span></span><br><span class="line">injectglist(forcegc.g)</span><br><span class="line">unlock(&amp;forcegc.lock)</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// scavenge heap once in a while</span></span><br><span class="line"><span class="comment">// 判断是否有5分钟未使用的span，有的话，归还给系统</span></span><br><span class="line"><span class="keyword">if</span> lastscavenge+scavengelimit/<span class="number">2</span> &lt; now &#123;</span><br><span class="line">mheap_.scavenge(<span class="keyword">int32</span>(nscavenge), <span class="keyword">uint64</span>(now), <span class="keyword">uint64</span>(scavengelimit))</span><br><span class="line">lastscavenge = now</span><br><span class="line">nscavenge++</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span> debug.schedtrace &gt; <span class="number">0</span> &amp;&amp; lasttrace+<span class="keyword">int64</span>(debug.schedtrace)*<span class="number">1000000</span> &lt;= now &#123;</span><br><span class="line">lasttrace = now</span><br><span class="line">schedtrace(debug.scheddetail &gt; <span class="number">0</span>)</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>扫描netpoll，并把g存放到去全局队列比较好理解，跟前面添加p和m的逻辑差不多，但是抢占这里就不是很理解了，你说抢占就抢占，被抢占的g岂不是很没面子，而且怎么抢占呢？</p><h3 id="retake"><a href="#retake" class="headerlink" title="retake"></a>retake</h3><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> forcePreemptNS = <span class="number">10</span> * <span class="number">1000</span> * <span class="number">1000</span> <span class="comment">// 10ms</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">retake</span><span class="params">(now <span class="keyword">int64</span>)</span> <span class="title">uint32</span></span> &#123;</span><br><span class="line">n := <span class="number">0</span></span><br><span class="line"><span class="comment">// Prevent allp slice changes. This lock will be completely</span></span><br><span class="line"><span class="comment">// uncontended unless we're already stopping the world.</span></span><br><span class="line">lock(&amp;allpLock)</span><br><span class="line"><span class="comment">// We can't use a range loop over allp because we may</span></span><br><span class="line"><span class="comment">// temporarily drop the allpLock. Hence, we need to re-fetch</span></span><br><span class="line"><span class="comment">// allp each time around the loop.</span></span><br><span class="line"><span class="keyword">for</span> i := <span class="number">0</span>; i &lt; <span class="built_in">len</span>(allp); i++ &#123;</span><br><span class="line">_p_ := allp[i]</span><br><span class="line"><span class="keyword">if</span> _p_ == <span class="literal">nil</span> &#123;</span><br><span class="line"><span class="comment">// This can happen if procresize has grown</span></span><br><span class="line"><span class="comment">// allp but not yet created new Ps.</span></span><br><span class="line"><span class="keyword">continue</span></span><br><span class="line">&#125;</span><br><span class="line">pd := &amp;_p_.sysmontick</span><br><span class="line">s := _p_.status</span><br><span class="line"><span class="keyword">if</span> s == _Psyscall &#123;</span><br><span class="line"><span class="comment">// Retake P from syscall if it's there for more than 1 sysmon tick (at least 20us).</span></span><br><span class="line"><span class="comment">// pd.syscalltick 即 _p_.sysmontick.syscalltick 只有在sysmon的时候会更新，而 _p_.syscalltick 则会每次都更新，所以，当syscall之后，第一个sysmon检测到的时候并不会抢占，而是第二次开始才会抢占，中间间隔至少有20us，最多会有10ms</span></span><br><span class="line">t := <span class="keyword">int64</span>(_p_.syscalltick)</span><br><span class="line"><span class="keyword">if</span> <span class="keyword">int64</span>(pd.syscalltick) != t &#123;</span><br><span class="line">pd.syscalltick = <span class="keyword">uint32</span>(t)</span><br><span class="line">pd.syscallwhen = now</span><br><span class="line"><span class="keyword">continue</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// On the one hand we don't want to retake Ps if there is no other work to do,</span></span><br><span class="line"><span class="comment">// but on the other hand we want to retake them eventually</span></span><br><span class="line"><span class="comment">// because they can prevent the sysmon thread from deep sleep.</span></span><br><span class="line"><span class="comment">// 是否有空p，有寻找p的m，以及当前的p在syscall之后，有没有超过10ms</span></span><br><span class="line"><span class="keyword">if</span> runqempty(_p_) &amp;&amp; atomic.Load(&amp;sched.nmspinning)+atomic.Load(&amp;sched.npidle) &gt; <span class="number">0</span> &amp;&amp; pd.syscallwhen+<span class="number">10</span>*<span class="number">1000</span>*<span class="number">1000</span> &gt; now &#123;</span><br><span class="line"><span class="keyword">continue</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// Drop allpLock so we can take sched.lock.</span></span><br><span class="line">unlock(&amp;allpLock)</span><br><span class="line"><span class="comment">// Need to decrement number of idle locked M's</span></span><br><span class="line"><span class="comment">// (pretending that one more is running) before the CAS.</span></span><br><span class="line"><span class="comment">// Otherwise the M from which we retake can exit the syscall,</span></span><br><span class="line"><span class="comment">// increment nmidle and report deadlock.</span></span><br><span class="line">incidlelocked(<span class="number">-1</span>)</span><br><span class="line"><span class="comment">// 抢占p，把p的状态转为idle状态</span></span><br><span class="line"><span class="keyword">if</span> atomic.Cas(&amp;_p_.status, s, _Pidle) &#123;</span><br><span class="line"><span class="keyword">if</span> trace.enabled &#123;</span><br><span class="line">traceGoSysBlock(_p_)</span><br><span class="line">traceProcStop(_p_)</span><br><span class="line">&#125;</span><br><span class="line">n++</span><br><span class="line">_p_.syscalltick++</span><br><span class="line"><span class="comment">// 把当前p移交出去，上面已经分析过了</span></span><br><span class="line">handoffp(_p_)</span><br><span class="line">&#125;</span><br><span class="line">incidlelocked(<span class="number">1</span>)</span><br><span class="line">lock(&amp;allpLock)</span><br><span class="line">&#125; <span class="keyword">else</span> <span class="keyword">if</span> s == _Prunning &#123;</span><br><span class="line"><span class="comment">// Preempt G if it's running for too long.</span></span><br><span class="line"><span class="comment">// 如果p是running状态，如果p下面的g执行太久了，则抢占</span></span><br><span class="line">t := <span class="keyword">int64</span>(_p_.schedtick)</span><br><span class="line"><span class="keyword">if</span> <span class="keyword">int64</span>(pd.schedtick) != t &#123;</span><br><span class="line">pd.schedtick = <span class="keyword">uint32</span>(t)</span><br><span class="line">pd.schedwhen = now</span><br><span class="line"><span class="keyword">continue</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 判断是否超出10ms, 不超过不抢占</span></span><br><span class="line"><span class="keyword">if</span> pd.schedwhen+forcePreemptNS &gt; now &#123;</span><br><span class="line"><span class="keyword">continue</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 开始抢占</span></span><br><span class="line">preemptone(_p_)</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">unlock(&amp;allpLock)</span><br><span class="line"><span class="keyword">return</span> <span class="keyword">uint32</span>(n)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="preemptone"><a href="#preemptone" class="headerlink" title="preemptone"></a>preemptone</h3><p>这个函数的注释，作者就表明这种抢占并不是很靠谱😂，我们先看一下实现吧</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">preemptone</span><span class="params">(_p_ *p)</span> <span class="title">bool</span></span> &#123;</span><br><span class="line">mp := _p_.m.ptr()</span><br><span class="line"><span class="keyword">if</span> mp == <span class="literal">nil</span> || mp == getg().m &#123;</span><br><span class="line"><span class="keyword">return</span> <span class="literal">false</span></span><br><span class="line">&#125;</span><br><span class="line">gp := mp.curg</span><br><span class="line"><span class="keyword">if</span> gp == <span class="literal">nil</span> || gp == mp.g0 &#123;</span><br><span class="line"><span class="keyword">return</span> <span class="literal">false</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 标识抢占字段</span></span><br><span class="line">gp.preempt = <span class="literal">true</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// Every call in a go routine checks for stack overflow by</span></span><br><span class="line"><span class="comment">// comparing the current stack pointer to gp-&gt;stackguard0.</span></span><br><span class="line"><span class="comment">// Setting gp-&gt;stackguard0 to StackPreempt folds</span></span><br><span class="line"><span class="comment">// preemption into the normal stack overflow check.</span></span><br><span class="line"><span class="comment">// 更新stackguard0，保证能检测到栈溢</span></span><br><span class="line">gp.stackguard0 = stackPreempt</span><br><span class="line"><span class="keyword">return</span> <span class="literal">true</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在这里，作者会更新   <code>gp.stackguard0 = stackPreempt</code>，然后让g误以为栈不够用了，那就只有乖乖的去进行栈扩张，站扩张的话就用调用<code>newstack</code> 分配一个新栈，然后把原先的栈的内容拷贝过去，而在 <code>newstack</code> 里面有一段如下</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> preempt &#123;</span><br><span class="line"><span class="keyword">if</span> thisg.m.locks != <span class="number">0</span> || thisg.m.mallocing != <span class="number">0</span> || thisg.m.preemptoff != <span class="string">""</span> || thisg.m.p.ptr().status != _Prunning &#123;</span><br><span class="line"><span class="comment">// Let the goroutine keep running for now.</span></span><br><span class="line"><span class="comment">// gp-&gt;preempt is set, so it will be preempted next time.</span></span><br><span class="line">gp.stackguard0 = gp.stack.lo + _StackGuard</span><br><span class="line">gogo(&amp;gp.sched) <span class="comment">// never return</span></span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>然后这里就发现g被抢占了，那你栈不够用就有可能是假的，但是管你呢，你再去调度去吧，也不给你扩栈了，虽然作者和雨痕大神都吐槽了一下这个，但是这种抢占方式自动1.5（也可能更早）就一直存在，且稳定运行，就说明还是很牛逼的了</p><h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><p>在调度器的设置上，最明显的就是复用：g 的free链表， m的free列表， p的free列表，这样就避免了重复创建销毁锁浪费的资源</p><p>其次就是多级缓存： 这一块跟内存上的设计思想也是一直的，p一直有一个 g 的待运行队列，自己没有货过多的时候，才会平衡到全局队列，全局队列操作需要锁，则本地操作则不需要，大大减少了锁的创建销毁所消耗的资源</p><p>至此，g m p的关系及状态转换大致都讲解完成了，由于对汇编这块比较薄弱，所以基本略过了，右面有机会还是需要多了解一点</p><h1 id="参考文档"><a href="#参考文档" class="headerlink" title="参考文档"></a>参考文档</h1><ul><li><p>《go语言学习笔记》</p></li><li><p><a href="https://www.cnblogs.com/zkweb/p/7815600.html" target="_blank" rel="noopener">Golang源码探索(二) 协程的实现原理</a></p></li><li><p><a href="https://segmentfault.com/a/1190000018777972" target="_blank" rel="noopener">【Go源码分析】Go scheduler 源码分析</a></p></li></ul>]]></content>
      
      
      <categories>
          
          <category> Go </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Go </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>深入理解Go-垃圾回收机制</title>
      <link href="/posts/13860/"/>
      <url>/posts/13860/</url>
      
        <content type="html"><![CDATA[<p>Go的GC自打出生的时候就开始被人诟病，但是在引入v1.5的三色标记和v1.8的混合写屏障后，正常的GC已经缩短到10us左右，已经变得非常优秀，了不起了，我们接下来探索一下Go的GC的原理吧</p><a id="more"></a><h1 id="三色标记原理"><a href="#三色标记原理" class="headerlink" title="三色标记原理"></a>三色标记原理</h1><p>我们首先看一张图，大概就会对 三色标记法 有一个大致的了解：</p><p><img src="http://note-1253518569.cossh.myqcloud.com/20190803175848.gif" alt></p><p>原理：</p><ol><li>首先把所有的对象都放到白色的集合中</li><li>从根节点开始遍历对象，遍历到的白色对象从白色集合中放到灰色集合中</li><li>遍历灰色集合中的对象，把灰色对象引用的白色集合的对象放入到灰色集合中，同时把遍历过的灰色集合中的对象放到黑色的集合中</li><li>循环步骤3，知道灰色集合中没有对象</li><li>步骤4结束后，白色集合中的对象就是不可达对象，也就是垃圾，进行回收</li></ol><h1 id="写屏障"><a href="#写屏障" class="headerlink" title="写屏障"></a>写屏障</h1><p>Go在进行三色标记的时候并没有STW，也就是说，此时的对象还是可以进行修改</p><p>那么我们考虑一下，下面的情况</p><p><img src="http://note-1253518569.cossh.myqcloud.com/20190803183838.png" alt></p><p>我们在进行三色标记中扫描灰色集合中，扫描到了对象A，并标记了对象A的所有引用，这时候，开始扫描对象D的引用，而此时，另一个goroutine修改了D-&gt;E的引用，变成了如下图所示</p><p><img src="http://note-1253518569.cossh.myqcloud.com/20190804181356.png" alt></p><p>这样会不会导致E对象就扫描不到了，而被误认为 为白色对象，也就是垃圾</p><p>写屏障就是为了解决这样的问题，引入写屏障后，在上述步骤后，E会被认为是存活的，即使后面E被A对象抛弃，E会被在下一轮的GC中进行回收，这一轮GC中是不会对对象E进行回收的</p><p>Go1.9中开始启用了混合写屏障，伪代码如下</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">writePointer(slot, ptr):</span><br><span class="line">    shade(*slot)</span><br><span class="line">    if any stack is grey:</span><br><span class="line">        shade(ptr)</span><br><span class="line">    *slot = ptr</span><br></pre></td></tr></table></figure><p>混合写屏障会同时标记指针写入目标的”原指针”和“新指针”.</p><p>标记原指针的原因是, 其他运行中的线程有可能会同时把这个指针的值复制到寄存器或者栈上的本地变量<br>因为<strong>复制指针到寄存器或者栈上的本地变量不会经过写屏障</strong>, 所以有可能会导致指针不被标记, 试想下面的情况：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">[go] b = obj</span><br><span class="line">[go] oldx = nil</span><br><span class="line">[gc] scan oldx...</span><br><span class="line">[go] oldx = b.x // 复制b.x到本地变量, 不进过写屏障</span><br><span class="line">[go] b.x = ptr // 写屏障应该标记b.x的原值</span><br><span class="line">[gc] scan b...</span><br><span class="line">如果写屏障不标记原值, 那么oldx就不会被扫描到.</span><br></pre></td></tr></table></figure><p>标记新指针的原因是, 其他运行中的线程有可能会转移指针的位置, 试想下面的情况:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">[go] a = ptr</span><br><span class="line">[go] b = obj</span><br><span class="line">[gc] scan b...</span><br><span class="line">[go] b.x = a // 写屏障应该标记b.x的新值</span><br><span class="line">[go] a = nil</span><br><span class="line">[gc] scan a...</span><br><span class="line">如果写屏障不标记新值, 那么ptr就不会被扫描到.</span><br></pre></td></tr></table></figure><p>混合写屏障可以让GC在并行标记结束后不需要重新扫描各个G的堆栈, 可以减少Mark Termination中的STW时间</p><p>除了写屏障外, 在GC的过程中所有新分配的对象都会立刻变为黑色, 在上面的mallocgc函数中可以看到</p><h1 id="回收流程"><a href="#回收流程" class="headerlink" title="回收流程"></a>回收流程</h1><p>GO的GC是并行GC, 也就是GC的大部分处理和普通的go代码是同时运行的, 这让GO的GC流程比较复杂.<br>首先GC有四个阶段, 它们分别是:</p><ul><li>Sweep Termination: 对未清扫的span进行清扫, 只有上一轮的GC的清扫工作完成才可以开始新一轮的GC</li><li>Mark: 扫描所有根对象, 和根对象可以到达的所有对象, 标记它们不被回收</li><li>Mark Termination: 完成标记工作, 重新扫描部分根对象(要求STW)</li><li>Sweep: 按标记结果清扫span</li></ul><p>下图是比较完整的GC流程, 并按颜色对这四个阶段进行了分类:</p><p><img src="http://note-1253518569.cossh.myqcloud.com/20190803211215.png" alt></p><p>在GC过程中会有两种后台任务(G), 一种是标记用的后台任务, 一种是清扫用的后台任务.<br>标记用的后台任务会在需要时启动, 可以同时工作的后台任务数量大约是P的数量的25%, 也就是go所讲的让25%的cpu用在GC上的根据.<br>清扫用的后台任务在程序启动时会启动一个, 进入清扫阶段时唤醒.</p><p>目前整个GC流程会进行两次STW(Stop The World), 第一次是Mark阶段的开始, 第二次是Mark Termination阶段.<br>第一次STW会准备根对象的扫描, 启动写屏障(Write Barrier)和辅助GC(mutator assist).<br>第二次STW会重新扫描部分根对象, 禁用写屏障(Write Barrier)和辅助GC(mutator assist).<br>需要注意的是, 不是所有根对象的扫描都需要STW, 例如扫描栈上的对象只需要停止拥有该栈的G.<br>写屏障的实现使用了Hybrid Write Barrier, 大幅减少了第二次STW的时间.</p><h1 id="源码分析"><a href="#源码分析" class="headerlink" title="源码分析"></a>源码分析</h1><h2 id="gcStart"><a href="#gcStart" class="headerlink" title="gcStart"></a>gcStart</h2><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">gcStart</span><span class="params">(mode gcMode, trigger gcTrigger)</span></span> &#123;</span><br><span class="line"><span class="comment">// Since this is called from malloc and malloc is called in</span></span><br><span class="line"><span class="comment">// the guts of a number of libraries that might be holding</span></span><br><span class="line"><span class="comment">// locks, don't attempt to start GC in non-preemptible or</span></span><br><span class="line"><span class="comment">// potentially unstable situations.</span></span><br><span class="line"><span class="comment">// 判断当前g是否可以抢占，不可抢占时不触发GC</span></span><br><span class="line">mp := acquirem()</span><br><span class="line"><span class="keyword">if</span> gp := getg(); gp == mp.g0 || mp.locks &gt; <span class="number">1</span> || mp.preemptoff != <span class="string">""</span> &#123;</span><br><span class="line">releasem(mp)</span><br><span class="line"><span class="keyword">return</span></span><br><span class="line">&#125;</span><br><span class="line">releasem(mp)</span><br><span class="line">mp = <span class="literal">nil</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// Pick up the remaining unswept/not being swept spans concurrently</span></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="comment">// This shouldn't happen if we're being invoked in background</span></span><br><span class="line"><span class="comment">// mode since proportional sweep should have just finished</span></span><br><span class="line"><span class="comment">// sweeping everything, but rounding errors, etc, may leave a</span></span><br><span class="line"><span class="comment">// few spans unswept. In forced mode, this is necessary since</span></span><br><span class="line"><span class="comment">// GC can be forced at any point in the sweeping cycle.</span></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="comment">// We check the transition condition continuously here in case</span></span><br><span class="line"><span class="comment">// this G gets delayed in to the next GC cycle.</span></span><br><span class="line"><span class="comment">// 清扫 残留的未清扫的垃圾</span></span><br><span class="line"><span class="keyword">for</span> trigger.test() &amp;&amp; gosweepone() != ^<span class="keyword">uintptr</span>(<span class="number">0</span>) &#123;</span><br><span class="line">sweep.nbgsweep++</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Perform GC initialization and the sweep termination</span></span><br><span class="line"><span class="comment">// transition.</span></span><br><span class="line">semacquire(&amp;work.startSema)</span><br><span class="line"><span class="comment">// Re-check transition condition under transition lock.</span></span><br><span class="line"><span class="comment">// 判断gcTrriger的条件是否成立</span></span><br><span class="line"><span class="keyword">if</span> !trigger.test() &#123;</span><br><span class="line">semrelease(&amp;work.startSema)</span><br><span class="line"><span class="keyword">return</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// For stats, check if this GC was forced by the user</span></span><br><span class="line"><span class="comment">// 判断并记录GC是否被强制执行的，runtime.GC()可以被用户调用并强制执行</span></span><br><span class="line">work.userForced = trigger.kind == gcTriggerAlways || trigger.kind == gcTriggerCycle</span><br><span class="line"></span><br><span class="line"><span class="comment">// In gcstoptheworld debug mode, upgrade the mode accordingly.</span></span><br><span class="line"><span class="comment">// We do this after re-checking the transition condition so</span></span><br><span class="line"><span class="comment">// that multiple goroutines that detect the heap trigger don't</span></span><br><span class="line"><span class="comment">// start multiple STW GCs.</span></span><br><span class="line"><span class="comment">// 设置gc的mode</span></span><br><span class="line"><span class="keyword">if</span> mode == gcBackgroundMode &#123;</span><br><span class="line"><span class="keyword">if</span> debug.gcstoptheworld == <span class="number">1</span> &#123;</span><br><span class="line">mode = gcForceMode</span><br><span class="line">&#125; <span class="keyword">else</span> <span class="keyword">if</span> debug.gcstoptheworld == <span class="number">2</span> &#123;</span><br><span class="line">mode = gcForceBlockMode</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Ok, we're doing it! Stop everybody else</span></span><br><span class="line">semacquire(&amp;worldsema)</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> trace.enabled &#123;</span><br><span class="line">traceGCStart()</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 启动后台标记任务</span></span><br><span class="line"><span class="keyword">if</span> mode == gcBackgroundMode &#123;</span><br><span class="line">gcBgMarkStartWorkers()</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 重置gc 标记相关的状态</span></span><br><span class="line">gcResetMarkState()</span><br><span class="line"></span><br><span class="line">work.stwprocs, work.maxprocs = gomaxprocs, gomaxprocs</span><br><span class="line"><span class="keyword">if</span> work.stwprocs &gt; ncpu &#123;</span><br><span class="line"><span class="comment">// This is used to compute CPU time of the STW phases,</span></span><br><span class="line"><span class="comment">// so it can't be more than ncpu, even if GOMAXPROCS is.</span></span><br><span class="line">work.stwprocs = ncpu</span><br><span class="line">&#125;</span><br><span class="line">work.heap0 = atomic.Load64(&amp;memstats.heap_live)</span><br><span class="line">work.pauseNS = <span class="number">0</span></span><br><span class="line">work.mode = mode</span><br><span class="line"></span><br><span class="line">now := nanotime()</span><br><span class="line">work.tSweepTerm = now</span><br><span class="line">work.pauseStart = now</span><br><span class="line"><span class="keyword">if</span> trace.enabled &#123;</span><br><span class="line">traceGCSTWStart(<span class="number">1</span>)</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// STW,停止世界</span></span><br><span class="line">systemstack(stopTheWorldWithSema)</span><br><span class="line"><span class="comment">// Finish sweep before we start concurrent scan.</span></span><br><span class="line"><span class="comment">// 先清扫上一轮的垃圾，确保上轮GC完成</span></span><br><span class="line">systemstack(<span class="function"><span class="keyword">func</span><span class="params">()</span></span> &#123;</span><br><span class="line">finishsweep_m()</span><br><span class="line">&#125;)</span><br><span class="line"><span class="comment">// clearpools before we start the GC. If we wait they memory will not be</span></span><br><span class="line"><span class="comment">// reclaimed until the next GC cycle.</span></span><br><span class="line"><span class="comment">// 清理 sync.pool sched.sudogcache、sched.deferpool，这里不展开，sync.pool已经说了，剩余的后面的文章会涉及</span></span><br><span class="line">clearpools()</span><br><span class="line"></span><br><span class="line"><span class="comment">// 增加GC技术</span></span><br><span class="line">work.cycles++</span><br><span class="line"><span class="keyword">if</span> mode == gcBackgroundMode &#123; <span class="comment">// Do as much work concurrently as possible</span></span><br><span class="line">gcController.startCycle()</span><br><span class="line">work.heapGoal = memstats.next_gc</span><br><span class="line"></span><br><span class="line"><span class="comment">// Enter concurrent mark phase and enable</span></span><br><span class="line"><span class="comment">// write barriers.</span></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="comment">// Because the world is stopped, all Ps will</span></span><br><span class="line"><span class="comment">// observe that write barriers are enabled by</span></span><br><span class="line"><span class="comment">// the time we start the world and begin</span></span><br><span class="line"><span class="comment">// scanning.</span></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="comment">// Write barriers must be enabled before assists are</span></span><br><span class="line"><span class="comment">// enabled because they must be enabled before</span></span><br><span class="line"><span class="comment">// any non-leaf heap objects are marked. Since</span></span><br><span class="line"><span class="comment">// allocations are blocked until assists can</span></span><br><span class="line"><span class="comment">// happen, we want enable assists as early as</span></span><br><span class="line"><span class="comment">// possible.</span></span><br><span class="line"><span class="comment">// 设置GC的状态为 gcMark</span></span><br><span class="line">setGCPhase(_GCmark)</span><br><span class="line"></span><br><span class="line"><span class="comment">// 更新 bgmark 的状态</span></span><br><span class="line">gcBgMarkPrepare() <span class="comment">// Must happen before assist enable.</span></span><br><span class="line"><span class="comment">// 计算并排队root 扫描任务，并初始化相关扫描任务状态</span></span><br><span class="line">gcMarkRootPrepare()</span><br><span class="line"></span><br><span class="line"><span class="comment">// Mark all active tinyalloc blocks. Since we're</span></span><br><span class="line"><span class="comment">// allocating from these, they need to be black like</span></span><br><span class="line"><span class="comment">// other allocations. The alternative is to blacken</span></span><br><span class="line"><span class="comment">// the tiny block on every allocation from it, which</span></span><br><span class="line"><span class="comment">// would slow down the tiny allocator.</span></span><br><span class="line"><span class="comment">// 标记 tiny 对象</span></span><br><span class="line">gcMarkTinyAllocs()</span><br><span class="line"></span><br><span class="line"><span class="comment">// At this point all Ps have enabled the write</span></span><br><span class="line"><span class="comment">// barrier, thus maintaining the no white to</span></span><br><span class="line"><span class="comment">// black invariant. Enable mutator assists to</span></span><br><span class="line"><span class="comment">// put back-pressure on fast allocating</span></span><br><span class="line"><span class="comment">// mutators.</span></span><br><span class="line"><span class="comment">// 设置 gcBlackenEnabled 为 1，启用写屏障</span></span><br><span class="line">atomic.Store(&amp;gcBlackenEnabled, <span class="number">1</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment">// Assists and workers can start the moment we start</span></span><br><span class="line"><span class="comment">// the world.</span></span><br><span class="line">gcController.markStartTime = now</span><br><span class="line"></span><br><span class="line"><span class="comment">// Concurrent mark.</span></span><br><span class="line">systemstack(<span class="function"><span class="keyword">func</span><span class="params">()</span></span> &#123;</span><br><span class="line">now = startTheWorldWithSema(trace.enabled)</span><br><span class="line">&#125;)</span><br><span class="line">work.pauseNS += now - work.pauseStart</span><br><span class="line">work.tMark = now</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line"><span class="comment">// 非并行模式</span></span><br><span class="line"><span class="comment">// 记录完成标记阶段的开始时间</span></span><br><span class="line"><span class="keyword">if</span> trace.enabled &#123;</span><br><span class="line"><span class="comment">// Switch to mark termination STW.</span></span><br><span class="line">traceGCSTWDone()</span><br><span class="line">traceGCSTWStart(<span class="number">0</span>)</span><br><span class="line">&#125;</span><br><span class="line">t := nanotime()</span><br><span class="line">work.tMark, work.tMarkTerm = t, t</span><br><span class="line">work.heapGoal = work.heap0</span><br><span class="line"></span><br><span class="line"><span class="comment">// Perform mark termination. This will restart the world.</span></span><br><span class="line"><span class="comment">// stw,进行标记，清扫并start the world</span></span><br><span class="line">gcMarkTermination(memstats.triggerRatio)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">semrelease(&amp;work.startSema)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="gcBgMarkStartWorkers"><a href="#gcBgMarkStartWorkers" class="headerlink" title="gcBgMarkStartWorkers"></a>gcBgMarkStartWorkers</h3><p>这个函数准备一些 执行bg mark工作的goroutine，但是这些goroutine并不是立即工作的，而是到等到GC的状态被标记为gcMark 才开始工作，见上个函数的119行</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">gcBgMarkStartWorkers</span><span class="params">()</span></span> &#123;</span><br><span class="line"><span class="comment">// Background marking is performed by per-P G's. Ensure that</span></span><br><span class="line"><span class="comment">// each P has a background GC G.</span></span><br><span class="line"><span class="keyword">for</span> _, p := <span class="keyword">range</span> allp &#123;</span><br><span class="line"><span class="keyword">if</span> p.gcBgMarkWorker == <span class="number">0</span> &#123;</span><br><span class="line"><span class="keyword">go</span> gcBgMarkWorker(p)</span><br><span class="line"><span class="comment">// 等待gcBgMarkWorker goroutine 的 bgMarkReady信号再继续</span></span><br><span class="line">notetsleepg(&amp;work.bgMarkReady, <span class="number">-1</span>)</span><br><span class="line">noteclear(&amp;work.bgMarkReady)</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="gcBgMarkWorker"><a href="#gcBgMarkWorker" class="headerlink" title="gcBgMarkWorker"></a>gcBgMarkWorker</h4><p>后台标记任务的函数</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br><span class="line">184</span><br><span class="line">185</span><br><span class="line">186</span><br><span class="line">187</span><br><span class="line">188</span><br><span class="line">189</span><br><span class="line">190</span><br><span class="line">191</span><br><span class="line">192</span><br><span class="line">193</span><br><span class="line">194</span><br><span class="line">195</span><br><span class="line">196</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">gcBgMarkWorker</span><span class="params">(_p_ *p)</span></span> &#123;</span><br><span class="line">gp := getg()</span><br><span class="line"><span class="comment">// 用于休眠结束后重新获取p和m</span></span><br><span class="line"><span class="keyword">type</span> parkInfo <span class="keyword">struct</span> &#123;</span><br><span class="line">m      muintptr <span class="comment">// Release this m on park.</span></span><br><span class="line">attach puintptr <span class="comment">// If non-nil, attach to this p on park.</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// We pass park to a gopark unlock function, so it can't be on</span></span><br><span class="line"><span class="comment">// the stack (see gopark). Prevent deadlock from recursively</span></span><br><span class="line"><span class="comment">// starting GC by disabling preemption.</span></span><br><span class="line">gp.m.preemptoff = <span class="string">"GC worker init"</span></span><br><span class="line">park := <span class="built_in">new</span>(parkInfo)</span><br><span class="line">gp.m.preemptoff = <span class="string">""</span></span><br><span class="line"><span class="comment">// 设置park的m和p的信息，留着后面传给gopark，在被gcController.findRunnable唤醒的时候，便于找回</span></span><br><span class="line">park.m.set(acquirem())</span><br><span class="line">park.attach.set(_p_)</span><br><span class="line"><span class="comment">// Inform gcBgMarkStartWorkers that this worker is ready.</span></span><br><span class="line"><span class="comment">// After this point, the background mark worker is scheduled</span></span><br><span class="line"><span class="comment">// cooperatively by gcController.findRunnable. Hence, it must</span></span><br><span class="line"><span class="comment">// never be preempted, as this would put it into _Grunnable</span></span><br><span class="line"><span class="comment">// and put it on a run queue. Instead, when the preempt flag</span></span><br><span class="line"><span class="comment">// is set, this puts itself into _Gwaiting to be woken up by</span></span><br><span class="line"><span class="comment">// gcController.findRunnable at the appropriate time.</span></span><br><span class="line"><span class="comment">// 让gcBgMarkStartWorkers notetsleepg停止等待并继续及退出</span></span><br><span class="line">notewakeup(&amp;work.bgMarkReady)</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> &#123;</span><br><span class="line"><span class="comment">// Go to sleep until woken by gcController.findRunnable.</span></span><br><span class="line"><span class="comment">// We can't releasem yet since even the call to gopark</span></span><br><span class="line"><span class="comment">// may be preempted.</span></span><br><span class="line"><span class="comment">// 让g进入休眠</span></span><br><span class="line">gopark(<span class="function"><span class="keyword">func</span><span class="params">(g *g, parkp unsafe.Pointer)</span> <span class="title">bool</span></span> &#123;</span><br><span class="line">park := (*parkInfo)(parkp)</span><br><span class="line"></span><br><span class="line"><span class="comment">// The worker G is no longer running, so it's</span></span><br><span class="line"><span class="comment">// now safe to allow preemption.</span></span><br><span class="line"><span class="comment">// 释放当前抢占的m</span></span><br><span class="line">releasem(park.m.ptr())</span><br><span class="line"></span><br><span class="line"><span class="comment">// If the worker isn't attached to its P,</span></span><br><span class="line"><span class="comment">// attach now. During initialization and after</span></span><br><span class="line"><span class="comment">// a phase change, the worker may have been</span></span><br><span class="line"><span class="comment">// running on a different P. As soon as we</span></span><br><span class="line"><span class="comment">// attach, the owner P may schedule the</span></span><br><span class="line"><span class="comment">// worker, so this must be done after the G is</span></span><br><span class="line"><span class="comment">// stopped.</span></span><br><span class="line"><span class="comment">// 设置关联p，上面已经设置过了</span></span><br><span class="line"><span class="keyword">if</span> park.attach != <span class="number">0</span> &#123;</span><br><span class="line">p := park.attach.ptr()</span><br><span class="line">park.attach.set(<span class="literal">nil</span>)</span><br><span class="line"><span class="comment">// cas the worker because we may be</span></span><br><span class="line"><span class="comment">// racing with a new worker starting</span></span><br><span class="line"><span class="comment">// on this P.</span></span><br><span class="line"><span class="keyword">if</span> !p.gcBgMarkWorker.cas(<span class="number">0</span>, guintptr(unsafe.Pointer(g))) &#123;</span><br><span class="line"><span class="comment">// The P got a new worker.</span></span><br><span class="line"><span class="comment">// Exit this worker.</span></span><br><span class="line"><span class="keyword">return</span> <span class="literal">false</span></span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> <span class="literal">true</span></span><br><span class="line">&#125;, unsafe.Pointer(park), waitReasonGCWorkerIdle, traceEvGoBlock, <span class="number">0</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment">// Loop until the P dies and disassociates this</span></span><br><span class="line"><span class="comment">// worker (the P may later be reused, in which case</span></span><br><span class="line"><span class="comment">// it will get a new worker) or we failed to associate.</span></span><br><span class="line"><span class="comment">// 检查P的gcBgMarkWorker是否和当前的G一致, 不一致时结束当前的任务</span></span><br><span class="line"><span class="keyword">if</span> _p_.gcBgMarkWorker.ptr() != gp &#123;</span><br><span class="line"><span class="keyword">break</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Disable preemption so we can use the gcw. If the</span></span><br><span class="line"><span class="comment">// scheduler wants to preempt us, we'll stop draining,</span></span><br><span class="line"><span class="comment">// dispose the gcw, and then preempt.</span></span><br><span class="line"><span class="comment">// gopark第一个函数中释放了m，这里再抢占回来</span></span><br><span class="line">park.m.set(acquirem())</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> gcBlackenEnabled == <span class="number">0</span> &#123;</span><br><span class="line">throw(<span class="string">"gcBgMarkWorker: blackening not enabled"</span>)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">startTime := nanotime()</span><br><span class="line"><span class="comment">// 设置gcmark的开始时间</span></span><br><span class="line">_p_.gcMarkWorkerStartTime = startTime</span><br><span class="line"></span><br><span class="line">decnwait := atomic.Xadd(&amp;work.nwait, <span class="number">-1</span>)</span><br><span class="line"><span class="keyword">if</span> decnwait == work.nproc &#123;</span><br><span class="line"><span class="built_in">println</span>(<span class="string">"runtime: work.nwait="</span>, decnwait, <span class="string">"work.nproc="</span>, work.nproc)</span><br><span class="line">throw(<span class="string">"work.nwait was &gt; work.nproc"</span>)</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 切换到g0工作</span></span><br><span class="line">systemstack(<span class="function"><span class="keyword">func</span><span class="params">()</span></span> &#123;</span><br><span class="line"><span class="comment">// Mark our goroutine preemptible so its stack</span></span><br><span class="line"><span class="comment">// can be scanned. This lets two mark workers</span></span><br><span class="line"><span class="comment">// scan each other (otherwise, they would</span></span><br><span class="line"><span class="comment">// deadlock). We must not modify anything on</span></span><br><span class="line"><span class="comment">// the G stack. However, stack shrinking is</span></span><br><span class="line"><span class="comment">// disabled for mark workers, so it is safe to</span></span><br><span class="line"><span class="comment">// read from the G stack.</span></span><br><span class="line"><span class="comment">// 设置G的状态为waiting，以便于另一个g扫描它的栈(两个g可以互相扫描对方的栈)</span></span><br><span class="line">casgstatus(gp, _Grunning, _Gwaiting)</span><br><span class="line"><span class="keyword">switch</span> _p_.gcMarkWorkerMode &#123;</span><br><span class="line"><span class="keyword">default</span>:</span><br><span class="line">throw(<span class="string">"gcBgMarkWorker: unexpected gcMarkWorkerMode"</span>)</span><br><span class="line"><span class="keyword">case</span> gcMarkWorkerDedicatedMode:</span><br><span class="line"><span class="comment">// 专心执行标记工作的模式</span></span><br><span class="line">gcDrain(&amp;_p_.gcw, gcDrainUntilPreempt|gcDrainFlushBgCredit)</span><br><span class="line"><span class="keyword">if</span> gp.preempt &#123;</span><br><span class="line"><span class="comment">// 被抢占了，把所有本地运行队列中的G放到全局运行队列中</span></span><br><span class="line"><span class="comment">// We were preempted. This is</span></span><br><span class="line"><span class="comment">// a useful signal to kick</span></span><br><span class="line"><span class="comment">// everything out of the run</span></span><br><span class="line"><span class="comment">// queue so it can run</span></span><br><span class="line"><span class="comment">// somewhere else.</span></span><br><span class="line">lock(&amp;sched.lock)</span><br><span class="line"><span class="keyword">for</span> &#123;</span><br><span class="line">gp, _ := runqget(_p_)</span><br><span class="line"><span class="keyword">if</span> gp == <span class="literal">nil</span> &#123;</span><br><span class="line"><span class="keyword">break</span></span><br><span class="line">&#125;</span><br><span class="line">globrunqput(gp)</span><br><span class="line">&#125;</span><br><span class="line">unlock(&amp;sched.lock)</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// Go back to draining, this time</span></span><br><span class="line"><span class="comment">// without preemption.</span></span><br><span class="line"><span class="comment">// 继续执行标记工作</span></span><br><span class="line">gcDrain(&amp;_p_.gcw, gcDrainNoBlock|gcDrainFlushBgCredit)</span><br><span class="line"><span class="keyword">case</span> gcMarkWorkerFractionalMode:</span><br><span class="line"><span class="comment">// 执行标记工作，知道被抢占</span></span><br><span class="line">gcDrain(&amp;_p_.gcw, gcDrainFractional|gcDrainUntilPreempt|gcDrainFlushBgCredit)</span><br><span class="line"><span class="keyword">case</span> gcMarkWorkerIdleMode:</span><br><span class="line"><span class="comment">// 空闲的时候执行标记工作</span></span><br><span class="line">gcDrain(&amp;_p_.gcw, gcDrainIdle|gcDrainUntilPreempt|gcDrainFlushBgCredit)</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 把G的waiting状态转换到runing状态</span></span><br><span class="line">casgstatus(gp, _Gwaiting, _Grunning)</span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line"><span class="comment">// If we are nearing the end of mark, dispose</span></span><br><span class="line"><span class="comment">// of the cache promptly. We must do this</span></span><br><span class="line"><span class="comment">// before signaling that we're no longer</span></span><br><span class="line"><span class="comment">// working so that other workers can't observe</span></span><br><span class="line"><span class="comment">// no workers and no work while we have this</span></span><br><span class="line"><span class="comment">// cached, and before we compute done.</span></span><br><span class="line"><span class="comment">// 及时处理本地缓存，上交到全局的队列中</span></span><br><span class="line"><span class="keyword">if</span> gcBlackenPromptly &#123;</span><br><span class="line">_p_.gcw.dispose()</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Account for time.</span></span><br><span class="line"><span class="comment">// 累加耗时</span></span><br><span class="line">duration := nanotime() - startTime</span><br><span class="line"><span class="keyword">switch</span> _p_.gcMarkWorkerMode &#123;</span><br><span class="line"><span class="keyword">case</span> gcMarkWorkerDedicatedMode:</span><br><span class="line">atomic.Xaddint64(&amp;gcController.dedicatedMarkTime, duration)</span><br><span class="line">atomic.Xaddint64(&amp;gcController.dedicatedMarkWorkersNeeded, <span class="number">1</span>)</span><br><span class="line"><span class="keyword">case</span> gcMarkWorkerFractionalMode:</span><br><span class="line">atomic.Xaddint64(&amp;gcController.fractionalMarkTime, duration)</span><br><span class="line">atomic.Xaddint64(&amp;_p_.gcFractionalMarkTime, duration)</span><br><span class="line"><span class="keyword">case</span> gcMarkWorkerIdleMode:</span><br><span class="line">atomic.Xaddint64(&amp;gcController.idleMarkTime, duration)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Was this the last worker and did we run out</span></span><br><span class="line"><span class="comment">// of work?</span></span><br><span class="line">incnwait := atomic.Xadd(&amp;work.nwait, +<span class="number">1</span>)</span><br><span class="line"><span class="keyword">if</span> incnwait &gt; work.nproc &#123;</span><br><span class="line"><span class="built_in">println</span>(<span class="string">"runtime: p.gcMarkWorkerMode="</span>, _p_.gcMarkWorkerMode,</span><br><span class="line"><span class="string">"work.nwait="</span>, incnwait, <span class="string">"work.nproc="</span>, work.nproc)</span><br><span class="line">throw(<span class="string">"work.nwait &gt; work.nproc"</span>)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// If this worker reached a background mark completion</span></span><br><span class="line"><span class="comment">// point, signal the main GC goroutine.</span></span><br><span class="line"><span class="keyword">if</span> incnwait == work.nproc &amp;&amp; !gcMarkWorkAvailable(<span class="literal">nil</span>) &#123;</span><br><span class="line"><span class="comment">// Make this G preemptible and disassociate it</span></span><br><span class="line"><span class="comment">// as the worker for this P so</span></span><br><span class="line"><span class="comment">// findRunnableGCWorker doesn't try to</span></span><br><span class="line"><span class="comment">// schedule it.</span></span><br><span class="line"><span class="comment">// 取消p m的关联</span></span><br><span class="line">_p_.gcBgMarkWorker.set(<span class="literal">nil</span>)</span><br><span class="line">releasem(park.m.ptr())</span><br><span class="line"></span><br><span class="line">gcMarkDone()</span><br><span class="line"></span><br><span class="line"><span class="comment">// Disable preemption and prepare to reattach</span></span><br><span class="line"><span class="comment">// to the P.</span></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="comment">// We may be running on a different P at this</span></span><br><span class="line"><span class="comment">// point, so we can't reattach until this G is</span></span><br><span class="line"><span class="comment">// parked.</span></span><br><span class="line">park.m.set(acquirem())</span><br><span class="line">park.attach.set(_p_)</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h5 id="gcDrain"><a href="#gcDrain" class="headerlink" title="gcDrain"></a>gcDrain</h5><p>三色标记的主要实现</p><p>gcDrain扫描所有的roots和对象，并表黑灰色对象，知道所有的roots和对象都被标记</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">gcDrain</span><span class="params">(gcw *gcWork, flags gcDrainFlags)</span></span> &#123;</span><br><span class="line"><span class="keyword">if</span> !writeBarrier.needed &#123;</span><br><span class="line">throw(<span class="string">"gcDrain phase incorrect"</span>)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">gp := getg().m.curg</span><br><span class="line"><span class="comment">// 看到抢占标识是否要返回</span></span><br><span class="line">preemptible := flags&amp;gcDrainUntilPreempt != <span class="number">0</span></span><br><span class="line"><span class="comment">// 没有任务时是否要等待任务</span></span><br><span class="line">blocking := flags&amp;(gcDrainUntilPreempt|gcDrainIdle|gcDrainFractional|gcDrainNoBlock) == <span class="number">0</span></span><br><span class="line"><span class="comment">// 是否计算后台的扫描量来减少辅助GC和唤醒等待中的G</span></span><br><span class="line">flushBgCredit := flags&amp;gcDrainFlushBgCredit != <span class="number">0</span></span><br><span class="line"><span class="comment">// 是否在空闲的时候执行标记任务</span></span><br><span class="line">idle := flags&amp;gcDrainIdle != <span class="number">0</span></span><br><span class="line"><span class="comment">// 记录初始的已经执行过的扫描任务</span></span><br><span class="line">initScanWork := gcw.scanWork</span><br><span class="line"></span><br><span class="line"><span class="comment">// checkWork is the scan work before performing the next</span></span><br><span class="line"><span class="comment">// self-preempt check.</span></span><br><span class="line"><span class="comment">// 设置对应模式的工作检查函数</span></span><br><span class="line">checkWork := <span class="keyword">int64</span>(<span class="number">1</span>&lt;&lt;<span class="number">63</span> - <span class="number">1</span>)</span><br><span class="line"><span class="keyword">var</span> check <span class="function"><span class="keyword">func</span><span class="params">()</span> <span class="title">bool</span></span></span><br><span class="line"><span class="function"><span class="title">if</span> <span class="title">flags</span>&amp;<span class="params">(gcDrainIdle|gcDrainFractional)</span> != 0</span> &#123;</span><br><span class="line">checkWork = initScanWork + drainCheckThreshold</span><br><span class="line"><span class="keyword">if</span> idle &#123;</span><br><span class="line">check = pollWork</span><br><span class="line">&#125; <span class="keyword">else</span> <span class="keyword">if</span> flags&amp;gcDrainFractional != <span class="number">0</span> &#123;</span><br><span class="line">check = pollFractionalWorkerExit</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Drain root marking jobs.</span></span><br><span class="line"><span class="comment">// 如果root对象没有扫描完，则扫描</span></span><br><span class="line"><span class="keyword">if</span> work.markrootNext &lt; work.markrootJobs &#123;</span><br><span class="line"><span class="keyword">for</span> !(preemptible &amp;&amp; gp.preempt) &#123;</span><br><span class="line">job := atomic.Xadd(&amp;work.markrootNext, +<span class="number">1</span>) - <span class="number">1</span></span><br><span class="line"><span class="keyword">if</span> job &gt;= work.markrootJobs &#123;</span><br><span class="line"><span class="keyword">break</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 执行root扫描任务</span></span><br><span class="line">markroot(gcw, job)</span><br><span class="line"><span class="keyword">if</span> check != <span class="literal">nil</span> &amp;&amp; check() &#123;</span><br><span class="line"><span class="keyword">goto</span> done</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Drain heap marking jobs.</span></span><br><span class="line"><span class="comment">// 循环直到被抢占</span></span><br><span class="line"><span class="keyword">for</span> !(preemptible &amp;&amp; gp.preempt) &#123;</span><br><span class="line"><span class="comment">// Try to keep work available on the global queue. We used to</span></span><br><span class="line"><span class="comment">// check if there were waiting workers, but it's better to</span></span><br><span class="line"><span class="comment">// just keep work available than to make workers wait. In the</span></span><br><span class="line"><span class="comment">// worst case, we'll do O(log(_WorkbufSize)) unnecessary</span></span><br><span class="line"><span class="comment">// balances.</span></span><br><span class="line"><span class="keyword">if</span> work.full == <span class="number">0</span> &#123;</span><br><span class="line"><span class="comment">// 平衡工作，如果全局的标记队列为空，则分一部分工作到全局队列中</span></span><br><span class="line">gcw.balance()</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> b <span class="keyword">uintptr</span></span><br><span class="line"><span class="keyword">if</span> blocking &#123;</span><br><span class="line">b = gcw.get()</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">b = gcw.tryGetFast()</span><br><span class="line"><span class="keyword">if</span> b == <span class="number">0</span> &#123;</span><br><span class="line">b = gcw.tryGet()</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 获取任务失败，跳出循环</span></span><br><span class="line"><span class="keyword">if</span> b == <span class="number">0</span> &#123;</span><br><span class="line"><span class="comment">// work barrier reached or tryGet failed.</span></span><br><span class="line"><span class="keyword">break</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 扫描获取的到对象</span></span><br><span class="line">scanobject(b, gcw)</span><br><span class="line"></span><br><span class="line"><span class="comment">// Flush background scan work credit to the global</span></span><br><span class="line"><span class="comment">// account if we've accumulated enough locally so</span></span><br><span class="line"><span class="comment">// mutator assists can draw on it.</span></span><br><span class="line"><span class="comment">// 如果当前扫描的数量超过了 gcCreditSlack，就把扫描的对象数量加到全局的数量，批量更新</span></span><br><span class="line"><span class="keyword">if</span> gcw.scanWork &gt;= gcCreditSlack &#123;</span><br><span class="line">atomic.Xaddint64(&amp;gcController.scanWork, gcw.scanWork)</span><br><span class="line"><span class="keyword">if</span> flushBgCredit &#123;</span><br><span class="line">gcFlushBgCredit(gcw.scanWork - initScanWork)</span><br><span class="line">initScanWork = <span class="number">0</span></span><br><span class="line">&#125;</span><br><span class="line">checkWork -= gcw.scanWork</span><br><span class="line">gcw.scanWork = <span class="number">0</span></span><br><span class="line"><span class="comment">// 如果扫描的对象数量已经达到了 执行下次抢占的目标数量 checkWork， 则调用对应模式的函数</span></span><br><span class="line"><span class="comment">// idle模式为 pollWork， Fractional模式为 pollFractionalWorkerExit ，在第20行</span></span><br><span class="line"><span class="keyword">if</span> checkWork &lt;= <span class="number">0</span> &#123;</span><br><span class="line">checkWork += drainCheckThreshold</span><br><span class="line"><span class="keyword">if</span> check != <span class="literal">nil</span> &amp;&amp; check() &#123;</span><br><span class="line"><span class="keyword">break</span></span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// In blocking mode, write barriers are not allowed after this</span></span><br><span class="line"><span class="comment">// point because we must preserve the condition that the work</span></span><br><span class="line"><span class="comment">// buffers are empty.</span></span><br><span class="line"></span><br><span class="line">done:</span><br><span class="line"><span class="comment">// Flush remaining scan work credit.</span></span><br><span class="line"><span class="keyword">if</span> gcw.scanWork &gt; <span class="number">0</span> &#123;</span><br><span class="line"><span class="comment">// 把扫描的对象数量添加到全局</span></span><br><span class="line">atomic.Xaddint64(&amp;gcController.scanWork, gcw.scanWork)</span><br><span class="line"><span class="keyword">if</span> flushBgCredit &#123;</span><br><span class="line">gcFlushBgCredit(gcw.scanWork - initScanWork)</span><br><span class="line">&#125;</span><br><span class="line">gcw.scanWork = <span class="number">0</span></span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h6 id="markroot"><a href="#markroot" class="headerlink" title="markroot"></a>markroot</h6><p>这个被用于根对象扫描</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">markroot</span><span class="params">(gcw *gcWork, i <span class="keyword">uint32</span>)</span></span> &#123;</span><br><span class="line"><span class="comment">// TODO(austin): This is a bit ridiculous. Compute and store</span></span><br><span class="line"><span class="comment">// the bases in gcMarkRootPrepare instead of the counts.</span></span><br><span class="line">baseFlushCache := <span class="keyword">uint32</span>(fixedRootCount)</span><br><span class="line">baseData := baseFlushCache + <span class="keyword">uint32</span>(work.nFlushCacheRoots)</span><br><span class="line">baseBSS := baseData + <span class="keyword">uint32</span>(work.nDataRoots)</span><br><span class="line">baseSpans := baseBSS + <span class="keyword">uint32</span>(work.nBSSRoots)</span><br><span class="line">baseStacks := baseSpans + <span class="keyword">uint32</span>(work.nSpanRoots)</span><br><span class="line">end := baseStacks + <span class="keyword">uint32</span>(work.nStackRoots)</span><br><span class="line"></span><br><span class="line"><span class="comment">// Note: if you add a case here, please also update heapdump.go:dumproots.</span></span><br><span class="line"><span class="keyword">switch</span> &#123;</span><br><span class="line"><span class="comment">// 释放mcache中的span</span></span><br><span class="line"><span class="keyword">case</span> baseFlushCache &lt;= i &amp;&amp; i &lt; baseData:</span><br><span class="line">flushmcache(<span class="keyword">int</span>(i - baseFlushCache))</span><br><span class="line"><span class="comment">// 扫描可读写的全局变量</span></span><br><span class="line"><span class="keyword">case</span> baseData &lt;= i &amp;&amp; i &lt; baseBSS:</span><br><span class="line"><span class="keyword">for</span> _, datap := <span class="keyword">range</span> activeModules() &#123;</span><br><span class="line">markrootBlock(datap.data, datap.edata-datap.data, datap.gcdatamask.bytedata, gcw, <span class="keyword">int</span>(i-baseData))</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 扫描只读的全局队列</span></span><br><span class="line"><span class="keyword">case</span> baseBSS &lt;= i &amp;&amp; i &lt; baseSpans:</span><br><span class="line"><span class="keyword">for</span> _, datap := <span class="keyword">range</span> activeModules() &#123;</span><br><span class="line">markrootBlock(datap.bss, datap.ebss-datap.bss, datap.gcbssmask.bytedata, gcw, <span class="keyword">int</span>(i-baseBSS))</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 扫描Finalizer队列</span></span><br><span class="line"><span class="keyword">case</span> i == fixedRootFinalizers:</span><br><span class="line"><span class="comment">// Only do this once per GC cycle since we don't call</span></span><br><span class="line"><span class="comment">// queuefinalizer during marking.</span></span><br><span class="line"><span class="keyword">if</span> work.markrootDone &#123;</span><br><span class="line"><span class="keyword">break</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">for</span> fb := allfin; fb != <span class="literal">nil</span>; fb = fb.alllink &#123;</span><br><span class="line">cnt := <span class="keyword">uintptr</span>(atomic.Load(&amp;fb.cnt))</span><br><span class="line">scanblock(<span class="keyword">uintptr</span>(unsafe.Pointer(&amp;fb.fin[<span class="number">0</span>])), cnt*unsafe.Sizeof(fb.fin[<span class="number">0</span>]), &amp;finptrmask[<span class="number">0</span>], gcw)</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 释放已经终止的stack</span></span><br><span class="line"><span class="keyword">case</span> i == fixedRootFreeGStacks:</span><br><span class="line"><span class="comment">// Only do this once per GC cycle; preferably</span></span><br><span class="line"><span class="comment">// concurrently.</span></span><br><span class="line"><span class="keyword">if</span> !work.markrootDone &#123;</span><br><span class="line"><span class="comment">// Switch to the system stack so we can call</span></span><br><span class="line"><span class="comment">// stackfree.</span></span><br><span class="line">systemstack(markrootFreeGStacks)</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 扫描MSpan.specials</span></span><br><span class="line"><span class="keyword">case</span> baseSpans &lt;= i &amp;&amp; i &lt; baseStacks:</span><br><span class="line"><span class="comment">// mark MSpan.specials</span></span><br><span class="line">markrootSpans(gcw, <span class="keyword">int</span>(i-baseSpans))</span><br><span class="line"></span><br><span class="line"><span class="keyword">default</span>:</span><br><span class="line"><span class="comment">// the rest is scanning goroutine stacks</span></span><br><span class="line"><span class="comment">// 获取需要扫描的g</span></span><br><span class="line"><span class="keyword">var</span> gp *g</span><br><span class="line"><span class="keyword">if</span> baseStacks &lt;= i &amp;&amp; i &lt; end &#123;</span><br><span class="line">gp = allgs[i-baseStacks]</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">throw(<span class="string">"markroot: bad index"</span>)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// remember when we've first observed the G blocked</span></span><br><span class="line"><span class="comment">// needed only to output in traceback</span></span><br><span class="line">status := readgstatus(gp) <span class="comment">// We are not in a scan state</span></span><br><span class="line"><span class="keyword">if</span> (status == _Gwaiting || status == _Gsyscall) &amp;&amp; gp.waitsince == <span class="number">0</span> &#123;</span><br><span class="line">gp.waitsince = work.tstart</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// scang must be done on the system stack in case</span></span><br><span class="line"><span class="comment">// we're trying to scan our own stack.</span></span><br><span class="line"><span class="comment">// 转交给g0进行扫描</span></span><br><span class="line">systemstack(<span class="function"><span class="keyword">func</span><span class="params">()</span></span> &#123;</span><br><span class="line"><span class="comment">// If this is a self-scan, put the user G in</span></span><br><span class="line"><span class="comment">// _Gwaiting to prevent self-deadlock. It may</span></span><br><span class="line"><span class="comment">// already be in _Gwaiting if this is a mark</span></span><br><span class="line"><span class="comment">// worker or we're in mark termination.</span></span><br><span class="line">userG := getg().m.curg</span><br><span class="line">selfScan := gp == userG &amp;&amp; readgstatus(userG) == _Grunning</span><br><span class="line"><span class="comment">// 如果是扫描自己的，则转换自己的g的状态</span></span><br><span class="line"><span class="keyword">if</span> selfScan &#123;</span><br><span class="line">casgstatus(userG, _Grunning, _Gwaiting)</span><br><span class="line">userG.waitreason = waitReasonGarbageCollectionScan</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// <span class="doctag">TODO:</span> scang blocks until gp's stack has</span></span><br><span class="line"><span class="comment">// been scanned, which may take a while for</span></span><br><span class="line"><span class="comment">// running goroutines. Consider doing this in</span></span><br><span class="line"><span class="comment">// two phases where the first is non-blocking:</span></span><br><span class="line"><span class="comment">// we scan the stacks we can and ask running</span></span><br><span class="line"><span class="comment">// goroutines to scan themselves; and the</span></span><br><span class="line"><span class="comment">// second blocks.</span></span><br><span class="line"><span class="comment">// 扫描g的栈</span></span><br><span class="line">scang(gp, gcw)</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> selfScan &#123;</span><br><span class="line">casgstatus(userG, _Gwaiting, _Grunning)</span><br><span class="line">&#125;</span><br><span class="line">&#125;)</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h6 id="markRootBlock"><a href="#markRootBlock" class="headerlink" title="markRootBlock"></a>markRootBlock</h6><p>根据 ptrmask0，来扫描[b0, b0+n0)区域</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">markrootBlock</span><span class="params">(b0, n0 <span class="keyword">uintptr</span>, ptrmask0 *<span class="keyword">uint8</span>, gcw *gcWork, shard <span class="keyword">int</span>)</span></span> &#123;</span><br><span class="line"><span class="keyword">if</span> rootBlockBytes%(<span class="number">8</span>*sys.PtrSize) != <span class="number">0</span> &#123;</span><br><span class="line"><span class="comment">// This is necessary to pick byte offsets in ptrmask0.</span></span><br><span class="line">throw(<span class="string">"rootBlockBytes must be a multiple of 8*ptrSize"</span>)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">b := b0 + <span class="keyword">uintptr</span>(shard)*rootBlockBytes</span><br><span class="line"><span class="comment">// 如果需扫描的block区域，超出b0+n0的区域，直接返回</span></span><br><span class="line"><span class="keyword">if</span> b &gt;= b0+n0 &#123;</span><br><span class="line"><span class="keyword">return</span></span><br><span class="line">&#125;</span><br><span class="line">ptrmask := (*<span class="keyword">uint8</span>)(add(unsafe.Pointer(ptrmask0), <span class="keyword">uintptr</span>(shard)*(rootBlockBytes/(<span class="number">8</span>*sys.PtrSize))))</span><br><span class="line">n := <span class="keyword">uintptr</span>(rootBlockBytes)</span><br><span class="line"><span class="keyword">if</span> b+n &gt; b0+n0 &#123;</span><br><span class="line">n = b0 + n0 - b</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Scan this shard.</span></span><br><span class="line"><span class="comment">// 扫描给定block的shard</span></span><br><span class="line">scanblock(b, n, ptrmask, gcw)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h6 id="scanblock"><a href="#scanblock" class="headerlink" title="scanblock"></a>scanblock</h6><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">scanblock</span><span class="params">(b0, n0 <span class="keyword">uintptr</span>, ptrmask *<span class="keyword">uint8</span>, gcw *gcWork)</span></span> &#123;</span><br><span class="line"><span class="comment">// Use local copies of original parameters, so that a stack trace</span></span><br><span class="line"><span class="comment">// due to one of the throws below shows the original block</span></span><br><span class="line"><span class="comment">// base and extent.</span></span><br><span class="line">b := b0</span><br><span class="line">n := n0</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> i := <span class="keyword">uintptr</span>(<span class="number">0</span>); i &lt; n; &#123;</span><br><span class="line"><span class="comment">// Find bits for the next word.</span></span><br><span class="line"><span class="comment">// 找到bitmap中对应的bits</span></span><br><span class="line">bits := <span class="keyword">uint32</span>(*addb(ptrmask, i/(sys.PtrSize*<span class="number">8</span>)))</span><br><span class="line"><span class="keyword">if</span> bits == <span class="number">0</span> &#123;</span><br><span class="line">i += sys.PtrSize * <span class="number">8</span></span><br><span class="line"><span class="keyword">continue</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">for</span> j := <span class="number">0</span>; j &lt; <span class="number">8</span> &amp;&amp; i &lt; n; j++ &#123;</span><br><span class="line"><span class="keyword">if</span> bits&amp;<span class="number">1</span> != <span class="number">0</span> &#123;</span><br><span class="line"><span class="comment">// 如果该地址包含指针</span></span><br><span class="line"><span class="comment">// Same work as in scanobject; see comments there.</span></span><br><span class="line">obj := *(*<span class="keyword">uintptr</span>)(unsafe.Pointer(b + i))</span><br><span class="line"><span class="keyword">if</span> obj != <span class="number">0</span> &#123;</span><br><span class="line"><span class="comment">// 如果该地址下找到了对应的对象，标灰</span></span><br><span class="line"><span class="keyword">if</span> obj, span, objIndex := findObject(obj, b, i); obj != <span class="number">0</span> &#123;</span><br><span class="line">greyobject(obj, b, i, span, gcw, objIndex)</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">bits &gt;&gt;= <span class="number">1</span></span><br><span class="line">i += sys.PtrSize</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h6 id="greyobject"><a href="#greyobject" class="headerlink" title="greyobject"></a>greyobject</h6><p>标灰对象其实就是找到对应bitmap，标记存活并扔进队列</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">greyobject</span><span class="params">(obj, base, off <span class="keyword">uintptr</span>, span *mspan, gcw *gcWork, objIndex <span class="keyword">uintptr</span>)</span></span> &#123;</span><br><span class="line"><span class="comment">// obj should be start of allocation, and so must be at least pointer-aligned.</span></span><br><span class="line"><span class="keyword">if</span> obj&amp;(sys.PtrSize<span class="number">-1</span>) != <span class="number">0</span> &#123;</span><br><span class="line">throw(<span class="string">"greyobject: obj not pointer-aligned"</span>)</span><br><span class="line">&#125;</span><br><span class="line">mbits := span.markBitsForIndex(objIndex)</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> useCheckmark &#123;</span><br><span class="line"><span class="comment">// 这里是用来debug，确保所有的对象都被正确标识</span></span><br><span class="line"><span class="keyword">if</span> !mbits.isMarked() &#123;</span><br><span class="line"><span class="comment">// 这个对象没有被标记</span></span><br><span class="line">printlock()</span><br><span class="line"><span class="built_in">print</span>(<span class="string">"runtime:greyobject: checkmarks finds unexpected unmarked object obj="</span>, hex(obj), <span class="string">"\n"</span>)</span><br><span class="line"><span class="built_in">print</span>(<span class="string">"runtime: found obj at *("</span>, hex(base), <span class="string">"+"</span>, hex(off), <span class="string">")\n"</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment">// Dump the source (base) object</span></span><br><span class="line">gcDumpObject(<span class="string">"base"</span>, base, off)</span><br><span class="line"></span><br><span class="line"><span class="comment">// Dump the object</span></span><br><span class="line">gcDumpObject(<span class="string">"obj"</span>, obj, ^<span class="keyword">uintptr</span>(<span class="number">0</span>))</span><br><span class="line"></span><br><span class="line">getg().m.traceback = <span class="number">2</span></span><br><span class="line">throw(<span class="string">"checkmark found unmarked object"</span>)</span><br><span class="line">&#125;</span><br><span class="line">hbits := heapBitsForAddr(obj)</span><br><span class="line"><span class="keyword">if</span> hbits.isCheckmarked(span.elemsize) &#123;</span><br><span class="line"><span class="keyword">return</span></span><br><span class="line">&#125;</span><br><span class="line">hbits.setCheckmarked(span.elemsize)</span><br><span class="line"><span class="keyword">if</span> !hbits.isCheckmarked(span.elemsize) &#123;</span><br><span class="line">throw(<span class="string">"setCheckmarked and isCheckmarked disagree"</span>)</span><br><span class="line">&#125;</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line"><span class="keyword">if</span> debug.gccheckmark &gt; <span class="number">0</span> &amp;&amp; span.isFree(objIndex) &#123;</span><br><span class="line"><span class="built_in">print</span>(<span class="string">"runtime: marking free object "</span>, hex(obj), <span class="string">" found at *("</span>, hex(base), <span class="string">"+"</span>, hex(off), <span class="string">")\n"</span>)</span><br><span class="line">gcDumpObject(<span class="string">"base"</span>, base, off)</span><br><span class="line">gcDumpObject(<span class="string">"obj"</span>, obj, ^<span class="keyword">uintptr</span>(<span class="number">0</span>))</span><br><span class="line">getg().m.traceback = <span class="number">2</span></span><br><span class="line">throw(<span class="string">"marking free object"</span>)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// If marked we have nothing to do.</span></span><br><span class="line"><span class="comment">// 对象被正确标记了，无需做其他的操作</span></span><br><span class="line"><span class="keyword">if</span> mbits.isMarked() &#123;</span><br><span class="line"><span class="keyword">return</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// mbits.setMarked() // Avoid extra call overhead with manual inlining.</span></span><br><span class="line"><span class="comment">// 标记对象</span></span><br><span class="line">atomic.Or8(mbits.bytep, mbits.mask)</span><br><span class="line"><span class="comment">// If this is a noscan object, fast-track it to black</span></span><br><span class="line"><span class="comment">// instead of greying it.</span></span><br><span class="line"><span class="comment">// 如果对象不是指针，则只需要标记，不需要放进队列，相当于直接标黑</span></span><br><span class="line"><span class="keyword">if</span> span.spanclass.noscan() &#123;</span><br><span class="line">gcw.bytesMarked += <span class="keyword">uint64</span>(span.elemsize)</span><br><span class="line"><span class="keyword">return</span></span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Queue the obj for scanning. The PREFETCH(obj) logic has been removed but</span></span><br><span class="line"><span class="comment">// seems like a nice optimization that can be added back in.</span></span><br><span class="line"><span class="comment">// There needs to be time between the PREFETCH and the use.</span></span><br><span class="line"><span class="comment">// Previously we put the obj in an 8 element buffer that is drained at a rate</span></span><br><span class="line"><span class="comment">// to give the PREFETCH time to do its work.</span></span><br><span class="line"><span class="comment">// Use of PREFETCHNTA might be more appropriate than PREFETCH</span></span><br><span class="line"><span class="comment">// 判断对象是否被放进队列，没有则放入，标灰步骤完成</span></span><br><span class="line"><span class="keyword">if</span> !gcw.putFast(obj) &#123;</span><br><span class="line">gcw.put(obj)</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h6 id="gcWork-putFast"><a href="#gcWork-putFast" class="headerlink" title="gcWork.putFast"></a>gcWork.putFast</h6><p>work有wbuf1 wbuf2两个队列用于保存灰色对象，首先会往wbuf1队列里加入灰色对象，wbuf1满了后，交换wbuf1和wbuf2，这事wbuf2便晋升为wbuf1，继续存放灰色对象，两个队列都满了，则想全局进行申请</p><p>putFast这里进尝试将对象放进wbuf1队列中</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(w *gcWork)</span> <span class="title">putFast</span><span class="params">(obj <span class="keyword">uintptr</span>)</span> <span class="title">bool</span></span> &#123;</span><br><span class="line">wbuf := w.wbuf1</span><br><span class="line"><span class="keyword">if</span> wbuf == <span class="literal">nil</span> &#123;</span><br><span class="line"><span class="comment">// 没有申请缓存队列，返回false</span></span><br><span class="line"><span class="keyword">return</span> <span class="literal">false</span></span><br><span class="line">&#125; <span class="keyword">else</span> <span class="keyword">if</span> wbuf.nobj == <span class="built_in">len</span>(wbuf.obj) &#123;</span><br><span class="line"><span class="comment">// wbuf1队列满了，返回false</span></span><br><span class="line"><span class="keyword">return</span> <span class="literal">false</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 向未满wbuf1队列中加入对象</span></span><br><span class="line">wbuf.obj[wbuf.nobj] = obj</span><br><span class="line">wbuf.nobj++</span><br><span class="line"><span class="keyword">return</span> <span class="literal">true</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h6 id="gcWork-put"><a href="#gcWork-put" class="headerlink" title="gcWork.put"></a>gcWork.put</h6><p>put不仅尝试将对象放入wbuf1，还会再wbuf1满的时候，尝试更换wbuf1 wbuf2的角色，都满的话，则想全局进行申请，并将满的队列上交到全局队列</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(w *gcWork)</span> <span class="title">put</span><span class="params">(obj <span class="keyword">uintptr</span>)</span></span> &#123;</span><br><span class="line">flushed := <span class="literal">false</span></span><br><span class="line">wbuf := w.wbuf1</span><br><span class="line"><span class="keyword">if</span> wbuf == <span class="literal">nil</span> &#123;</span><br><span class="line"><span class="comment">// 如果wbuf1不存在，则初始化wbuf1 wbuf2两个队列</span></span><br><span class="line">w.init()</span><br><span class="line">wbuf = w.wbuf1</span><br><span class="line"><span class="comment">// wbuf is empty at this point.</span></span><br><span class="line">&#125; <span class="keyword">else</span> <span class="keyword">if</span> wbuf.nobj == <span class="built_in">len</span>(wbuf.obj) &#123;</span><br><span class="line"><span class="comment">// wbuf1满了，更换wbuf1 wbuf2的角色</span></span><br><span class="line">w.wbuf1, w.wbuf2 = w.wbuf2, w.wbuf1</span><br><span class="line">wbuf = w.wbuf1</span><br><span class="line"><span class="keyword">if</span> wbuf.nobj == <span class="built_in">len</span>(wbuf.obj) &#123;</span><br><span class="line"><span class="comment">// 更换角色后，wbuf1也满了，说明两个队列都满了</span></span><br><span class="line"><span class="comment">// 把 wbuf1上交全局并获取一个空的队列</span></span><br><span class="line">putfull(wbuf)</span><br><span class="line">wbuf = getempty()</span><br><span class="line">w.wbuf1 = wbuf</span><br><span class="line"><span class="comment">// 设置队列上交的标志位</span></span><br><span class="line">flushed = <span class="literal">true</span></span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">wbuf.obj[wbuf.nobj] = obj</span><br><span class="line">wbuf.nobj++</span><br><span class="line"></span><br><span class="line"><span class="comment">// If we put a buffer on full, let the GC controller know so</span></span><br><span class="line"><span class="comment">// it can encourage more workers to run. We delay this until</span></span><br><span class="line"><span class="comment">// the end of put so that w is in a consistent state, since</span></span><br><span class="line"><span class="comment">// enlistWorker may itself manipulate w.</span></span><br><span class="line"><span class="comment">// 此时全局已经有标记满的队列，GC controller选择调度更多work进行工作</span></span><br><span class="line"><span class="keyword">if</span> flushed &amp;&amp; gcphase == _GCmark &#123;</span><br><span class="line">gcController.enlistWorker()</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>到这里，接下来，我们继续分析gcDrain里面的函数，追踪一下，我们标灰的对象是如何被标黑的</p><h6 id="gcw-balance"><a href="#gcw-balance" class="headerlink" title="gcw.balance()"></a>gcw.balance()</h6><p>继续分析 gcDrain的58行，balance work是什么</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(w *gcWork)</span> <span class="title">balance</span><span class="params">()</span></span> &#123;</span><br><span class="line"><span class="keyword">if</span> w.wbuf1 == <span class="literal">nil</span> &#123;</span><br><span class="line"><span class="comment">// 这里wbuf1 wbuf2队列还没有初始化</span></span><br><span class="line"><span class="keyword">return</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 如果wbuf2不为空，则上交到全局，并获取一个空岛队列给wbuf2</span></span><br><span class="line"><span class="keyword">if</span> wbuf := w.wbuf2; wbuf.nobj != <span class="number">0</span> &#123;</span><br><span class="line">putfull(wbuf)</span><br><span class="line">w.wbuf2 = getempty()</span><br><span class="line">&#125; <span class="keyword">else</span> <span class="keyword">if</span> wbuf := w.wbuf1; wbuf.nobj &gt; <span class="number">4</span> &#123;</span><br><span class="line"><span class="comment">// 把未满的wbuf1分成两半，并把其中一半上交的全局队列</span></span><br><span class="line">w.wbuf1 = handoff(wbuf)</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line"><span class="keyword">return</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// We flushed a buffer to the full list, so wake a worker.</span></span><br><span class="line"><span class="comment">// 这里，全局队列有满的队列了，其他work可以工作了</span></span><br><span class="line"><span class="keyword">if</span> gcphase == _GCmark &#123;</span><br><span class="line">gcController.enlistWorker()</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h6 id="gcw-get"><a href="#gcw-get" class="headerlink" title="gcw.get()"></a>gcw.get()</h6><p>继续分析 gcDrain的63行，这里就是首先从本地的队列获取一个对象，如果本地队列的wbuf1没有，尝试从wbuf2获取，如果两个都没有，则尝试从全局队列获取一个满的队列，并获取一个对象</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(w *gcWork)</span> <span class="title">get</span><span class="params">()</span> <span class="title">uintptr</span></span> &#123;</span><br><span class="line">wbuf := w.wbuf1</span><br><span class="line"><span class="keyword">if</span> wbuf == <span class="literal">nil</span> &#123;</span><br><span class="line">w.init()</span><br><span class="line">wbuf = w.wbuf1</span><br><span class="line"><span class="comment">// wbuf is empty at this point.</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span> wbuf.nobj == <span class="number">0</span> &#123;</span><br><span class="line"><span class="comment">// wbuf1空了，更换wbuf1 wbuf2的角色</span></span><br><span class="line">w.wbuf1, w.wbuf2 = w.wbuf2, w.wbuf1</span><br><span class="line">wbuf = w.wbuf1</span><br><span class="line"><span class="comment">// 原wbuf2也是空的，尝试从全局队列获取一个满的队列</span></span><br><span class="line"><span class="keyword">if</span> wbuf.nobj == <span class="number">0</span> &#123;</span><br><span class="line">owbuf := wbuf</span><br><span class="line">wbuf = getfull()</span><br><span class="line"><span class="comment">// 获取不到，则返回</span></span><br><span class="line"><span class="keyword">if</span> wbuf == <span class="literal">nil</span> &#123;</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 把空的队列上传到全局空队列，并把获取的满的队列，作为自身的wbuf1</span></span><br><span class="line">putempty(owbuf)</span><br><span class="line">w.wbuf1 = wbuf</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// <span class="doctag">TODO:</span> This might be a good place to add prefetch code</span></span><br><span class="line"></span><br><span class="line">wbuf.nobj--</span><br><span class="line"><span class="keyword">return</span> wbuf.obj[wbuf.nobj]</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>gcw.tryGet()</code> <code>gcw.tryGetFast()</code> 逻辑差不多，相对比较简单，就不继续分析了</p><h6 id="scanobject"><a href="#scanobject" class="headerlink" title="scanobject"></a>scanobject</h6><p>我们继续分析到 gcDrain 的L76，这里已经获取到了b，开始消费队列</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">scanobject</span><span class="params">(b <span class="keyword">uintptr</span>, gcw *gcWork)</span></span> &#123;</span><br><span class="line"><span class="comment">// Find the bits for b and the size of the object at b.</span></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="comment">// b is either the beginning of an object, in which case this</span></span><br><span class="line"><span class="comment">// is the size of the object to scan, or it points to an</span></span><br><span class="line"><span class="comment">// oblet, in which case we compute the size to scan below.</span></span><br><span class="line"><span class="comment">// 获取b对应的bits</span></span><br><span class="line">hbits := heapBitsForAddr(b)</span><br><span class="line"><span class="comment">// 获取b所在的span</span></span><br><span class="line">s := spanOfUnchecked(b)</span><br><span class="line">n := s.elemsize</span><br><span class="line"><span class="keyword">if</span> n == <span class="number">0</span> &#123;</span><br><span class="line">throw(<span class="string">"scanobject n == 0"</span>)</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 对象过大，则切割后再扫描，maxObletBytes为128k</span></span><br><span class="line"><span class="keyword">if</span> n &gt; maxObletBytes &#123;</span><br><span class="line"><span class="comment">// Large object. Break into oblets for better</span></span><br><span class="line"><span class="comment">// parallelism and lower latency.</span></span><br><span class="line"><span class="keyword">if</span> b == s.base() &#123;</span><br><span class="line"><span class="comment">// It's possible this is a noscan object (not</span></span><br><span class="line"><span class="comment">// from greyobject, but from other code</span></span><br><span class="line"><span class="comment">// paths), in which case we must *not* enqueue</span></span><br><span class="line"><span class="comment">// oblets since their bitmaps will be</span></span><br><span class="line"><span class="comment">// uninitialized.</span></span><br><span class="line"><span class="comment">// 如果不是指针，直接标记返回，相当于标黑了</span></span><br><span class="line"><span class="keyword">if</span> s.spanclass.noscan() &#123;</span><br><span class="line"><span class="comment">// Bypass the whole scan.</span></span><br><span class="line">gcw.bytesMarked += <span class="keyword">uint64</span>(n)</span><br><span class="line"><span class="keyword">return</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Enqueue the other oblets to scan later.</span></span><br><span class="line"><span class="comment">// Some oblets may be in b's scalar tail, but</span></span><br><span class="line"><span class="comment">// these will be marked as "no more pointers",</span></span><br><span class="line"><span class="comment">// so we'll drop out immediately when we go to</span></span><br><span class="line"><span class="comment">// scan those.</span></span><br><span class="line"><span class="comment">// 按maxObletBytes切割后放入到 队列</span></span><br><span class="line"><span class="keyword">for</span> oblet := b + maxObletBytes; oblet &lt; s.base()+s.elemsize; oblet += maxObletBytes &#123;</span><br><span class="line"><span class="keyword">if</span> !gcw.putFast(oblet) &#123;</span><br><span class="line">gcw.put(oblet)</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Compute the size of the oblet. Since this object</span></span><br><span class="line"><span class="comment">// must be a large object, s.base() is the beginning</span></span><br><span class="line"><span class="comment">// of the object.</span></span><br><span class="line">n = s.base() + s.elemsize - b</span><br><span class="line"><span class="keyword">if</span> n &gt; maxObletBytes &#123;</span><br><span class="line">n = maxObletBytes</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> i <span class="keyword">uintptr</span></span><br><span class="line"><span class="keyword">for</span> i = <span class="number">0</span>; i &lt; n; i += sys.PtrSize &#123;</span><br><span class="line"><span class="comment">// Find bits for this word.</span></span><br><span class="line"><span class="comment">// 获取到对应的bits</span></span><br><span class="line"><span class="keyword">if</span> i != <span class="number">0</span> &#123;</span><br><span class="line"><span class="comment">// Avoid needless hbits.next() on last iteration.</span></span><br><span class="line">hbits = hbits.next()</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// Load bits once. See CL 22712 and issue 16973 for discussion.</span></span><br><span class="line">bits := hbits.bits()</span><br><span class="line"><span class="comment">// During checkmarking, 1-word objects store the checkmark</span></span><br><span class="line"><span class="comment">// in the type bit for the one word. The only one-word objects</span></span><br><span class="line"><span class="comment">// are pointers, or else they'd be merged with other non-pointer</span></span><br><span class="line"><span class="comment">// data into larger allocations.</span></span><br><span class="line"><span class="keyword">if</span> i != <span class="number">1</span>*sys.PtrSize &amp;&amp; bits&amp;bitScan == <span class="number">0</span> &#123;</span><br><span class="line"><span class="keyword">break</span> <span class="comment">// no more pointers in this object</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 不是指针，继续</span></span><br><span class="line"><span class="keyword">if</span> bits&amp;bitPointer == <span class="number">0</span> &#123;</span><br><span class="line"><span class="keyword">continue</span> <span class="comment">// not a pointer</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Work here is duplicated in scanblock and above.</span></span><br><span class="line"><span class="comment">// If you make changes here, make changes there too.</span></span><br><span class="line">obj := *(*<span class="keyword">uintptr</span>)(unsafe.Pointer(b + i))</span><br><span class="line"></span><br><span class="line"><span class="comment">// At this point we have extracted the next potential pointer.</span></span><br><span class="line"><span class="comment">// Quickly filter out nil and pointers back to the current object.</span></span><br><span class="line"><span class="keyword">if</span> obj != <span class="number">0</span> &amp;&amp; obj-b &gt;= n &#123;</span><br><span class="line"><span class="comment">// Test if obj points into the Go heap and, if so,</span></span><br><span class="line"><span class="comment">// mark the object.</span></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="comment">// Note that it's possible for findObject to</span></span><br><span class="line"><span class="comment">// fail if obj points to a just-allocated heap</span></span><br><span class="line"><span class="comment">// object because of a race with growing the</span></span><br><span class="line"><span class="comment">// heap. In this case, we know the object was</span></span><br><span class="line"><span class="comment">// just allocated and hence will be marked by</span></span><br><span class="line"><span class="comment">// allocation itself.</span></span><br><span class="line"><span class="comment">// 找到指针对应的对象，并标灰</span></span><br><span class="line"><span class="keyword">if</span> obj, span, objIndex := findObject(obj, b, i); obj != <span class="number">0</span> &#123;</span><br><span class="line">greyobject(obj, b, i, span, gcw, objIndex)</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">gcw.bytesMarked += <span class="keyword">uint64</span>(n)</span><br><span class="line">gcw.scanWork += <span class="keyword">int64</span>(i)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>综上，我们可以发现，标灰就是标记并放进队列，标黑就是标记，所以当灰色对象从队列中取出后，我们就可以认为这个对象是黑色对象了</p><p>至此，gcDrain的标记工作分析完成，我们继续回到gcBgMarkWorker分析</p><h5 id="gcMarkDone"><a href="#gcMarkDone" class="headerlink" title="gcMarkDone"></a>gcMarkDone</h5><p>gcMarkDone会将mark1阶段进入到mark2阶段， mark2阶段进入到mark termination阶段</p><p>mark1阶段： 包括所有root标记，全局缓存队列和本地缓存队列</p><p>mark2阶段：本地缓存队列会被禁用</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">gcMarkDone</span><span class="params">()</span></span> &#123;</span><br><span class="line">top:</span><br><span class="line">semacquire(&amp;work.markDoneSema)</span><br><span class="line"></span><br><span class="line"><span class="comment">// Re-check transition condition under transition lock.</span></span><br><span class="line"><span class="keyword">if</span> !(gcphase == _GCmark &amp;&amp; work.nwait == work.nproc &amp;&amp; !gcMarkWorkAvailable(<span class="literal">nil</span>)) &#123;</span><br><span class="line">semrelease(&amp;work.markDoneSema)</span><br><span class="line"><span class="keyword">return</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Disallow starting new workers so that any remaining workers</span></span><br><span class="line"><span class="comment">// in the current mark phase will drain out.</span></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="comment">// TODO(austin): Should dedicated workers keep an eye on this</span></span><br><span class="line"><span class="comment">// and exit gcDrain promptly?</span></span><br><span class="line"><span class="comment">// 禁止新的标记任务</span></span><br><span class="line">atomic.Xaddint64(&amp;gcController.dedicatedMarkWorkersNeeded, <span class="number">-0xffffffff</span>)</span><br><span class="line">prevFractionalGoal := gcController.fractionalUtilizationGoal</span><br><span class="line">gcController.fractionalUtilizationGoal = <span class="number">0</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 如果gcBlackenPromptly表名需要所有本地缓存队列立即上交到全局队列，并禁用本地缓存队列</span></span><br><span class="line"><span class="keyword">if</span> !gcBlackenPromptly &#123;</span><br><span class="line"><span class="comment">// Transition from mark 1 to mark 2.</span></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="comment">// The global work list is empty, but there can still be work</span></span><br><span class="line"><span class="comment">// sitting in the per-P work caches.</span></span><br><span class="line"><span class="comment">// Flush and disable work caches.</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// Disallow caching workbufs and indicate that we're in mark 2.</span></span><br><span class="line"><span class="comment">// 禁用本地缓存队列，进入mark2阶段</span></span><br><span class="line">gcBlackenPromptly = <span class="literal">true</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// Prevent completion of mark 2 until we've flushed</span></span><br><span class="line"><span class="comment">// cached workbufs.</span></span><br><span class="line">atomic.Xadd(&amp;work.nwait, <span class="number">-1</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment">// GC is set up for mark 2. Let Gs blocked on the</span></span><br><span class="line"><span class="comment">// transition lock go while we flush caches.</span></span><br><span class="line">semrelease(&amp;work.markDoneSema)</span><br><span class="line"><span class="comment">// 切换到g0执行，本地缓存上传到全局的操作</span></span><br><span class="line">systemstack(<span class="function"><span class="keyword">func</span><span class="params">()</span></span> &#123;</span><br><span class="line"><span class="comment">// Flush all currently cached workbufs and</span></span><br><span class="line"><span class="comment">// ensure all Ps see gcBlackenPromptly. This</span></span><br><span class="line"><span class="comment">// also blocks until any remaining mark 1</span></span><br><span class="line"><span class="comment">// workers have exited their loop so we can</span></span><br><span class="line"><span class="comment">// start new mark 2 workers.</span></span><br><span class="line">forEachP(<span class="function"><span class="keyword">func</span><span class="params">(_p_ *p)</span></span> &#123;</span><br><span class="line">wbBufFlush1(_p_)</span><br><span class="line">_p_.gcw.dispose()</span><br><span class="line">&#125;)</span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line"><span class="comment">// Check that roots are marked. We should be able to</span></span><br><span class="line"><span class="comment">// do this before the forEachP, but based on issue</span></span><br><span class="line"><span class="comment">// #16083 there may be a (harmless) race where we can</span></span><br><span class="line"><span class="comment">// enter mark 2 while some workers are still scanning</span></span><br><span class="line"><span class="comment">// stacks. The forEachP ensures these scans are done.</span></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="comment">// TODO(austin): Figure out the race and fix this</span></span><br><span class="line"><span class="comment">// properly.</span></span><br><span class="line"><span class="comment">// 检查所有的root是否都被标记了</span></span><br><span class="line">gcMarkRootCheck()</span><br><span class="line"></span><br><span class="line"><span class="comment">// Now we can start up mark 2 workers.</span></span><br><span class="line">atomic.Xaddint64(&amp;gcController.dedicatedMarkWorkersNeeded, <span class="number">0xffffffff</span>)</span><br><span class="line">gcController.fractionalUtilizationGoal = prevFractionalGoal</span><br><span class="line"></span><br><span class="line">incnwait := atomic.Xadd(&amp;work.nwait, +<span class="number">1</span>)</span><br><span class="line"><span class="comment">// 如果没有更多的任务，则执行第二次调用，从mark2阶段转换到mark termination阶段</span></span><br><span class="line"><span class="keyword">if</span> incnwait == work.nproc &amp;&amp; !gcMarkWorkAvailable(<span class="literal">nil</span>) &#123;</span><br><span class="line"><span class="comment">// This loop will make progress because</span></span><br><span class="line"><span class="comment">// gcBlackenPromptly is now true, so it won't</span></span><br><span class="line"><span class="comment">// take this same "if" branch.</span></span><br><span class="line"><span class="keyword">goto</span> top</span><br><span class="line">&#125;</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line"><span class="comment">// Transition to mark termination.</span></span><br><span class="line">now := nanotime()</span><br><span class="line">work.tMarkTerm = now</span><br><span class="line">work.pauseStart = now</span><br><span class="line">getg().m.preemptoff = <span class="string">"gcing"</span></span><br><span class="line"><span class="keyword">if</span> trace.enabled &#123;</span><br><span class="line">traceGCSTWStart(<span class="number">0</span>)</span><br><span class="line">&#125;</span><br><span class="line">systemstack(stopTheWorldWithSema)</span><br><span class="line"><span class="comment">// The gcphase is _GCmark, it will transition to _GCmarktermination</span></span><br><span class="line"><span class="comment">// below. The important thing is that the wb remains active until</span></span><br><span class="line"><span class="comment">// all marking is complete. This includes writes made by the GC.</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// Record that one root marking pass has completed.</span></span><br><span class="line">work.markrootDone = <span class="literal">true</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// Disable assists and background workers. We must do</span></span><br><span class="line"><span class="comment">// this before waking blocked assists.</span></span><br><span class="line">atomic.Store(&amp;gcBlackenEnabled, <span class="number">0</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment">// Wake all blocked assists. These will run when we</span></span><br><span class="line"><span class="comment">// start the world again.</span></span><br><span class="line"><span class="comment">// 唤醒所有的辅助GC</span></span><br><span class="line">gcWakeAllAssists()</span><br><span class="line"></span><br><span class="line"><span class="comment">// Likewise, release the transition lock. Blocked</span></span><br><span class="line"><span class="comment">// workers and assists will run when we start the</span></span><br><span class="line"><span class="comment">// world again.</span></span><br><span class="line">semrelease(&amp;work.markDoneSema)</span><br><span class="line"></span><br><span class="line"><span class="comment">// endCycle depends on all gcWork cache stats being</span></span><br><span class="line"><span class="comment">// flushed. This is ensured by mark 2.</span></span><br><span class="line"><span class="comment">// 计算下一次gc出发的阈值</span></span><br><span class="line">nextTriggerRatio := gcController.endCycle()</span><br><span class="line"></span><br><span class="line"><span class="comment">// Perform mark termination. This will restart the world.</span></span><br><span class="line"><span class="comment">// start the world，并进入完成阶段</span></span><br><span class="line">gcMarkTermination(nextTriggerRatio)</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h6 id="gcMarkTermination"><a href="#gcMarkTermination" class="headerlink" title="gcMarkTermination"></a>gcMarkTermination</h6><p>结束标记，并进行清扫等工作</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br><span class="line">184</span><br><span class="line">185</span><br><span class="line">186</span><br><span class="line">187</span><br><span class="line">188</span><br><span class="line">189</span><br><span class="line">190</span><br><span class="line">191</span><br><span class="line">192</span><br><span class="line">193</span><br><span class="line">194</span><br><span class="line">195</span><br><span class="line">196</span><br><span class="line">197</span><br><span class="line">198</span><br><span class="line">199</span><br><span class="line">200</span><br><span class="line">201</span><br><span class="line">202</span><br><span class="line">203</span><br><span class="line">204</span><br><span class="line">205</span><br><span class="line">206</span><br><span class="line">207</span><br><span class="line">208</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">gcMarkTermination</span><span class="params">(nextTriggerRatio <span class="keyword">float64</span>)</span></span> &#123;</span><br><span class="line"><span class="comment">// World is stopped.</span></span><br><span class="line"><span class="comment">// Start marktermination which includes enabling the write barrier.</span></span><br><span class="line">atomic.Store(&amp;gcBlackenEnabled, <span class="number">0</span>)</span><br><span class="line">gcBlackenPromptly = <span class="literal">false</span></span><br><span class="line"><span class="comment">// 设置GC的阶段标识</span></span><br><span class="line">setGCPhase(_GCmarktermination)</span><br><span class="line"></span><br><span class="line">work.heap1 = memstats.heap_live</span><br><span class="line">startTime := nanotime()</span><br><span class="line"></span><br><span class="line">mp := acquirem()</span><br><span class="line">mp.preemptoff = <span class="string">"gcing"</span></span><br><span class="line">_g_ := getg()</span><br><span class="line">_g_.m.traceback = <span class="number">2</span></span><br><span class="line">gp := _g_.m.curg</span><br><span class="line"><span class="comment">// 设置当前g的状态为waiting状态</span></span><br><span class="line">casgstatus(gp, _Grunning, _Gwaiting)</span><br><span class="line">gp.waitreason = waitReasonGarbageCollection</span><br><span class="line"></span><br><span class="line"><span class="comment">// Run gc on the g0 stack. We do this so that the g stack</span></span><br><span class="line"><span class="comment">// we're currently running on will no longer change. Cuts</span></span><br><span class="line"><span class="comment">// the root set down a bit (g0 stacks are not scanned, and</span></span><br><span class="line"><span class="comment">// we don't need to scan gc's internal state).  We also</span></span><br><span class="line"><span class="comment">// need to switch to g0 so we can shrink the stack.</span></span><br><span class="line">systemstack(<span class="function"><span class="keyword">func</span><span class="params">()</span></span> &#123;</span><br><span class="line"><span class="comment">// 通过g0扫描当前g的栈</span></span><br><span class="line">gcMark(startTime)</span><br><span class="line"><span class="comment">// Must return immediately.</span></span><br><span class="line"><span class="comment">// The outer function's stack may have moved</span></span><br><span class="line"><span class="comment">// during gcMark (it shrinks stacks, including the</span></span><br><span class="line"><span class="comment">// outer function's stack), so we must not refer</span></span><br><span class="line"><span class="comment">// to any of its variables. Return back to the</span></span><br><span class="line"><span class="comment">// non-system stack to pick up the new addresses</span></span><br><span class="line"><span class="comment">// before continuing.</span></span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line">systemstack(<span class="function"><span class="keyword">func</span><span class="params">()</span></span> &#123;</span><br><span class="line">work.heap2 = work.bytesMarked</span><br><span class="line"><span class="keyword">if</span> debug.gccheckmark &gt; <span class="number">0</span> &#123;</span><br><span class="line"><span class="comment">// Run a full stop-the-world mark using checkmark bits,</span></span><br><span class="line"><span class="comment">// to check that we didn't forget to mark anything during</span></span><br><span class="line"><span class="comment">// the concurrent mark process.</span></span><br><span class="line"><span class="comment">// 如果启用了gccheckmark，则检查所有可达对象是否都有标记</span></span><br><span class="line">gcResetMarkState()</span><br><span class="line">initCheckmarks()</span><br><span class="line">gcMark(startTime)</span><br><span class="line">clearCheckmarks()</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// marking is complete so we can turn the write barrier off</span></span><br><span class="line"><span class="comment">// 设置gc的阶段标识，GCoff时会关闭写屏障</span></span><br><span class="line">setGCPhase(_GCoff)</span><br><span class="line"><span class="comment">// 开始清扫</span></span><br><span class="line">gcSweep(work.mode)</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> debug.gctrace &gt; <span class="number">1</span> &#123;</span><br><span class="line">startTime = nanotime()</span><br><span class="line"><span class="comment">// The g stacks have been scanned so</span></span><br><span class="line"><span class="comment">// they have gcscanvalid==true and gcworkdone==true.</span></span><br><span class="line"><span class="comment">// Reset these so that all stacks will be rescanned.</span></span><br><span class="line">gcResetMarkState()</span><br><span class="line">finishsweep_m()</span><br><span class="line"></span><br><span class="line"><span class="comment">// Still in STW but gcphase is _GCoff, reset to _GCmarktermination</span></span><br><span class="line"><span class="comment">// At this point all objects will be found during the gcMark which</span></span><br><span class="line"><span class="comment">// does a complete STW mark and object scan.</span></span><br><span class="line">setGCPhase(_GCmarktermination)</span><br><span class="line">gcMark(startTime)</span><br><span class="line">setGCPhase(_GCoff) <span class="comment">// marking is done, turn off wb.</span></span><br><span class="line">gcSweep(work.mode)</span><br><span class="line">&#125;</span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line">_g_.m.traceback = <span class="number">0</span></span><br><span class="line">casgstatus(gp, _Gwaiting, _Grunning)</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> trace.enabled &#123;</span><br><span class="line">traceGCDone()</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// all done</span></span><br><span class="line">mp.preemptoff = <span class="string">""</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> gcphase != _GCoff &#123;</span><br><span class="line">throw(<span class="string">"gc done but gcphase != _GCoff"</span>)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Update GC trigger and pacing for the next cycle.</span></span><br><span class="line"><span class="comment">// 更新下次出发gc的增长比</span></span><br><span class="line">gcSetTriggerRatio(nextTriggerRatio)</span><br><span class="line"></span><br><span class="line"><span class="comment">// Update timing memstats</span></span><br><span class="line"><span class="comment">// 更新用时</span></span><br><span class="line">now := nanotime()</span><br><span class="line">sec, nsec, _ := time_now()</span><br><span class="line">unixNow := sec*<span class="number">1e9</span> + <span class="keyword">int64</span>(nsec)</span><br><span class="line">work.pauseNS += now - work.pauseStart</span><br><span class="line">work.tEnd = now</span><br><span class="line">atomic.Store64(&amp;memstats.last_gc_unix, <span class="keyword">uint64</span>(unixNow)) <span class="comment">// must be Unix time to make sense to user</span></span><br><span class="line">atomic.Store64(&amp;memstats.last_gc_nanotime, <span class="keyword">uint64</span>(now)) <span class="comment">// monotonic time for us</span></span><br><span class="line">memstats.pause_ns[memstats.numgc%<span class="keyword">uint32</span>(<span class="built_in">len</span>(memstats.pause_ns))] = <span class="keyword">uint64</span>(work.pauseNS)</span><br><span class="line">memstats.pause_end[memstats.numgc%<span class="keyword">uint32</span>(<span class="built_in">len</span>(memstats.pause_end))] = <span class="keyword">uint64</span>(unixNow)</span><br><span class="line">memstats.pause_total_ns += <span class="keyword">uint64</span>(work.pauseNS)</span><br><span class="line"></span><br><span class="line"><span class="comment">// Update work.totaltime.</span></span><br><span class="line">sweepTermCpu := <span class="keyword">int64</span>(work.stwprocs) * (work.tMark - work.tSweepTerm)</span><br><span class="line"><span class="comment">// We report idle marking time below, but omit it from the</span></span><br><span class="line"><span class="comment">// overall utilization here since it's "free".</span></span><br><span class="line">markCpu := gcController.assistTime + gcController.dedicatedMarkTime + gcController.fractionalMarkTime</span><br><span class="line">markTermCpu := <span class="keyword">int64</span>(work.stwprocs) * (work.tEnd - work.tMarkTerm)</span><br><span class="line">cycleCpu := sweepTermCpu + markCpu + markTermCpu</span><br><span class="line">work.totaltime += cycleCpu</span><br><span class="line"></span><br><span class="line"><span class="comment">// Compute overall GC CPU utilization.</span></span><br><span class="line">totalCpu := sched.totaltime + (now-sched.procresizetime)*<span class="keyword">int64</span>(gomaxprocs)</span><br><span class="line">memstats.gc_cpu_fraction = <span class="keyword">float64</span>(work.totaltime) / <span class="keyword">float64</span>(totalCpu)</span><br><span class="line"></span><br><span class="line"><span class="comment">// Reset sweep state.</span></span><br><span class="line"><span class="comment">// 重置清扫的状态</span></span><br><span class="line">sweep.nbgsweep = <span class="number">0</span></span><br><span class="line">sweep.npausesweep = <span class="number">0</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 如果是强制开启的gc，标识增加</span></span><br><span class="line"><span class="keyword">if</span> work.userForced &#123;</span><br><span class="line">memstats.numforcedgc++</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Bump GC cycle count and wake goroutines waiting on sweep.</span></span><br><span class="line"><span class="comment">// 统计执行GC的次数然后唤醒等待清扫的G</span></span><br><span class="line">lock(&amp;work.sweepWaiters.lock)</span><br><span class="line">memstats.numgc++</span><br><span class="line">injectglist(work.sweepWaiters.head.ptr())</span><br><span class="line">work.sweepWaiters.head = <span class="number">0</span></span><br><span class="line">unlock(&amp;work.sweepWaiters.lock)</span><br><span class="line"></span><br><span class="line"><span class="comment">// Finish the current heap profiling cycle and start a new</span></span><br><span class="line"><span class="comment">// heap profiling cycle. We do this before starting the world</span></span><br><span class="line"><span class="comment">// so events don't leak into the wrong cycle.</span></span><br><span class="line">mProf_NextCycle()</span><br><span class="line"><span class="comment">// start the world</span></span><br><span class="line">systemstack(<span class="function"><span class="keyword">func</span><span class="params">()</span></span> &#123; startTheWorldWithSema(<span class="literal">true</span>) &#125;)</span><br><span class="line"></span><br><span class="line"><span class="comment">// Flush the heap profile so we can start a new cycle next GC.</span></span><br><span class="line"><span class="comment">// This is relatively expensive, so we don't do it with the</span></span><br><span class="line"><span class="comment">// world stopped.</span></span><br><span class="line">mProf_Flush()</span><br><span class="line"></span><br><span class="line"><span class="comment">// Prepare workbufs for freeing by the sweeper. We do this</span></span><br><span class="line"><span class="comment">// asynchronously because it can take non-trivial time.</span></span><br><span class="line">prepareFreeWorkbufs()</span><br><span class="line"></span><br><span class="line"><span class="comment">// Free stack spans. This must be done between GC cycles.</span></span><br><span class="line">systemstack(freeStackSpans)</span><br><span class="line"></span><br><span class="line"><span class="comment">// Print gctrace before dropping worldsema. As soon as we drop</span></span><br><span class="line"><span class="comment">// worldsema another cycle could start and smash the stats</span></span><br><span class="line"><span class="comment">// we're trying to print.</span></span><br><span class="line"><span class="keyword">if</span> debug.gctrace &gt; <span class="number">0</span> &#123;</span><br><span class="line">util := <span class="keyword">int</span>(memstats.gc_cpu_fraction * <span class="number">100</span>)</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> sbuf [<span class="number">24</span>]<span class="keyword">byte</span></span><br><span class="line">printlock()</span><br><span class="line"><span class="built_in">print</span>(<span class="string">"gc "</span>, memstats.numgc,</span><br><span class="line"><span class="string">" @"</span>, <span class="keyword">string</span>(itoaDiv(sbuf[:], <span class="keyword">uint64</span>(work.tSweepTerm-runtimeInitTime)/<span class="number">1e6</span>, <span class="number">3</span>)), <span class="string">"s "</span>,</span><br><span class="line">util, <span class="string">"%: "</span>)</span><br><span class="line">prev := work.tSweepTerm</span><br><span class="line"><span class="keyword">for</span> i, ns := <span class="keyword">range</span> []<span class="keyword">int64</span>&#123;work.tMark, work.tMarkTerm, work.tEnd&#125; &#123;</span><br><span class="line"><span class="keyword">if</span> i != <span class="number">0</span> &#123;</span><br><span class="line"><span class="built_in">print</span>(<span class="string">"+"</span>)</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">print</span>(<span class="keyword">string</span>(fmtNSAsMS(sbuf[:], <span class="keyword">uint64</span>(ns-prev))))</span><br><span class="line">prev = ns</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">print</span>(<span class="string">" ms clock, "</span>)</span><br><span class="line"><span class="keyword">for</span> i, ns := <span class="keyword">range</span> []<span class="keyword">int64</span>&#123;sweepTermCpu, gcController.assistTime, gcController.dedicatedMarkTime + gcController.fractionalMarkTime, gcController.idleMarkTime, markTermCpu&#125; &#123;</span><br><span class="line"><span class="keyword">if</span> i == <span class="number">2</span> || i == <span class="number">3</span> &#123;</span><br><span class="line"><span class="comment">// Separate mark time components with /.</span></span><br><span class="line"><span class="built_in">print</span>(<span class="string">"/"</span>)</span><br><span class="line">&#125; <span class="keyword">else</span> <span class="keyword">if</span> i != <span class="number">0</span> &#123;</span><br><span class="line"><span class="built_in">print</span>(<span class="string">"+"</span>)</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">print</span>(<span class="keyword">string</span>(fmtNSAsMS(sbuf[:], <span class="keyword">uint64</span>(ns))))</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">print</span>(<span class="string">" ms cpu, "</span>,</span><br><span class="line">work.heap0&gt;&gt;<span class="number">20</span>, <span class="string">"-&gt;"</span>, work.heap1&gt;&gt;<span class="number">20</span>, <span class="string">"-&gt;"</span>, work.heap2&gt;&gt;<span class="number">20</span>, <span class="string">" MB, "</span>,</span><br><span class="line">work.heapGoal&gt;&gt;<span class="number">20</span>, <span class="string">" MB goal, "</span>,</span><br><span class="line">work.maxprocs, <span class="string">" P"</span>)</span><br><span class="line"><span class="keyword">if</span> work.userForced &#123;</span><br><span class="line"><span class="built_in">print</span>(<span class="string">" (forced)"</span>)</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">print</span>(<span class="string">"\n"</span>)</span><br><span class="line">printunlock()</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">semrelease(&amp;worldsema)</span><br><span class="line"><span class="comment">// Careful: another GC cycle may start now.</span></span><br><span class="line"></span><br><span class="line">releasem(mp)</span><br><span class="line">mp = <span class="literal">nil</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// now that gc is done, kick off finalizer thread if needed</span></span><br><span class="line"><span class="comment">// 如果不是并行GC，则让当前M开始调度</span></span><br><span class="line"><span class="keyword">if</span> !concurrentSweep &#123;</span><br><span class="line"><span class="comment">// give the queued finalizers, if any, a chance to run</span></span><br><span class="line">Gosched()</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h6 id="goSweep"><a href="#goSweep" class="headerlink" title="goSweep"></a>goSweep</h6><p>清扫任务</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">gcSweep</span><span class="params">(mode gcMode)</span></span> &#123;</span><br><span class="line"><span class="keyword">if</span> gcphase != _GCoff &#123;</span><br><span class="line">throw(<span class="string">"gcSweep being done but phase is not GCoff"</span>)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">lock(&amp;mheap_.lock)</span><br><span class="line"><span class="comment">// sweepgen在每次GC之后都会增长2，每次GC之后sweepSpans的角色都会互换</span></span><br><span class="line">mheap_.sweepgen += <span class="number">2</span></span><br><span class="line">mheap_.sweepdone = <span class="number">0</span></span><br><span class="line"><span class="keyword">if</span> mheap_.sweepSpans[mheap_.sweepgen/<span class="number">2</span>%<span class="number">2</span>].index != <span class="number">0</span> &#123;</span><br><span class="line"><span class="comment">// We should have drained this list during the last</span></span><br><span class="line"><span class="comment">// sweep phase. We certainly need to start this phase</span></span><br><span class="line"><span class="comment">// with an empty swept list.</span></span><br><span class="line">throw(<span class="string">"non-empty swept list"</span>)</span><br><span class="line">&#125;</span><br><span class="line">mheap_.pagesSwept = <span class="number">0</span></span><br><span class="line">unlock(&amp;mheap_.lock)</span><br><span class="line"><span class="comment">// 如果不是并行GC，或者强制GC</span></span><br><span class="line"><span class="keyword">if</span> !_ConcurrentSweep || mode == gcForceBlockMode &#123;</span><br><span class="line"><span class="comment">// Special case synchronous sweep.</span></span><br><span class="line"><span class="comment">// Record that no proportional sweeping has to happen.</span></span><br><span class="line">lock(&amp;mheap_.lock)</span><br><span class="line">mheap_.sweepPagesPerByte = <span class="number">0</span></span><br><span class="line">unlock(&amp;mheap_.lock)</span><br><span class="line"><span class="comment">// Sweep all spans eagerly.</span></span><br><span class="line"><span class="comment">// 清扫所有的span</span></span><br><span class="line"><span class="keyword">for</span> sweepone() != ^<span class="keyword">uintptr</span>(<span class="number">0</span>) &#123;</span><br><span class="line">sweep.npausesweep++</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// Free workbufs eagerly.</span></span><br><span class="line"><span class="comment">// 释放所有的 workbufs</span></span><br><span class="line">prepareFreeWorkbufs()</span><br><span class="line"><span class="keyword">for</span> freeSomeWbufs(<span class="literal">false</span>) &#123;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// All "free" events for this mark/sweep cycle have</span></span><br><span class="line"><span class="comment">// now happened, so we can make this profile cycle</span></span><br><span class="line"><span class="comment">// available immediately.</span></span><br><span class="line">mProf_NextCycle()</span><br><span class="line">mProf_Flush()</span><br><span class="line"><span class="keyword">return</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Background sweep.</span></span><br><span class="line">lock(&amp;sweep.lock)</span><br><span class="line"><span class="comment">// 唤醒后台清扫任务,也就是 bgsweep 函数，清扫流程跟上面非并行清扫差不多</span></span><br><span class="line"><span class="keyword">if</span> sweep.parked &#123;</span><br><span class="line">sweep.parked = <span class="literal">false</span></span><br><span class="line">ready(sweep.g, <span class="number">0</span>, <span class="literal">true</span>)</span><br><span class="line">&#125;</span><br><span class="line">unlock(&amp;sweep.lock)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h6 id="sweepone"><a href="#sweepone" class="headerlink" title="sweepone"></a>sweepone</h6><p>接下来我们就分析一下sweepone 清扫的流程</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">sweepone</span><span class="params">()</span> <span class="title">uintptr</span></span> &#123;</span><br><span class="line">_g_ := getg()</span><br><span class="line">sweepRatio := mheap_.sweepPagesPerByte <span class="comment">// For debugging</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// increment locks to ensure that the goroutine is not preempted</span></span><br><span class="line"><span class="comment">// in the middle of sweep thus leaving the span in an inconsistent state for next GC</span></span><br><span class="line">_g_.m.locks++</span><br><span class="line"><span class="comment">// 检查是否已经完成了清扫</span></span><br><span class="line"><span class="keyword">if</span> atomic.Load(&amp;mheap_.sweepdone) != <span class="number">0</span> &#123;</span><br><span class="line">_g_.m.locks--</span><br><span class="line"><span class="keyword">return</span> ^<span class="keyword">uintptr</span>(<span class="number">0</span>)</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 增加清扫的worker数量</span></span><br><span class="line">atomic.Xadd(&amp;mheap_.sweepers, +<span class="number">1</span>)</span><br><span class="line"></span><br><span class="line">npages := ^<span class="keyword">uintptr</span>(<span class="number">0</span>)</span><br><span class="line">sg := mheap_.sweepgen</span><br><span class="line"><span class="keyword">for</span> &#123;</span><br><span class="line"><span class="comment">// 循环获取需要清扫的span</span></span><br><span class="line">s := mheap_.sweepSpans[<span class="number">1</span>-sg/<span class="number">2</span>%<span class="number">2</span>].pop()</span><br><span class="line"><span class="keyword">if</span> s == <span class="literal">nil</span> &#123;</span><br><span class="line">atomic.Store(&amp;mheap_.sweepdone, <span class="number">1</span>)</span><br><span class="line"><span class="keyword">break</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span> s.state != mSpanInUse &#123;</span><br><span class="line"><span class="comment">// This can happen if direct sweeping already</span></span><br><span class="line"><span class="comment">// swept this span, but in that case the sweep</span></span><br><span class="line"><span class="comment">// generation should always be up-to-date.</span></span><br><span class="line"><span class="keyword">if</span> s.sweepgen != sg &#123;</span><br><span class="line"><span class="built_in">print</span>(<span class="string">"runtime: bad span s.state="</span>, s.state, <span class="string">" s.sweepgen="</span>, s.sweepgen, <span class="string">" sweepgen="</span>, sg, <span class="string">"\n"</span>)</span><br><span class="line">throw(<span class="string">"non in-use span in unswept list"</span>)</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">continue</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// sweepgen == h-&gt;sweepgen - 2, 表示这个span需要清扫</span></span><br><span class="line"><span class="comment">// sweepgen == h-&gt;sweepgen - 1, 表示这个span正在被清扫</span></span><br><span class="line"><span class="comment">// 这是里确定span的状态及尝试转换span的状态</span></span><br><span class="line"><span class="keyword">if</span> s.sweepgen != sg<span class="number">-2</span> || !atomic.Cas(&amp;s.sweepgen, sg<span class="number">-2</span>, sg<span class="number">-1</span>) &#123;</span><br><span class="line"><span class="keyword">continue</span></span><br><span class="line">&#125;</span><br><span class="line">npages = s.npages</span><br><span class="line"><span class="comment">// 单个span的清扫</span></span><br><span class="line"><span class="keyword">if</span> !s.sweep(<span class="literal">false</span>) &#123;</span><br><span class="line"><span class="comment">// Span is still in-use, so this returned no</span></span><br><span class="line"><span class="comment">// pages to the heap and the span needs to</span></span><br><span class="line"><span class="comment">// move to the swept in-use list.</span></span><br><span class="line">npages = <span class="number">0</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">break</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Decrement the number of active sweepers and if this is the</span></span><br><span class="line"><span class="comment">// last one print trace information.</span></span><br><span class="line"><span class="comment">// 当前worker清扫任务完成，更新sweepers的数量</span></span><br><span class="line"><span class="keyword">if</span> atomic.Xadd(&amp;mheap_.sweepers, <span class="number">-1</span>) == <span class="number">0</span> &amp;&amp; atomic.Load(&amp;mheap_.sweepdone) != <span class="number">0</span> &#123;</span><br><span class="line"><span class="keyword">if</span> debug.gcpacertrace &gt; <span class="number">0</span> &#123;</span><br><span class="line"><span class="built_in">print</span>(<span class="string">"pacer: sweep done at heap size "</span>, memstats.heap_live&gt;&gt;<span class="number">20</span>, <span class="string">"MB; allocated "</span>, (memstats.heap_live-mheap_.sweepHeapLiveBasis)&gt;&gt;<span class="number">20</span>, <span class="string">"MB during sweep; swept "</span>, mheap_.pagesSwept, <span class="string">" pages at "</span>, sweepRatio, <span class="string">" pages/byte\n"</span>)</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">_g_.m.locks--</span><br><span class="line"><span class="keyword">return</span> npages</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h6 id="mspan-sweep"><a href="#mspan-sweep" class="headerlink" title="mspan.sweep"></a>mspan.sweep</h6><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br><span class="line">184</span><br><span class="line">185</span><br><span class="line">186</span><br><span class="line">187</span><br><span class="line">188</span><br><span class="line">189</span><br><span class="line">190</span><br><span class="line">191</span><br><span class="line">192</span><br><span class="line">193</span><br><span class="line">194</span><br><span class="line">195</span><br><span class="line">196</span><br><span class="line">197</span><br><span class="line">198</span><br><span class="line">199</span><br><span class="line">200</span><br><span class="line">201</span><br><span class="line">202</span><br><span class="line">203</span><br><span class="line">204</span><br><span class="line">205</span><br><span class="line">206</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(s *mspan)</span> <span class="title">sweep</span><span class="params">(preserve <span class="keyword">bool</span>)</span> <span class="title">bool</span></span> &#123;</span><br><span class="line"><span class="comment">// It's critical that we enter this function with preemption disabled,</span></span><br><span class="line"><span class="comment">// GC must not start while we are in the middle of this function.</span></span><br><span class="line">_g_ := getg()</span><br><span class="line"><span class="keyword">if</span> _g_.m.locks == <span class="number">0</span> &amp;&amp; _g_.m.mallocing == <span class="number">0</span> &amp;&amp; _g_ != _g_.m.g0 &#123;</span><br><span class="line">throw(<span class="string">"MSpan_Sweep: m is not locked"</span>)</span><br><span class="line">&#125;</span><br><span class="line">sweepgen := mheap_.sweepgen</span><br><span class="line"><span class="comment">// 只有正在清扫中状态的span才可以正常执行</span></span><br><span class="line"><span class="keyword">if</span> s.state != mSpanInUse || s.sweepgen != sweepgen<span class="number">-1</span> &#123;</span><br><span class="line"><span class="built_in">print</span>(<span class="string">"MSpan_Sweep: state="</span>, s.state, <span class="string">" sweepgen="</span>, s.sweepgen, <span class="string">" mheap.sweepgen="</span>, sweepgen, <span class="string">"\n"</span>)</span><br><span class="line">throw(<span class="string">"MSpan_Sweep: bad span state"</span>)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> trace.enabled &#123;</span><br><span class="line">traceGCSweepSpan(s.npages * _PageSize)</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 先更新清扫的page数</span></span><br><span class="line">atomic.Xadd64(&amp;mheap_.pagesSwept, <span class="keyword">int64</span>(s.npages))</span><br><span class="line"></span><br><span class="line">spc := s.spanclass</span><br><span class="line">size := s.elemsize</span><br><span class="line">res := <span class="literal">false</span></span><br><span class="line"></span><br><span class="line">c := _g_.m.mcache</span><br><span class="line">freeToHeap := <span class="literal">false</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// The allocBits indicate which unmarked objects don't need to be</span></span><br><span class="line"><span class="comment">// processed since they were free at the end of the last GC cycle</span></span><br><span class="line"><span class="comment">// and were not allocated since then.</span></span><br><span class="line"><span class="comment">// If the allocBits index is &gt;= s.freeindex and the bit</span></span><br><span class="line"><span class="comment">// is not marked then the object remains unallocated</span></span><br><span class="line"><span class="comment">// since the last GC.</span></span><br><span class="line"><span class="comment">// This situation is analogous to being on a freelist.</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// Unlink &amp; free special records for any objects we're about to free.</span></span><br><span class="line"><span class="comment">// Two complications here:</span></span><br><span class="line"><span class="comment">// 1. An object can have both finalizer and profile special records.</span></span><br><span class="line"><span class="comment">//    In such case we need to queue finalizer for execution,</span></span><br><span class="line"><span class="comment">//    mark the object as live and preserve the profile special.</span></span><br><span class="line"><span class="comment">// 2. A tiny object can have several finalizers setup for different offsets.</span></span><br><span class="line"><span class="comment">//    If such object is not marked, we need to queue all finalizers at once.</span></span><br><span class="line"><span class="comment">// Both 1 and 2 are possible at the same time.</span></span><br><span class="line">specialp := &amp;s.specials</span><br><span class="line">special := *specialp</span><br><span class="line"><span class="comment">// 判断在special中的对象是否存活，是否至少有一个finalizer，释放没有finalizer的对象，把有finalizer的对象组成队列</span></span><br><span class="line"><span class="keyword">for</span> special != <span class="literal">nil</span> &#123;</span><br><span class="line"><span class="comment">// A finalizer can be set for an inner byte of an object, find object beginning.</span></span><br><span class="line">objIndex := <span class="keyword">uintptr</span>(special.offset) / size</span><br><span class="line">p := s.base() + objIndex*size</span><br><span class="line">mbits := s.markBitsForIndex(objIndex)</span><br><span class="line"><span class="keyword">if</span> !mbits.isMarked() &#123;</span><br><span class="line"><span class="comment">// This object is not marked and has at least one special record.</span></span><br><span class="line"><span class="comment">// Pass 1: see if it has at least one finalizer.</span></span><br><span class="line">hasFin := <span class="literal">false</span></span><br><span class="line">endOffset := p - s.base() + size</span><br><span class="line"><span class="keyword">for</span> tmp := special; tmp != <span class="literal">nil</span> &amp;&amp; <span class="keyword">uintptr</span>(tmp.offset) &lt; endOffset; tmp = tmp.next &#123;</span><br><span class="line"><span class="keyword">if</span> tmp.kind == _KindSpecialFinalizer &#123;</span><br><span class="line"><span class="comment">// Stop freeing of object if it has a finalizer.</span></span><br><span class="line">mbits.setMarkedNonAtomic()</span><br><span class="line">hasFin = <span class="literal">true</span></span><br><span class="line"><span class="keyword">break</span></span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// Pass 2: queue all finalizers _or_ handle profile record.</span></span><br><span class="line"><span class="keyword">for</span> special != <span class="literal">nil</span> &amp;&amp; <span class="keyword">uintptr</span>(special.offset) &lt; endOffset &#123;</span><br><span class="line"><span class="comment">// Find the exact byte for which the special was setup</span></span><br><span class="line"><span class="comment">// (as opposed to object beginning).</span></span><br><span class="line">p := s.base() + <span class="keyword">uintptr</span>(special.offset)</span><br><span class="line"><span class="keyword">if</span> special.kind == _KindSpecialFinalizer || !hasFin &#123;</span><br><span class="line"><span class="comment">// Splice out special record.</span></span><br><span class="line">y := special</span><br><span class="line">special = special.next</span><br><span class="line">*specialp = special</span><br><span class="line">freespecial(y, unsafe.Pointer(p), size)</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line"><span class="comment">// This is profile record, but the object has finalizers (so kept alive).</span></span><br><span class="line"><span class="comment">// Keep special record.</span></span><br><span class="line">specialp = &amp;special.next</span><br><span class="line">special = *specialp</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line"><span class="comment">// object is still live: keep special record</span></span><br><span class="line">specialp = &amp;special.next</span><br><span class="line">special = *specialp</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> debug.allocfreetrace != <span class="number">0</span> || raceenabled || msanenabled &#123;</span><br><span class="line"><span class="comment">// Find all newly freed objects. This doesn't have to</span></span><br><span class="line"><span class="comment">// efficient; allocfreetrace has massive overhead.</span></span><br><span class="line">mbits := s.markBitsForBase()</span><br><span class="line">abits := s.allocBitsForIndex(<span class="number">0</span>)</span><br><span class="line"><span class="keyword">for</span> i := <span class="keyword">uintptr</span>(<span class="number">0</span>); i &lt; s.nelems; i++ &#123;</span><br><span class="line"><span class="keyword">if</span> !mbits.isMarked() &amp;&amp; (abits.index &lt; s.freeindex || abits.isMarked()) &#123;</span><br><span class="line">x := s.base() + i*s.elemsize</span><br><span class="line"><span class="keyword">if</span> debug.allocfreetrace != <span class="number">0</span> &#123;</span><br><span class="line">tracefree(unsafe.Pointer(x), size)</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span> raceenabled &#123;</span><br><span class="line">racefree(unsafe.Pointer(x), size)</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span> msanenabled &#123;</span><br><span class="line">msanfree(unsafe.Pointer(x), size)</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">mbits.advance()</span><br><span class="line">abits.advance()</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Count the number of free objects in this span.</span></span><br><span class="line"><span class="comment">// 获取需要释放的alloc对象的总数</span></span><br><span class="line">nalloc := <span class="keyword">uint16</span>(s.countAlloc())</span><br><span class="line"><span class="comment">// 如果sizeclass为0，却分配的总数量为0，则释放到mheap</span></span><br><span class="line"><span class="keyword">if</span> spc.sizeclass() == <span class="number">0</span> &amp;&amp; nalloc == <span class="number">0</span> &#123;</span><br><span class="line">s.needzero = <span class="number">1</span></span><br><span class="line">freeToHeap = <span class="literal">true</span></span><br><span class="line">&#125;</span><br><span class="line">nfreed := s.allocCount - nalloc</span><br><span class="line"><span class="keyword">if</span> nalloc &gt; s.allocCount &#123;</span><br><span class="line"><span class="built_in">print</span>(<span class="string">"runtime: nelems="</span>, s.nelems, <span class="string">" nalloc="</span>, nalloc, <span class="string">" previous allocCount="</span>, s.allocCount, <span class="string">" nfreed="</span>, nfreed, <span class="string">"\n"</span>)</span><br><span class="line">throw(<span class="string">"sweep increased allocation count"</span>)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">s.allocCount = nalloc</span><br><span class="line"><span class="comment">// 判断span是否empty</span></span><br><span class="line">wasempty := s.nextFreeIndex() == s.nelems</span><br><span class="line"><span class="comment">// 重置freeindex</span></span><br><span class="line">s.freeindex = <span class="number">0</span> <span class="comment">// reset allocation index to start of span.</span></span><br><span class="line"><span class="keyword">if</span> trace.enabled &#123;</span><br><span class="line">getg().m.p.ptr().traceReclaimed += <span class="keyword">uintptr</span>(nfreed) * s.elemsize</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// gcmarkBits becomes the allocBits.</span></span><br><span class="line"><span class="comment">// get a fresh cleared gcmarkBits in preparation for next GC</span></span><br><span class="line"><span class="comment">// 重置 allocBits为 gcMarkBits</span></span><br><span class="line">s.allocBits = s.gcmarkBits</span><br><span class="line"><span class="comment">// 重置 gcMarkBits</span></span><br><span class="line">s.gcmarkBits = newMarkBits(s.nelems)</span><br><span class="line"></span><br><span class="line"><span class="comment">// Initialize alloc bits cache.</span></span><br><span class="line"><span class="comment">// 更新allocCache</span></span><br><span class="line">s.refillAllocCache(<span class="number">0</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment">// We need to set s.sweepgen = h.sweepgen only when all blocks are swept,</span></span><br><span class="line"><span class="comment">// because of the potential for a concurrent free/SetFinalizer.</span></span><br><span class="line"><span class="comment">// But we need to set it before we make the span available for allocation</span></span><br><span class="line"><span class="comment">// (return it to heap or mcentral), because allocation code assumes that a</span></span><br><span class="line"><span class="comment">// span is already swept if available for allocation.</span></span><br><span class="line"><span class="keyword">if</span> freeToHeap || nfreed == <span class="number">0</span> &#123;</span><br><span class="line"><span class="comment">// The span must be in our exclusive ownership until we update sweepgen,</span></span><br><span class="line"><span class="comment">// check for potential races.</span></span><br><span class="line"><span class="keyword">if</span> s.state != mSpanInUse || s.sweepgen != sweepgen<span class="number">-1</span> &#123;</span><br><span class="line"><span class="built_in">print</span>(<span class="string">"MSpan_Sweep: state="</span>, s.state, <span class="string">" sweepgen="</span>, s.sweepgen, <span class="string">" mheap.sweepgen="</span>, sweepgen, <span class="string">"\n"</span>)</span><br><span class="line">throw(<span class="string">"MSpan_Sweep: bad span state after sweep"</span>)</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// Serialization point.</span></span><br><span class="line"><span class="comment">// At this point the mark bits are cleared and allocation ready</span></span><br><span class="line"><span class="comment">// to go so release the span.</span></span><br><span class="line">atomic.Store(&amp;s.sweepgen, sweepgen)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> nfreed &gt; <span class="number">0</span> &amp;&amp; spc.sizeclass() != <span class="number">0</span> &#123;</span><br><span class="line">c.local_nsmallfree[spc.sizeclass()] += <span class="keyword">uintptr</span>(nfreed)</span><br><span class="line"><span class="comment">// 把span释放到mcentral上</span></span><br><span class="line">res = mheap_.central[spc].mcentral.freeSpan(s, preserve, wasempty)</span><br><span class="line"><span class="comment">// MCentral_FreeSpan updates sweepgen</span></span><br><span class="line">&#125; <span class="keyword">else</span> <span class="keyword">if</span> freeToHeap &#123;</span><br><span class="line"><span class="comment">// 这里是大对象的span释放，与117行呼应</span></span><br><span class="line"><span class="comment">// Free large span to heap</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// NOTE(rsc,dvyukov): The original implementation of efence</span></span><br><span class="line"><span class="comment">// in CL 22060046 used SysFree instead of SysFault, so that</span></span><br><span class="line"><span class="comment">// the operating system would eventually give the memory</span></span><br><span class="line"><span class="comment">// back to us again, so that an efence program could run</span></span><br><span class="line"><span class="comment">// longer without running out of memory. Unfortunately,</span></span><br><span class="line"><span class="comment">// calling SysFree here without any kind of adjustment of the</span></span><br><span class="line"><span class="comment">// heap data structures means that when the memory does</span></span><br><span class="line"><span class="comment">// come back to us, we have the wrong metadata for it, either in</span></span><br><span class="line"><span class="comment">// the MSpan structures or in the garbage collection bitmap.</span></span><br><span class="line"><span class="comment">// Using SysFault here means that the program will run out of</span></span><br><span class="line"><span class="comment">// memory fairly quickly in efence mode, but at least it won't</span></span><br><span class="line"><span class="comment">// have mysterious crashes due to confused memory reuse.</span></span><br><span class="line"><span class="comment">// It should be possible to switch back to SysFree if we also</span></span><br><span class="line"><span class="comment">// implement and then call some kind of MHeap_DeleteSpan.</span></span><br><span class="line"><span class="keyword">if</span> debug.efence &gt; <span class="number">0</span> &#123;</span><br><span class="line">s.limit = <span class="number">0</span> <span class="comment">// prevent mlookup from finding this span</span></span><br><span class="line">sysFault(unsafe.Pointer(s.base()), size)</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line"><span class="comment">// 把sapn释放到mheap上</span></span><br><span class="line">mheap_.freeSpan(s, <span class="number">1</span>)</span><br><span class="line">&#125;</span><br><span class="line">c.local_nlargefree++</span><br><span class="line">c.local_largefree += size</span><br><span class="line">res = <span class="literal">true</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span> !res &#123;</span><br><span class="line"><span class="comment">// The span has been swept and is still in-use, so put</span></span><br><span class="line"><span class="comment">// it on the swept in-use list.</span></span><br><span class="line"><span class="comment">// 如果span未释放到mcentral或mheap，表示span仍然处于in-use状态</span></span><br><span class="line">mheap_.sweepSpans[sweepgen/<span class="number">2</span>%<span class="number">2</span>].push(s)</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> res</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>ok，至此Go的GC流程已经分析完成了，结合最上面开始的图，可能会容易理解一点</p><h1 id="参考文档"><a href="#参考文档" class="headerlink" title="参考文档"></a>参考文档</h1><ol><li><a href="https://www.cnblogs.com/zkweb/p/7880099.html" target="_blank" rel="noopener">Golang源码探索(三) GC的实现原理</a></li><li>《Go语言学习笔记》</li><li><a href="http://idiotsky.top/2017/08/16/gc-three-color/" target="_blank" rel="noopener">一张图了解三色标记法</a></li></ol>]]></content>
      
      
      <categories>
          
          <category> Go </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Go </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>基于Nginx和dnsmasq实现路由的动态DNS解析</title>
      <link href="/posts/8255/"/>
      <url>/posts/8255/</url>
      
        <content type="html"><![CDATA[<p>近期在跟前端同学联调的时候，出现了一点小插曲，我们两个的项目是同一个域名，然而，他的本地没有搭服务端的运行环境，所以就导致了前端需要的hosts文件和请求接口需要的hosts文件不一致的情况，基于这种情况，我就考虑是否可以通过nginx来匹配不同的路由，将请求打到不同的机器上面？</p><a id="more"></a><p>我们都知道 nginx可以通过 <code>resolver</code> 命令来设置域名的DNS解析服务器，所以，如果路由是前端路由，就请求 自身的DNS服务器，将域名解析到本机，如果是接口，就通过我的DNS服务器或者正常的DNS服务器解析到其他的地址</p><p>按照上面的思路，我们就需要在本机搭建一个DNS服务器，这里我选用了 <code>dnsmasq</code>，没有什么理由，就是网上资料多🤪</p><h1 id="dnsmasq"><a href="#dnsmasq" class="headerlink" title="dnsmasq"></a>dnsmasq</h1><h2 id="安装"><a href="#安装" class="headerlink" title="安装"></a>安装</h2><p>通过 <code>brew</code> 安装即可</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">brew install dnsmasq</span><br></pre></td></tr></table></figure><h2 id="配置"><a href="#配置" class="headerlink" title="配置"></a>配置</h2><h3 id="配置dnsmasq"><a href="#配置dnsmasq" class="headerlink" title="配置dnsmasq"></a>配置dnsmasq</h3><p>配置文件在 <code>/usr/local/etc/dnsmasq.conf</code></p><ol><li>设置 <code>listen-address</code>: listen-address=127.0.0.1 或者其他需要监听的内网或公网ip地址</li><li>取消注释 <code>strict-order</code></li><li>如果不想使用 <code>/etc/hosts</code> 和 <code>/etc/resolve.conf</code> 可以修改如下<ol><li>配置 <code>resolv-file</code>: resolv-file=/etc/resolv.dnsmasq.conf 文件名字随意</li><li>配置 <code>addn-hosts</code>: addn-hosts=/etc/dnsmasq.hosts 文件名字随意</li></ol></li></ol><h3 id="配置resolv"><a href="#配置resolv" class="headerlink" title="配置resolv"></a>配置resolv</h3><p>这里的resolv指的是 上面配置中 <code>resolv-file</code> 所对应的文件</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">nameserver 127.0.0.1 # 放在第一位，会首先去这个地址请求dns解析</span><br><span class="line">nameserver 114.114.114.114</span><br></pre></td></tr></table></figure><h3 id="配置hosts"><a href="#配置hosts" class="headerlink" title="配置hosts"></a>配置hosts</h3><p>把 需要解析的域名 添加进去即可，例</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">127.0.0.1 test.tyloafer.cn</span><br></pre></td></tr></table></figure><h2 id="启停控制"><a href="#启停控制" class="headerlink" title="启停控制"></a>启停控制</h2><ul><li>启动： brew services start dnsmasq</li><li>停止： brew services stop dnsmasq</li><li>重启： brew services restart dnsmasq</li></ul><h1 id="Nginx"><a href="#Nginx" class="headerlink" title="Nginx"></a>Nginx</h1><figure class="highlight nginx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="section">server</span> &#123;</span><br><span class="line">    <span class="attribute">listen</span>       <span class="number">80</span>;</span><br><span class="line">    <span class="attribute">server_name</span>  test.tyloafer.cn;</span><br><span class="line">    <span class="attribute">root</span> html;</span><br><span class="line">    <span class="attribute">add_header</span> Content-Type <span class="string">'text/html; charset=utf-8'</span>;</span><br><span class="line">    <span class="attribute">location</span> <span class="regexp">~ /local</span> &#123;</span><br><span class="line">        <span class="attribute">resolver</span> <span class="number">127.0.0.1</span> ipv6=<span class="literal">off</span>;</span><br><span class="line">        <span class="attribute">proxy_pass</span> http://test.tyloafer.cn/1.html<span class="variable">$is_args</span><span class="variable">$args</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="attribute">location</span> <span class="regexp">~ /remote</span> &#123;</span><br><span class="line">        <span class="attribute">resolver</span> <span class="number">114.114.114.114</span>;</span><br><span class="line">        <span class="attribute">proxy_pass</span> http://test.tyloafer.cn/1.html<span class="variable">$is_args</span><span class="variable">$args</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="attribute">location</span> <span class="regexp">~ /1.html</span> &#123;</span><br><span class="line">        <span class="attribute">add_header</span> Content-Type <span class="string">'text/html; charset=utf-8'</span>;</span><br><span class="line">        <span class="attribute">return</span> <span class="number">200</span> <span class="string">"ok"</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>请求流程分析：</p><blockquote><p><a href="http://test.tyloafer.cn/local" target="_blank" rel="noopener">http://test.tyloafer.cn/local</a></p></blockquote><ol><li>首先 根据本机的dns解析，会解析到127.0.0.1，也就是本机</li><li>然后 nginx接收到这个请求，会匹配到 <code>location ~ /local</code> 这条规则，然后 调用127.0.0.1 的DNS服务器，也就是上面搭建的，将请求转发到本机的 <code>/1.html</code> 路由下</li><li>nginx收到 proxy_pass的请求，匹配到 <code>location ~ /1.html</code> ，然后输出 “ok”</li></ol><blockquote><p><a href="http://test.tyloafer.cn/remote" target="_blank" rel="noopener">http://test.tyloafer.cn/remote</a></p></blockquote><ol><li>首先 根据本机的dns解析，会解析到127.0.0.1，也就是本机</li><li>然后 nginx接收到这个请求，会匹配到 <code>location ~ /remote</code> 这条规则，然后 调用114.114.114.114 的DNS服务器，这里会进行正常的DNS解析，找到真实的服务器地址</li><li>目标服务器的nginx收到 proxy_pass的请求，进行相应的处理（1.html 在我的目标服务器上没有，所以会返回404）</li></ol>]]></content>
      
      
      <categories>
          
          <category> Nginx </category>
          
          <category> DNS </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Nginx </tag>
            
            <tag> DNS </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Go Http包解析：为什么需要response.Body.Close()</title>
      <link href="/posts/33256/"/>
      <url>/posts/33256/</url>
      
        <content type="html"><![CDATA[<p>最近线上的一个项目遇到了内存泄露的问题，查了heap之后，发现 http包的 dialConn函数竟然占了内存使用的大头，这个有点懵逼了，后面在网上查询资料的时候无意间发现一句话</p><blockquote><p>10次内存泄露，有9次是goroutine泄露。</p></blockquote><p>结果发现，正是我认为的不可能的goroutine泄露导致了这次的内存泄露，而goroutine泄露的原因就是 没有调用 <code>response.Body.Close()</code></p><a id="more"></a><h1 id="实验"><a href="#实验" class="headerlink" title="实验"></a>实验</h1><p>既然发现是 <code>response.Body.Close()</code> 惹的祸，那就做个实验证实一下</p><h2 id="不close-response-Body"><a href="#不close-response-Body" class="headerlink" title="不close response.Body"></a>不close response.Body</h2><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line"><span class="keyword">for</span> <span class="literal">true</span> &#123;</span><br><span class="line">requestWithNoClose()</span><br><span class="line">time.Sleep(time.Microsecond * <span class="number">100</span>)</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">requestWithNoClose</span><span class="params">()</span></span> &#123;</span><br><span class="line">_, err := http.Get(<span class="string">"https://www.baidu.com"</span>)</span><br><span class="line"><span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">fmt.Printf(<span class="string">"error occurred while fetching page, error: %s"</span>, err.Error())</span><br><span class="line">&#125;</span><br><span class="line">fmt.Println(<span class="string">"ok"</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>##close response.Body</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line"><span class="keyword">for</span> <span class="literal">true</span> &#123;</span><br><span class="line">requestWithClose()</span><br><span class="line">time.Sleep(time.Microsecond * <span class="number">10</span>)</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">requestWithClose</span><span class="params">()</span></span> &#123;</span><br><span class="line">resp, err := http.Get(<span class="string">"https://www.baidu.com"</span>)</span><br><span class="line"><span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">fmt.Printf(<span class="string">"error occurred while fetching page, error: %s"</span>, err.Error())</span><br><span class="line"><span class="keyword">return</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">defer</span> resp.Body.Close()</span><br><span class="line">fmt.Println(<span class="string">"ok"</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="结果"><a href="#结果" class="headerlink" title="结果"></a>结果</h2><p>同样的代码，区别只有 是否<code>resp.Body.Close()</code> 是否被调用，我们运行一段时间后，发现内存差距如此之大</p><p><img src="http://note-1253518569.cossh.myqcloud.com/20190712195959.png" alt></p><p>后面，我们就带着问题，深入一下Http包的底层实现来找出具体原因</p><h1 id="结构体"><a href="#结构体" class="headerlink" title="结构体"></a>结构体</h1><p>只分析我们可能用会用到的</p><h2 id="Transport"><a href="#Transport" class="headerlink" title="Transport"></a>Transport</h2><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> Transport <span class="keyword">struct</span> &#123;</span><br><span class="line">idleMu     sync.Mutex</span><br><span class="line">wantIdle   <span class="keyword">bool</span>                                <span class="comment">// user has requested to close all idle conns</span></span><br><span class="line">  <span class="comment">// 空闲的连接 缓存的地方</span></span><br><span class="line">idleConn   <span class="keyword">map</span>[connectMethodKey][]*persistConn <span class="comment">// most recently used at end</span></span><br><span class="line">  <span class="comment">// connectMethodKey =&gt; 空闲连接的chan 形成的map</span></span><br><span class="line">  <span class="comment">// 有空闲连接放入的时候，首先尝试放入这个chan，方便另一个可能需要连接的goroutine直接使用，如果没有goroutine需要连接，就放入到上面的idleConn里面，便于后面的请求连接复用</span></span><br><span class="line">idleConnCh <span class="keyword">map</span>[connectMethodKey]<span class="keyword">chan</span> *persistConn</span><br><span class="line"><span class="comment">// DisableKeepAlives, if true, disables HTTP keep-alives and</span></span><br><span class="line"><span class="comment">// will only use the connection to the server for a single</span></span><br><span class="line"><span class="comment">// HTTP request.</span></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="comment">// This is unrelated to the similarly named TCP keep-alives.</span></span><br><span class="line">  <span class="comment">// 是否开启 keepAlive，为true的话，连接不会被复用</span></span><br><span class="line">DisableKeepAlives <span class="keyword">bool</span></span><br><span class="line"><span class="comment">// MaxIdleConns controls the maximum number of idle (keep-alive)</span></span><br><span class="line"><span class="comment">// connections across all hosts. Zero means no limit.</span></span><br><span class="line">  <span class="comment">// 所有hosts对应的最大的连接总数</span></span><br><span class="line">MaxIdleConns <span class="keyword">int</span></span><br><span class="line">  <span class="comment">// 每一个host对应的最大的空闲连接数</span></span><br><span class="line">MaxIdleConnsPerHost <span class="keyword">int</span></span><br><span class="line">  <span class="comment">// 每一个host对应的最大连接数</span></span><br><span class="line">MaxConnsPerHost <span class="keyword">int</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="pconnect"><a href="#pconnect" class="headerlink" title="pconnect"></a>pconnect</h2><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> persistConn <span class="keyword">struct</span> &#123;</span><br><span class="line">   <span class="comment">// alt optionally specifies the TLS NextProto RoundTripper.</span></span><br><span class="line">   <span class="comment">// This is used for HTTP/2 today and future protocols later.</span></span><br><span class="line">   <span class="comment">// If it's non-nil, the rest of the fields are unused.</span></span><br><span class="line">   alt RoundTripper</span><br><span class="line"></span><br><span class="line">   t         *Transport</span><br><span class="line">   cacheKey  connectMethodKey</span><br><span class="line">   conn      net.Conn</span><br><span class="line">   tlsState  *tls.ConnectionState</span><br><span class="line">   br        *bufio.Reader       <span class="comment">// from conn</span></span><br><span class="line">   bw        *bufio.Writer       <span class="comment">// to conn</span></span><br><span class="line">   nwrite    <span class="keyword">int64</span>               <span class="comment">// bytes written</span></span><br><span class="line">   <span class="comment">// roundTrip 往 这个chan 里写入request，readLoop从这个 chan 读取request</span></span><br><span class="line">   reqch     <span class="keyword">chan</span> requestAndChan <span class="comment">// written by roundTrip; read by readLoop</span></span><br><span class="line">   <span class="comment">// roundTrip 往 这个chan 里写入request 和 writeErrCh，writeLoop从这个 chan 读取request写入大盘 连接 里，并写入 err 到 writeErrCh chan</span></span><br><span class="line">   writech   <span class="keyword">chan</span> writeRequest   <span class="comment">// written by roundTrip; read by writeLoop</span></span><br><span class="line">   closech   <span class="keyword">chan</span> <span class="keyword">struct</span>&#123;&#125;       <span class="comment">// closed when conn closed</span></span><br><span class="line">   <span class="comment">// 判断body是否读取完</span></span><br><span class="line">   sawEOF    <span class="keyword">bool</span>  <span class="comment">// whether we've seen EOF from conn; owned by readLoop</span></span><br><span class="line">   <span class="comment">// writeErrCh passes the request write error (usually nil)</span></span><br><span class="line">   <span class="comment">// from the writeLoop goroutine to the readLoop which passes</span></span><br><span class="line">   <span class="comment">// it off to the res.Body reader, which then uses it to decide</span></span><br><span class="line">   <span class="comment">// whether or not a connection can be reused. Issue 7569.</span></span><br><span class="line">   <span class="comment">// writeLoop 写入 err的 chan</span></span><br><span class="line">   writeErrCh <span class="keyword">chan</span> error</span><br><span class="line"> <span class="comment">// writeLoop 结束的时候关闭</span></span><br><span class="line">   writeLoopDone <span class="keyword">chan</span> <span class="keyword">struct</span>&#123;&#125; <span class="comment">// closed when write loop ends</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="writeRequest"><a href="#writeRequest" class="headerlink" title="writeRequest"></a>writeRequest</h2><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> writeRequest <span class="keyword">struct</span> &#123;</span><br><span class="line">   req *transportRequest</span><br><span class="line">   ch  <span class="keyword">chan</span>&lt;- error</span><br><span class="line"></span><br><span class="line">   <span class="comment">// Optional blocking chan for Expect: 100-continue (for receive).</span></span><br><span class="line">   <span class="comment">// If not nil, writeLoop blocks sending request body until</span></span><br><span class="line">   <span class="comment">// it receives from this chan.</span></span><br><span class="line">   continueCh &lt;-<span class="keyword">chan</span> <span class="keyword">struct</span>&#123;&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>##requestAndChan</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> requestAndChan <span class="keyword">struct</span> &#123;</span><br><span class="line">   req *Request</span><br><span class="line">   ch  <span class="keyword">chan</span> responseAndError <span class="comment">// unbuffered; always send in select on callerGone</span></span><br><span class="line"></span><br><span class="line">   <span class="comment">// whether the Transport (as opposed to the user client code)</span></span><br><span class="line">   <span class="comment">// added the Accept-Encoding gzip header. If the Transport</span></span><br><span class="line">   <span class="comment">// set it, only then do we transparently decode the gzip.</span></span><br><span class="line">   addedGzip <span class="keyword">bool</span></span><br><span class="line"></span><br><span class="line">   <span class="comment">// Optional blocking chan for Expect: 100-continue (for send).</span></span><br><span class="line">   <span class="comment">// If the request has an "Expect: 100-continue" header and</span></span><br><span class="line">   <span class="comment">// the server responds 100 Continue, readLoop send a value</span></span><br><span class="line">   <span class="comment">// to writeLoop via this chan.</span></span><br><span class="line">   continueCh <span class="keyword">chan</span>&lt;- <span class="keyword">struct</span>&#123;&#125;</span><br><span class="line"></span><br><span class="line">   callerGone &lt;-<span class="keyword">chan</span> <span class="keyword">struct</span>&#123;&#125; <span class="comment">// closed when roundTrip caller has returned</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="请求流程"><a href="#请求流程" class="headerlink" title="请求流程"></a>请求流程</h1><p>这里的函数没有太多的逻辑，贴出来主要是为了追踪过程</p><p>这里用一个简单的例子表示</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">  <span class="comment">// 调用 Http 包的 Get 函数处理</span></span><br><span class="line">resp, err := http.Get(<span class="string">"https://www.baidu.com"</span>)</span><br><span class="line"><span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line"><span class="built_in">panic</span>(err)</span><br><span class="line">&#125;</span><br><span class="line">resp.Body.Close()</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="client-Get"><a href="#client-Get" class="headerlink" title="client.Get"></a>client.Get</h2><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> DefaultClient = &amp;Client&#123;&#125;</span><br><span class="line">....</span><br><span class="line"><span class="comment">// 使用默认的 client， 调用 client.Get 来处理</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">Get</span><span class="params">(url <span class="keyword">string</span>)</span> <span class="params">(resp *Response, err error)</span></span> &#123;</span><br><span class="line"><span class="keyword">return</span> DefaultClient.Get(url)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(c *Client)</span> <span class="title">Get</span><span class="params">(url <span class="keyword">string</span>)</span> <span class="params">(resp *Response, err error)</span></span> &#123;</span><br><span class="line">  <span class="comment">// request这里的创建忽略</span></span><br><span class="line">req, err := NewRequest(<span class="string">"GET"</span>, url, <span class="literal">nil</span>)</span><br><span class="line"><span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line"><span class="keyword">return</span> <span class="literal">nil</span>, err</span><br><span class="line">&#125;</span><br><span class="line">  <span class="comment">// 调用 client.Do 函数来处理， 然后 client.Do 调用 client.do 来处理，不懂为啥非要多一层嵌套</span></span><br><span class="line"><span class="keyword">return</span> c.Do(req)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="client-do"><a href="#client-do" class="headerlink" title="client.do"></a>client.do</h2><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(c *Client)</span> <span class="title">do</span><span class="params">(req *Request)</span> <span class="params">(retres *Response, reterr error)</span></span> &#123;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// URL 及 hook检测，忽略...</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> (</span><br><span class="line">deadline      = c.deadline()</span><br><span class="line">reqs          []*Request</span><br><span class="line">resp          *Response</span><br><span class="line">copyHeaders   = c.makeHeadersCopier(req)</span><br><span class="line">reqBodyClosed = <span class="literal">false</span> <span class="comment">// have we closed the current req.Body?</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// Redirect behavior:</span></span><br><span class="line">redirectMethod <span class="keyword">string</span></span><br><span class="line">includeBody    <span class="keyword">bool</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 错误自定义处理，忽略....</span></span><br><span class="line">  </span><br><span class="line"><span class="keyword">for</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 省略无关的代码....</span></span><br><span class="line">    </span><br><span class="line">reqs = <span class="built_in">append</span>(reqs, req)</span><br><span class="line"><span class="keyword">var</span> err error</span><br><span class="line"><span class="keyword">var</span> didTimeout <span class="function"><span class="keyword">func</span><span class="params">()</span> <span class="title">bool</span></span></span><br><span class="line"><span class="function">    // 调用 <span class="title">client</span>.<span class="title">send</span> 方法来获取<span class="title">response</span>，主要逻辑</span></span><br><span class="line"><span class="function"><span class="title">if</span> <span class="title">resp</span>, <span class="title">didTimeout</span>, <span class="title">err</span> = <span class="title">c</span>.<span class="title">send</span><span class="params">(req, deadline)</span>; <span class="title">err</span> != <span class="title">nil</span></span> &#123;</span><br><span class="line"><span class="comment">// c.send() always closes req.Body</span></span><br><span class="line">reqBodyClosed = <span class="literal">true</span></span><br><span class="line"><span class="keyword">if</span> !deadline.IsZero() &amp;&amp; didTimeout() &#123;</span><br><span class="line">err = &amp;httpError&#123;</span><br><span class="line"><span class="comment">// <span class="doctag">TODO:</span> early in cycle: s/Client.Timeout exceeded/timeout or context cancelation/</span></span><br><span class="line">err:     err.Error() + <span class="string">" (Client.Timeout exceeded while awaiting headers)"</span>,</span><br><span class="line">timeout: <span class="literal">true</span>,</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> <span class="literal">nil</span>, uerr(err)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 判断是否需要跳转，进而进一步请求</span></span><br><span class="line"><span class="keyword">var</span> shouldRedirect <span class="keyword">bool</span></span><br><span class="line">redirectMethod, shouldRedirect, includeBody = redirectBehavior(req.Method, resp, reqs[<span class="number">0</span>])</span><br><span class="line"><span class="keyword">if</span> !shouldRedirect &#123;</span><br><span class="line"><span class="keyword">return</span> resp, <span class="literal">nil</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">req.closeBody()</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="client-send"><a href="#client-send" class="headerlink" title="client.send"></a>client.send</h2><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(c *Client)</span> <span class="title">send</span><span class="params">(req *Request, deadline time.Time)</span> <span class="params">(resp *Response, didTimeout <span class="keyword">func</span>()</span> <span class="title">bool</span>, <span class="title">err</span> <span class="title">error</span>)</span> &#123;</span><br><span class="line"><span class="keyword">if</span> c.Jar != <span class="literal">nil</span> &#123;</span><br><span class="line"><span class="keyword">for</span> _, cookie := <span class="keyword">range</span> c.Jar.Cookies(req.URL) &#123;</span><br><span class="line">req.AddCookie(cookie)</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">  <span class="comment">// 调用 send 方法来获取 response</span></span><br><span class="line">resp, didTimeout, err = send(req, c.transport(), deadline)</span><br><span class="line"><span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line"><span class="keyword">return</span> <span class="literal">nil</span>, didTimeout, err</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span> c.Jar != <span class="literal">nil</span> &#123;</span><br><span class="line"><span class="keyword">if</span> rc := resp.Cookies(); <span class="built_in">len</span>(rc) &gt; <span class="number">0</span> &#123;</span><br><span class="line">c.Jar.SetCookies(req.URL, rc)</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> resp, <span class="literal">nil</span>, <span class="literal">nil</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="send"><a href="#send" class="headerlink" title="send"></a>send</h2><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">send</span><span class="params">(ireq *Request, rt RoundTripper, deadline time.Time)</span> <span class="params">(resp *Response, didTimeout <span class="keyword">func</span>()</span> <span class="title">bool</span>, <span class="title">err</span> <span class="title">error</span>)</span> &#123;</span><br><span class="line">req := ireq <span class="comment">// req is either the original request, or a modified fork</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// URL Hader 等判断及请求fork，忽略....</span></span><br><span class="line">  </span><br><span class="line">stopTimer, didTimeout := setRequestCancel(req, rt, deadline)</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 调用 Transport.RoundTrip 来处理请求</span></span><br><span class="line">resp, err = rt.RoundTrip(req)</span><br><span class="line"><span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">stopTimer()</span><br><span class="line"><span class="keyword">if</span> resp != <span class="literal">nil</span> &#123;</span><br><span class="line">log.Printf(<span class="string">"RoundTripper returned a response &amp; error; ignoring response"</span>)</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span> tlsErr, ok := err.(tls.RecordHeaderError); ok &#123;</span><br><span class="line"><span class="comment">// If we get a bad TLS record header, check to see if the</span></span><br><span class="line"><span class="comment">// response looks like HTTP and give a more helpful error.</span></span><br><span class="line"><span class="comment">// See golang.org/issue/11111.</span></span><br><span class="line"><span class="keyword">if</span> <span class="keyword">string</span>(tlsErr.RecordHeader[:]) == <span class="string">"HTTP/"</span> &#123;</span><br><span class="line">err = errors.New(<span class="string">"http: server gave HTTP response to HTTPS client"</span>)</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> <span class="literal">nil</span>, didTimeout, err</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span> !deadline.IsZero() &#123;</span><br><span class="line">resp.Body = &amp;cancelTimerBody&#123;</span><br><span class="line">stop:          stopTimer,</span><br><span class="line">rc:            resp.Body,</span><br><span class="line">reqDidTimeout: didTimeout,</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> resp, <span class="literal">nil</span>, <span class="literal">nil</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="Transport-roundTrip"><a href="#Transport-roundTrip" class="headerlink" title="Transport.roundTrip"></a>Transport.roundTrip</h2><p>这里开始接近重点区域了</p><p>这个函数主要就是湖区连接，然后获取response返回</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(t *Transport)</span> <span class="title">roundTrip</span><span class="params">(req *Request)</span> <span class="params">(*Response, error)</span></span> &#123;</span><br><span class="line">   t.nextProtoOnce.Do(t.onceSetNextProtoDefaults)</span><br><span class="line">   ctx := req.Context()</span><br><span class="line">   trace := httptrace.ContextClientTrace(ctx)</span><br><span class="line"></span><br><span class="line">   <span class="comment">// URL, header schema 等判断，与主流程无关，忽略...</span></span><br><span class="line"></span><br><span class="line">   <span class="keyword">for</span> &#123;</span><br><span class="line">     <span class="comment">// 判断context 是否完成，超时等</span></span><br><span class="line">      <span class="keyword">select</span> &#123;</span><br><span class="line">      <span class="keyword">case</span> &lt;-ctx.Done():</span><br><span class="line">         req.closeBody()</span><br><span class="line">         <span class="keyword">return</span> <span class="literal">nil</span>, ctx.Err()</span><br><span class="line">      <span class="keyword">default</span>:</span><br><span class="line">      &#125;</span><br><span class="line"></span><br><span class="line">      <span class="comment">// treq gets modified by roundTrip, so we need to recreate for each retry.</span></span><br><span class="line">      <span class="comment">// treq会被 roundTrip 方法修改，所有每一次循环需要创建一个新的</span></span><br><span class="line">      treq := &amp;transportRequest&#123;Request: req, trace: trace&#125;</span><br><span class="line">      <span class="comment">// 根据当前的请求获取 connectMethod，包含schema和address，方便请求的复用，这里不重要，不做详细分析</span></span><br><span class="line">      cm, err := t.connectMethodForRequest(treq)</span><br><span class="line">      <span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">         req.closeBody()</span><br><span class="line">         <span class="keyword">return</span> <span class="literal">nil</span>, err</span><br><span class="line">      &#125;</span><br><span class="line"></span><br><span class="line">      <span class="comment">// Get the cached or newly-created connection to either the</span></span><br><span class="line">      <span class="comment">// host (for http or https), the http proxy, or the http proxy</span></span><br><span class="line">      <span class="comment">// pre-CONNECTed to https server. In any case, we'll be ready</span></span><br><span class="line">      <span class="comment">// to send it requests.</span></span><br><span class="line">      <span class="comment">// 根据请求和connectMethod获取一个可用的连接，重要，后面会具体分析</span></span><br><span class="line">      pconn, err := t.getConn(treq, cm)</span><br><span class="line">      <span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">         t.setReqCanceler(req, <span class="literal">nil</span>)</span><br><span class="line">         req.closeBody()</span><br><span class="line">         <span class="keyword">return</span> <span class="literal">nil</span>, err</span><br><span class="line">      &#125;</span><br><span class="line"></span><br><span class="line">      <span class="keyword">var</span> resp *Response</span><br><span class="line">      <span class="keyword">if</span> pconn.alt != <span class="literal">nil</span> &#123;</span><br><span class="line">         <span class="comment">// HTTP/2 path.</span></span><br><span class="line">         <span class="comment">// http2 使用，这里不展开</span></span><br><span class="line">         t.decHostConnCount(cm.key()) <span class="comment">// don't count cached http2 conns toward conns per host</span></span><br><span class="line">         t.setReqCanceler(req, <span class="literal">nil</span>)   <span class="comment">// not cancelable with CancelRequest</span></span><br><span class="line">         resp, err = pconn.alt.RoundTrip(req)</span><br><span class="line">      &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">         <span class="comment">// 获取response，这里是重点，后面展开</span></span><br><span class="line">         resp, err = pconn.roundTrip(treq)</span><br><span class="line">      &#125;</span><br><span class="line">     </span><br><span class="line">     <span class="comment">// 判断获取response是否有误及错误处理等操作，无关紧要，忽略</span></span><br><span class="line">     </span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>接下来，进入重点分析了 <code>getConn</code> <code>persistConn.roundTrip</code> <code>Transport.dialConn</code> 以及内存泄露的罪魁祸首 <code>persistConn.readLoop</code> <code>persistConn.writeLoop</code></p><h3 id="Transport-getConn"><a href="#Transport-getConn" class="headerlink" title="Transport.getConn"></a>Transport.getConn</h3><p>这个方法根据connectMethod，也就是 schema和addr（忽略proxy代理），复用连接或者创建一个新的连接，同时开启了两个goroutine，分别 读取response 和 写request</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(t *Transport)</span> <span class="title">getConn</span><span class="params">(treq *transportRequest, cm connectMethod)</span> <span class="params">(*persistConn, error)</span></span> &#123;</span><br><span class="line">  </span><br><span class="line">  <span class="comment">// trace相关的忽略...</span></span><br><span class="line">  </span><br><span class="line">req := treq.Request</span><br><span class="line">trace := treq.trace</span><br><span class="line">ctx := req.Context()</span><br><span class="line"><span class="keyword">if</span> trace != <span class="literal">nil</span> &amp;&amp; trace.GetConn != <span class="literal">nil</span> &#123;</span><br><span class="line">trace.GetConn(cm.addr())</span><br><span class="line">&#125;</span><br><span class="line">  </span><br><span class="line">  <span class="comment">// 从idleConn里面获取一个 connectMethod对应的空闲的 连接，获取到了直接返回</span></span><br><span class="line"><span class="keyword">if</span> pc, idleSince := t.getIdleConn(cm); pc != <span class="literal">nil</span> &#123;</span><br><span class="line"><span class="keyword">if</span> trace != <span class="literal">nil</span> &amp;&amp; trace.GotConn != <span class="literal">nil</span> &#123;</span><br><span class="line">trace.GotConn(pc.gotIdleConnTrace(idleSince))</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// set request canceler to some non-nil function so we</span></span><br><span class="line"><span class="comment">// can detect whether it was cleared between now and when</span></span><br><span class="line"><span class="comment">// we enter roundTrip</span></span><br><span class="line">t.setReqCanceler(req, <span class="function"><span class="keyword">func</span><span class="params">(error)</span></span> &#123;&#125;)</span><br><span class="line"><span class="keyword">return</span> pc, <span class="literal">nil</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> dialRes <span class="keyword">struct</span> &#123;</span><br><span class="line">pc  *persistConn</span><br><span class="line">err error</span><br><span class="line">&#125;</span><br><span class="line">  <span class="comment">// 没有获取到空闲连接，定义一个 dialRes 结构体，用于接收 自身创建的另一个goroutine创建的 连接</span></span><br><span class="line">dialc := <span class="built_in">make</span>(<span class="keyword">chan</span> dialRes)</span><br><span class="line">cmKey := cm.key()</span><br><span class="line"></span><br><span class="line"><span class="comment">// Copy these hooks so we don't race on the postPendingDial in</span></span><br><span class="line"><span class="comment">// the goroutine we launch. Issue 11136.</span></span><br><span class="line">testHookPrePendingDial := testHookPrePendingDial</span><br><span class="line">testHookPostPendingDial := testHookPostPendingDial</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 处理 dialc 中暂时用不到的连接的方法，后面会讲到为什么有可能创建的连接是没有人使用的</span></span><br><span class="line">handlePendingDial := <span class="function"><span class="keyword">func</span><span class="params">()</span></span> &#123;</span><br><span class="line">testHookPrePendingDial()</span><br><span class="line"><span class="keyword">go</span> <span class="function"><span class="keyword">func</span><span class="params">()</span></span> &#123;</span><br><span class="line"><span class="keyword">if</span> v := &lt;-dialc; v.err == <span class="literal">nil</span> &#123;</span><br><span class="line">t.putOrCloseIdleConn(v.pc)</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">t.decHostConnCount(cmKey)</span><br><span class="line">&#125;</span><br><span class="line">testHookPostPendingDial()</span><br><span class="line">&#125;()</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">cancelc := <span class="built_in">make</span>(<span class="keyword">chan</span> error, <span class="number">1</span>)</span><br><span class="line">t.setReqCanceler(req, <span class="function"><span class="keyword">func</span><span class="params">(err error)</span></span> &#123; cancelc &lt;- err &#125;)</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 忽略部分判断...</span></span><br><span class="line"></span><br><span class="line">  <span class="comment">// 开启一个goroutine，去创建一个连接，dialConn 是重点，后面深入分析</span></span><br><span class="line"><span class="keyword">go</span> <span class="function"><span class="keyword">func</span><span class="params">()</span></span> &#123;</span><br><span class="line">pc, err := t.dialConn(ctx, cm)</span><br><span class="line">dialc &lt;- dialRes&#123;pc, err&#125;</span><br><span class="line">&#125;()</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 获取 idleChan中对应connectMethod的 channel</span></span><br><span class="line">idleConnCh := t.getIdleConnCh(cm)</span><br><span class="line">  </span><br><span class="line">  <span class="comment">// 从多个chan中获取连接，获取取消信号，先来的先处理</span></span><br><span class="line"><span class="keyword">select</span> &#123;</span><br><span class="line"><span class="keyword">case</span> v := &lt;-dialc:</span><br><span class="line">    <span class="comment">// 上面 goroutine首先创建完成了一个连接，使用这个链接</span></span><br><span class="line"><span class="comment">// Our dial finished.</span></span><br><span class="line"><span class="keyword">if</span> v.pc != <span class="literal">nil</span> &#123;</span><br><span class="line"><span class="keyword">if</span> trace != <span class="literal">nil</span> &amp;&amp; trace.GotConn != <span class="literal">nil</span> &amp;&amp; v.pc.alt == <span class="literal">nil</span> &#123;</span><br><span class="line">trace.GotConn(httptrace.GotConnInfo&#123;Conn: v.pc.conn&#125;)</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> v.pc, <span class="literal">nil</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// Our dial failed. See why to return a nicer error</span></span><br><span class="line"><span class="comment">// value.</span></span><br><span class="line">t.decHostConnCount(cmKey)</span><br><span class="line"><span class="keyword">select</span> &#123;</span><br><span class="line"><span class="keyword">case</span> &lt;-req.Cancel:</span><br><span class="line"><span class="comment">// It was an error due to cancelation, so prioritize that</span></span><br><span class="line"><span class="comment">// error value. (Issue 16049)</span></span><br><span class="line"><span class="keyword">return</span> <span class="literal">nil</span>, errRequestCanceledConn</span><br><span class="line"><span class="keyword">case</span> &lt;-req.Context().Done():</span><br><span class="line"><span class="keyword">return</span> <span class="literal">nil</span>, req.Context().Err()</span><br><span class="line"><span class="keyword">case</span> err := &lt;-cancelc:</span><br><span class="line"><span class="keyword">if</span> err == errRequestCanceled &#123;</span><br><span class="line">err = errRequestCanceledConn</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> <span class="literal">nil</span>, err</span><br><span class="line"><span class="keyword">default</span>:</span><br><span class="line"><span class="comment">// It wasn't an error due to cancelation, so</span></span><br><span class="line"><span class="comment">// return the original error message:</span></span><br><span class="line"><span class="keyword">return</span> <span class="literal">nil</span>, v.err</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">case</span> pc := &lt;-idleConnCh:</span><br><span class="line">    <span class="comment">// 另一个goroutine的request首先完成了，然后会把这个链接首先尝试放入对应connectMethod对应的 chan，如果放入不了，则放入idleConns的map中，进入这里说明，另一个goroutine把连接放入了chan，并被当前goroutine捕获了，那么上面 </span></span><br><span class="line">    <span class="comment">// go func() &#123;</span></span><br><span class="line"><span class="comment">//     pc, err := t.dialConn(ctx, cm)</span></span><br><span class="line"><span class="comment">//     dialc &lt;- dialRes&#123;pc, err&#125;</span></span><br><span class="line"><span class="comment">// &#125;()</span></span><br><span class="line">    <span class="comment">// 生成的连接就暂时没用了，这时候就用到上面 handlePendingDial 定义的方法，去处理这个多余的连接</span></span><br><span class="line"><span class="comment">// Another request finished first and its net.Conn</span></span><br><span class="line"><span class="comment">// became available before our dial. Or somebody</span></span><br><span class="line"><span class="comment">// else's dial that they didn't use.</span></span><br><span class="line"><span class="comment">// But our dial is still going, so give it away</span></span><br><span class="line"><span class="comment">// when it finishes:</span></span><br><span class="line">handlePendingDial()</span><br><span class="line"><span class="keyword">if</span> trace != <span class="literal">nil</span> &amp;&amp; trace.GotConn != <span class="literal">nil</span> &#123;</span><br><span class="line">trace.GotConn(httptrace.GotConnInfo&#123;Conn: pc.conn, Reused: pc.isReused()&#125;)</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> pc, <span class="literal">nil</span></span><br><span class="line"><span class="keyword">case</span> &lt;-req.Cancel:</span><br><span class="line">handlePendingDial()</span><br><span class="line"><span class="keyword">return</span> <span class="literal">nil</span>, errRequestCanceledConn</span><br><span class="line"><span class="keyword">case</span> &lt;-req.Context().Done():</span><br><span class="line">handlePendingDial()</span><br><span class="line"><span class="keyword">return</span> <span class="literal">nil</span>, req.Context().Err()</span><br><span class="line"><span class="keyword">case</span> err := &lt;-cancelc:</span><br><span class="line">handlePendingDial()</span><br><span class="line"><span class="keyword">if</span> err == errRequestCanceled &#123;</span><br><span class="line">err = errRequestCanceledConn</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> <span class="literal">nil</span>, err</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>上面的 <code>handlePendingDial</code> 方法中，调用了 <code>putOrCloseIdleConn</code>，这个方法到底干了什么，跟 <code>idleConnCh</code> 和 <code>idleConn</code> 有什么关系？</p><h4 id="Transport-putOrCloseIdleConn"><a href="#Transport-putOrCloseIdleConn" class="headerlink" title="Transport.putOrCloseIdleConn"></a>Transport.putOrCloseIdleConn</h4><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(t *Transport)</span> <span class="title">putOrCloseIdleConn</span><span class="params">(pconn *persistConn)</span></span> &#123;</span><br><span class="line"><span class="keyword">if</span> err := t.tryPutIdleConn(pconn); err != <span class="literal">nil</span> &#123;</span><br><span class="line">pconn.<span class="built_in">close</span>(err)</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h5 id="Transport-tryPutIdleConn"><a href="#Transport-tryPutIdleConn" class="headerlink" title="Transport.tryPutIdleConn"></a>Transport.tryPutIdleConn</h5><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(t *Transport)</span> <span class="title">tryPutIdleConn</span><span class="params">(pconn *persistConn)</span> <span class="title">error</span></span> &#123;</span><br><span class="line"><span class="keyword">if</span> t.DisableKeepAlives || t.MaxIdleConnsPerHost &lt; <span class="number">0</span> &#123;</span><br><span class="line"><span class="keyword">return</span> errKeepAlivesDisabled</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span> pconn.isBroken() &#123;</span><br><span class="line"><span class="keyword">return</span> errConnBroken</span><br><span class="line">&#125;</span><br><span class="line">  <span class="comment">// http2判断</span></span><br><span class="line"><span class="keyword">if</span> pconn.alt != <span class="literal">nil</span> &#123;</span><br><span class="line"><span class="keyword">return</span> errNotCachingH2Conn</span><br><span class="line">&#125;</span><br><span class="line">  <span class="comment">// 标记为 reused</span></span><br><span class="line">pconn.markReused()</span><br><span class="line">  <span class="comment">// cacheKey是由 connectMethod得到的</span></span><br><span class="line">key := pconn.cacheKey</span><br><span class="line"></span><br><span class="line">t.idleMu.Lock()</span><br><span class="line"><span class="keyword">defer</span> t.idleMu.Unlock()</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 获取connectMethod对应的 idleConnCh</span></span><br><span class="line">waitingDialer := t.idleConnCh[key]</span><br><span class="line"><span class="keyword">select</span> &#123;</span><br><span class="line"><span class="keyword">case</span> waitingDialer &lt;- pconn:</span><br><span class="line">    <span class="comment">// 在这里尝试将 连接 放到 connectMethod对应的chan里面，如果没有另一个goroutine接收就算了</span></span><br><span class="line"><span class="comment">// We're done with this pconn and somebody else is</span></span><br><span class="line"><span class="comment">// currently waiting for a conn of this type (they're</span></span><br><span class="line"><span class="comment">// actively dialing, but this conn is ready</span></span><br><span class="line"><span class="comment">// first). Chrome calls this socket late binding. See</span></span><br><span class="line"><span class="comment">// https://insouciant.org/tech/connection-management-in-chromium/</span></span><br><span class="line"><span class="keyword">return</span> <span class="literal">nil</span></span><br><span class="line"><span class="keyword">default</span>:</span><br><span class="line">    <span class="comment">// 没有另一个goroutine接收的chan，从map中删除，便于垃圾回收</span></span><br><span class="line"><span class="keyword">if</span> waitingDialer != <span class="literal">nil</span> &#123;</span><br><span class="line"><span class="comment">// They had populated this, but their dial won</span></span><br><span class="line"><span class="comment">// first, so we can clean up this map entry.</span></span><br><span class="line"><span class="built_in">delete</span>(t.idleConnCh, key)</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span> t.wantIdle &#123;</span><br><span class="line"><span class="keyword">return</span> errWantIdle</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span> t.idleConn == <span class="literal">nil</span> &#123;</span><br><span class="line">t.idleConn = <span class="built_in">make</span>(<span class="keyword">map</span>[connectMethodKey][]*persistConn)</span><br><span class="line">&#125;</span><br><span class="line">idles := t.idleConn[key]</span><br><span class="line">  <span class="comment">// 设定了每个 connectMethod对应的最大空闲连接数，超过就不再往里面填充</span></span><br><span class="line"><span class="keyword">if</span> <span class="built_in">len</span>(idles) &gt;= t.maxIdleConnsPerHost() &#123;</span><br><span class="line"><span class="keyword">return</span> errTooManyIdleHost</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">for</span> _, exist := <span class="keyword">range</span> idles &#123;</span><br><span class="line"><span class="keyword">if</span> exist == pconn &#123;</span><br><span class="line">log.Fatalf(<span class="string">"dup idle pconn %p in freelist"</span>, pconn)</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">  </span><br><span class="line">  <span class="comment">// 后面就是清理多有的连接，及重置timer等操作，与主流程无关，不展开分析</span></span><br><span class="line">t.idleConn[key] = <span class="built_in">append</span>(idles, pconn)</span><br><span class="line">t.idleLRU.add(pconn)</span><br><span class="line"><span class="keyword">if</span> t.MaxIdleConns != <span class="number">0</span> &amp;&amp; t.idleLRU.<span class="built_in">len</span>() &gt; t.MaxIdleConns &#123;</span><br><span class="line">oldest := t.idleLRU.removeOldest()</span><br><span class="line">oldest.<span class="built_in">close</span>(errTooManyIdle)</span><br><span class="line">t.removeIdleConnLocked(oldest)</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span> t.IdleConnTimeout &gt; <span class="number">0</span> &#123;</span><br><span class="line"><span class="keyword">if</span> pconn.idleTimer != <span class="literal">nil</span> &#123;</span><br><span class="line">pconn.idleTimer.Reset(t.IdleConnTimeout)</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">pconn.idleTimer = time.AfterFunc(t.IdleConnTimeout, pconn.closeConnIfStillIdle)</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">pconn.idleAt = time.Now()</span><br><span class="line"><span class="keyword">return</span> <span class="literal">nil</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="Transport-dialConn"><a href="#Transport-dialConn" class="headerlink" title="Transport.dialConn"></a>Transport.dialConn</h4><p>跑偏了一会，现在接着 getConn分析 dialConn 这个函数</p><p>这个函数主要就是创建了一个 连接，然后 创建了两个goroutine，分别去往这个连接写入请求(<code>writeLoop</code>函数)和读取响应(<code>readLoop</code>函数)</p><p>而这两个函数，又会与 <code>persistConn.roundTrip</code> 通过chan进行关联，这里先对函数进行分析，分析完成后，再画出对应的关联图示</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(t *Transport)</span> <span class="title">dialConn</span><span class="params">(ctx context.Context, cm connectMethod)</span> <span class="params">(*persistConn, error)</span></span> &#123;</span><br><span class="line">pconn := &amp;persistConn&#123;</span><br><span class="line">t:             t,</span><br><span class="line">cacheKey:      cm.key(),</span><br><span class="line">reqch:         <span class="built_in">make</span>(<span class="keyword">chan</span> requestAndChan, <span class="number">1</span>),</span><br><span class="line">writech:       <span class="built_in">make</span>(<span class="keyword">chan</span> writeRequest, <span class="number">1</span>),</span><br><span class="line">closech:       <span class="built_in">make</span>(<span class="keyword">chan</span> <span class="keyword">struct</span>&#123;&#125;),</span><br><span class="line">writeErrCh:    <span class="built_in">make</span>(<span class="keyword">chan</span> error, <span class="number">1</span>),</span><br><span class="line">writeLoopDone: <span class="built_in">make</span>(<span class="keyword">chan</span> <span class="keyword">struct</span>&#123;&#125;),</span><br><span class="line">&#125;</span><br><span class="line">trace := httptrace.ContextClientTrace(ctx)</span><br><span class="line">wrapErr := <span class="function"><span class="keyword">func</span><span class="params">(err error)</span> <span class="title">error</span></span> &#123;</span><br><span class="line"><span class="keyword">if</span> cm.proxyURL != <span class="literal">nil</span> &#123;</span><br><span class="line"><span class="comment">// Return a typed error, per Issue 16997</span></span><br><span class="line"><span class="keyword">return</span> &amp;net.OpError&#123;Op: <span class="string">"proxyconnect"</span>, Net: <span class="string">"tcp"</span>, Err: err&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> err</span><br><span class="line">&#125;</span><br><span class="line">  <span class="comment">// 构建一个 TLS的连接</span></span><br><span class="line"><span class="keyword">if</span> cm.scheme() == <span class="string">"https"</span> &amp;&amp; t.DialTLS != <span class="literal">nil</span> &#123;</span><br><span class="line"><span class="keyword">var</span> err error</span><br><span class="line">pconn.conn, err = t.DialTLS(<span class="string">"tcp"</span>, cm.addr())</span><br><span class="line"><span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line"><span class="keyword">return</span> <span class="literal">nil</span>, wrapErr(err)</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span> pconn.conn == <span class="literal">nil</span> &#123;</span><br><span class="line"><span class="keyword">return</span> <span class="literal">nil</span>, wrapErr(errors.New(<span class="string">"net/http: Transport.DialTLS returned (nil, nil)"</span>))</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span> tc, ok := pconn.conn.(*tls.Conn); ok &#123;</span><br><span class="line"><span class="comment">// Handshake here, in case DialTLS didn't. TLSNextProto below</span></span><br><span class="line"><span class="comment">// depends on it for knowing the connection state.</span></span><br><span class="line"><span class="keyword">if</span> trace != <span class="literal">nil</span> &amp;&amp; trace.TLSHandshakeStart != <span class="literal">nil</span> &#123;</span><br><span class="line">trace.TLSHandshakeStart()</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span> err := tc.Handshake(); err != <span class="literal">nil</span> &#123;</span><br><span class="line"><span class="keyword">go</span> pconn.conn.Close()</span><br><span class="line"><span class="keyword">if</span> trace != <span class="literal">nil</span> &amp;&amp; trace.TLSHandshakeDone != <span class="literal">nil</span> &#123;</span><br><span class="line">trace.TLSHandshakeDone(tls.ConnectionState&#123;&#125;, err)</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> <span class="literal">nil</span>, err</span><br><span class="line">&#125;</span><br><span class="line">cs := tc.ConnectionState()</span><br><span class="line"><span class="keyword">if</span> trace != <span class="literal">nil</span> &amp;&amp; trace.TLSHandshakeDone != <span class="literal">nil</span> &#123;</span><br><span class="line">trace.TLSHandshakeDone(cs, <span class="literal">nil</span>)</span><br><span class="line">&#125;</span><br><span class="line">pconn.tlsState = &amp;cs</span><br><span class="line">&#125;</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    <span class="comment">// 构建一个普通的tcp连接</span></span><br><span class="line">conn, err := t.dial(ctx, <span class="string">"tcp"</span>, cm.addr())</span><br><span class="line"><span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line"><span class="keyword">return</span> <span class="literal">nil</span>, wrapErr(err)</span><br><span class="line">&#125;</span><br><span class="line">pconn.conn = conn</span><br><span class="line"><span class="keyword">if</span> cm.scheme() == <span class="string">"https"</span> &#123;</span><br><span class="line"><span class="keyword">var</span> firstTLSHost <span class="keyword">string</span></span><br><span class="line"><span class="keyword">if</span> firstTLSHost, _, err = net.SplitHostPort(cm.addr()); err != <span class="literal">nil</span> &#123;</span><br><span class="line"><span class="keyword">return</span> <span class="literal">nil</span>, wrapErr(err)</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span> err = pconn.addTLS(firstTLSHost, trace); err != <span class="literal">nil</span> &#123;</span><br><span class="line"><span class="keyword">return</span> <span class="literal">nil</span>, wrapErr(err)</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// proxy 设置、 协议转换等，忽略...</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> t.MaxConnsPerHost &gt; <span class="number">0</span> &#123;</span><br><span class="line">pconn.conn = &amp;connCloseListener&#123;Conn: pconn.conn, t: t, cmKey: pconn.cacheKey&#125;</span><br><span class="line">&#125;</span><br><span class="line">pconn.br = bufio.NewReader(pconn)</span><br><span class="line">pconn.bw = bufio.NewWriter(persistConnWriter&#123;pconn&#125;)</span><br><span class="line"><span class="keyword">go</span> pconn.readLoop()</span><br><span class="line"><span class="keyword">go</span> pconn.writeLoop()</span><br><span class="line"><span class="keyword">return</span> pconn, <span class="literal">nil</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h5 id="persistConn-readLoop"><a href="#persistConn-readLoop" class="headerlink" title="persistConn.readLoop"></a>persistConn.readLoop</h5><p>readLoop 这里从连接中读取 response，然后通过chan发送给persistConn.roundTrip，最后等待结束</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(pc *persistConn)</span> <span class="title">readLoop</span><span class="params">()</span></span> &#123;</span><br><span class="line">   closeErr := errReadLoopExiting <span class="comment">// default value, if not changed below</span></span><br><span class="line">   <span class="keyword">defer</span> <span class="function"><span class="keyword">func</span><span class="params">()</span></span> &#123;</span><br><span class="line">     <span class="comment">// 关闭这个链接，这里的关闭函数 相当于 close(pc.closech)，然后 writeLoop 的 &lt;-pc.closech 就不会阻塞，而正常退出了，这样就可以理解，为什么readLoop函数退出后，writeLoop函数也就退出了</span></span><br><span class="line">      pc.<span class="built_in">close</span>(closeErr)</span><br><span class="line">      pc.t.removeIdleConn(pc)</span><br><span class="line">   &#125;()</span><br><span class="line"></span><br><span class="line">   <span class="comment">// 这个函数同上面分析的 Transport.tryPutIdleConn</span></span><br><span class="line">   tryPutIdleConn := <span class="function"><span class="keyword">func</span><span class="params">(trace *httptrace.ClientTrace)</span> <span class="title">bool</span></span> &#123;</span><br><span class="line">      <span class="keyword">if</span> err := pc.t.tryPutIdleConn(pc); err != <span class="literal">nil</span> &#123;</span><br><span class="line">         closeErr = err</span><br><span class="line">         <span class="keyword">if</span> trace != <span class="literal">nil</span> &amp;&amp; trace.PutIdleConn != <span class="literal">nil</span> &amp;&amp; err != errKeepAlivesDisabled &#123;</span><br><span class="line">            trace.PutIdleConn(err)</span><br><span class="line">         &#125;</span><br><span class="line">         <span class="keyword">return</span> <span class="literal">false</span></span><br><span class="line">      &#125;</span><br><span class="line">      <span class="keyword">if</span> trace != <span class="literal">nil</span> &amp;&amp; trace.PutIdleConn != <span class="literal">nil</span> &#123;</span><br><span class="line">         trace.PutIdleConn(<span class="literal">nil</span>)</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="keyword">return</span> <span class="literal">true</span></span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line">   <span class="comment">// eofc is used to block caller goroutines reading from Response.Body</span></span><br><span class="line">   <span class="comment">// at EOF until this goroutines has (potentially) added the connection</span></span><br><span class="line">   <span class="comment">// back to the idle pool.</span></span><br><span class="line">   eofc := <span class="built_in">make</span>(<span class="keyword">chan</span> <span class="keyword">struct</span>&#123;&#125;)</span><br><span class="line">   <span class="keyword">defer</span> <span class="built_in">close</span>(eofc) <span class="comment">// unblock reader on errors</span></span><br><span class="line"></span><br><span class="line">   <span class="comment">// 省略部分...</span></span><br><span class="line"></span><br><span class="line">   alive := <span class="literal">true</span></span><br><span class="line">   <span class="keyword">for</span> alive &#123;</span><br><span class="line">      pc.readLimit = pc.maxHeaderResponseSize()</span><br><span class="line">      _, err := pc.br.Peek(<span class="number">1</span>)</span><br><span class="line"></span><br><span class="line">      pc.mu.Lock()</span><br><span class="line">      <span class="keyword">if</span> pc.numExpectedResponses == <span class="number">0</span> &#123;</span><br><span class="line">         pc.readLoopPeekFailLocked(err)</span><br><span class="line">         pc.mu.Unlock()</span><br><span class="line">         <span class="keyword">return</span></span><br><span class="line">      &#125;</span><br><span class="line">      pc.mu.Unlock()</span><br><span class="line"></span><br><span class="line">      <span class="comment">// 从当前连接中获取request, 这里标记为 m1</span></span><br><span class="line">      rc := &lt;-pc.reqch</span><br><span class="line">      trace := httptrace.ContextClientTrace(rc.req.Context())</span><br><span class="line"></span><br><span class="line">      <span class="keyword">var</span> resp *Response</span><br><span class="line">      <span class="keyword">if</span> err == <span class="literal">nil</span> &#123;</span><br><span class="line">         <span class="comment">// 从请求中获取response，就是那么简单</span></span><br><span class="line">         resp, err = pc.readResponse(rc, trace)</span><br><span class="line">      &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">         err = transportReadFromServerError&#123;err&#125;</span><br><span class="line">         closeErr = err</span><br><span class="line">      &#125;</span><br><span class="line"></span><br><span class="line">      <span class="comment">// 如果读取response失败，则包装错误返回给 上层，即 persistConn.roundTrip 函数</span></span><br><span class="line">      <span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">         <span class="keyword">if</span> pc.readLimit &lt;= <span class="number">0</span> &#123;</span><br><span class="line">            err = fmt.Errorf(<span class="string">"net/http: server response headers exceeded %d bytes; aborted"</span>, pc.maxHeaderResponseSize())</span><br><span class="line">         &#125;</span><br><span class="line"></span><br><span class="line">         <span class="keyword">select</span> &#123;</span><br><span class="line">         <span class="keyword">case</span> rc.ch &lt;- responseAndError&#123;err: err&#125;:</span><br><span class="line">         <span class="keyword">case</span> &lt;-rc.callerGone:</span><br><span class="line">            <span class="keyword">return</span></span><br><span class="line">         &#125;</span><br><span class="line">         <span class="keyword">return</span></span><br><span class="line">      &#125;</span><br><span class="line">      pc.readLimit = maxInt64 <span class="comment">// effictively no limit for response bodies</span></span><br><span class="line"></span><br><span class="line">      pc.mu.Lock()</span><br><span class="line">      pc.numExpectedResponses--</span><br><span class="line">      pc.mu.Unlock()</span><br><span class="line"></span><br><span class="line">      hasBody := rc.req.Method != <span class="string">"HEAD"</span> &amp;&amp; resp.ContentLength != <span class="number">0</span></span><br><span class="line"></span><br><span class="line">      <span class="keyword">if</span> resp.Close || rc.req.Close || resp.StatusCode &lt;= <span class="number">199</span> &#123;</span><br><span class="line">         <span class="comment">// Don't do keep-alive on error if either party requested a close</span></span><br><span class="line">         <span class="comment">// or we get an unexpected informational (1xx) response.</span></span><br><span class="line">         <span class="comment">// StatusCode 100 is already handled above.</span></span><br><span class="line">         alive = <span class="literal">false</span></span><br><span class="line">      &#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// body为空的处理，忽略....</span></span><br><span class="line"></span><br><span class="line">      waitForBodyRead := <span class="built_in">make</span>(<span class="keyword">chan</span> <span class="keyword">bool</span>, <span class="number">2</span>)</span><br><span class="line">      body := &amp;bodyEOFSignal&#123;</span><br><span class="line">         body: resp.Body,</span><br><span class="line">         <span class="comment">// resp.Body.Close() 的最终调用的函数， Close()影响readLoop 和 writeLoop 两个goroutine 这两个goroutine的关闭，在后面讲close的时候具体介绍</span></span><br><span class="line">         earlyCloseFn: <span class="function"><span class="keyword">func</span><span class="params">()</span> <span class="title">error</span></span> &#123;</span><br><span class="line">            waitForBodyRead &lt;- <span class="literal">false</span></span><br><span class="line">            &lt;-eofc <span class="comment">// will be closed by deferred call at the end of the function</span></span><br><span class="line">            <span class="keyword">return</span> <span class="literal">nil</span></span><br><span class="line"></span><br><span class="line">         &#125;,</span><br><span class="line">         <span class="comment">// 上面函数出错后，会调用这个函数，这个函数影响readLoop 和 writeLoop 两个goroutine的形式，与上面的逻辑大致相同</span></span><br><span class="line">         fn: <span class="function"><span class="keyword">func</span><span class="params">(err error)</span> <span class="title">error</span></span> &#123;</span><br><span class="line">            isEOF := err == io.EOF</span><br><span class="line">            waitForBodyRead &lt;- isEOF</span><br><span class="line">            <span class="keyword">if</span> isEOF &#123;</span><br><span class="line">               &lt;-eofc <span class="comment">// see comment above eofc declaration</span></span><br><span class="line">            &#125; <span class="keyword">else</span> <span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">               <span class="keyword">if</span> cerr := pc.canceled(); cerr != <span class="literal">nil</span> &#123;</span><br><span class="line">                  <span class="keyword">return</span> cerr</span><br><span class="line">               &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">return</span> err</span><br><span class="line">         &#125;,</span><br><span class="line">      &#125;</span><br><span class="line"></span><br><span class="line">      <span class="comment">// 组装resp</span></span><br><span class="line">      resp.Body = body</span><br><span class="line">      <span class="keyword">if</span> rc.addedGzip &amp;&amp; strings.EqualFold(resp.Header.Get(<span class="string">"Content-Encoding"</span>), <span class="string">"gzip"</span>) &#123;</span><br><span class="line">         resp.Body = &amp;gzipReader&#123;body: body&#125;</span><br><span class="line">         resp.Header.Del(<span class="string">"Content-Encoding"</span>)</span><br><span class="line">         resp.Header.Del(<span class="string">"Content-Length"</span>)</span><br><span class="line">         resp.ContentLength = <span class="number">-1</span></span><br><span class="line">         resp.Uncompressed = <span class="literal">true</span></span><br><span class="line">      &#125;</span><br><span class="line"></span><br><span class="line">      <span class="comment">// 将resp通过chan返回给 persistConn.roundTrip 函数</span></span><br><span class="line">      <span class="keyword">select</span> &#123;</span><br><span class="line">      <span class="keyword">case</span> rc.ch &lt;- responseAndError&#123;res: resp&#125;:</span><br><span class="line">      <span class="keyword">case</span> &lt;-rc.callerGone:</span><br><span class="line">         <span class="keyword">return</span></span><br><span class="line">      &#125;</span><br><span class="line"></span><br><span class="line">      <span class="comment">// Before looping back to the top of this function and peeking on</span></span><br><span class="line">      <span class="comment">// the bufio.Reader, wait for the caller goroutine to finish</span></span><br><span class="line">      <span class="comment">// reading the response body. (or for cancelation or death)</span></span><br><span class="line">      <span class="comment">// 阻塞在这里，等待 请求 body close 或 请求cancel 或 context done 或 pc.closech</span></span><br><span class="line">      <span class="keyword">select</span> &#123;</span><br><span class="line">      <span class="keyword">case</span> bodyEOF := &lt;-waitForBodyRead:</span><br><span class="line">         pc.t.setReqCanceler(rc.req, <span class="literal">nil</span>) <span class="comment">// before pc might return to idle pool</span></span><br><span class="line">         alive = alive &amp;&amp;</span><br><span class="line">            bodyEOF &amp;&amp;</span><br><span class="line">            !pc.sawEOF &amp;&amp;</span><br><span class="line">            pc.wroteRequest() &amp;&amp;</span><br><span class="line">            tryPutIdleConn(trace)</span><br><span class="line">         <span class="keyword">if</span> bodyEOF &#123;</span><br><span class="line">            eofc &lt;- <span class="keyword">struct</span>&#123;&#125;&#123;&#125;</span><br><span class="line">         &#125;</span><br><span class="line">      <span class="keyword">case</span> &lt;-rc.req.Cancel:</span><br><span class="line">         alive = <span class="literal">false</span></span><br><span class="line">         pc.t.CancelRequest(rc.req)</span><br><span class="line">      <span class="keyword">case</span> &lt;-rc.req.Context().Done():</span><br><span class="line">         alive = <span class="literal">false</span></span><br><span class="line">         pc.t.cancelRequest(rc.req, rc.req.Context().Err())</span><br><span class="line">      <span class="keyword">case</span> &lt;-pc.closech:</span><br><span class="line">         alive = <span class="literal">false</span></span><br><span class="line">      &#125;</span><br><span class="line"></span><br><span class="line">      testHookReadLoopBeforeNextRead()</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h5 id="persistConn-writeLoop"><a href="#persistConn-writeLoop" class="headerlink" title="persistConn.writeLoop"></a>persistConn.writeLoop</h5><p>相对于<code>persistConn.readLoop</code>， 这个函数就简单很多，其主要功能也就是往连接里面写request请求</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(pc *persistConn)</span> <span class="title">writeLoop</span><span class="params">()</span></span> &#123;</span><br><span class="line">   <span class="keyword">defer</span> <span class="built_in">close</span>(pc.writeLoopDone)</span><br><span class="line">   <span class="keyword">for</span> &#123;</span><br><span class="line">      <span class="keyword">select</span> &#123;</span><br><span class="line">      <span class="comment">// 首先通过pc.writech chan 从 persistConn.roundTrip 函数中获取 writeRequest, 可以简单理解为 request</span></span><br><span class="line">      <span class="keyword">case</span> wr := &lt;-pc.writech:</span><br><span class="line">         startBytesWritten := pc.nwrite</span><br><span class="line">         err := wr.req.Request.write(pc.bw, pc.isProxy, wr.req.extra, pc.waitForContinue(wr.continueCh))</span><br><span class="line">         <span class="keyword">if</span> bre, ok := err.(requestBodyReadError); ok &#123;</span><br><span class="line">            err = bre.error</span><br><span class="line">            <span class="comment">// Errors reading from the user's</span></span><br><span class="line">            <span class="comment">// Request.Body are high priority.</span></span><br><span class="line">            <span class="comment">// Set it here before sending on the</span></span><br><span class="line">            <span class="comment">// channels below or calling</span></span><br><span class="line">            <span class="comment">// pc.close() which tears town</span></span><br><span class="line">            <span class="comment">// connections and causes other</span></span><br><span class="line">            <span class="comment">// errors.</span></span><br><span class="line">            wr.req.setError(err)</span><br><span class="line">         &#125;</span><br><span class="line">         <span class="keyword">if</span> err == <span class="literal">nil</span> &#123;</span><br><span class="line">            err = pc.bw.Flush()</span><br><span class="line">         &#125;</span><br><span class="line">         <span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">            wr.req.Request.closeBody()</span><br><span class="line">            <span class="keyword">if</span> pc.nwrite == startBytesWritten &#123;</span><br><span class="line">               err = nothingWrittenError&#123;err&#125;</span><br><span class="line">            &#125;</span><br><span class="line">         &#125;</span><br><span class="line">         <span class="comment">// 把 err 通过 chan 返回给 persistConn.roundTrip 函数，persistConn.roundTrip 函数判断 err是否为 nil及相应的处理</span></span><br><span class="line">         pc.writeErrCh &lt;- err <span class="comment">// to the body reader, which might recycle us</span></span><br><span class="line">         wr.ch &lt;- err         <span class="comment">// to the roundTrip function</span></span><br><span class="line">         <span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">            <span class="comment">// 如果 写入请求出现错误，这里关闭，pc.closech chan，readLoop的第151行就会停止阻塞，将alive设为false，进而结束循环，终止 readLoop的goroutine</span></span><br><span class="line">            pc.<span class="built_in">close</span>(err)</span><br><span class="line">            <span class="keyword">return</span></span><br><span class="line">         &#125;</span><br><span class="line">      <span class="keyword">case</span> &lt;-pc.closech:</span><br><span class="line">         <span class="comment">// 这里结束阻塞，是由 readLoop 结束是，调用 第3行的 defer函数，关闭 pc.closech chan 导致的</span></span><br><span class="line">         <span class="keyword">return</span></span><br><span class="line">      &#125;</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="persistConn-roundTrip"><a href="#persistConn-roundTrip" class="headerlink" title="persistConn.roundTrip"></a>persistConn.roundTrip</h3><p>无论是 <code>persistConn.readLoop</code> 还是 <code>persistConn.writeLoop</code> 都避免不了和这个函数交互，这个函数的重要性也就不言而喻了</p><p>但是 这个函数的主要逻辑就是 创建个连接的 writeRequest chan， 也就是 writeLoop 用到的chan，然后把request 通过这个 chan 传给  <code>persistConn.writeLoop</code> ，然后 在创建一个 responseAndError chan，也就是 readLoop 用到的chan，从 这个chan中获取  <code>persistConn.readLoop</code>  获取到的 response，最后把 response返回给上层函数</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(pc *persistConn)</span> <span class="title">roundTrip</span><span class="params">(req *transportRequest)</span> <span class="params">(resp *Response, err error)</span></span> &#123;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 设置 request的头信息，cancel函数，省略....</span></span><br><span class="line">  </span><br><span class="line"><span class="keyword">var</span> continueCh <span class="keyword">chan</span> <span class="keyword">struct</span>&#123;&#125;</span><br><span class="line"><span class="keyword">if</span> req.ProtoAtLeast(<span class="number">1</span>, <span class="number">1</span>) &amp;&amp; req.Body != <span class="literal">nil</span> &amp;&amp; req.expectsContinue() &#123;</span><br><span class="line">continueCh = <span class="built_in">make</span>(<span class="keyword">chan</span> <span class="keyword">struct</span>&#123;&#125;, <span class="number">1</span>)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">gone := <span class="built_in">make</span>(<span class="keyword">chan</span> <span class="keyword">struct</span>&#123;&#125;)</span><br><span class="line"><span class="keyword">defer</span> <span class="built_in">close</span>(gone)</span><br><span class="line"></span><br><span class="line"><span class="keyword">defer</span> <span class="function"><span class="keyword">func</span><span class="params">()</span></span> &#123;</span><br><span class="line"><span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">pc.t.setReqCanceler(req.Request, <span class="literal">nil</span>)</span><br><span class="line">&#125;</span><br><span class="line">&#125;()</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> debugRoundTrip = <span class="literal">false</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// Write the request concurrently with waiting for a response,</span></span><br><span class="line"><span class="comment">// in case the server decides to reply before reading our full</span></span><br><span class="line"><span class="comment">// request body.</span></span><br><span class="line">startBytesWritten := pc.nwrite</span><br><span class="line">writeErrCh := <span class="built_in">make</span>(<span class="keyword">chan</span> error, <span class="number">1</span>)</span><br><span class="line">  <span class="comment">// 把 request 放入 writech chan 里面，这样， `persistConn.writeLoop` 的第6行就可以拿到 request，往 连接 里面写入请求信息了</span></span><br><span class="line">pc.writech &lt;- writeRequest&#123;req, writeErrCh, continueCh&#125;</span><br><span class="line">  </span><br><span class="line">  <span class="comment">// 定义responseAndError chan，并放入 reqch chan 里面，这样  `persistConn.readLoop` 的第46行，也就是 m1标记的地方，就可以解除阻塞，开始获取 response的逻辑了</span></span><br><span class="line">resc := <span class="built_in">make</span>(<span class="keyword">chan</span> responseAndError)</span><br><span class="line">pc.reqch &lt;- requestAndChan&#123;</span><br><span class="line">req:        req.Request,</span><br><span class="line">ch:         resc,</span><br><span class="line">addedGzip:  requestedGzip,</span><br><span class="line">continueCh: continueCh,</span><br><span class="line">callerGone: gone,</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> respHeaderTimer &lt;-<span class="keyword">chan</span> time.Time</span><br><span class="line">cancelChan := req.Request.Cancel</span><br><span class="line">ctxDoneChan := req.Context().Done()</span><br><span class="line">  <span class="comment">// 阻塞在这里，直到 获取 writeLoop 返回的写入错误或 pc.closech的关闭信息，连接超时的信息或 readLoop的 resp或cancel或ctx done的信息</span></span><br><span class="line"><span class="keyword">for</span> &#123;</span><br><span class="line">testHookWaitResLoop()</span><br><span class="line"><span class="keyword">select</span> &#123;</span><br><span class="line">    <span class="comment">// 这里获取到 writeLoop的写入信息，可能是err，也可能不是，下面做对应的处理</span></span><br><span class="line"><span class="keyword">case</span> err := &lt;-writeErrCh:</span><br><span class="line"><span class="keyword">if</span> debugRoundTrip &#123;</span><br><span class="line">req.logf(<span class="string">"writeErrCh resv: %T/%#v"</span>, err, err)</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">pc.<span class="built_in">close</span>(fmt.Errorf(<span class="string">"write error: %v"</span>, err))</span><br><span class="line"><span class="keyword">return</span> <span class="literal">nil</span>, pc.mapRoundTripError(req, startBytesWritten, err)</span><br><span class="line">&#125;</span><br><span class="line">      <span class="comment">// 写入request没有问题，判断是否有超时</span></span><br><span class="line"><span class="keyword">if</span> d := pc.t.ResponseHeaderTimeout; d &gt; <span class="number">0</span> &#123;</span><br><span class="line"><span class="keyword">if</span> debugRoundTrip &#123;</span><br><span class="line">req.logf(<span class="string">"starting timer for %v"</span>, d)</span><br><span class="line">&#125;</span><br><span class="line">timer := time.NewTimer(d)</span><br><span class="line"><span class="keyword">defer</span> timer.Stop() <span class="comment">// prevent leaks</span></span><br><span class="line">respHeaderTimer = timer.C</span><br><span class="line">&#125;</span><br><span class="line">      <span class="comment">// 到此获取到了 writeLoop的信息，但是并没有return，进入下一个循环</span></span><br><span class="line"><span class="keyword">case</span> &lt;-pc.closech:</span><br><span class="line">      <span class="comment">// closech的关闭信息</span></span><br><span class="line"><span class="keyword">if</span> debugRoundTrip &#123;</span><br><span class="line">req.logf(<span class="string">"closech recv: %T %#v"</span>, pc.closed, pc.closed)</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> <span class="literal">nil</span>, pc.mapRoundTripError(req, startBytesWritten, pc.closed)</span><br><span class="line"><span class="keyword">case</span> &lt;-respHeaderTimer:</span><br><span class="line">      <span class="comment">// 等待超时的信息</span></span><br><span class="line"><span class="keyword">if</span> debugRoundTrip &#123;</span><br><span class="line">req.logf(<span class="string">"timeout waiting for response headers."</span>)</span><br><span class="line">&#125;</span><br><span class="line">pc.<span class="built_in">close</span>(errTimeout)</span><br><span class="line"><span class="keyword">return</span> <span class="literal">nil</span>, errTimeout</span><br><span class="line"><span class="keyword">case</span> re := &lt;-resc:</span><br><span class="line">      <span class="comment">// 从 readLoop获取到 response</span></span><br><span class="line"><span class="keyword">if</span> (re.res == <span class="literal">nil</span>) == (re.err == <span class="literal">nil</span>) &#123;</span><br><span class="line"><span class="built_in">panic</span>(fmt.Sprintf(<span class="string">"internal error: exactly one of res or err should be set; nil=%v"</span>, re.res == <span class="literal">nil</span>))</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span> debugRoundTrip &#123;</span><br><span class="line">req.logf(<span class="string">"resc recv: %p, %T/%#v"</span>, re.res, re.err, re.err)</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span> re.err != <span class="literal">nil</span> &#123;</span><br><span class="line"><span class="keyword">return</span> <span class="literal">nil</span>, pc.mapRoundTripError(req, startBytesWritten, re.err)</span><br><span class="line">&#125;</span><br><span class="line">      <span class="comment">// 返回 response，这里结束循环</span></span><br><span class="line"><span class="keyword">return</span> re.res, <span class="literal">nil</span></span><br><span class="line"><span class="keyword">case</span> &lt;-cancelChan:</span><br><span class="line">pc.t.CancelRequest(req.Request)</span><br><span class="line">cancelChan = <span class="literal">nil</span></span><br><span class="line"><span class="keyword">case</span> &lt;-ctxDoneChan:</span><br><span class="line">pc.t.cancelRequest(req.Request, req.Context().Err())</span><br><span class="line">cancelChan = <span class="literal">nil</span></span><br><span class="line">ctxDoneChan = <span class="literal">nil</span></span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="交互图示"><a href="#交互图示" class="headerlink" title="交互图示"></a>交互图示</h2><p>上面 <code>persistConn.roundTrip</code> <code>persistConn.readLoop</code> <code>persistConn.writeLoop</code> 之间的数据交互，可能靠语言比较苍白，这里画一下图示</p><p><img src="http://note-1253518569.cossh.myqcloud.com/20190717221524.png" alt></p><h2 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h2><p>综上分析，可以发现，readLoop和 writeLoop 两个goroutine在 写入请求并获取response返回后，并没有跳出for循环，而继续阻塞在 下一次for循环的select 语句里面，所以，两个函数所在的goroutine并没有运行结束，导致了最开的现象: goroutine持续增加导致内存持续增加</p><h1 id="Close流程"><a href="#Close流程" class="headerlink" title="Close流程"></a>Close流程</h1><h2 id="close"><a href="#close" class="headerlink" title="close"></a>close</h2><p>close的主要逻辑是通过调用 <code>readLoop</code> 的第89行定义的earlyCloseFn 方法， 向 waitForBodyRead 的chan写入false，进而让 <code>readLoop</code> 退出阻塞，终止 <code>readLoop</code> 的 goroutine</p><p> <code>readLoop</code>  退出的时候，关闭 closech chan，进而让 <code>writeLoop</code> 退出阻塞，终止 <code>writeLoop</code> 的goroutine</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(es *bodyEOFSignal)</span> <span class="title">Close</span><span class="params">()</span> <span class="title">error</span></span> &#123;</span><br><span class="line">es.mu.Lock()</span><br><span class="line"><span class="keyword">defer</span> es.mu.Unlock()</span><br><span class="line"><span class="keyword">if</span> es.closed &#123;</span><br><span class="line"><span class="keyword">return</span> <span class="literal">nil</span></span><br><span class="line">&#125;</span><br><span class="line">es.closed = <span class="literal">true</span></span><br><span class="line"><span class="keyword">if</span> es.earlyCloseFn != <span class="literal">nil</span> &amp;&amp; es.rerr != io.EOF &#123;</span><br><span class="line">    <span class="comment">// 调用 readLoop定义的函数处理</span></span><br><span class="line"><span class="keyword">return</span> es.earlyCloseFn()</span><br><span class="line">&#125;</span><br><span class="line">err := es.body.Close()</span><br><span class="line"><span class="keyword">return</span> es.condfn(err)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>##earlyCloseFn</p><p>定义的 earlyCloseFn 方法</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">body := &amp;bodyEOFSignal&#123;</span><br><span class="line">   body: resp.Body,</span><br><span class="line">   earlyCloseFn: <span class="function"><span class="keyword">func</span><span class="params">()</span> <span class="title">error</span></span> &#123;</span><br><span class="line">     <span class="comment">// 向 waiForBody 的chan 中写入 false</span></span><br><span class="line">      waitForBodyRead &lt;- <span class="literal">false</span></span><br><span class="line">      &lt;-eofc <span class="comment">// will be closed by deferred call at the end of the function</span></span><br><span class="line">      <span class="keyword">return</span> <span class="literal">nil</span></span><br><span class="line"></span><br><span class="line">   &#125;,</span><br><span class="line">   fn: <span class="function"><span class="keyword">func</span><span class="params">(err error)</span> <span class="title">error</span></span> &#123;</span><br><span class="line">      isEOF := err == io.EOF</span><br><span class="line">      waitForBodyRead &lt;- isEOF</span><br><span class="line">      <span class="keyword">if</span> isEOF &#123;</span><br><span class="line">         &lt;-eofc <span class="comment">// see comment above eofc declaration</span></span><br><span class="line">      &#125; <span class="keyword">else</span> <span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">         <span class="keyword">if</span> cerr := pc.canceled(); cerr != <span class="literal">nil</span> &#123;</span><br><span class="line">            <span class="keyword">return</span> cerr</span><br><span class="line">         &#125;</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="keyword">return</span> err</span><br><span class="line">   &#125;,</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="结束readLoop"><a href="#结束readLoop" class="headerlink" title="结束readLoop"></a>结束readLoop</h2><p>回过头来看 <code>readLoop</code> 阻塞的代码</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">select</span> &#123;</span><br><span class="line"><span class="keyword">case</span> bodyEOF := &lt;-waitForBodyRead:</span><br><span class="line">  <span class="comment">// 这里的 waitForBodyRead 接收到 earlyCloseFn 传递过来的 false，并赋值给 bodyEOF</span></span><br><span class="line">pc.t.setReqCanceler(rc.req, <span class="literal">nil</span>) <span class="comment">// before pc might return to idle pool</span></span><br><span class="line">  <span class="comment">// bodyEOF 为 false，整个表达式的 值为 false，从而退出整个for循环，结束 当前goroutine</span></span><br><span class="line">alive = alive &amp;&amp;</span><br><span class="line">bodyEOF &amp;&amp;</span><br><span class="line">!pc.sawEOF &amp;&amp;</span><br><span class="line">pc.wroteRequest() &amp;&amp;</span><br><span class="line">tryPutIdleConn(trace)</span><br><span class="line"><span class="keyword">if</span> bodyEOF &#123;</span><br><span class="line">eofc &lt;- <span class="keyword">struct</span>&#123;&#125;&#123;&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">case</span> &lt;-rc.req.Cancel:</span><br><span class="line">alive = <span class="literal">false</span></span><br><span class="line">pc.t.CancelRequest(rc.req)</span><br><span class="line"><span class="keyword">case</span> &lt;-rc.req.Context().Done():</span><br><span class="line">alive = <span class="literal">false</span></span><br><span class="line">pc.t.cancelRequest(rc.req, rc.req.Context().Err())</span><br><span class="line"><span class="keyword">case</span> &lt;-pc.closech:</span><br><span class="line">alive = <span class="literal">false</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>当 <code>readLoop</code> 退出的时候，调用函数最开始定义的 defer 函数</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">defer</span> <span class="function"><span class="keyword">func</span><span class="params">()</span></span> &#123;</span><br><span class="line">   <span class="comment">// 这里的 close 把 pc.closech chan 关闭 （有兴趣的可以追一下，不难），进而影响 writeLoop 的阻塞</span></span><br><span class="line">pc.<span class="built_in">close</span>(closeErr)</span><br><span class="line">pc.t.removeIdleConn(pc)</span><br><span class="line">&#125;()</span><br></pre></td></tr></table></figure><h2 id="结束writeLoop"><a href="#结束writeLoop" class="headerlink" title="结束writeLoop"></a>结束writeLoop</h2><p>继续看一下 <code>writeLoop</code> 阻塞的代码</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">select</span> &#123;</span><br><span class="line"><span class="keyword">case</span> wr := &lt;-pc.writech:</span><br><span class="line">startBytesWritten := pc.nwrite</span><br><span class="line">err := wr.req.Request.write(pc.bw, pc.isProxy, wr.req.extra, pc.waitForContinue(wr.continueCh))</span><br><span class="line"><span class="keyword">if</span> bre, ok := err.(requestBodyReadError); ok &#123;</span><br><span class="line">err = bre.error</span><br><span class="line"><span class="comment">// Errors reading from the user's</span></span><br><span class="line"><span class="comment">// Request.Body are high priority.</span></span><br><span class="line"><span class="comment">// Set it here before sending on the</span></span><br><span class="line"><span class="comment">// channels below or calling</span></span><br><span class="line"><span class="comment">// pc.close() which tears town</span></span><br><span class="line"><span class="comment">// connections and causes other</span></span><br><span class="line"><span class="comment">// errors.</span></span><br><span class="line">wr.req.setError(err)</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span> err == <span class="literal">nil</span> &#123;</span><br><span class="line">err = pc.bw.Flush()</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">wr.req.Request.closeBody()</span><br><span class="line"><span class="keyword">if</span> pc.nwrite == startBytesWritten &#123;</span><br><span class="line">err = nothingWrittenError&#123;err&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">pc.writeErrCh &lt;- err <span class="comment">// to the body reader, which might recycle us</span></span><br><span class="line">wr.ch &lt;- err         <span class="comment">// to the roundTrip function</span></span><br><span class="line"><span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">pc.<span class="built_in">close</span>(err)</span><br><span class="line"><span class="keyword">return</span></span><br><span class="line">&#125;</span><br><span class="line">  <span class="comment">// 在 上面 readLoop 关闭 pc.closech chan 后，这里就直接return了，循环终止，结束当前goroutine</span></span><br><span class="line"><span class="keyword">case</span> &lt;-pc.closech:</span><br><span class="line"><span class="keyword">return</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> Go </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Go </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>深入理解Go-内存分配</title>
      <link href="/posts/19281/"/>
      <url>/posts/19281/</url>
      
        <content type="html"><![CDATA[<p>Go语言内置运行时（就是runtime），抛弃了传统的内存分配方式，改为自主管理，最开始是基于tcmalloc，虽然后面改动相对已经很大了。使用自主管理可以实现更好的内存使用模式，比如内存池、预分配等等，从而避免了系统调用所带来的性能问题。</p><a id="more"></a><p>在了解Go的内存分配之前，我们可以看一下内存分配的基本策略，来帮助我们理解Go的内存分配</p><p>基本策略：</p><ol><li>每次从操作系统申请一大块内存，以减少系统调用</li><li>将申请的大块内存按照特定大小预先切成小块，构成链表</li><li>为对象分配内存时，从大小合适的链表中提取一块即可</li><li>如果对象销毁，则将对象占用的内存，归还到原链表，以便复用</li><li>如果限制内存过多，则尝试归还部分给操作系统，降低整体开销</li></ol><p>下面我们从源码角度来分析Go的内存分配策略有何异同</p><h1 id="准备"><a href="#准备" class="headerlink" title="准备"></a>准备</h1><p>在追踪源码之前，我们需要首先了解一些概念和结构体</p><ul><li>span: 又多个地址连续的页（page）组成的大块内存</li><li>object: 将span按特定大小切分成多个小块，每个小块可存储一个对象</li></ul><h2 id="对象分类"><a href="#对象分类" class="headerlink" title="对象分类"></a>对象分类</h2><ul><li>小对象（tiny）: size &lt; 16byte</li><li>普通对象： 16byte ~ 32K</li><li>大对象（large）： size &gt; 32K</li></ul><h2 id="大小转换"><a href="#大小转换" class="headerlink" title="大小转换"></a>大小转换</h2><p><img src="http://note-1253518569.cossh.myqcloud.com/20190715112737.png" alt></p><h2 id="结构体"><a href="#结构体" class="headerlink" title="结构体"></a>结构体</h2><h3 id="mHeap"><a href="#mHeap" class="headerlink" title="mHeap"></a>mHeap</h3><p>代表Go程序持有的所有堆空间，Go程序使用一个<code>mheap</code>的全局对象<code>_mheap</code>来管理堆内存。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> mheap <span class="keyword">struct</span> &#123;</span><br><span class="line">lock      mutex</span><br><span class="line">free      [_MaxMHeapList]mSpanList <span class="comment">// page在127以内的闲置的span列表</span></span><br><span class="line">freelarge mTreap                   <span class="comment">// page数大于127的大span组成的树状结构体</span></span><br><span class="line">busy      [_MaxMHeapList]mSpanList <span class="comment">// page在127以内的已分配的span列表</span></span><br><span class="line">busylarge mSpanList                <span class="comment">// page数大于127的已分配的大span组成的列表</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// allspans is a slice of all mspans ever created. Each mspan</span></span><br><span class="line"><span class="comment">// appears exactly once.</span></span><br><span class="line"><span class="comment">// 所有创建过的mspan的slice</span></span><br><span class="line">allspans []*mspan <span class="comment">// all spans out there</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// arenas is the heap arena map. It points to the metadata for</span></span><br><span class="line"><span class="comment">// the heap for every arena frame of the entire usable virtual</span></span><br><span class="line"><span class="comment">// address space.</span></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="comment">// Use arenaIndex to compute indexes into this array.</span></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="comment">// For regions of the address space that are not backed by the</span></span><br><span class="line"><span class="comment">// Go heap, the arena map contains nil.</span></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="comment">// Modifications are protected by mheap_.lock. Reads can be</span></span><br><span class="line"><span class="comment">// performed without locking; however, a given entry can</span></span><br><span class="line"><span class="comment">// transition from nil to non-nil at any time when the lock</span></span><br><span class="line"><span class="comment">// isn't held. (Entries never transitions back to nil.)</span></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="comment">// In general, this is a two-level mapping consisting of an L1</span></span><br><span class="line"><span class="comment">// map and possibly many L2 maps. This saves space when there</span></span><br><span class="line"><span class="comment">// are a huge number of arena frames. However, on many</span></span><br><span class="line"><span class="comment">// platforms (even 64-bit), arenaL1Bits is 0, making this</span></span><br><span class="line"><span class="comment">// effectively a single-level map. In this case, arenas[0]</span></span><br><span class="line"><span class="comment">// will never be nil.</span></span><br><span class="line"><span class="comment">// 一组heapArena组成，每一个heapArena都包含了连续的pagesPerArena个span，这个主要是为mheap管理span和垃圾回收服务，heapArena也有介绍</span></span><br><span class="line">arenas [<span class="number">1</span> &lt;&lt; arenaL1Bits]*[<span class="number">1</span> &lt;&lt; arenaL2Bits]*heapArena</span><br><span class="line"></span><br><span class="line"><span class="comment">// heapArenaAlloc is pre-reserved space for allocating heapArena</span></span><br><span class="line"><span class="comment">// objects. This is only used on 32-bit, where we pre-reserve</span></span><br><span class="line"><span class="comment">// this space to avoid interleaving it with the heap itself.</span></span><br><span class="line"><span class="comment">// 预先分配的 heapArena 对象的地址</span></span><br><span class="line">heapArenaAlloc linearAlloc</span><br><span class="line"></span><br><span class="line"><span class="comment">// arenaHints is a list of addresses at which to attempt to</span></span><br><span class="line"><span class="comment">// add more heap arenas. This is initially populated with a</span></span><br><span class="line"><span class="comment">// set of general hint addresses, and grown with the bounds of</span></span><br><span class="line"><span class="comment">// actual heap arena ranges.</span></span><br><span class="line">arenaHints *arenaHint</span><br><span class="line"></span><br><span class="line"><span class="comment">// arena is a pre-reserved space for allocating heap arenas</span></span><br><span class="line"><span class="comment">// (the actual arenas). This is only used on 32-bit.</span></span><br><span class="line"><span class="comment">// 仅32位使用</span></span><br><span class="line">arena linearAlloc</span><br><span class="line"></span><br><span class="line"><span class="comment">//_ uint32 // ensure 64-bit alignment of central</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// central free lists for small size classes.</span></span><br><span class="line"><span class="comment">// the padding makes sure that the MCentrals are</span></span><br><span class="line"><span class="comment">// spaced CacheLineSize bytes apart, so that each MCentral.lock</span></span><br><span class="line"><span class="comment">// gets its own cache line.</span></span><br><span class="line"><span class="comment">// central is indexed by spanClass.</span></span><br><span class="line"><span class="comment">// mcentral 内存分配中心，mcache没有足够的内存分配的时候，会从mcentral分配</span></span><br><span class="line">central [numSpanClasses]<span class="keyword">struct</span> &#123;</span><br><span class="line">mcentral mcentral</span><br><span class="line">pad      [sys.CacheLineSize - unsafe.Sizeof(mcentral&#123;&#125;)%sys.CacheLineSize]<span class="keyword">byte</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">spanalloc             fixalloc <span class="comment">// allocator for span*</span></span><br><span class="line">cachealloc            fixalloc <span class="comment">// allocator for mcache*</span></span><br><span class="line">treapalloc            fixalloc <span class="comment">// allocator for treapNodes* used by large objects</span></span><br><span class="line">specialfinalizeralloc fixalloc <span class="comment">// allocator for specialfinalizer*</span></span><br><span class="line">specialprofilealloc   fixalloc <span class="comment">// allocator for specialprofile*</span></span><br><span class="line">speciallock           mutex    <span class="comment">// lock for special record allocators.</span></span><br><span class="line">arenaHintAlloc        fixalloc <span class="comment">// allocator for arenaHints</span></span><br><span class="line"></span><br><span class="line">unused *specialfinalizer <span class="comment">// never set, just here to force the specialfinalizer type into DWARF</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="mSpanList"><a href="#mSpanList" class="headerlink" title="mSpanList"></a>mSpanList</h3><p>mSpan的链表，<code>free</code> <code>busy</code> <code>busyLarge</code> 上的mSpan都是通过链表串联起来的</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">type mSpanList struct &#123;</span><br><span class="line">first *mspan // first span in list, or nil if none</span><br><span class="line">last  *mspan // last span in list, or nil if none</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="mSpan"><a href="#mSpan" class="headerlink" title="mSpan"></a>mSpan</h3><p>Go中内存管理的基本单元，是由一片连续的<code>8KB</code>的页组成的大块内存。注意，这里的页和操作系统本身的页并不是一回事，它一般是操作系统页大小的几倍。一句话概括：<code>mspan</code>是一个包含起始地址、<code>mspan</code>规格、页的数量等内容的双端链表。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> mspan <span class="keyword">struct</span> &#123;</span><br><span class="line">next *mspan     <span class="comment">// next span in list, or nil if none</span></span><br><span class="line">prev *mspan     <span class="comment">// previous span in list, or nil if none</span></span><br><span class="line">list *mSpanList <span class="comment">// For debugging. <span class="doctag">TODO:</span> Remove.</span></span><br><span class="line"></span><br><span class="line">startAddr <span class="keyword">uintptr</span> <span class="comment">// address of first byte of span aka s.base()</span></span><br><span class="line"><span class="comment">// 该span锁包含的页数</span></span><br><span class="line">npages    <span class="keyword">uintptr</span> <span class="comment">// number of pages in span</span></span><br><span class="line"></span><br><span class="line">manualFreeList gclinkptr <span class="comment">// list of free objects in _MSpanManual spans</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// freeindex is the slot index between 0 and nelems at which to begin scanning</span></span><br><span class="line"><span class="comment">// for the next free object in this span.</span></span><br><span class="line"><span class="comment">// Each allocation scans allocBits starting at freeindex until it encounters a 0</span></span><br><span class="line"><span class="comment">// indicating a free object. freeindex is then adjusted so that subsequent scans begin</span></span><br><span class="line"><span class="comment">// just past the newly discovered free object.</span></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="comment">// If freeindex == nelem, this span has no free objects.</span></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="comment">// allocBits is a bitmap of objects in this span.</span></span><br><span class="line"><span class="comment">// If n &gt;= freeindex and allocBits[n/8] &amp; (1&lt;&lt;(n%8)) is 0</span></span><br><span class="line"><span class="comment">// then object n is free;</span></span><br><span class="line"><span class="comment">// otherwise, object n is allocated. Bits starting at nelem are</span></span><br><span class="line"><span class="comment">// undefined and should never be referenced.</span></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="comment">// Object n starts at address n*elemsize + (start &lt;&lt; pageShift).</span></span><br><span class="line"><span class="comment">// 用于定位下一个可用的object, 大小范围在 0- nelems 之间</span></span><br><span class="line">freeindex <span class="keyword">uintptr</span></span><br><span class="line"><span class="comment">// <span class="doctag">TODO:</span> Look up nelems from sizeclass and remove this field if it</span></span><br><span class="line"><span class="comment">// helps performance.</span></span><br><span class="line"><span class="comment">// span里object的数量</span></span><br><span class="line">nelems <span class="keyword">uintptr</span> <span class="comment">// number of object in the span.</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// Cache of the allocBits at freeindex. allocCache is shifted</span></span><br><span class="line"><span class="comment">// such that the lowest bit corresponds to the bit freeindex.</span></span><br><span class="line"><span class="comment">// allocCache holds the complement of allocBits, thus allowing</span></span><br><span class="line"><span class="comment">// ctz (count trailing zero) to use it directly.</span></span><br><span class="line"><span class="comment">// allocCache may contain bits beyond s.nelems; the caller must ignore</span></span><br><span class="line"><span class="comment">// these.</span></span><br><span class="line"><span class="comment">// 用于缓存freeindex开始的bitmap, 缓存的bit值与原值相反，ctz函数可以通过这个值快速计算出下一个 free object的index</span></span><br><span class="line">allocCache <span class="keyword">uint64</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 分配位图，每一位代表每一块是否已经分配</span></span><br><span class="line">allocBits  *gcBits</span><br><span class="line"></span><br><span class="line"><span class="comment">// 已经分配的object的数量</span></span><br><span class="line">allocCount  <span class="keyword">uint16</span>     <span class="comment">// number of allocated objects</span></span><br><span class="line"></span><br><span class="line">elemsize    <span class="keyword">uintptr</span>    <span class="comment">// computed from sizeclass or from npages</span></span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="spanClass"><a href="#spanClass" class="headerlink" title="spanClass"></a>spanClass</h3><p>class表中的class ID，和Size Classs相关</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> spanClass <span class="keyword">uint8</span></span><br></pre></td></tr></table></figure><h3 id="mTreap"><a href="#mTreap" class="headerlink" title="mTreap"></a>mTreap</h3><p>这个结构是包含mspan的树状结构，主要是给 freeLarge使用，在查找对应classsize的大对象的时候，使用树状结构查找要比链表更快</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> mTreap <span class="keyword">struct</span> &#123;</span><br><span class="line">treap *treapNode</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="mtreapNode"><a href="#mtreapNode" class="headerlink" title="mtreapNode"></a>mtreapNode</h3><p>mTreap结构的节点，节点信息包含mspan和左右子节点等信息</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> treapNode <span class="keyword">struct</span> &#123;</span><br><span class="line">right     *treapNode <span class="comment">// all treapNodes &gt; this treap node</span></span><br><span class="line">left      *treapNode <span class="comment">// all treapNodes &lt; this treap node</span></span><br><span class="line">parent    *treapNode <span class="comment">// direct parent of this node, nil if root</span></span><br><span class="line">npagesKey <span class="keyword">uintptr</span>    <span class="comment">// number of pages in spanKey, used as primary sort key</span></span><br><span class="line">spanKey   *mspan     <span class="comment">// span of size npagesKey, used as secondary sort key</span></span><br><span class="line">priority  <span class="keyword">uint32</span>     <span class="comment">// random number used by treap algorithm to keep tree probabilistically balanced</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="heapArena"><a href="#heapArena" class="headerlink" title="heapArena"></a>heapArena</h3><p>heapArena存储的是arena的元数据， arenas是一组heapArena构成，所有的分配的内存都在 <code>arenas</code> 里面，大致 arenas[L1][L2] = heapArena， 而对于 分配出去的内存的 address，通过 <code>arenaIndex</code> 可以计算出 <code>L1 L2</code>， 从而找到该内存所对应的 arenas[L1][L2]，即 heapArena</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> heapArena <span class="keyword">struct</span> &#123;</span><br><span class="line"><span class="comment">// bitmap stores the pointer/scalar bitmap for the words in</span></span><br><span class="line"><span class="comment">// this arena. See mbitmap.go for a description. Use the</span></span><br><span class="line"><span class="comment">// heapBits type to access this.</span></span><br><span class="line">bitmap [heapArenaBitmapBytes]<span class="keyword">byte</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// spans maps from virtual address page ID within this arena to *mspan.</span></span><br><span class="line"><span class="comment">// For allocated spans, their pages map to the span itself.</span></span><br><span class="line"><span class="comment">// For free spans, only the lowest and highest pages map to the span itself.</span></span><br><span class="line"><span class="comment">// Internal pages map to an arbitrary span.</span></span><br><span class="line"><span class="comment">// For pages that have never been allocated, spans entries are nil.</span></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="comment">// Modifications are protected by mheap.lock. Reads can be</span></span><br><span class="line"><span class="comment">// performed without locking, but ONLY from indexes that are</span></span><br><span class="line"><span class="comment">// known to contain in-use or stack spans. This means there</span></span><br><span class="line"><span class="comment">// must not be a safe-point between establishing that an</span></span><br><span class="line"><span class="comment">// address is live and looking it up in the spans array.</span></span><br><span class="line">spans [pagesPerArena]*mspan</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="arenaHint"><a href="#arenaHint" class="headerlink" title="arenaHint"></a>arenaHint</h3><p>这个是记录arena可以增长的地址</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> arenaHint <span class="keyword">struct</span> &#123;</span><br><span class="line">addr <span class="keyword">uintptr</span></span><br><span class="line"><span class="comment">// down 为 true，表示可以扩展arena的大小</span></span><br><span class="line">down <span class="keyword">bool</span></span><br><span class="line">next *arenaHint</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="mcentral"><a href="#mcentral" class="headerlink" title="mcentral"></a>mcentral</h3><p>mcentral则是全局资源，为多个线程服务，当某个线程内存不足时会向mcentral申请，当某个线程释放内存时又会回收进mcentral</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> mcentral <span class="keyword">struct</span> &#123;</span><br><span class="line">lock      mutex</span><br><span class="line">spanclass spanClass</span><br><span class="line"><span class="comment">// free object 的链表</span></span><br><span class="line">nonempty  mSpanList <span class="comment">// list of spans with a free object, ie a nonempty free list</span></span><br><span class="line"><span class="comment">// no free object 的链表</span></span><br><span class="line">empty     mSpanList <span class="comment">// list of spans with no free objects (or cached in an mcache)</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// nmalloc is the cumulative count of objects allocated from</span></span><br><span class="line"><span class="comment">// this mcentral, assuming all spans in mcaches are</span></span><br><span class="line"><span class="comment">// fully-allocated. Written atomically, read under STW.</span></span><br><span class="line">nmalloc <span class="keyword">uint64</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="结构图"><a href="#结构图" class="headerlink" title="结构图"></a>结构图</h2><p>接下来，我们结合一下宏观的图示来理解一下上面的结构体之间的关联，同时对于后面的内存分配有一个简单的了解，等到后面全部讲完后，在回过头来看看这幅图，可能会对Go的内存分配有更清晰的认知</p><p><img src="http://note-1253518569.cossh.myqcloud.com/20190715112554.png" alt></p><h1 id="初始化"><a href="#初始化" class="headerlink" title="初始化"></a>初始化</h1><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">mallocinit</span><span class="params">()</span></span> &#123;</span><br><span class="line"><span class="comment">// Initialize the heap.</span></span><br><span class="line"><span class="comment">// 初始化 mheap</span></span><br><span class="line">mheap_.init()</span><br><span class="line">_g_ := getg()</span><br><span class="line">  <span class="comment">// 获取当前g所在的m的mcache，并初始化</span></span><br><span class="line">_g_.m.mcache = allocmcache()</span><br><span class="line"><span class="keyword">for</span> i := <span class="number">0x7f</span>; i &gt;= <span class="number">0</span>; i-- &#123;</span><br><span class="line">  <span class="keyword">var</span> p <span class="keyword">uintptr</span></span><br><span class="line">  <span class="keyword">switch</span> &#123;</span><br><span class="line">  <span class="keyword">case</span> GOARCH == <span class="string">"arm64"</span> &amp;&amp; GOOS == <span class="string">"darwin"</span>:</span><br><span class="line">  p = <span class="keyword">uintptr</span>(i)&lt;&lt;<span class="number">40</span> | uintptrMask&amp;(<span class="number">0x0013</span>&lt;&lt;<span class="number">28</span>)</span><br><span class="line">  <span class="keyword">case</span> GOARCH == <span class="string">"arm64"</span>:</span><br><span class="line">  p = <span class="keyword">uintptr</span>(i)&lt;&lt;<span class="number">40</span> | uintptrMask&amp;(<span class="number">0x0040</span>&lt;&lt;<span class="number">32</span>)</span><br><span class="line">  <span class="keyword">case</span> raceenabled:</span><br><span class="line">    <span class="comment">// The TSAN runtime requires the heap</span></span><br><span class="line">    <span class="comment">// to be in the range [0x00c000000000,</span></span><br><span class="line">    <span class="comment">// 0x00e000000000).</span></span><br><span class="line">    p = <span class="keyword">uintptr</span>(i)&lt;&lt;<span class="number">32</span> | uintptrMask&amp;(<span class="number">0x00c0</span>&lt;&lt;<span class="number">32</span>)</span><br><span class="line">    <span class="keyword">if</span> p &gt;= uintptrMask&amp;<span class="number">0x00e000000000</span> &#123;</span><br><span class="line">      <span class="keyword">continue</span></span><br><span class="line">    &#125;</span><br><span class="line">  <span class="keyword">default</span>:</span><br><span class="line">  p = <span class="keyword">uintptr</span>(i)&lt;&lt;<span class="number">40</span> | uintptrMask&amp;(<span class="number">0x00c0</span>&lt;&lt;<span class="number">32</span>)</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">// 保存 arena相关属性</span></span><br><span class="line">  hint := (*arenaHint)(mheap_.arenaHintAlloc.alloc())</span><br><span class="line">  hint.addr = p</span><br><span class="line">  hint.next, mheap_.arenaHints = mheap_.arenaHints, hint</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="mheap-init"><a href="#mheap-init" class="headerlink" title="mheap.init"></a>mheap.init</h2><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(h *mheap)</span> <span class="title">init</span><span class="params">()</span></span> &#123;</span><br><span class="line">h.treapalloc.init(unsafe.Sizeof(treapNode&#123;&#125;), <span class="literal">nil</span>, <span class="literal">nil</span>, &amp;memstats.other_sys)</span><br><span class="line">h.spanalloc.init(unsafe.Sizeof(mspan&#123;&#125;), recordspan, unsafe.Pointer(h), &amp;memstats.mspan_sys)</span><br><span class="line">h.cachealloc.init(unsafe.Sizeof(mcache&#123;&#125;), <span class="literal">nil</span>, <span class="literal">nil</span>, &amp;memstats.mcache_sys)</span><br><span class="line">h.specialfinalizeralloc.init(unsafe.Sizeof(specialfinalizer&#123;&#125;), <span class="literal">nil</span>, <span class="literal">nil</span>, &amp;memstats.other_sys)</span><br><span class="line">h.specialprofilealloc.init(unsafe.Sizeof(specialprofile&#123;&#125;), <span class="literal">nil</span>, <span class="literal">nil</span>, &amp;memstats.other_sys)</span><br><span class="line">h.arenaHintAlloc.init(unsafe.Sizeof(arenaHint&#123;&#125;), <span class="literal">nil</span>, <span class="literal">nil</span>, &amp;memstats.other_sys)</span><br><span class="line"></span><br><span class="line"><span class="comment">// Don't zero mspan allocations. Background sweeping can</span></span><br><span class="line"><span class="comment">// inspect a span concurrently with allocating it, so it's</span></span><br><span class="line"><span class="comment">// important that the span's sweepgen survive across freeing</span></span><br><span class="line"><span class="comment">// and re-allocating a span to prevent background sweeping</span></span><br><span class="line"><span class="comment">// from improperly cas'ing it from 0.</span></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="comment">// This is safe because mspan contains no heap pointers.</span></span><br><span class="line">h.spanalloc.zero = <span class="literal">false</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// h-&gt;mapcache needs no init</span></span><br><span class="line"><span class="keyword">for</span> i := <span class="keyword">range</span> h.free &#123;</span><br><span class="line">h.free[i].init()</span><br><span class="line">h.busy[i].init()</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">h.busylarge.init()</span><br><span class="line"><span class="keyword">for</span> i := <span class="keyword">range</span> h.central &#123;</span><br><span class="line">h.central[i].mcentral.init(spanClass(i))</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="mcentral-init"><a href="#mcentral-init" class="headerlink" title="mcentral.init"></a>mcentral.init</h3><p>初始化某个规格的mcentral</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Initialize a single central free list.</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(c *mcentral)</span> <span class="title">init</span><span class="params">(spc spanClass)</span></span> &#123;</span><br><span class="line">c.spanclass = spc</span><br><span class="line">c.nonempty.init()</span><br><span class="line">c.empty.init()</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="allocmcache"><a href="#allocmcache" class="headerlink" title="allocmcache"></a>allocmcache</h3><p>mcache的初始化</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">allocmcache</span><span class="params">()</span> *<span class="title">mcache</span></span> &#123;</span><br><span class="line">lock(&amp;mheap_.lock)</span><br><span class="line">c := (*mcache)(mheap_.cachealloc.alloc())</span><br><span class="line">unlock(&amp;mheap_.lock)</span><br><span class="line"><span class="keyword">for</span> i := <span class="keyword">range</span> c.alloc &#123;</span><br><span class="line">c.alloc[i] = &amp;emptymspan</span><br><span class="line">&#125;</span><br><span class="line">c.next_sample = nextSample()</span><br><span class="line"><span class="keyword">return</span> c</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="fixalloc-alloc"><a href="#fixalloc-alloc" class="headerlink" title="fixalloc.alloc"></a>fixalloc.alloc</h4><p>fixalloc是一个固定大小的分配器。主要用来分配一些对内存的包装的结构,比如:mspan,mcache..等等,虽然启动分配的实际使用内存是由其他内存分配器分配的。 主要分配思路为: 开始的时候一次性分配一大块内存，每次请求分配一小块，释放时放在list链表中，由于size是不变的，所以不会出现内存碎片。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(f *fixalloc)</span> <span class="title">alloc</span><span class="params">()</span> <span class="title">unsafe</span>.<span class="title">Pointer</span></span> &#123;</span><br><span class="line"><span class="keyword">if</span> f.size == <span class="number">0</span> &#123;</span><br><span class="line"><span class="built_in">print</span>(<span class="string">"runtime: use of FixAlloc_Alloc before FixAlloc_Init\n"</span>)</span><br><span class="line">throw(<span class="string">"runtime: internal error"</span>)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 如果list不要为空，直接拿</span></span><br><span class="line"><span class="keyword">if</span> f.list != <span class="literal">nil</span> &#123;</span><br><span class="line">v := unsafe.Pointer(f.list)</span><br><span class="line">f.list = f.list.next</span><br><span class="line">f.inuse += f.size</span><br><span class="line"><span class="keyword">if</span> f.zero &#123;</span><br><span class="line">memclrNoHeapPointers(v, f.size)</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> v</span><br><span class="line">&#125;</span><br><span class="line">  <span class="comment">// 如果块为空，则从系统分配中调用系统内存分配</span></span><br><span class="line"><span class="keyword">if</span> <span class="keyword">uintptr</span>(f.nchunk) &lt; f.size &#123;</span><br><span class="line">f.chunk = <span class="keyword">uintptr</span>(persistentalloc(_FixAllocChunk, <span class="number">0</span>, f.stat))</span><br><span class="line">f.nchunk = _FixAllocChunk</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 从chunk中分配一个固定大小的size，释放的时候，会回归到list中</span></span><br><span class="line">v := unsafe.Pointer(f.chunk)</span><br><span class="line"><span class="keyword">if</span> f.first != <span class="literal">nil</span> &#123;</span><br><span class="line">f.first(f.arg, v)</span><br><span class="line">&#125;</span><br><span class="line">f.chunk = f.chunk + f.size</span><br><span class="line">f.nchunk -= <span class="keyword">uint32</span>(f.size)</span><br><span class="line">f.inuse += f.size</span><br><span class="line"><span class="keyword">return</span> v</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>初始化的工作很简单：</p><ol><li>初始化heap，初始化free large对应规格的链表，初始化busyLarge链表</li><li>初始化每个规格对应的mcentral</li><li>初始化mcache，对mcache里面每个对应的规格进行初始化</li><li>初始化 arenaHints，填充一组地址，后面根据真正的arena边界来进行扩增</li></ol><h1 id="分配"><a href="#分配" class="headerlink" title="分配"></a>分配</h1><h2 id="newObject"><a href="#newObject" class="headerlink" title="newObject"></a>newObject</h2><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">newobject</span><span class="params">(typ *_type)</span> <span class="title">unsafe</span>.<span class="title">Pointer</span></span> &#123;</span><br><span class="line"><span class="keyword">return</span> mallocgc(typ.size, typ, <span class="literal">true</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="mallocgc"><a href="#mallocgc" class="headerlink" title="mallocgc"></a>mallocgc</h3><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">mallocgc</span><span class="params">(size <span class="keyword">uintptr</span>, typ *_type, needzero <span class="keyword">bool</span>)</span> <span class="title">unsafe</span>.<span class="title">Pointer</span></span> &#123;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Set mp.mallocing to keep from being preempted by GC.</span></span><br><span class="line"><span class="comment">// 加锁防止被GC抢占</span></span><br><span class="line">mp := acquirem()</span><br><span class="line"><span class="keyword">if</span> mp.mallocing != <span class="number">0</span> &#123;</span><br><span class="line">throw(<span class="string">"malloc deadlock"</span>)</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span> mp.gsignal == getg() &#123;</span><br><span class="line">throw(<span class="string">"malloc during signal"</span>)</span><br><span class="line">&#125;</span><br><span class="line">mp.mallocing = <span class="number">1</span></span><br><span class="line"></span><br><span class="line">shouldhelpgc := <span class="literal">false</span></span><br><span class="line">dataSize := size</span><br><span class="line"><span class="comment">// 获取当前线程的mcache</span></span><br><span class="line">c := gomcache()</span><br><span class="line"><span class="keyword">var</span> x unsafe.Pointer</span><br><span class="line"></span><br><span class="line"><span class="comment">// 判断分配的对象是否 是nil或非指针类型</span></span><br><span class="line">noscan := typ == <span class="literal">nil</span> || typ.kind&amp;kindNoPointers != <span class="number">0</span></span><br><span class="line"><span class="keyword">if</span> size &lt;= maxSmallSize &#123;</span><br><span class="line"><span class="keyword">if</span> noscan &amp;&amp; size &lt; maxTinySize &#123;</span><br><span class="line"><span class="comment">// 这里开始小对象的内存分配</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 对齐，调整偏移量</span></span><br><span class="line">off := c.tinyoffset</span><br><span class="line"><span class="comment">// Align tiny pointer for required (conservative) alignment.</span></span><br><span class="line"><span class="keyword">if</span> size&amp;<span class="number">7</span> == <span class="number">0</span> &#123;</span><br><span class="line">off = round(off, <span class="number">8</span>)</span><br><span class="line">&#125; <span class="keyword">else</span> <span class="keyword">if</span> size&amp;<span class="number">3</span> == <span class="number">0</span> &#123;</span><br><span class="line">off = round(off, <span class="number">4</span>)</span><br><span class="line">&#125; <span class="keyword">else</span> <span class="keyword">if</span> size&amp;<span class="number">1</span> == <span class="number">0</span> &#123;</span><br><span class="line">off = round(off, <span class="number">2</span>)</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 如果当前mcache上绑定的tiny 块内存空间足够，直接分配，并返回</span></span><br><span class="line"><span class="keyword">if</span> off+size &lt;= maxTinySize &amp;&amp; c.tiny != <span class="number">0</span> &#123;</span><br><span class="line"><span class="comment">// The object fits into existing tiny block.</span></span><br><span class="line">x = unsafe.Pointer(c.tiny + off)</span><br><span class="line">c.tinyoffset = off + size</span><br><span class="line">c.local_tinyallocs++</span><br><span class="line">mp.mallocing = <span class="number">0</span></span><br><span class="line">releasem(mp)</span><br><span class="line"><span class="keyword">return</span> x</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// Allocate a new maxTinySize block.</span></span><br><span class="line"><span class="comment">// 当前mcache上的 tiny 块内存空间不足，重新分配一块 tiny 块内存</span></span><br><span class="line">span := c.alloc[tinySpanClass]</span><br><span class="line"></span><br><span class="line"><span class="comment">// 尝试从 allocCache 获取内存，获取不到返回0</span></span><br><span class="line">v := nextFreeFast(span)</span><br><span class="line"><span class="keyword">if</span> v == <span class="number">0</span> &#123;</span><br><span class="line"><span class="comment">// 没有从 allocCache 获取到内存，netxtFree函数 尝试从 mcentral获取一个新的对应规格的快内存，替换原先内存空间不足的内存块，并分配内存，后面解析 nextFree 函数</span></span><br><span class="line">v, _, shouldhelpgc = c.nextFree(tinySpanClass)</span><br><span class="line">&#125;</span><br><span class="line">x = unsafe.Pointer(v)</span><br><span class="line">(*[<span class="number">2</span>]<span class="keyword">uint64</span>)(x)[<span class="number">0</span>] = <span class="number">0</span></span><br><span class="line">(*[<span class="number">2</span>]<span class="keyword">uint64</span>)(x)[<span class="number">1</span>] = <span class="number">0</span></span><br><span class="line"><span class="comment">// See if we need to replace the existing tiny block with the new one</span></span><br><span class="line"><span class="comment">// based on amount of remaining free space.</span></span><br><span class="line"><span class="keyword">if</span> size &lt; c.tinyoffset || c.tiny == <span class="number">0</span> &#123;</span><br><span class="line">c.tiny = <span class="keyword">uintptr</span>(x)</span><br><span class="line">c.tinyoffset = size</span><br><span class="line">&#125;</span><br><span class="line">size = maxTinySize</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line"><span class="comment">// 这里开始 正常对象的 内存分配</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 首先查表，以确定 sizeclass</span></span><br><span class="line"><span class="keyword">var</span> sizeclass <span class="keyword">uint8</span></span><br><span class="line"><span class="keyword">if</span> size &lt;= smallSizeMax<span class="number">-8</span> &#123;</span><br><span class="line">sizeclass = size_to_class8[(size+smallSizeDiv<span class="number">-1</span>)/smallSizeDiv]</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">sizeclass = size_to_class128[(size-smallSizeMax+largeSizeDiv<span class="number">-1</span>)/largeSizeDiv]</span><br><span class="line">&#125;</span><br><span class="line">size = <span class="keyword">uintptr</span>(class_to_size[sizeclass])</span><br><span class="line">spc := makeSpanClass(sizeclass, noscan)</span><br><span class="line"><span class="comment">// 找到对应 sizeclass(后面 `规格` 来代替)的span</span></span><br><span class="line">span := c.alloc[spc]</span><br><span class="line"><span class="comment">// 同小对象分配一样，尝试从 allocCache 获取内存，获取不到返回0</span></span><br><span class="line">v := nextFreeFast(span)</span><br><span class="line"><span class="keyword">if</span> v == <span class="number">0</span> &#123;</span><br><span class="line">v, span, shouldhelpgc = c.nextFree(spc)</span><br><span class="line">&#125;</span><br><span class="line">x = unsafe.Pointer(v)</span><br><span class="line"><span class="keyword">if</span> needzero &amp;&amp; span.needzero != <span class="number">0</span> &#123;</span><br><span class="line">memclrNoHeapPointers(unsafe.Pointer(v), size)</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line"><span class="comment">// 这里开始大对象的分配</span></span><br><span class="line"><span class="comment">// 大对象的分配与 小对象 和普通对象 的分配有点不一样，大对象直接从 mheap 上分配</span></span><br><span class="line"><span class="keyword">var</span> s *mspan</span><br><span class="line">shouldhelpgc = <span class="literal">true</span></span><br><span class="line">systemstack(<span class="function"><span class="keyword">func</span><span class="params">()</span></span> &#123;</span><br><span class="line">s = largeAlloc(size, needzero, noscan)</span><br><span class="line">&#125;)</span><br><span class="line">s.freeindex = <span class="number">1</span></span><br><span class="line">s.allocCount = <span class="number">1</span></span><br><span class="line">x = unsafe.Pointer(s.base())</span><br><span class="line">size = s.elemsize</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// bitmap标记...</span></span><br><span class="line"><span class="comment">// 检查出发条件，启动垃圾回收 ...</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> x</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>整理一下 这段代码的基本思路：</p><ol><li><p>首先判定 对象是 大对象 还是 普通对象还是 小对象</p></li><li><p>如果是 小对象</p><ol><li>从 mcache 的alloc 找到对应 classsize 的 mspan</li><li><p>如果当前mspan有足够的空间，分配并修改mspan的相关属性（nextFreeFast函数中实现）</p></li><li><p>如果当前mspan没有足够的空间，从 mcentral重新获取一块 对应 classsize的 mspan，替换原先的mspan，然后 分配并修改mspan的相关属性</p></li></ol></li><li><p>如果是普通对象，逻辑大致同小对象的 内存分配</p><ol><li><p>首先查表，以确定 需要分配内存的对象的 sizeclass，并找到 对应 classsize的 mspan</p></li><li><p>如果当前mspan有足够的空间，分配并修改mspan的相关属性（nextFreeFast函数中实现）</p></li><li><p>如果当前mspan没有足够的空间，从 mcentral重新获取一块 对应 classsize的 mspan，替换原先的mspan，然后 分配并修改mspan的相关属性</p></li></ol></li><li><p>如果是大对象，直接从mheap进行分配，这里的实现依靠 <code>largeAlloc</code> 函数实现，我们先跟一下这个函数</p></li></ol><h2 id="largeAlloc"><a href="#largeAlloc" class="headerlink" title="largeAlloc"></a>largeAlloc</h2><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">largeAlloc</span><span class="params">(size <span class="keyword">uintptr</span>, needzero <span class="keyword">bool</span>, noscan <span class="keyword">bool</span>)</span> *<span class="title">mspan</span></span> &#123;</span><br><span class="line"><span class="comment">// print("largeAlloc size=", size, "\n")</span></span><br><span class="line"></span><br><span class="line">  <span class="comment">// 内存溢出判断</span></span><br><span class="line"><span class="keyword">if</span> size+_PageSize &lt; size &#123;</span><br><span class="line">throw(<span class="string">"out of memory"</span>)</span><br><span class="line">&#125;</span><br><span class="line">  </span><br><span class="line">  <span class="comment">// 计算出对象所需的页数</span></span><br><span class="line">npages := size &gt;&gt; _PageShift</span><br><span class="line"><span class="keyword">if</span> size&amp;_PageMask != <span class="number">0</span> &#123;</span><br><span class="line">npages++</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Deduct credit for this span allocation and sweep if</span></span><br><span class="line"><span class="comment">// necessary. mHeap_Alloc will also sweep npages, so this only</span></span><br><span class="line"><span class="comment">// pays the debt down to npage pages.</span></span><br><span class="line">deductSweepCredit(npages*_PageSize, npages)</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 分配函数的具体实现</span></span><br><span class="line">s := mheap_.alloc(npages, makeSpanClass(<span class="number">0</span>, noscan), <span class="literal">true</span>, needzero)</span><br><span class="line"><span class="keyword">if</span> s == <span class="literal">nil</span> &#123;</span><br><span class="line">throw(<span class="string">"out of memory"</span>)</span><br><span class="line">&#125;</span><br><span class="line">s.limit = s.base() + size</span><br><span class="line">  <span class="comment">// bitmap 记录分配的span</span></span><br><span class="line">heapBitsForAddr(s.base()).initSpan(s)</span><br><span class="line"><span class="keyword">return</span> s</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="mheap-alloc"><a href="#mheap-alloc" class="headerlink" title="mheap.alloc"></a>mheap.alloc</h3><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(h *mheap)</span> <span class="title">alloc</span><span class="params">(npage <span class="keyword">uintptr</span>, spanclass spanClass, large <span class="keyword">bool</span>, needzero <span class="keyword">bool</span>)</span> *<span class="title">mspan</span></span> &#123;</span><br><span class="line"><span class="comment">// Don't do any operations that lock the heap on the G stack.</span></span><br><span class="line"><span class="comment">// It might trigger stack growth, and the stack growth code needs</span></span><br><span class="line"><span class="comment">// to be able to allocate heap.</span></span><br><span class="line"><span class="keyword">var</span> s *mspan</span><br><span class="line">systemstack(<span class="function"><span class="keyword">func</span><span class="params">()</span></span> &#123;</span><br><span class="line">s = h.alloc_m(npage, spanclass, large)</span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> s != <span class="literal">nil</span> &#123;</span><br><span class="line"><span class="keyword">if</span> needzero &amp;&amp; s.needzero != <span class="number">0</span> &#123;</span><br><span class="line">memclrNoHeapPointers(unsafe.Pointer(s.base()), s.npages&lt;&lt;_PageShift)</span><br><span class="line">&#125;</span><br><span class="line">s.needzero = <span class="number">0</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> s</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="mheap-alloc-m"><a href="#mheap-alloc-m" class="headerlink" title="mheap.alloc_m"></a>mheap.alloc_m</h4><p>根据页数从 heap 上面分配一个新的span，并且在 HeapMap 和 HeapMapCache 上记录对象的sizeclass</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(h *mheap)</span> <span class="title">alloc_m</span><span class="params">(npage <span class="keyword">uintptr</span>, spanclass spanClass, large <span class="keyword">bool</span>)</span> *<span class="title">mspan</span></span> &#123;</span><br><span class="line">_g_ := getg()</span><br><span class="line"><span class="keyword">if</span> _g_ != _g_.m.g0 &#123;</span><br><span class="line">throw(<span class="string">"_mheap_alloc not on g0 stack"</span>)</span><br><span class="line">&#125;</span><br><span class="line">lock(&amp;h.lock)</span><br><span class="line"></span><br><span class="line"><span class="comment">// 清理垃圾，内存块状态标记 省略...</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 从 heap中获取指定页数的span</span></span><br><span class="line">s := h.allocSpanLocked(npage, &amp;memstats.heap_inuse)</span><br><span class="line"><span class="keyword">if</span> s != <span class="literal">nil</span> &#123;</span><br><span class="line"><span class="comment">// Record span info, because gc needs to be</span></span><br><span class="line"><span class="comment">// able to map interior pointer to containing span.</span></span><br><span class="line">atomic.Store(&amp;s.sweepgen, h.sweepgen)</span><br><span class="line">h.sweepSpans[h.sweepgen/<span class="number">2</span>%<span class="number">2</span>].push(s) <span class="comment">// Add to swept in-use list.// 忽略</span></span><br><span class="line">s.state = _MSpanInUse</span><br><span class="line">s.allocCount = <span class="number">0</span></span><br><span class="line">s.spanclass = spanclass</span><br><span class="line">    <span class="comment">// 重置span的状态</span></span><br><span class="line"><span class="keyword">if</span> sizeclass := spanclass.sizeclass(); sizeclass == <span class="number">0</span> &#123;</span><br><span class="line">s.elemsize = s.npages &lt;&lt; _PageShift</span><br><span class="line">s.divShift = <span class="number">0</span></span><br><span class="line">s.divMul = <span class="number">0</span></span><br><span class="line">s.divShift2 = <span class="number">0</span></span><br><span class="line">s.baseMask = <span class="number">0</span></span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">s.elemsize = <span class="keyword">uintptr</span>(class_to_size[sizeclass])</span><br><span class="line">m := &amp;class_to_divmagic[sizeclass]</span><br><span class="line">s.divShift = m.shift</span><br><span class="line">s.divMul = m.mul</span><br><span class="line">s.divShift2 = m.shift2</span><br><span class="line">s.baseMask = m.baseMask</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// update stats, sweep lists</span></span><br><span class="line">h.pagesInUse += <span class="keyword">uint64</span>(npage)</span><br><span class="line"><span class="keyword">if</span> large &#123;</span><br><span class="line">      <span class="comment">// 更新 mheap中大对象的相关属性</span></span><br><span class="line">memstats.heap_objects++</span><br><span class="line">mheap_.largealloc += <span class="keyword">uint64</span>(s.elemsize)</span><br><span class="line">mheap_.nlargealloc++</span><br><span class="line">atomic.Xadd64(&amp;memstats.heap_live, <span class="keyword">int64</span>(npage&lt;&lt;_PageShift))</span><br><span class="line"><span class="comment">// Swept spans are at the end of lists.</span></span><br><span class="line">      <span class="comment">// 根据页数判断是busy还是 busylarge链表，并追加到末尾</span></span><br><span class="line"><span class="keyword">if</span> s.npages &lt; <span class="keyword">uintptr</span>(<span class="built_in">len</span>(h.busy)) &#123;</span><br><span class="line">h.busy[s.npages].insertBack(s)</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">h.busylarge.insertBack(s)</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// gc trace 标记，省略...</span></span><br><span class="line">unlock(&amp;h.lock)</span><br><span class="line"><span class="keyword">return</span> s</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h5 id="mheap-allocSpanLocked"><a href="#mheap-allocSpanLocked" class="headerlink" title="mheap.allocSpanLocked"></a>mheap.allocSpanLocked</h5><p>分配一个给定大小的span，并将分配的span从freelist中移除</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(h *mheap)</span> <span class="title">allocSpanLocked</span><span class="params">(npage <span class="keyword">uintptr</span>, stat *<span class="keyword">uint64</span>)</span> *<span class="title">mspan</span></span> &#123;</span><br><span class="line"><span class="keyword">var</span> list *mSpanList</span><br><span class="line"><span class="keyword">var</span> s *mspan</span><br><span class="line"></span><br><span class="line"><span class="comment">// Try in fixed-size lists up to max.</span></span><br><span class="line">  <span class="comment">// 先尝试获取指定页数的span，如果没有，则试试页数更多的</span></span><br><span class="line"><span class="keyword">for</span> i := <span class="keyword">int</span>(npage); i &lt; <span class="built_in">len</span>(h.free); i++ &#123;</span><br><span class="line">list = &amp;h.free[i]</span><br><span class="line"><span class="keyword">if</span> !list.isEmpty() &#123;</span><br><span class="line">s = list.first</span><br><span class="line">list.remove(s)</span><br><span class="line"><span class="keyword">goto</span> HaveSpan</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// Best fit in list of large spans.</span></span><br><span class="line">  <span class="comment">// 从 freelarge 上找到一个合适的span节点返回 ，下面继续分析这个函数</span></span><br><span class="line">s = h.allocLarge(npage) <span class="comment">// allocLarge removed s from h.freelarge for us</span></span><br><span class="line"><span class="keyword">if</span> s == <span class="literal">nil</span> &#123;</span><br><span class="line">    <span class="comment">// 如果 freelarge上找不到合适的span节点，就只有从 系统 重新分配了</span></span><br><span class="line">    <span class="comment">// 后面继续分析这个函数</span></span><br><span class="line"><span class="keyword">if</span> !h.grow(npage) &#123;</span><br><span class="line"><span class="keyword">return</span> <span class="literal">nil</span></span><br><span class="line">&#125;</span><br><span class="line">    <span class="comment">// 从系统分配后，再次到freelarge 上寻找合适的节点</span></span><br><span class="line">s = h.allocLarge(npage)</span><br><span class="line"><span class="keyword">if</span> s == <span class="literal">nil</span> &#123;</span><br><span class="line"><span class="keyword">return</span> <span class="literal">nil</span></span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">HaveSpan:</span><br><span class="line">  <span class="comment">// 从 free 上面获取到了 合适页数的span</span></span><br><span class="line"><span class="comment">// Mark span in use. 省略....</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> s.npages &gt; npage &#123;</span><br><span class="line"><span class="comment">// Trim extra and put it back in the heap.</span></span><br><span class="line">    <span class="comment">// 创建一个 s.napges - npage 大小的span，并放回 heap</span></span><br><span class="line">t := (*mspan)(h.spanalloc.alloc())</span><br><span class="line">t.init(s.base()+npage&lt;&lt;_PageShift, s.npages-npage)</span><br><span class="line">    <span class="comment">// 更新获取到的span s 的属性</span></span><br><span class="line">s.npages = npage</span><br><span class="line">h.setSpan(t.base()<span class="number">-1</span>, s)</span><br><span class="line">h.setSpan(t.base(), t)</span><br><span class="line">h.setSpan(t.base()+t.npages*pageSize<span class="number">-1</span>, t)</span><br><span class="line">t.needzero = s.needzero</span><br><span class="line">s.state = _MSpanManual <span class="comment">// prevent coalescing with s</span></span><br><span class="line">t.state = _MSpanManual</span><br><span class="line">h.freeSpanLocked(t, <span class="literal">false</span>, <span class="literal">false</span>, s.unusedsince)</span><br><span class="line">s.state = _MSpanFree</span><br><span class="line">&#125;</span><br><span class="line">s.unusedsince = <span class="number">0</span></span><br><span class="line"><span class="comment">// 将s放到spans 和 arenas 数组里面</span></span><br><span class="line">h.setSpans(s.base(), npage, s)</span><br><span class="line"></span><br><span class="line">*stat += <span class="keyword">uint64</span>(npage &lt;&lt; _PageShift)</span><br><span class="line">memstats.heap_idle -= <span class="keyword">uint64</span>(npage &lt;&lt; _PageShift)</span><br><span class="line"></span><br><span class="line"><span class="comment">//println("spanalloc", hex(s.start&lt;&lt;_PageShift))</span></span><br><span class="line"><span class="keyword">if</span> s.inList() &#123;</span><br><span class="line">throw(<span class="string">"still in list"</span>)</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> s</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h6 id="mheap-allocLarge"><a href="#mheap-allocLarge" class="headerlink" title="mheap.allocLarge"></a>mheap.allocLarge</h6><p>从 mheap 的 freeLarge 树上面找到一个指定page数量的span，并将该span从树上移除，找不到则返回nil</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(h *mheap)</span> <span class="title">allocLarge</span><span class="params">(npage <span class="keyword">uintptr</span>)</span> *<span class="title">mspan</span></span> &#123;</span><br><span class="line"><span class="comment">// Search treap for smallest span with &gt;= npage pages.</span></span><br><span class="line"><span class="keyword">return</span> h.freelarge.remove(npage)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 上面的 h.freelarge.remove 即调用这个函数</span></span><br><span class="line"><span class="comment">// 典型的二叉树寻找算法</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(root *mTreap)</span> <span class="title">remove</span><span class="params">(npages <span class="keyword">uintptr</span>)</span> *<span class="title">mspan</span></span> &#123;</span><br><span class="line">t := root.treap</span><br><span class="line"><span class="keyword">for</span> t != <span class="literal">nil</span> &#123;</span><br><span class="line"><span class="keyword">if</span> t.spanKey == <span class="literal">nil</span> &#123;</span><br><span class="line">throw(<span class="string">"treap node with nil spanKey found"</span>)</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span> t.npagesKey &lt; npages &#123;</span><br><span class="line">t = t.right</span><br><span class="line">&#125; <span class="keyword">else</span> <span class="keyword">if</span> t.left != <span class="literal">nil</span> &amp;&amp; t.left.npagesKey &gt;= npages &#123;</span><br><span class="line">t = t.left</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">result := t.spanKey</span><br><span class="line">root.removeNode(t)</span><br><span class="line"><span class="keyword">return</span> result</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> <span class="literal">nil</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>注： 在看 《Go语言学习笔记》的时候，这里的查找算法还是 对链表的 遍历查找</p><h6 id="mheap-grow"><a href="#mheap-grow" class="headerlink" title="mheap.grow"></a>mheap.grow</h6><p>在 mheap.allocSpanLocked 这个函数中，如果 freelarge上找不到合适的span节点，就只有从 系统 重新分配了，那我们接下来就继续分析一下这个函数的实现</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(h *mheap)</span> <span class="title">grow</span><span class="params">(npage <span class="keyword">uintptr</span>)</span> <span class="title">bool</span></span> &#123;</span><br><span class="line">ask := npage &lt;&lt; _PageShift</span><br><span class="line">  <span class="comment">// 向系统申请内存，后面继续追踪 sysAlloc 这个函数</span></span><br><span class="line">v, size := h.sysAlloc(ask)</span><br><span class="line"><span class="keyword">if</span> v == <span class="literal">nil</span> &#123;</span><br><span class="line"><span class="built_in">print</span>(<span class="string">"runtime: out of memory: cannot allocate "</span>, ask, <span class="string">"-byte block ("</span>, memstats.heap_sys, <span class="string">" in use)\n"</span>)</span><br><span class="line"><span class="keyword">return</span> <span class="literal">false</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Create a fake "in use" span and free it, so that the</span></span><br><span class="line"><span class="comment">// right coalescing happens.</span></span><br><span class="line">  <span class="comment">// 创建 span 来管理刚刚申请的内存</span></span><br><span class="line">s := (*mspan)(h.spanalloc.alloc())</span><br><span class="line">s.init(<span class="keyword">uintptr</span>(v), size/pageSize)</span><br><span class="line">h.setSpans(s.base(), s.npages, s)</span><br><span class="line">atomic.Store(&amp;s.sweepgen, h.sweepgen)</span><br><span class="line">s.state = _MSpanInUse</span><br><span class="line">h.pagesInUse += <span class="keyword">uint64</span>(s.npages)</span><br><span class="line">  <span class="comment">// 将刚刚申请的span放到 arenas 和 spans 数组里面</span></span><br><span class="line">h.freeSpanLocked(s, <span class="literal">false</span>, <span class="literal">true</span>, <span class="number">0</span>)</span><br><span class="line"><span class="keyword">return</span> <span class="literal">true</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h6 id="mheao-sysAlloc"><a href="#mheao-sysAlloc" class="headerlink" title="mheao.sysAlloc"></a>mheao.sysAlloc</h6> <figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(h *mheap)</span> <span class="title">sysAlloc</span><span class="params">(n <span class="keyword">uintptr</span>)</span> <span class="params">(v unsafe.Pointer, size <span class="keyword">uintptr</span>)</span></span> &#123;</span><br><span class="line">n = round(n, heapArenaBytes)</span><br><span class="line"></span><br><span class="line"><span class="comment">// First, try the arena pre-reservation.</span></span><br><span class="line">  <span class="comment">// 从 arena 中 获取对应大小的内存， 获取不到返回nil</span></span><br><span class="line">v = h.arena.alloc(n, heapArenaBytes, &amp;memstats.heap_sys)</span><br><span class="line"><span class="keyword">if</span> v != <span class="literal">nil</span> &#123;</span><br><span class="line">    <span class="comment">// 从arena获取到需要的内存，跳转到 mapped操作</span></span><br><span class="line">size = n</span><br><span class="line"><span class="keyword">goto</span> mapped</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Try to grow the heap at a hint address.</span></span><br><span class="line">  <span class="comment">// 尝试 从 arenaHint向下扩展内存</span></span><br><span class="line"><span class="keyword">for</span> h.arenaHints != <span class="literal">nil</span> &#123;</span><br><span class="line">hint := h.arenaHints</span><br><span class="line">p := hint.addr</span><br><span class="line"><span class="keyword">if</span> hint.down &#123;</span><br><span class="line">p -= n</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span> p+n &lt; p &#123;</span><br><span class="line"><span class="comment">// We can't use this, so don't ask.</span></span><br><span class="line">      <span class="comment">// 表名 hint.down = false 不能向下扩展内存</span></span><br><span class="line">v = <span class="literal">nil</span></span><br><span class="line">&#125; <span class="keyword">else</span> <span class="keyword">if</span> arenaIndex(p+n<span class="number">-1</span>) &gt;= <span class="number">1</span>&lt;&lt;arenaBits &#123;</span><br><span class="line">      <span class="comment">// 超出 heap 可寻址的内存地址，不能使用</span></span><br><span class="line"><span class="comment">// Outside addressable heap. Can't use.</span></span><br><span class="line">v = <span class="literal">nil</span></span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      <span class="comment">// 当前hint可以向下扩展内存，利用mmap向系统申请内存</span></span><br><span class="line">v = sysReserve(unsafe.Pointer(p), n)</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span> p == <span class="keyword">uintptr</span>(v) &#123;</span><br><span class="line"><span class="comment">// Success. Update the hint.</span></span><br><span class="line"><span class="keyword">if</span> !hint.down &#123;</span><br><span class="line">p += n</span><br><span class="line">&#125;</span><br><span class="line">hint.addr = p</span><br><span class="line">size = n</span><br><span class="line"><span class="keyword">break</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// Failed. Discard this hint and try the next.</span></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="comment">// <span class="doctag">TODO:</span> This would be cleaner if sysReserve could be</span></span><br><span class="line"><span class="comment">// told to only return the requested address. In</span></span><br><span class="line"><span class="comment">// particular, this is already how Windows behaves, so</span></span><br><span class="line"><span class="comment">// it would simply things there.</span></span><br><span class="line"><span class="keyword">if</span> v != <span class="literal">nil</span> &#123;</span><br><span class="line">sysFree(v, n, <span class="literal">nil</span>)</span><br><span class="line">&#125;</span><br><span class="line">h.arenaHints = hint.next</span><br><span class="line">h.arenaHintAlloc.free(unsafe.Pointer(hint))</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> size == <span class="number">0</span> &#123;</span><br><span class="line"><span class="keyword">if</span> raceenabled &#123;</span><br><span class="line"><span class="comment">// The race detector assumes the heap lives in</span></span><br><span class="line"><span class="comment">// [0x00c000000000, 0x00e000000000), but we</span></span><br><span class="line"><span class="comment">// just ran out of hints in this region. Give</span></span><br><span class="line"><span class="comment">// a nice failure.</span></span><br><span class="line">throw(<span class="string">"too many address space collisions for -race mode"</span>)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// All of the hints failed, so we'll take any</span></span><br><span class="line"><span class="comment">// (sufficiently aligned) address the kernel will give</span></span><br><span class="line"><span class="comment">// us.</span></span><br><span class="line">v, size = sysReserveAligned(<span class="literal">nil</span>, n, heapArenaBytes)</span><br><span class="line"><span class="keyword">if</span> v == <span class="literal">nil</span> &#123;</span><br><span class="line"><span class="keyword">return</span> <span class="literal">nil</span>, <span class="number">0</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Create new hints for extending this region.</span></span><br><span class="line">hint := (*arenaHint)(h.arenaHintAlloc.alloc())</span><br><span class="line">hint.addr, hint.down = <span class="keyword">uintptr</span>(v), <span class="literal">true</span></span><br><span class="line">hint.next, mheap_.arenaHints = mheap_.arenaHints, hint</span><br><span class="line">hint = (*arenaHint)(h.arenaHintAlloc.alloc())</span><br><span class="line">hint.addr = <span class="keyword">uintptr</span>(v) + size</span><br><span class="line">hint.next, mheap_.arenaHints = mheap_.arenaHints, hint</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Check for bad pointers or pointers we can't use.</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">var</span> bad <span class="keyword">string</span></span><br><span class="line">p := <span class="keyword">uintptr</span>(v)</span><br><span class="line"><span class="keyword">if</span> p+size &lt; p &#123;</span><br><span class="line">bad = <span class="string">"region exceeds uintptr range"</span></span><br><span class="line">&#125; <span class="keyword">else</span> <span class="keyword">if</span> arenaIndex(p) &gt;= <span class="number">1</span>&lt;&lt;arenaBits &#123;</span><br><span class="line">bad = <span class="string">"base outside usable address space"</span></span><br><span class="line">&#125; <span class="keyword">else</span> <span class="keyword">if</span> arenaIndex(p+size<span class="number">-1</span>) &gt;= <span class="number">1</span>&lt;&lt;arenaBits &#123;</span><br><span class="line">bad = <span class="string">"end outside usable address space"</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span> bad != <span class="string">""</span> &#123;</span><br><span class="line"><span class="comment">// This should be impossible on most architectures,</span></span><br><span class="line"><span class="comment">// but it would be really confusing to debug.</span></span><br><span class="line"><span class="built_in">print</span>(<span class="string">"runtime: memory allocated by OS ["</span>, hex(p), <span class="string">", "</span>, hex(p+size), <span class="string">") not in usable address space: "</span>, bad, <span class="string">"\n"</span>)</span><br><span class="line">throw(<span class="string">"memory reservation exceeds address space limit"</span>)</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> <span class="keyword">uintptr</span>(v)&amp;(heapArenaBytes<span class="number">-1</span>) != <span class="number">0</span> &#123;</span><br><span class="line">throw(<span class="string">"misrounded allocation in sysAlloc"</span>)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Back the reservation.</span></span><br><span class="line">sysMap(v, size, &amp;memstats.heap_sys)</span><br><span class="line"></span><br><span class="line">mapped:</span><br><span class="line"><span class="comment">// Create arena metadata.</span></span><br><span class="line">  <span class="comment">// 根据 v 的address，计算出 arenas 的L1 L2</span></span><br><span class="line"><span class="keyword">for</span> ri := arenaIndex(<span class="keyword">uintptr</span>(v)); ri &lt;= arenaIndex(<span class="keyword">uintptr</span>(v)+size<span class="number">-1</span>); ri++ &#123;</span><br><span class="line">l2 := h.arenas[ri.l1()]</span><br><span class="line"><span class="keyword">if</span> l2 == <span class="literal">nil</span> &#123;</span><br><span class="line">      <span class="comment">// 如果 L2 为 nil，则分配 arenas[L1]</span></span><br><span class="line"><span class="comment">// Allocate an L2 arena map.</span></span><br><span class="line">l2 = (*[<span class="number">1</span> &lt;&lt; arenaL2Bits]*heapArena)(persistentalloc(unsafe.Sizeof(*l2), sys.PtrSize, <span class="literal">nil</span>))</span><br><span class="line"><span class="keyword">if</span> l2 == <span class="literal">nil</span> &#123;</span><br><span class="line">throw(<span class="string">"out of memory allocating heap arena map"</span>)</span><br><span class="line">&#125;</span><br><span class="line">atomic.StorepNoWB(unsafe.Pointer(&amp;h.arenas[ri.l1()]), unsafe.Pointer(l2))</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 如果 arenas[ri.L1()][ri.L2()] 不为空 说明已经实例化过了</span></span><br><span class="line"><span class="keyword">if</span> l2[ri.l2()] != <span class="literal">nil</span> &#123;</span><br><span class="line">throw(<span class="string">"arena already initialized"</span>)</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">var</span> r *heapArena</span><br><span class="line">    <span class="comment">// 从 arena 上分配内存</span></span><br><span class="line">r = (*heapArena)(h.heapArenaAlloc.alloc(unsafe.Sizeof(*r), sys.PtrSize, &amp;memstats.gc_sys))</span><br><span class="line"><span class="keyword">if</span> r == <span class="literal">nil</span> &#123;</span><br><span class="line">r = (*heapArena)(persistentalloc(unsafe.Sizeof(*r), sys.PtrSize, &amp;memstats.gc_sys))</span><br><span class="line"><span class="keyword">if</span> r == <span class="literal">nil</span> &#123;</span><br><span class="line">throw(<span class="string">"out of memory allocating heap arena metadata"</span>)</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Store atomically just in case an object from the</span></span><br><span class="line"><span class="comment">// new heap arena becomes visible before the heap lock</span></span><br><span class="line"><span class="comment">// is released (which shouldn't happen, but there's</span></span><br><span class="line"><span class="comment">// little downside to this).</span></span><br><span class="line">atomic.StorepNoWB(unsafe.Pointer(&amp;l2[ri.l2()]), unsafe.Pointer(r))</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 省略部分代码...</span></span><br><span class="line"><span class="keyword">return</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>至此，大对象的分配流程至此结束，我们继续看一下，小对象和普通话对象的分配流程</p><h2 id="小对象和普通对象分配"><a href="#小对象和普通对象分配" class="headerlink" title="小对象和普通对象分配"></a>小对象和普通对象分配</h2><p>下面一段是 小对象和普通对象的内存查找和分配的主要函数，在上面的时候已经分析过了，下面我们就着重分析这两个函数</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">span := c.alloc[spc]</span><br><span class="line">v := nextFreeFast(span)</span><br><span class="line"><span class="keyword">if</span> v == <span class="number">0</span> &#123;</span><br><span class="line">v, _, shouldhelpgc = c.nextFree(spc)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="nextFreeFast"><a href="#nextFreeFast" class="headerlink" title="nextFreeFast"></a>nextFreeFast</h3><p>这个函数返回 span 上可用的地址，如果找不到 则返回0</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">nextFreeFast</span><span class="params">(s *mspan)</span> <span class="title">gclinkptr</span></span> &#123;</span><br><span class="line">  <span class="comment">// 计算s.allocCache从低位起有多少个0</span></span><br><span class="line">theBit := sys.Ctz64(s.allocCache) <span class="comment">// Is there a free object in the allocCache?</span></span><br><span class="line"><span class="keyword">if</span> theBit &lt; <span class="number">64</span> &#123;</span><br><span class="line">    </span><br><span class="line">result := s.freeindex + <span class="keyword">uintptr</span>(theBit)</span><br><span class="line"><span class="keyword">if</span> result &lt; s.nelems &#123;</span><br><span class="line">freeidx := result + <span class="number">1</span></span><br><span class="line"><span class="keyword">if</span> freeidx%<span class="number">64</span> == <span class="number">0</span> &amp;&amp; freeidx != s.nelems &#123;</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span></span><br><span class="line">&#125;</span><br><span class="line">      <span class="comment">// 更新bitmap、可用的 slot索引</span></span><br><span class="line">s.allocCache &gt;&gt;= <span class="keyword">uint</span>(theBit + <span class="number">1</span>)</span><br><span class="line">s.freeindex = freeidx</span><br><span class="line">s.allocCount++</span><br><span class="line">      <span class="comment">// 返回 找到的内存的地址</span></span><br><span class="line"><span class="keyword">return</span> gclinkptr(result*s.elemsize + s.base())</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="mcache-nextFree"><a href="#mcache-nextFree" class="headerlink" title="mcache.nextFree"></a>mcache.nextFree</h3><p>如果 nextFreeFast 找不到 合适的内存，就会进入这个函数</p><p>nextFree 如果在cached span 里面找到未使用的object，则返回，否则，调用refill 函数，从 central 中获取对应classsize的span，然后 从新的span里面找到未使用的object返回</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(c *mcache)</span> <span class="title">nextFree</span><span class="params">(spc spanClass)</span> <span class="params">(v gclinkptr, s *mspan, shouldhelpgc <span class="keyword">bool</span>)</span></span> &#123;</span><br><span class="line"><span class="comment">// 先找到 mcache 中 对应 规格的 span</span></span><br><span class="line">  s = c.alloc[spc]</span><br><span class="line">shouldhelpgc = <span class="literal">false</span></span><br><span class="line">  <span class="comment">// 在 当前span中找到合适的 index索引</span></span><br><span class="line">freeIndex := s.nextFreeIndex()</span><br><span class="line"><span class="keyword">if</span> freeIndex == s.nelems &#123;</span><br><span class="line"><span class="comment">// The span is full.</span></span><br><span class="line">    <span class="comment">// freeIndex == nelems 时，表示当前span已满</span></span><br><span class="line"><span class="keyword">if</span> <span class="keyword">uintptr</span>(s.allocCount) != s.nelems &#123;</span><br><span class="line"><span class="built_in">println</span>(<span class="string">"runtime: s.allocCount="</span>, s.allocCount, <span class="string">"s.nelems="</span>, s.nelems)</span><br><span class="line">throw(<span class="string">"s.allocCount != s.nelems &amp;&amp; freeIndex == s.nelems"</span>)</span><br><span class="line">&#125;</span><br><span class="line">    <span class="comment">// 调用refill函数，从 mcentral 中获取可用的span，并替换掉当前 mcache里面的span</span></span><br><span class="line">systemstack(<span class="function"><span class="keyword">func</span><span class="params">()</span></span> &#123;</span><br><span class="line">c.refill(spc)</span><br><span class="line">&#125;)</span><br><span class="line">shouldhelpgc = <span class="literal">true</span></span><br><span class="line">s = c.alloc[spc]</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 再次到新的span里面查找合适的index</span></span><br><span class="line">freeIndex = s.nextFreeIndex()</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> freeIndex &gt;= s.nelems &#123;</span><br><span class="line">throw(<span class="string">"freeIndex is not valid"</span>)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 计算出来 内存地址，并更新span的属性</span></span><br><span class="line">v = gclinkptr(freeIndex*s.elemsize + s.base())</span><br><span class="line">s.allocCount++</span><br><span class="line"><span class="keyword">if</span> <span class="keyword">uintptr</span>(s.allocCount) &gt; s.nelems &#123;</span><br><span class="line"><span class="built_in">println</span>(<span class="string">"s.allocCount="</span>, s.allocCount, <span class="string">"s.nelems="</span>, s.nelems)</span><br><span class="line">throw(<span class="string">"s.allocCount &gt; s.nelems"</span>)</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="mcache-refill"><a href="#mcache-refill" class="headerlink" title="mcache.refill"></a>mcache.refill</h4><p>Refill 根据指定的sizeclass获取对应的span，并作为 mcache的新的sizeclass对应的span</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(c *mcache)</span> <span class="title">refill</span><span class="params">(spc spanClass)</span></span> &#123;</span><br><span class="line">_g_ := getg()</span><br><span class="line"></span><br><span class="line">_g_.m.locks++</span><br><span class="line"><span class="comment">// Return the current cached span to the central lists.</span></span><br><span class="line">s := c.alloc[spc]</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> <span class="keyword">uintptr</span>(s.allocCount) != s.nelems &#123;</span><br><span class="line">throw(<span class="string">"refill of span with free space remaining"</span>)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 判断s是不是 空的span</span></span><br><span class="line"><span class="keyword">if</span> s != &amp;emptymspan &#123;</span><br><span class="line">s.incache = <span class="literal">false</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 尝试从 mcentral 获取一个新的span来代替老的span</span></span><br><span class="line"><span class="comment">// Get a new cached span from the central lists.</span></span><br><span class="line">s = mheap_.central[spc].mcentral.cacheSpan()</span><br><span class="line"><span class="keyword">if</span> s == <span class="literal">nil</span> &#123;</span><br><span class="line">throw(<span class="string">"out of memory"</span>)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> <span class="keyword">uintptr</span>(s.allocCount) == s.nelems &#123;</span><br><span class="line">throw(<span class="string">"span has no free space"</span>)</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 更新mcache的span</span></span><br><span class="line">c.alloc[spc] = s</span><br><span class="line">_g_.m.locks--</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h5 id="mcentral-cacheSpan"><a href="#mcentral-cacheSpan" class="headerlink" title="mcentral.cacheSpan"></a>mcentral.cacheSpan</h5><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(c *mcentral)</span> <span class="title">cacheSpan</span><span class="params">()</span> *<span class="title">mspan</span></span> &#123;</span><br><span class="line"><span class="comment">// Deduct credit for this span allocation and sweep if necessary.</span></span><br><span class="line">spanBytes := <span class="keyword">uintptr</span>(class_to_allocnpages[c.spanclass.sizeclass()]) * _PageSize</span><br><span class="line"><span class="comment">// 清理垃圾...</span></span><br><span class="line">lock(&amp;c.lock)</span><br><span class="line"></span><br><span class="line">sg := mheap_.sweepgen</span><br><span class="line">retry:</span><br><span class="line"><span class="keyword">var</span> s *mspan</span><br><span class="line"><span class="keyword">for</span> s = c.nonempty.first; s != <span class="literal">nil</span>; s = s.next &#123;</span><br><span class="line">    <span class="comment">// if sweepgen == h-&gt;sweepgen - 2, the span needs sweeping</span></span><br><span class="line">    <span class="comment">// if sweepgen == h-&gt;sweepgen - 1, the span is currently being swept</span></span><br><span class="line">    <span class="comment">// if sweepgen == h-&gt;sweepgen, the span is swept and ready to use</span></span><br><span class="line">    <span class="comment">// h-&gt;sweepgen is incremented by 2 after every GC</span></span><br><span class="line">    <span class="comment">// 需要清理的span</span></span><br><span class="line"><span class="keyword">if</span> s.sweepgen == sg<span class="number">-2</span> &amp;&amp; atomic.Cas(&amp;s.sweepgen, sg<span class="number">-2</span>, sg<span class="number">-1</span>) &#123;</span><br><span class="line">c.nonempty.remove(s)</span><br><span class="line">c.empty.insertBack(s)</span><br><span class="line">unlock(&amp;c.lock)</span><br><span class="line">s.sweep(<span class="literal">true</span>)</span><br><span class="line"><span class="keyword">goto</span> havespan</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span> s.sweepgen == sg<span class="number">-1</span> &#123;</span><br><span class="line"><span class="comment">// the span is being swept by background sweeper, skip</span></span><br><span class="line"><span class="keyword">continue</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// we have a nonempty span that does not require sweeping, allocate from it</span></span><br><span class="line">    <span class="comment">// 找到片 没有被 清理的span，分配，跳转到 havespan标签继续处理</span></span><br><span class="line">c.nonempty.remove(s)</span><br><span class="line">c.empty.insertBack(s)</span><br><span class="line">unlock(&amp;c.lock)</span><br><span class="line"><span class="keyword">goto</span> havespan</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 对于 上一轮循环中，可能 正在清扫的span，清扫后的span可能会有有用的span，所以在这里 在进行一次遍历检查</span></span><br><span class="line"><span class="keyword">for</span> s = c.empty.first; s != <span class="literal">nil</span>; s = s.next &#123;</span><br><span class="line"><span class="keyword">if</span> s.sweepgen == sg<span class="number">-2</span> &amp;&amp; atomic.Cas(&amp;s.sweepgen, sg<span class="number">-2</span>, sg<span class="number">-1</span>) &#123;</span><br><span class="line"><span class="comment">// we have an empty span that requires sweeping,</span></span><br><span class="line"><span class="comment">// sweep it and see if we can free some space in it</span></span><br><span class="line">c.empty.remove(s)</span><br><span class="line"><span class="comment">// swept spans are at the end of the list</span></span><br><span class="line">c.empty.insertBack(s)</span><br><span class="line">unlock(&amp;c.lock)</span><br><span class="line">s.sweep(<span class="literal">true</span>)</span><br><span class="line">freeIndex := s.nextFreeIndex()</span><br><span class="line"><span class="keyword">if</span> freeIndex != s.nelems &#123;</span><br><span class="line">s.freeindex = freeIndex</span><br><span class="line"><span class="keyword">goto</span> havespan</span><br><span class="line">&#125;</span><br><span class="line">lock(&amp;c.lock)</span><br><span class="line"><span class="comment">// the span is still empty after sweep</span></span><br><span class="line"><span class="comment">// it is already in the empty list, so just retry</span></span><br><span class="line"><span class="keyword">goto</span> retry</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span> s.sweepgen == sg<span class="number">-1</span> &#123;</span><br><span class="line"><span class="comment">// the span is being swept by background sweeper, skip</span></span><br><span class="line"><span class="keyword">continue</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// already swept empty span,</span></span><br><span class="line"><span class="comment">// all subsequent ones must also be either swept or in process of sweeping</span></span><br><span class="line"><span class="keyword">break</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">unlock(&amp;c.lock)</span><br><span class="line"></span><br><span class="line"><span class="comment">// Replenish central list if empty.</span></span><br><span class="line">  <span class="comment">// 找不到 合适的span，补充对应classsize的span，grow函数会调用 mheap.alloc 来填充span，上面已经分析过了，不再赘述</span></span><br><span class="line">s = c.grow()</span><br><span class="line"><span class="keyword">if</span> s == <span class="literal">nil</span> &#123;</span><br><span class="line"><span class="keyword">return</span> <span class="literal">nil</span></span><br><span class="line">&#125;</span><br><span class="line">lock(&amp;c.lock)</span><br><span class="line">  <span class="comment">// 插入到empty span list后面</span></span><br><span class="line">c.empty.insertBack(s)</span><br><span class="line">unlock(&amp;c.lock)</span><br><span class="line"></span><br><span class="line"><span class="comment">// At this point s is a non-empty span, queued at the end of the empty list,</span></span><br><span class="line"><span class="comment">// c is unlocked.</span></span><br><span class="line">havespan:</span><br><span class="line"></span><br><span class="line"><span class="built_in">cap</span> := <span class="keyword">int32</span>((s.npages &lt;&lt; _PageShift) / s.elemsize)</span><br><span class="line">n := <span class="built_in">cap</span> - <span class="keyword">int32</span>(s.allocCount)</span><br><span class="line"><span class="keyword">if</span> n == <span class="number">0</span> || s.freeindex == s.nelems || <span class="keyword">uintptr</span>(s.allocCount) == s.nelems &#123;</span><br><span class="line">throw(<span class="string">"span has no free objects"</span>)</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// Assume all objects from this span will be allocated in the</span></span><br><span class="line"><span class="comment">// mcache. If it gets uncached, we'll adjust this.</span></span><br><span class="line">atomic.Xadd64(&amp;c.nmalloc, <span class="keyword">int64</span>(n))</span><br><span class="line">usedBytes := <span class="keyword">uintptr</span>(s.allocCount) * s.elemsize</span><br><span class="line">atomic.Xadd64(&amp;memstats.heap_live, <span class="keyword">int64</span>(spanBytes)-<span class="keyword">int64</span>(usedBytes))</span><br><span class="line"><span class="comment">// 表示 span 为正在使用</span></span><br><span class="line">s.incache = <span class="literal">true</span></span><br><span class="line">freeByteBase := s.freeindex &amp;^ (<span class="number">64</span> - <span class="number">1</span>)</span><br><span class="line">whichByte := freeByteBase / <span class="number">8</span></span><br><span class="line">  <span class="comment">// 更新 bitmap</span></span><br><span class="line"><span class="comment">// Init alloc bits cache.</span></span><br><span class="line">s.refillAllocCache(whichByte)</span><br><span class="line"></span><br><span class="line"><span class="comment">// Adjust the allocCache so that s.freeindex corresponds to the low bit in</span></span><br><span class="line"><span class="comment">// s.allocCache.</span></span><br><span class="line">s.allocCache &gt;&gt;= s.freeindex % <span class="number">64</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> s</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>到这里，如果 从 mcentral 找不到对应的span，就开始了内存扩张之旅了，也就是我们上面分析的 <code>mheap.alloc</code>，后面的分析就同上了</p><h2 id="分配小结"><a href="#分配小结" class="headerlink" title="分配小结"></a>分配小结</h2><p>综上，可以看出Go的内存分配的大致流程如下</p><ol><li>首先判定 对象是 大对象 还是 普通对象还是 小对象</li><li>如果是 小对象<ol><li>从 mcache 的alloc 找到对应 classsize 的 mspan</li><li>如果当前mspan有足够的空间，分配并修改mspan的相关属性（nextFreeFast函数中实现）</li><li>如果当前mspan没有足够的空间，从 mcentral重新获取一块 对应 classsize的 mspan，替换原先的mspan，然后 分配并修改mspan的相关属性</li><li>如果mcentral没有足够的对应的classsize的span，则去向mheap申请</li><li>如果 对应classsize的span没有了，则找一个相近的classsize的span，切割并分配</li><li>如果 找不到相近的classsize的span，则去向系统申请，并补充到mheap中</li></ol></li><li>如果是普通对象，逻辑大致同小对象的 内存分配<ol><li>首先查表，以确定 需要分配内存的对象的 sizeclass，并找到 对应 classsize的 mspan</li><li>如果当前mspan有足够的空间，分配并修改mspan的相关属性（nextFreeFast函数中实现）</li><li>如果当前mspan没有足够的空间，从 mcentral重新获取一块 对应 classsize的 mspan，替换原先的mspan，然后 分配并修改mspan的相关属性</li><li>如果mcentral没有足够的对应的classsize的span，则去向mheap申请</li><li>如果 对应classsize的span没有了，则找一个相近的classsize的span，切割并分配</li><li>如果 找不到相近的classsize的span，则去向系统申请，并补充到mheap中</li></ol></li><li>如果是大对象，直接从mheap进行分配<ol><li>如果 对应classsize的span没有了，则找一个相近的classsize的span，切割并分配</li><li>如果 找不到相近的classsize的span，则去向系统申请，并补充到mheap中</li></ol></li></ol><h1 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h1><p>《Go语言学习笔记》</p><p><a href="https://studygolang.com/articles/20604" target="_blank" rel="noopener">《图解Go语言内存分配》</a></p><p><a href="https://www.jianshu.com/p/47691d870756" target="_blank" rel="noopener">《探索Go内存管理(分配)》</a></p><p><a href="http://legendtkl.com/2017/04/02/golang-alloc/" target="_blank" rel="noopener">《Golang 内存管理》</a></p>]]></content>
      
      
      <categories>
          
          <category> Go </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Go </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>深入理解Go-逃逸分析</title>
      <link href="/posts/30194/"/>
      <url>/posts/30194/</url>
      
        <content type="html"><![CDATA[<blockquote><p>How do I know whether a variable is allocated on the heap or the stack?</p><p>From a correctness standpoint, you don’t need to know. Each variable in Go exists as long as there are references to it. The storage location chosen by the implementation is irrelevant to the semantics of the language.</p><p>The storage location does have an effect on writing efficient programs. When possible, the Go compilers will allocate variables that are local to a function in that function’s stack frame. However, if the compiler cannot prove that the variable is not referenced after the function returns, then the compiler must allocate the variable on the garbage-collected heap to avoid dangling pointer errors. Also, if a local variable is very large, it might make more sense to store it on the heap rather than the stack.</p><p>In the current compilers, if a variable has its address taken, that variable is a candidate for allocation on the heap. However, a basic escape analysis recognizes some cases when such variables will not live past the return from the function and can reside on the stack.</p></blockquote><p>在Go里面定义了一个变量，到底是分配在堆上还是栈上，Go官方文档告诉我们，不需要管，他们会分析，其实这个分析就是逃逸分析</p><p>在编程语言的编译优化原理中，分析指针动态范围的方法称之为逃逸分析。通俗来讲，当一个对象的指针被多个方法或线程引用时，我们称这个指针发生了逃逸。</p><a id="more"></a><p>发生逃逸行为的情况主要有两种：</p><ul><li>方法逃逸：当一个对象在方法中定义之后，作为参数传递或返回值到其它方法中</li><li>线程逃逸：如类变量或实例变量，可能被其它线程访问到</li></ul><p>这里主要对 <strong>方法逃逸</strong> 进行分析，通过逃逸分析来判断一个变量到底是分配在堆上还是栈上</p><h1 id="逃逸策略"><a href="#逃逸策略" class="headerlink" title="逃逸策略"></a>逃逸策略</h1><ul><li>如果编译器不能证明某个变量在函数返回后不再被引用，则分配在堆上</li><li>如果一个变量过大，则有可能分配在堆上</li></ul><h1 id="分析目的"><a href="#分析目的" class="headerlink" title="分析目的"></a>分析目的</h1><ul><li>不逃逸的对象分配在栈上，则变量在用完后就会被编译器回收，从而减少GC的压力</li><li>栈上的分配要比堆上的分配更加高效</li><li>同步消除，如果定义的对象上有同步锁，但是栈在运行时只有一个线程访问，逃逸分析后如果在栈上则会将同步锁去除</li></ul><h1 id="逃逸场景"><a href="#逃逸场景" class="headerlink" title="逃逸场景"></a>逃逸场景</h1><h2 id="指针逃逸"><a href="#指针逃逸" class="headerlink" title="指针逃逸"></a>指针逃逸</h2><blockquote><p>在 build 的时候，通过添加 -gcflags “-m” 编译参数就可以查看编译过程中的逃逸分析</p></blockquote><p>在有些时候，因为变量太大等原因，我们会选择返回变量的指针，而非变量，这里其实就是逃逸的一个经典现象</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">test()</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">test</span><span class="params">()</span> *<span class="title">int</span></span> &#123;</span><br><span class="line">i := <span class="number">1</span></span><br><span class="line"><span class="keyword">return</span> &amp;i</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>逃逸分析结果：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"># command-line-arguments</span><br><span class="line">./main.go:7:6: can inline test</span><br><span class="line">./main.go:3:6: can inline main</span><br><span class="line">./main.go:4:6: inlining call to test</span><br><span class="line">./main.go:4:6: main &amp;i does not escape</span><br><span class="line">./main.go:9:9: &amp;i escapes to heap</span><br><span class="line">./main.go:8:2: moved to heap: i</span><br></pre></td></tr></table></figure><p>可以看到最后两行指出，变量 <code>i</code> 逃逸到了 <code>heap</code> 上</p><h2 id="栈空间不足逃逸"><a href="#栈空间不足逃逸" class="headerlink" title="栈空间不足逃逸"></a>栈空间不足逃逸</h2><p>首先，我们尝试创建一个 长度较小的 slice</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">stack()</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">stack</span><span class="params">()</span></span> &#123;</span><br><span class="line">s := <span class="built_in">make</span>([]<span class="keyword">int</span>, <span class="number">10</span>, <span class="number">10</span>)</span><br><span class="line">s[<span class="number">0</span>] = <span class="number">1</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>逃逸分析结果：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">./main.go:12:6: can inline stack</span><br><span class="line">./main.go:3:6: can inline main</span><br><span class="line">./main.go:4:7: inlining call to stack</span><br><span class="line">./main.go:4:7: main make([]int, 10, 10) does not escape</span><br><span class="line">./main.go:13:11: stack make([]int, 10, 10) does not escape</span><br></pre></td></tr></table></figure><p>结果显示未逃逸</p><p>然后，我们创建一个超大的slice</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">stack()</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">stack</span><span class="params">()</span></span> &#123;</span><br><span class="line">s := <span class="built_in">make</span>([]<span class="keyword">int</span>, <span class="number">100000</span>, <span class="number">100000</span>)</span><br><span class="line">s[<span class="number">0</span>] = <span class="number">1</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>逃逸分析结果：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">./main.go:12:6: can inline stack</span><br><span class="line">./main.go:3:6: can inline main</span><br><span class="line">./main.go:4:7: inlining call to stack</span><br><span class="line">./main.go:4:7: make([]int, 100000, 100000) escapes to heap</span><br><span class="line">./main.go:13:11: make([]int, 100000, 100000) escapes to heap</span><br></pre></td></tr></table></figure><p>这时候就逃逸到了堆上了</p><h2 id="动态类型逃逸"><a href="#动态类型逃逸" class="headerlink" title="动态类型逃逸"></a>动态类型逃逸</h2><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">dynamic()</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">dynamic</span><span class="params">()</span> <span class="title">interface</span></span>&#123;&#125; &#123;</span><br><span class="line">i := <span class="number">0</span></span><br><span class="line"><span class="keyword">return</span> i</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>逃逸分析结果：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">./main.go:18:6: can inline dynamic</span><br><span class="line">./main.go:3:6: can inline main</span><br><span class="line">./main.go:5:9: inlining call to dynamic</span><br><span class="line">./main.go:5:9: main i does not escape</span><br><span class="line">./main.go:20:2: i escapes to heap</span><br></pre></td></tr></table></figure><p>这里的动态类型逃逸，其实在理解了<code>interface{}</code>的内部结构后，还是可以归并到 <strong>指针逃逸</strong> 这一类的，有兴趣的同学可以看一下 <a href="https://tyloafer.github.io/posts/2647/">《深入理解Go的interface》</a></p><h2 id="闭包引用逃逸"><a href="#闭包引用逃逸" class="headerlink" title="闭包引用逃逸"></a>闭包引用逃逸</h2><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">f := fibonacci()</span><br><span class="line"><span class="keyword">for</span> i := <span class="number">0</span>; i &lt; <span class="number">10</span>; i++ &#123;</span><br><span class="line">f()</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">fibonacci</span><span class="params">()</span> <span class="title">func</span><span class="params">()</span> <span class="title">int</span></span> &#123;</span><br><span class="line">a, b := <span class="number">0</span>, <span class="number">1</span></span><br><span class="line"><span class="keyword">return</span> <span class="function"><span class="keyword">func</span><span class="params">()</span> <span class="title">int</span></span> &#123;</span><br><span class="line">a, b = b, a+b</span><br><span class="line"><span class="keyword">return</span> a</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>逃逸分析结果：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">./main.go:11:9: can inline fibonacci.func1</span><br><span class="line">./main.go:11:9: func literal escapes to heap</span><br><span class="line">./main.go:11:9: func literal escapes to heap</span><br><span class="line">./main.go:12:10: &amp;b escapes to heap</span><br><span class="line">./main.go:10:5: moved to heap: b</span><br><span class="line">./main.go:12:13: &amp;a escapes to heap</span><br><span class="line">./main.go:10:2: moved to heap: a</span><br></pre></td></tr></table></figure><h1 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h1><p><a href="https://my.oschina.net/renhc/blog/2222104" target="_blank" rel="noopener">《Go 逃逸分析》</a></p>]]></content>
      
      
      <categories>
          
          <category> Go </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Go </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Go学习之Channel总结</title>
      <link href="/posts/30283/"/>
      <url>/posts/30283/</url>
      
        <content type="html"><![CDATA[<p>Channel是Go中的一个核心类型，你可以把它看成一个管道，通过它并发核心单元就可以发送或者接收数据进行通讯(communication)。</p><a id="more"></a><h1 id="类型"><a href="#类型" class="headerlink" title="类型"></a>类型</h1><p>T表示任意的一种类型</p><ul><li>双向: chan T</li><li>单向仅发送： chan &lt;-</li><li>单向仅接受： &lt;- chan</li></ul><p>单向的channel，不仅可以通过声明<code>make(chan &lt;- interface{})</code> 来创建，还可以通过隐身或显示的通过 <code>chan</code> 来转换，如下</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">  channel := <span class="built_in">make</span>(<span class="keyword">chan</span> <span class="keyword">int</span>, <span class="number">10</span>)</span><br><span class="line">convert(channel)</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">convert</span><span class="params">(channel <span class="keyword">chan</span>&lt;- <span class="keyword">int</span>)</span></span> &#123;&#125;</span><br></pre></td></tr></table></figure><p>在 <code>convert函数中，就可以吧channel当成单向输入管道来使用了</code></p><p>既然 双向 chan，既可以接收，也可以发送，为什么还会有单向chan的存在？ 我的一个理解便是 <strong>权限收敛</strong>，例如一个爬虫系统中，有些进程a仅仅负责抓取页面内容，并转发给进程b，那进程a仅需要 <code>单向发送的chan</code> 即可</p><h1 id="Blocking"><a href="#Blocking" class="headerlink" title="Blocking"></a>Blocking</h1><p>缺省情况下，发送chan或接收chan会一直阻塞着，直到另一方准备好。这种方式可以用来在gororutine中进行同步，而不必使用显示的锁或者条件变量。</p><p>如官方的例子中<code>x, y := &lt;-c, &lt;-c</code>这句会一直等待计算结果发送到channel中。以下面例子看一下</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">bufferChannel</span><span class="params">()</span></span> &#123;</span><br><span class="line">channel := <span class="built_in">make</span>(<span class="keyword">chan</span> <span class="keyword">int</span>)</span><br><span class="line">i := <span class="number">0</span></span><br><span class="line"><span class="keyword">go</span> <span class="function"><span class="keyword">func</span><span class="params">(i <span class="keyword">int</span>)</span></span> &#123;</span><br><span class="line">    fmt.Printf(<span class="string">"start goroutine %d\n"</span>, i)①</span><br><span class="line">channel &lt;- i</span><br><span class="line">fmt.Printf(<span class="string">"send %d to channel\n"</span>, i)②</span><br><span class="line">&#125;(i)</span><br><span class="line">time.Sleep(<span class="number">2</span> * time.Second)</span><br><span class="line">fmt.Println(<span class="string">"sleep 2 second"</span>)</span><br><span class="line">value := &lt;-channel③</span><br><span class="line">fmt.Println(<span class="string">"got "</span>, value)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>输出结果如下</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">start goroutine 0</span><br><span class="line">sleep 2 second</span><br><span class="line">got  0</span><br><span class="line">send 0 to channel</span><br></pre></td></tr></table></figure><p>可以看出，<code>go func</code> 执行到了①后并没有继续执行②，而是等待③执行完成后，再去执行②，也就可以说明 <code>channel &lt;- i</code> 阻塞了<code>goroutine</code>的继续执行</p><p>如果，我不想在这里阻塞，而是我直接把数据放到<code>channel</code>里，等接收方准备好后，到<code>channel</code>中自取自用如何处理，这里就涉及到了另一个概念 <strong>buffered channel</strong></p><h1 id="buffered-channel"><a href="#buffered-channel" class="headerlink" title="buffered channel"></a>buffered channel</h1><p>我们把程序修改一下</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">bufferChannel</span><span class="params">()</span></span> &#123;</span><br><span class="line">channel := <span class="built_in">make</span>(<span class="keyword">chan</span> <span class="keyword">int</span>, <span class="number">1</span>) <span class="comment">// 这里加了个参数</span></span><br><span class="line">i := <span class="number">0</span></span><br><span class="line"><span class="keyword">go</span> <span class="function"><span class="keyword">func</span><span class="params">(i <span class="keyword">int</span>)</span></span> &#123;</span><br><span class="line">fmt.Printf(<span class="string">"start goroutine %d\n"</span>, i)①</span><br><span class="line">channel &lt;- i</span><br><span class="line">fmt.Printf(<span class="string">"send %d to channel\n"</span>, i)②</span><br><span class="line">&#125;(i)</span><br><span class="line">time.Sleep(<span class="number">2</span> * time.Second)</span><br><span class="line">fmt.Println(<span class="string">"sleep 2 second"</span>)</span><br><span class="line">value := &lt;-channel③</span><br><span class="line">fmt.Println(<span class="string">"got "</span>, value)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>输出结果</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">start goroutine 0</span><br><span class="line">send 0 to channel</span><br><span class="line">sleep 2 second</span><br><span class="line">got  0</span><br></pre></td></tr></table></figure><p>我们发现<code>go func</code>执行完①之后就执行了②，并没有等待③的执行结束，这就是<strong>buffered channel</strong>的效果了</p><p>我们只需要在make的时候，声明底2个参数，也就是chan的缓冲区大小即可</p><p>通过上面的程序可以看出，我们一直在使用③的形成，即<code>&lt;- chan</code>来读取chan中的数据，但是如果有多个goroutine在同时像一个chan写数据，我们除了使用</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> &#123;</span><br><span class="line">value &lt;- <span class="keyword">chan</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>还有什么更优雅的方式吗</p><h1 id="for-…-range"><a href="#for-…-range" class="headerlink" title="for … range"></a>for … range</h1><p>还是上面那个程序，我们使用 <em>for … range</em> 进行一下改造</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">bufferChannel</span><span class="params">()</span></span> &#123;</span><br><span class="line">   channel := <span class="built_in">make</span>(<span class="keyword">chan</span> <span class="keyword">int</span>, <span class="number">1</span>)</span><br><span class="line">   i := <span class="number">0</span></span><br><span class="line">   <span class="keyword">go</span> <span class="function"><span class="keyword">func</span><span class="params">(i <span class="keyword">int</span>)</span></span> &#123;</span><br><span class="line">      fmt.Printf(<span class="string">"start goroutine %d\n"</span>, i)</span><br><span class="line">      channel &lt;- i</span><br><span class="line">      fmt.Printf(<span class="string">"send %d to channel\n"</span>, i)</span><br><span class="line">   &#125;(i)</span><br><span class="line">   time.Sleep(<span class="number">2</span> * time.Second)</span><br><span class="line">   fmt.Println(<span class="string">"sleep 2 second"</span>)</span><br><span class="line">   <span class="keyword">for</span> value := <span class="keyword">range</span> channel &#123;</span><br><span class="line">      fmt.Println(<span class="string">"got "</span>, value)</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p> 这样就可以遍历 <code>channel</code> 中的数据了，但是我们在运行的时候就会发现，哎 这个程序怎么停不下来了？<code>range channel</code>产生的迭代值为Channel中发送的值，它会一直迭代直到channel被关闭，所以 我们<code>goroutine</code>发送完数据后，把<code>channel</code>关闭一下试试，这一次，我们不再进行<code>time.Sleep(2 * time.Second)</code></p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">bufferChannel</span><span class="params">()</span></span> &#123;</span><br><span class="line">   channel := <span class="built_in">make</span>(<span class="keyword">chan</span> <span class="keyword">int</span>, <span class="number">1</span>)</span><br><span class="line">   i := <span class="number">0</span></span><br><span class="line">   <span class="keyword">go</span> <span class="function"><span class="keyword">func</span><span class="params">(i <span class="keyword">int</span>)</span></span> &#123;</span><br><span class="line">      fmt.Printf(<span class="string">"start goroutine %d\n"</span>, i)</span><br><span class="line">      channel &lt;- i</span><br><span class="line">      fmt.Printf(<span class="string">"send %d to channel\n"</span>, i)</span><br><span class="line">      <span class="built_in">close</span>(channel)</span><br><span class="line">   &#125;(i)</span><br><span class="line">   <span class="keyword">for</span> value := <span class="keyword">range</span> channel &#123;</span><br><span class="line">      fmt.Println(<span class="string">"got "</span>, value)</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这样，整个程序就可以正常退出了，所以，在使用<code>range</code>的时候需要注意，如果<code>channel</code>不关闭，则<code>range</code>会一直阻塞在这里的</p><h1 id="select"><a href="#select" class="headerlink" title="select"></a>select</h1><p>我们上面讲的一直都是只有一个<code>channel</code>的时候，我们应该怎么去做，加入有两个<code>channel</code>或者更多的<code>channel</code>，我们应该怎么去做，这里就介绍一下 go里面的多路复用 <code>select</code>，以下面程序为例</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">example</span><span class="params">()</span></span> &#123;</span><br><span class="line">tick := time.Tick(time.Second)</span><br><span class="line">after := time.After(<span class="number">3</span> * time.Second)</span><br><span class="line"><span class="keyword">for</span> &#123;</span><br><span class="line"><span class="keyword">select</span> &#123;</span><br><span class="line"><span class="keyword">case</span> &lt;-tick:</span><br><span class="line">fmt.Println(<span class="string">"tick 1 second"</span>)</span><br><span class="line"><span class="keyword">case</span> &lt;-after:</span><br><span class="line">fmt.Println(<span class="string">"after 3 second"</span>)</span><br><span class="line"><span class="keyword">return</span></span><br><span class="line">    <span class="keyword">default</span>:</span><br><span class="line">fmt.Println(<span class="string">"come into default"</span>)</span><br><span class="line">time.Sleep(<span class="number">500</span> * time.Millisecond)</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>time.Tick</code>是go的time包提供的一个定时器的一个函数，它返回一个<code>channel</code>，并在指定时间间隔内，向channel发送一条数据,<code>time.Tick(time.Second)</code>就是每秒钟向这个channel发送一个数据</p><p><code>time.After</code>是go的time包提供的一个定时器的一个函数，它返回一个<code>channel</code>，并在指定时间间隔后，向channel发送一条数据，<code>time.After(3 * time.Second)</code>就是3s后向这个channel发送一个数据</p><p>输出结果</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">come into default</span><br><span class="line">come into default</span><br><span class="line">tick 1 second</span><br><span class="line">come into default</span><br><span class="line">come into default</span><br><span class="line">tick 1 second</span><br><span class="line">come into default</span><br><span class="line">come into default</span><br><span class="line">tick 1 second</span><br><span class="line">after 3 second</span><br></pre></td></tr></table></figure><p>可以看到，<code>select</code>会选择一个没有阻塞的 <code>channel</code>，并执行响应 <code>case</code>下的逻辑，这样就可以避免由于一个 <code>channel</code>阻塞而导致后续的逻辑阻塞的情况了</p><p>我们继续做个小实验，把上面关闭的<code>channel</code>放到 <code>select</code>里面试一下</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">example</span><span class="params">()</span></span> &#123;</span><br><span class="line">tick := time.Tick(time.Second)</span><br><span class="line">after := time.After(<span class="number">3</span> * time.Second)</span><br><span class="line">channel := <span class="built_in">make</span>(<span class="keyword">chan</span> <span class="keyword">int</span>, <span class="number">1</span>)</span><br><span class="line"><span class="keyword">go</span> <span class="function"><span class="keyword">func</span><span class="params">()</span></span> &#123;</span><br><span class="line">channel &lt;- <span class="number">1</span></span><br><span class="line"><span class="built_in">close</span>(channel)</span><br><span class="line">&#125;()</span><br><span class="line"><span class="keyword">for</span> &#123;</span><br><span class="line"><span class="keyword">select</span> &#123;</span><br><span class="line"><span class="keyword">case</span> &lt;-tick:</span><br><span class="line">fmt.Println(<span class="string">"tick 1 second"</span>)</span><br><span class="line"><span class="keyword">case</span> &lt;-after:</span><br><span class="line">fmt.Println(<span class="string">"after 3 second"</span>)</span><br><span class="line"><span class="keyword">return</span></span><br><span class="line"><span class="keyword">case</span> value := &lt;- channel:</span><br><span class="line">fmt.Println(<span class="string">"got"</span>, value)</span><br><span class="line"><span class="keyword">default</span>:</span><br><span class="line">fmt.Println(<span class="string">"come into default"</span>)</span><br><span class="line">time.Sleep(<span class="number">500</span> * time.Millisecond)</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>输出结果</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">.</span><br><span class="line">.</span><br><span class="line">.</span><br><span class="line">.</span><br><span class="line">got 0</span><br><span class="line">got 0</span><br><span class="line">got 0</span><br><span class="line">got 0</span><br><span class="line">got 0</span><br><span class="line">after 3 second</span><br></pre></td></tr></table></figure><p>简直是车祸现场，幸好设置了3s主动退出，那case的时候，有没有办法判断这个channel是否关闭了呢，当然是可以的，看下面的程序</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">example</span><span class="params">()</span></span> &#123;</span><br><span class="line">tick := time.Tick(time.Second)</span><br><span class="line">after := time.After(<span class="number">3</span> * time.Second)</span><br><span class="line">channel := <span class="built_in">make</span>(<span class="keyword">chan</span> <span class="keyword">int</span>, <span class="number">1</span>)</span><br><span class="line"><span class="keyword">go</span> <span class="function"><span class="keyword">func</span><span class="params">()</span></span> &#123;</span><br><span class="line">channel &lt;- <span class="number">1</span></span><br><span class="line"><span class="built_in">close</span>(channel)</span><br><span class="line">&#125;()</span><br><span class="line"><span class="keyword">for</span> &#123;</span><br><span class="line"><span class="keyword">select</span> &#123;</span><br><span class="line"><span class="keyword">case</span> &lt;-tick:</span><br><span class="line">fmt.Println(<span class="string">"tick 1 second"</span>)</span><br><span class="line"><span class="keyword">case</span> &lt;-after:</span><br><span class="line">fmt.Println(<span class="string">"after 3 second"</span>)</span><br><span class="line"><span class="keyword">return</span></span><br><span class="line"><span class="keyword">case</span> value, ok := &lt;- channel:</span><br><span class="line"><span class="keyword">if</span> ok &#123;</span><br><span class="line">fmt.Println(<span class="string">"got"</span>, value)</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">fmt.Println(<span class="string">"channel is closed"</span>)</span><br><span class="line">time.Sleep(time.Second)</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">default</span>:</span><br><span class="line">fmt.Println(<span class="string">"come into default"</span>)</span><br><span class="line">time.Sleep(<span class="number">500</span> * time.Millisecond)</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>输出结果</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">come into default</span><br><span class="line">got 1</span><br><span class="line">channel is closed</span><br><span class="line">tick 1 second</span><br><span class="line">channel is closed</span><br><span class="line">channel is closed</span><br><span class="line">after 3 second</span><br></pre></td></tr></table></figure><p>综上可以看出，通过 <code>value, ok := &lt;- channel</code> 这种形式，ok获取的就是用来判断channel</p><p>是否关闭的，ok为 true，表示channel正常，否则，channel就是关闭的</p>]]></content>
      
      
      <categories>
          
          <category> Go </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Go </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Go学习之Channel的一些模式</title>
      <link href="/posts/30113/"/>
      <url>/posts/30113/</url>
      
        <content type="html"><![CDATA[<p>除了在goroutine之间安全的传递数据之外，在看了《Concurrency in Go》之后，感慨channel还有那么多模式可供使用，在个人的学习中总结了以下几种常用的模式</p><a id="more"></a><h1 id="pipeline"><a href="#pipeline" class="headerlink" title="pipeline"></a>pipeline</h1><h2 id="概念"><a href="#概念" class="headerlink" title="概念"></a>概念</h2><p>我们以爬虫为例，一般爬虫分为如下步骤：</p><p>抓取页面 -&gt; 解析页面 -&gt; 整合数据分析 -&gt; 分析结果入库</p><p>如果你把上面所有的步骤都放在一个函数里面处理，那会是多难看，多难以维护，从解耦角度考虑，我们可以起四个进程，分别承担不同的角色，例如，进程1负责抓取页面， 进程2负责解析页面，等等，各个进程拿到一个数据后，交给下一个进程来处理，这就是pipeline的基本思想，每个角色只负责关心自己的东西</p><h2 id="示例"><a href="#示例" class="headerlink" title="示例"></a>示例</h2><p>给定一个数n，执行 (n<em>2 + 1) </em> 2的操作</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">pipeline</span><span class="params">()</span></span> &#123;</span><br><span class="line">generator := <span class="function"><span class="keyword">func</span><span class="params">(done <span class="keyword">chan</span> <span class="keyword">interface</span>&#123;&#125;, intergers ...<span class="keyword">int</span>)</span> &lt;-<span class="title">chan</span> <span class="title">int</span></span> &#123;</span><br><span class="line">inStream := <span class="built_in">make</span>(<span class="keyword">chan</span> <span class="keyword">int</span>)</span><br><span class="line"><span class="keyword">go</span> <span class="function"><span class="keyword">func</span><span class="params">()</span></span> &#123;</span><br><span class="line"><span class="keyword">defer</span> <span class="built_in">close</span>(inStream)</span><br><span class="line"><span class="keyword">for</span> _, i := <span class="keyword">range</span> intergers &#123;</span><br><span class="line"><span class="keyword">select</span> &#123;</span><br><span class="line"><span class="keyword">case</span> &lt;-done:</span><br><span class="line"><span class="keyword">return</span></span><br><span class="line"><span class="keyword">case</span> inStream &lt;- i:</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;()</span><br><span class="line"><span class="keyword">return</span> inStream</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">add := <span class="function"><span class="keyword">func</span><span class="params">(done &lt;-<span class="keyword">chan</span> <span class="keyword">interface</span>&#123;&#125;, inStream &lt;-<span class="keyword">chan</span> <span class="keyword">int</span>, increment <span class="keyword">int</span>)</span> &lt;-<span class="title">chan</span> <span class="title">int</span></span> &#123;</span><br><span class="line">addInStream := <span class="built_in">make</span>(<span class="keyword">chan</span> <span class="keyword">int</span>)</span><br><span class="line"><span class="keyword">go</span> <span class="function"><span class="keyword">func</span><span class="params">()</span></span> &#123;</span><br><span class="line"><span class="keyword">defer</span> <span class="built_in">close</span>(addInStream)</span><br><span class="line"><span class="keyword">for</span> i := <span class="keyword">range</span> inStream &#123;</span><br><span class="line"><span class="keyword">select</span> &#123;</span><br><span class="line"><span class="keyword">case</span> &lt;-done:</span><br><span class="line"><span class="keyword">return</span></span><br><span class="line"><span class="keyword">case</span> addInStream &lt;- i + increment:</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;()</span><br><span class="line"><span class="keyword">return</span> addInStream</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">multiply := <span class="function"><span class="keyword">func</span><span class="params">(done &lt;-<span class="keyword">chan</span> <span class="keyword">interface</span>&#123;&#125;, inStream &lt;-<span class="keyword">chan</span> <span class="keyword">int</span>, increment <span class="keyword">int</span>)</span> &lt;-<span class="title">chan</span> <span class="title">int</span></span> &#123;</span><br><span class="line">multiplyInStream := <span class="built_in">make</span>(<span class="keyword">chan</span> <span class="keyword">int</span>)</span><br><span class="line"><span class="keyword">go</span> <span class="function"><span class="keyword">func</span><span class="params">()</span></span> &#123;</span><br><span class="line"><span class="keyword">defer</span> <span class="built_in">close</span>(multiplyInStream)</span><br><span class="line"><span class="keyword">for</span> i := <span class="keyword">range</span> inStream &#123;</span><br><span class="line"><span class="keyword">select</span> &#123;</span><br><span class="line"><span class="keyword">case</span> &lt;-done:</span><br><span class="line"><span class="keyword">return</span></span><br><span class="line"><span class="keyword">case</span> multiplyInStream &lt;- i * increment:</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;()</span><br><span class="line"><span class="keyword">return</span> multiplyInStream</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">done := <span class="built_in">make</span>(<span class="keyword">chan</span> <span class="keyword">interface</span>&#123;&#125;)</span><br><span class="line"><span class="keyword">defer</span> <span class="built_in">close</span>(done)</span><br><span class="line">inStream := generator(done, []<span class="keyword">int</span>&#123;<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>, <span class="number">6</span>, <span class="number">7</span>&#125;...)</span><br><span class="line">pipeline := multiply(done, add(done, multiply(done, inStream, <span class="number">2</span>), <span class="number">1</span>), <span class="number">2</span>)</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> v := <span class="keyword">range</span> pipeline &#123;</span><br><span class="line">fmt.Println(v)</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="扇入扇出"><a href="#扇入扇出" class="headerlink" title="扇入扇出"></a>扇入扇出</h1><p>在pipeline模型中，是一种高效的流式处理，但是假如pipeline中有a,b,c三个环节，b环节处理的特别慢，这时候就会影响到c环节的处理，如果增加b环节进程处理的数量，也就可以减弱b环节的慢处理对整个pipeline的影响，那么a-&gt;多个b的过程就是 <strong>扇入</strong>， 多个b环节输出数据到c环节，就是<strong>扇出</strong></p><h2 id="示例-1"><a href="#示例-1" class="headerlink" title="示例"></a>示例</h2><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">FanInFanOut</span><span class="params">()</span></span> &#123;</span><br><span class="line">producer := <span class="function"><span class="keyword">func</span><span class="params">(intergers ...<span class="keyword">int</span>)</span> &lt;-<span class="title">chan</span> <span class="title">interface</span></span>&#123;&#125; &#123;</span><br><span class="line">inStream := <span class="built_in">make</span>(<span class="keyword">chan</span> <span class="keyword">interface</span>&#123;&#125;)</span><br><span class="line"><span class="keyword">go</span> <span class="function"><span class="keyword">func</span><span class="params">()</span></span> &#123;</span><br><span class="line"><span class="keyword">defer</span> <span class="built_in">close</span>(inStream)</span><br><span class="line"><span class="keyword">for</span> _, v := <span class="keyword">range</span> intergers &#123;</span><br><span class="line">time.Sleep(<span class="number">5</span> * time.Second)</span><br><span class="line">inStream &lt;- v</span><br><span class="line">&#125;</span><br><span class="line">&#125;()</span><br><span class="line"><span class="keyword">return</span> inStream</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">fanIn := <span class="function"><span class="keyword">func</span><span class="params">(channels ...&lt;-<span class="keyword">chan</span> <span class="keyword">interface</span>&#123;&#125;,</span></span></span><br><span class="line"><span class="function"><span class="params">)</span> &lt;-<span class="title">chan</span> <span class="title">interface</span></span>&#123;&#125; &#123;</span><br><span class="line"><span class="keyword">var</span> wg sync.WaitGroup</span><br><span class="line">multiplexStream := <span class="built_in">make</span>(<span class="keyword">chan</span> <span class="keyword">interface</span>&#123;&#125;)</span><br><span class="line"></span><br><span class="line">multiplex := <span class="function"><span class="keyword">func</span><span class="params">(c &lt;-<span class="keyword">chan</span> <span class="keyword">interface</span>&#123;&#125;)</span></span> &#123;</span><br><span class="line"><span class="keyword">defer</span> wg.Done()</span><br><span class="line"><span class="keyword">for</span> i := <span class="keyword">range</span> c &#123;</span><br><span class="line">multiplexStream &lt;- i</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">wg.Add(<span class="built_in">len</span>(channels))</span><br><span class="line"><span class="keyword">for</span> _, c := <span class="keyword">range</span> channels &#123;</span><br><span class="line"><span class="keyword">go</span> multiplex(c)</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">go</span> <span class="function"><span class="keyword">func</span><span class="params">()</span></span> &#123;</span><br><span class="line">wg.Wait()</span><br><span class="line"><span class="built_in">close</span>(multiplexStream)</span><br><span class="line">&#125;()</span><br><span class="line"><span class="keyword">return</span> multiplexStream</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">consumer := <span class="function"><span class="keyword">func</span><span class="params">(inStream &lt;-<span class="keyword">chan</span> <span class="keyword">interface</span>&#123;&#125;)</span></span> &#123;</span><br><span class="line"><span class="keyword">for</span> v := <span class="keyword">range</span> inStream &#123;</span><br><span class="line">fmt.Println(v)</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">nums := runtime.NumCPU()</span><br><span class="line">producerStreams := <span class="built_in">make</span>([]&lt;-<span class="keyword">chan</span> <span class="keyword">interface</span>&#123;&#125;, nums)</span><br><span class="line"><span class="keyword">for</span> i := <span class="number">0</span>; i &lt; nums; i++ &#123;</span><br><span class="line">producerStreams[i] = producer(i)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">consumer(fanIn(producerStreams...))</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="tee-channel"><a href="#tee-channel" class="headerlink" title="tee- channel"></a>tee- channel</h1><h2 id="概念-1"><a href="#概念-1" class="headerlink" title="概念"></a>概念</h2><p>假如你从channel中拿到了一条sql语句，这时候，你想对这条sql记录，分析并执行，那你就需要将这条sql分别转发给这三个任务对应的channel，tee-channel 就是做这个事情的</p><h2 id="示例-2"><a href="#示例-2" class="headerlink" title="示例"></a>示例</h2><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">teeChannel</span><span class="params">()</span></span> &#123;</span><br><span class="line">producer := <span class="function"><span class="keyword">func</span><span class="params">(intergers ...<span class="keyword">int</span>)</span> &lt;-<span class="title">chan</span> <span class="title">interface</span></span>&#123;&#125; &#123;</span><br><span class="line">inStream := <span class="built_in">make</span>(<span class="keyword">chan</span> <span class="keyword">interface</span>&#123;&#125;)</span><br><span class="line"><span class="keyword">go</span> <span class="function"><span class="keyword">func</span><span class="params">()</span></span> &#123;</span><br><span class="line"><span class="keyword">defer</span> <span class="built_in">close</span>(inStream)</span><br><span class="line"><span class="keyword">for</span> _, v := <span class="keyword">range</span> intergers &#123;</span><br><span class="line">inStream &lt;- v</span><br><span class="line">&#125;</span><br><span class="line">&#125;()</span><br><span class="line"><span class="keyword">return</span> inStream</span><br><span class="line">&#125;</span><br><span class="line">tee := <span class="function"><span class="keyword">func</span><span class="params">(in &lt;-<span class="keyword">chan</span> <span class="keyword">interface</span>&#123;&#125;)</span> <span class="params">(_, _ &lt;-<span class="keyword">chan</span> <span class="keyword">interface</span>&#123;&#125;)</span></span> &#123;</span><br><span class="line">out1 := <span class="built_in">make</span>(<span class="keyword">chan</span> <span class="keyword">interface</span>&#123;&#125;)</span><br><span class="line">out2 := <span class="built_in">make</span>(<span class="keyword">chan</span> <span class="keyword">interface</span>&#123;&#125;)</span><br><span class="line"><span class="keyword">go</span> <span class="function"><span class="keyword">func</span><span class="params">()</span></span> &#123;</span><br><span class="line"><span class="keyword">defer</span> <span class="built_in">close</span>(out1)</span><br><span class="line"><span class="keyword">defer</span> <span class="built_in">close</span>(out2)</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> val := <span class="keyword">range</span> in &#123;</span><br><span class="line">out1, out2 := out1, out2</span><br><span class="line"><span class="keyword">for</span> i := <span class="number">0</span>; i &lt; <span class="number">2</span>; i++ &#123;</span><br><span class="line"><span class="keyword">select</span> &#123;</span><br><span class="line"><span class="keyword">case</span> out1 &lt;- val:</span><br><span class="line">out1 = <span class="literal">nil</span></span><br><span class="line"><span class="keyword">case</span> out2 &lt;- val:</span><br><span class="line">out2 = <span class="literal">nil</span></span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;()</span><br><span class="line"><span class="keyword">return</span> out1, out2</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">out1, out2 := tee(producer(<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>))</span><br><span class="line"><span class="keyword">for</span> val1 := <span class="keyword">range</span> out1 &#123;</span><br><span class="line">fmt.Printf(<span class="string">"out1: %v, out2: %v"</span>, val1, &lt;-out2)</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="桥接channel"><a href="#桥接channel" class="headerlink" title="桥接channel"></a>桥接channel</h1><h2 id="概念-2"><a href="#概念-2" class="headerlink" title="概念"></a>概念</h2><p>无论是前面提到的<strong>pipeline</strong>还是<strong>扇入扇出</strong>，每个goroutine都是对一个channel进行消费，但是实际场景中，可能会有多个channel来供给我们消费，而作为消费者，我们不关心这些值是来自于哪个channel，这种情况下，处理一个充满channel的channel可能会很多。如果我们定义一个功能，可以将充满channel的channel拆解为一个简单的channel，这将使消费者更专注于手头的工作，这就是<strong>桥接channel</strong>的思想</p><h2 id="示例-3"><a href="#示例-3" class="headerlink" title="示例"></a>示例</h2><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">bridge</span><span class="params">()</span></span> &#123;</span><br><span class="line">gen := <span class="function"><span class="keyword">func</span><span class="params">()</span> &lt;-<span class="title">chan</span> &lt;-<span class="title">chan</span> <span class="title">interface</span></span>&#123;&#125; &#123;</span><br><span class="line">in := <span class="built_in">make</span>(<span class="keyword">chan</span> (&lt;-<span class="keyword">chan</span> <span class="keyword">interface</span>&#123;&#125;))</span><br><span class="line"><span class="keyword">go</span> <span class="function"><span class="keyword">func</span><span class="params">()</span></span> &#123;</span><br><span class="line"><span class="keyword">defer</span> <span class="built_in">close</span>(in)</span><br><span class="line"><span class="keyword">for</span> i := <span class="number">0</span>; i &lt; <span class="number">10</span>; i++ &#123;</span><br><span class="line">stream := <span class="built_in">make</span>(<span class="keyword">chan</span> <span class="keyword">interface</span>&#123;&#125;, <span class="number">1</span>)</span><br><span class="line">stream &lt;- i</span><br><span class="line"><span class="built_in">close</span>(stream)</span><br><span class="line">in &lt;- stream</span><br><span class="line">&#125;</span><br><span class="line">&#125;()</span><br><span class="line"><span class="keyword">return</span> in</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">bridge := <span class="function"><span class="keyword">func</span><span class="params">(in &lt;-<span class="keyword">chan</span> (&lt;-<span class="keyword">chan</span> <span class="keyword">interface</span>&#123;&#125;)</span>) &lt;-<span class="title">chan</span> <span class="title">interface</span></span>&#123;&#125; &#123;</span><br><span class="line">valStream := <span class="built_in">make</span>(<span class="keyword">chan</span> <span class="keyword">interface</span>&#123;&#125;)</span><br><span class="line"><span class="keyword">go</span> <span class="function"><span class="keyword">func</span><span class="params">()</span></span> &#123;</span><br><span class="line"><span class="keyword">defer</span> <span class="built_in">close</span>(valStream)</span><br><span class="line"><span class="keyword">for</span> &#123;</span><br><span class="line">stream := <span class="built_in">make</span>(&lt;-<span class="keyword">chan</span> <span class="keyword">interface</span>&#123;&#125;)</span><br><span class="line"><span class="keyword">select</span> &#123;</span><br><span class="line"><span class="keyword">case</span> maybeStream, ok := &lt;-in:</span><br><span class="line"><span class="keyword">if</span> ok == <span class="literal">false</span> &#123;</span><br><span class="line"><span class="keyword">return</span></span><br><span class="line">&#125;</span><br><span class="line">stream = maybeStream</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">for</span> val := <span class="keyword">range</span> stream &#123;</span><br><span class="line">valStream &lt;- val</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;()</span><br><span class="line"><span class="keyword">return</span> valStream</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> val := <span class="keyword">range</span> bridge(gen()) &#123;</span><br><span class="line">fmt.Println(val)</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> Go </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Go </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>在centos7上安装V2ray 比shadowsock更科学的上网方式</title>
      <link href="/posts/57533/"/>
      <url>/posts/57533/</url>
      
        <content type="html"><![CDATA[<p>近期ss的存活周期越来越短了，具体什么原因，咱也不知道，咱也不敢问，咱只能选择另一种更加科学的上网方式了，这里还是推荐一下  <a href="https://www.vultr.com/?ref=7290537" target="_blank" rel="noopener">Vultr家的VPS</a> ，换IP方便</p><a id="more"></a><h1 id="服务端安装"><a href="#服务端安装" class="headerlink" title="服务端安装"></a>服务端安装</h1><blockquote><p>Bash &lt;(curl -L -s <a href="https://install.direct/go.sh" target="_blank" rel="noopener">https://install.direct/go.sh</a>)</p></blockquote><p>执行完上面的脚本，就会输出如下安装的提示信息了，其中<code>PORT</code>和<code>UUID</code> 使我们后面需要用到的配置信息</p><p><img src="http://note-1253518569.cossh.myqcloud.com/20190613145405.png" alt="v2ray安装"></p><p>然后通过<code>service v2ray start / stop /status</code>，就可以进行v2ray的启停了</p><p>接下来执行以下下面命令，可以看出配置文件为 <code>/etc/v2ray/config.json</code>， 里面也包含了 <code>UUID</code>和<code>PORT</code>等信息</p><blockquote><p>ps aux | grep v2ray</p></blockquote><p><img src="http://note-1253518569.cossh.myqcloud.com/20190620190741.png" alt></p><h1 id="客户端配置"><a href="#客户端配置" class="headerlink" title="客户端配置"></a>客户端配置</h1><table><thead><tr><th style="text-align:center">项目</th><th style="text-align:center">值</th></tr></thead><tbody><tr><td style="text-align:center">主机/服务器/地址</td><td style="text-align:center">服务器ip</td></tr><tr><td style="text-align:center">端口 port</td><td style="text-align:center">图中的PORT</td></tr><tr><td style="text-align:center">用户ID</td><td style="text-align:center">图中的UUID</td></tr><tr><td style="text-align:center">额外ID AlterId</td><td style="text-align:center">64</td></tr><tr><td style="text-align:center">加密方式 security</td><td style="text-align:center">auto</td></tr><tr><td style="text-align:center">用户等级</td><td style="text-align:center">1</td></tr><tr><td style="text-align:center">网络/传输协议 network</td><td style="text-align:center">Tcp</td></tr><tr><td style="text-align:center">加密方式</td><td style="text-align:center">none</td></tr><tr><td style="text-align:center">Mux</td><td style="text-align:center">开启</td></tr><tr><td style="text-align:center">远程路由/DNS (可选)</td><td style="text-align:center">1.1.1.1</td></tr><tr><td style="text-align:center">路由</td><td style="text-align:center">BifrsotV:绕过局域网和中国大陆地址与网站;V2RayN:参数设置-绕过中国大陆地址和ip(这一步的目的是直连国内网站，降低延迟)</td></tr></tbody></table><h1 id="客户端"><a href="#客户端" class="headerlink" title="客户端"></a>客户端</h1><h2 id="安卓"><a href="#安卓" class="headerlink" title="安卓"></a>安卓</h2><ul><li><a href="https://play.google.com/store/apps/details?id=com.github.dawndiy.bifrostv" target="_blank" rel="noopener">birfrostV</a>   推荐这个，v2rayNG对于很多国内的网址，还是会走代理</li><li><a href="https://play.google.com/store/apps/details?id=com.v2ray.ang" target="_blank" rel="noopener">v2rayNG</a></li></ul><h2 id="Windows"><a href="#Windows" class="headerlink" title="Windows"></a>Windows</h2><p>以下两个都需要下载</p><ul><li><a href="https://github.com/v2ray/v2ray-core/releases" target="_blank" rel="noopener">v2ray-core</a> ，点击链接，到github上选择自己的平台版本即可</li><li><a href="https://github.com/2dust/v2rayN/releases/" target="_blank" rel="noopener">v2rayN</a> 点击链接，下载里面的<a href="https://github.com/2dust/v2rayN/releases/download/2.29/v2rayN.zip" target="_blank" rel="noopener">v2rayN.zip</a>即可</li><li><a href="https://github.com/Cenmrev/V2RayW/releases" target="_blank" rel="noopener">v2rayW</a> 下载压缩包即可，这个程序会主动帮助下载 v2ray-core 所以更方便点，界面也比 v2rayN 看着舒服</li></ul><h1 id="Mac"><a href="#Mac" class="headerlink" title="Mac"></a>Mac</h1><ul><li><a href="https://github.com/v2ray/v2ray-core/releases" target="_blank" rel="noopener">v2ray-core</a> ，点击链接，到github上选择Mac的压缩包，下载解压就可以了</li></ul>]]></content>
      
      
      <categories>
          
          <category> 科学上网 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 科学上网 </tag>
            
            <tag> V2ray </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>OpenTSDB概述</title>
      <link href="/posts/44478/"/>
      <url>/posts/44478/</url>
      
        <content type="html"><![CDATA[<p>OpenTSDB 是一个时系列数据（库），它基于HBase存储数据，充分发挥了HBase的分布式列存储特性，支持数百万每秒的读写，它的特点就是容易扩展，灵活的tag机制。</p><a id="more"></a><h2 id="存储相关概念"><a href="#存储相关概念" class="headerlink" title="存储相关概念"></a>存储相关概念</h2><p>例：假设我们采集1个服务器（hostname=qatest）的CPU使用率，发现该服务器在21:00的时候，CPU使用率达到99%</p><ul><li><p>Metric：即平时我们所说的监控项。譬如上面的CPU使用率</p></li><li><p>Tags：就是一些标签，在OpenTSDB里面，Tags由tagk和tagv组成，即tagk=takv。标签是用来描述Metric的，譬如上面为了标记是服务器A的CpuUsage，tags可为hostname=qatest</p></li><li><p>Value：一个Value表示一个metric的实际数值，譬如上面的99%</p></li><li><p>Timestamp：即时间戳，用来描述Value是什么时候的，譬如上面的21:00</p></li><li><p>Data Point：即某个Metric在某个时间点的数值。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Data Point包括以下部分：Metric、Tags、Value、Timestamp</span><br></pre></td></tr></table></figure><p>   上面描述的服务器在21:00时候的cpu使用率，就是1个DataPoint</p></li></ul><h2 id="查询组件"><a href="#查询组件" class="headerlink" title="查询组件"></a>查询组件</h2><table><thead><tr><th>参数</th><th>数据类型</th><th>Required</th><th>描述</th><th>示例</th></tr></thead><tbody><tr><td>Start Time</td><td>String或Integer</td><td>Required</td><td>查询的开始时间。可以是绝对时间或相对时间</td><td>24h-ago</td></tr><tr><td>End Time</td><td>String或Integer</td><td>Optional</td><td>查询的结束时间。如果未提供结束时间，则当前时间即结束时间</td><td>1h-ago</td></tr><tr><td>Metric</td><td>String</td><td>Required</td><td>系统中的metric全名。必须是全名并且大小写敏感</td><td>sys.cpu.user</td></tr><tr><td>Aggregation Function</td><td>String</td><td>Required</td><td>用于组合多个时间序列的数学函数（即如何合并一个组中的时间序列值）</td><td>sum</td></tr><tr><td>Filter</td><td>String</td><td>Optional</td><td>过滤标签值以减少查询或组中挑选出的时间序列的数量，并聚合各个标签</td><td>host=*,dc=lax</td></tr><tr><td>Downsampler</td><td>String</td><td>Optional</td><td>可选的时间间隔和函数，用于减少随时间返回的数据点的数量</td><td>1h-avg</td></tr><tr><td>Rate</td><td>String</td><td>Optional</td><td>用于计算结果的每秒变化率</td><td>rate</td></tr><tr><td>Functions</td><td>String</td><td>Optional</td><td>数据处理函数，如附加过滤、时间切换等</td><td>highestMax(…)</td></tr><tr><td>Expressions</td><td>String</td><td>Optional</td><td>数据处理函数，例如将一个序列分化成另一个序列</td><td>(m2/(m1 + m2))*100</td></tr></tbody></table><h3 id="Aggregation-聚合"><a href="#Aggregation-聚合" class="headerlink" title="Aggregation(聚合)"></a>Aggregation(聚合)</h3><table><thead><tr><th>聚合器</th><th>TSD版本</th><th>描述</th><th>插值</th></tr></thead><tbody><tr><td>avg</td><td>1.0</td><td>数据点平均值</td><td>线性插值</td></tr><tr><td>count</td><td>2.2</td><td>集合中原始数据点的数量</td><td>0替换缺失值</td></tr><tr><td>dev</td><td>1.0</td><td>计算标准差</td><td>线性插值</td></tr><tr><td>Ep50r3</td><td>2.2</td><td>使用R-3方法计算估计的50%</td><td>线性插值</td></tr><tr><td>Ep50r7</td><td>2.2</td><td>使用R-7方法计算估计的50%</td><td>线性插值</td></tr><tr><td>Ep75r3</td><td>2.2</td><td>使用R-3方法计算估计的75%</td><td>线性插值</td></tr><tr><td>Ep75r7</td><td>2.2</td><td>使用R-7方法计算估计的75%</td><td>线性插值</td></tr><tr><td>Ep90r3</td><td>2.2</td><td>使用R-3方法计算估计的90%</td><td>线性插值</td></tr><tr><td>Ep90r7</td><td>2.2</td><td>使用R-7方法计算估计的90%</td><td>线性插值</td></tr><tr><td>Ep95r3</td><td>2.2</td><td>使用R-3方法计算估计的95%</td><td>线性插值</td></tr><tr><td>Ep95r7</td><td>2.2</td><td>使用R-7方法计算估计的95%</td><td>线性插值</td></tr><tr><td>Ep99r3</td><td>2.2</td><td>使用R-3方法计算估计的99%</td><td>线性插值</td></tr><tr><td>Ep99r7</td><td>2.2</td><td>使用R-7方法计算估计的99%</td><td>线性插值</td></tr><tr><td>Ep999r3</td><td>2.2</td><td>使用R-3方法计算估计的999%</td><td>线性插值</td></tr><tr><td>Ep999r7</td><td>2.2</td><td>使用R-7方法计算估计的999%</td><td>线性插值</td></tr><tr><td>first</td><td>2.3</td><td>返回集合中的第一个数据点。仅仅对降采样有用，对聚合无用</td><td>不定</td></tr><tr><td>last</td><td>2.3</td><td>返回集合中的最后一个数据点。仅仅对降采样有用，对聚合无用</td><td>不定</td></tr><tr><td>mimmin</td><td>2.0</td><td>筛选最小的数据点</td><td>线性插值</td></tr><tr><td>mimmax</td><td>2.0</td><td>筛选最大的数据点</td><td>线性插值</td></tr><tr><td>min</td><td>1.0</td><td>筛选最小的数据点</td><td>线性插值</td></tr><tr><td>max</td><td>1.0</td><td>筛选最大的数据点</td><td>线性插值</td></tr><tr><td>none</td><td>2.3</td><td>通过所有时间序列的聚合跳过组</td><td>0替换缺失值</td></tr><tr><td>p50</td><td>2.3</td><td>计算50%</td><td>线性插值</td></tr><tr><td>p75</td><td>2.3</td><td>计算75%</td><td>线性插值</td></tr><tr><td>p90</td><td>2.3</td><td>计算90%</td><td>线性插值</td></tr><tr><td>p95</td><td>2.3</td><td>计算95%</td><td>线性插值</td></tr><tr><td>p99</td><td>2.3</td><td>计算99%</td><td>线性插值</td></tr><tr><td>p999</td><td>2.3</td><td>计算999%</td><td>线性插值</td></tr><tr><td>sum</td><td>1.0</td><td>将数据点一起求和</td><td>线性插值</td></tr><tr><td>zimsum</td><td>1.0</td><td>将数据点一起求和</td><td>0替换缺失值</td></tr></tbody></table><h3 id="Functions-函数"><a href="#Functions-函数" class="headerlink" title="Functions(函数)"></a>Functions(函数)</h3><h4 id="Bosun语法"><a href="#Bosun语法" class="headerlink" title="Bosun语法"></a>Bosun语法</h4><ul><li><p>q(query string, startDuration string, endDuration string) seriesSet *</p></li><li><p>band(query string, duration string, period string, num scalar) seriesSet *</p></li><li><p>over(query string, duration string, period string, num scalar) seriesSet *</p></li><li><p>change(query string, startDuration string, endDuration string) numberSet *</p></li><li><p>count(query string, startDuration string, endDuration string) scalar *</p></li><li><p>window(query string, duration string, period string, num scalar, funcName string) seriesSet *</p></li><li><p>avg(seriesSet) numberSet<br>取数据集的平均值</p></li><li><p>sum(seriesSet) numberSet<br>求和</p></li><li><p>cCount(seriesSet) numberSet<br>数据集的变化程度，根据每个数据与它前一个数据的比较得出。例如，数据集cCount([0,1,0,1])返回3</p></li><li><p>dev(seriesSet) numberSet<br>标准差</p></li><li><p>diff(seriesSet) numberSet<br>最后一个数减去第一个数的差值</p></li><li><p>first(seriesSet) numberSet<br>数据集的第一个数据</p></li><li><p>last(seriesSet) numberSet<br>数据集的最后一个数据</p></li><li><p>len(seriesSet) numberSet<br>数据集的长度</p></li><li><p>max(seriesSet) numberSet<br>最大值</p></li><li><p>median(seriesSet) numberSet<br>中间值</p></li><li><p>min(seriesSet) numberSet<br>最小值</p></li><li><p>percentile(seriesSet, p numberSet|scalar) numberSet<br>返回数据集前百分比为p的数据，例如最大值max相当于p&gt;=1, 中间值相当于p==0.5</p></li><li><p>since(seriesSet) numberSet</p></li><li><p>Returns the number of seconds since the most recent data point in each series.</p></li><li><p>streak(seriesSet) numberSet<br>连续非零数据的最大长度</p></li><li><p>t(numberSet, group string) seriesSet</p><p>Transposes N series of length 1 to 1 series of length N. If the group parameter is not the empty string, the number of series returned is equal to the number of tagks passed. This is useful for performing scalar aggregation across multiple results from a query. For example, to get the total memory used on the web tier: sum(t(avg(q(“avg:os.mem.used{host=-web}”, “5m”, “”)), “”)).</p></li><li><p>alert(name string, key string) numberSet *</p></li><li><p>abs(numberSet) numberSet<br>返回数据集中每个元素的绝对值</p></li><li><p>d(string) scalar<br>返回一个时间段的秒数，例如d(“1h”)返回60</p></li><li><p>tod(scalar) string<br>Returns an OpenTSDB duration string that represents the given number of seconds. This lets you do math on durations and then pass it to the duration arguments in functions like q()<br>des(series, alpha scalar, beta scalar) series<br>Returns series smoothed using Holt-Winters double exponential smoothing. Alpha (scalar) is the data smoothing factor. Beta (scalar) is the trend smoothing factor.</p></li><li><p>dropg(seriesSet, threshold numberSet|scalar) seriesSet<br>移除数据集中大于指定阀值的元素</p></li><li><p>dropge(seriesSet, threshold numberSet|scalar) seriesSet<br>移除数据集中大于等于指定阀值的元素</p></li><li><p>dropl(seriesSet, threshold numberSet|scalar) seriesSet<br>移除数据集中小于等于指定阀值的元素</p></li><li><p>drople(seriesSet, threshold numberSet|scalar) seriesSet<br>移除数据集中小于等于指定阀值的元素</p></li><li><p>dropna(seriesSet) seriesSet<br>移除数据集中类型是NaN是Inf的元素</p></li><li><p>dropbool(seriesSet, seriesSet) seriesSet</p></li><li><p>epoch() scalar<br>返回当前的Unix时间戳</p></li><li><p>filter(seriesSet, numberSet) seriesSet</p></li><li><p>limit(numberSet, count scalar) numberSet</p></li><li><p>lookup(table string, key string) numberSet</p></li><li><p>shift(seriesSet, dur string) seriesSet</p></li><li><p>merge(SeriesSet…) seriesSet</p></li><li><p>nv(numberSet, scalar) numberSet</p></li></ul><h2 id="示例"><a href="#示例" class="headerlink" title="示例"></a>示例</h2><h3 id="简单聚合测试"><a href="#简单聚合测试" class="headerlink" title="简单聚合测试"></a>简单聚合测试</h3><table><thead><tr><th>序号</th><th>metric</th><th>tag</th><th>value</th></tr></thead><tbody><tr><td>1</td><td>test.host.2</td><td>dc=dal host=web01</td><td>3</td></tr><tr><td>2</td><td>test.host.2</td><td>dc=dal host=web02</td><td>2</td></tr><tr><td>3</td><td>test.host.2</td><td>dc=dal host=web03</td><td>10</td></tr><tr><td>4</td><td>test.host.2</td><td>host=web01</td><td>1</td></tr><tr><td>5</td><td>test.host.2</td><td>host=web01 owner=jdoe</td><td>4</td></tr><tr><td>6</td><td>test.host.2</td><td>dc=lax host=web01</td><td>8</td></tr><tr><td>7</td><td>test.host.2</td><td>dc=lax host=web02</td><td>4</td></tr></tbody></table><ol><li><p>单tag查询</p><blockquote><p>q(“sum:test.host.2{host=web01}”, “24h”, “”)</p></blockquote><blockquote><p>匹配结果：1，4，5，6</p></blockquote><p>| group          | result                | computations |<br>| :————- | :——————– | :———– |<br>| { host=web01 } | <code>{&quot;1557327756&quot;: 16 }</code> |              |</p><blockquote><p>q(“avg:test.host.2{host=web01}”, “24h”, “”)</p></blockquote><p>| group          | result                 | computations |<br>| :————- | :——————— | :———– |<br>| { host=web01 } | <code>{   &quot;1557327756&quot;: 4}</code> |              |</p><blockquote><p>q(“count:test.host.2{host=web01}”, “24h”, “”)</p></blockquote><p>|                |                         |              |<br>| :————- | :———————- | :———– |<br>| group          | result                  | computations |<br>| { host=web01 } | <code>{   &quot;1557327756&quot;: 4 }</code> |              |</p></li><li><p>多tag查询</p><blockquote><p>q(“sum:test.host.2{dc=dal,host=web01}”, “24h”, “”)</p></blockquote><blockquote><p>匹配结果：1</p></blockquote><p>| group                  | result                  | computations |<br>| :——————— | :———————- | :———– |<br>| { dc=dal, host=web01 } | <code>{   &quot;1557327756&quot;: 3 }</code> |              |</p><blockquote><p>q(“avg:test.host.2{dc=dal,host=web01}”, “24h”, “”)</p></blockquote><p>| group                  | result                  | computations |<br>| :——————— | :———————- | :———– |<br>| { dc=dal, host=web01 } | <code>{   &quot;1557327756&quot;: 3 }</code> |              |</p><blockquote><p>q(“count:test.host.2{dc=dal,host=web01}”, “24h”, “”)</p></blockquote><p>| group                  | result                  | computations |<br>| :——————— | :———————- | :———– |<br>| { dc=dal, host=web01 } | <code>{   &quot;1557327756&quot;: 1 }</code> |              |</p></li><li><p>正则*查询</p><blockquote><p>q(“sum:test.host.2{dc=dal,host=*}”, “24h”, “”)</p></blockquote><blockquote><p>匹配结果：1，2，3</p><p>匹配结果会以 查询中的唯一tag为一个聚类</p></blockquote><p>| group                  | result                   | computations |<br>| :——————— | :———————– | :———– |<br>| { dc=dal, host=web01 } | <code>{   &quot;1557327756&quot;: 3 }</code>  |              |<br>| { dc=dal, host=web02 } | <code>{   &quot;1557327756&quot;: 2 }</code>  |              |<br>| { dc=dal, host=web03 } | <code>{   &quot;1557327756&quot;: 10 }</code> |              |</p><blockquote><p>q(“avg:test.host.2{dc=dal,host=*}”, “24h”, “”)</p></blockquote><p>| group                  | result                   | computations |<br>| :——————— | :———————– | :———– |<br>| { dc=dal, host=web01 } | <code>{   &quot;1557327756&quot;: 3 }</code>  |              |<br>| { dc=dal, host=web02 } | <code>{   &quot;1557327756&quot;: 2 }</code>  |              |<br>| { dc=dal, host=web03 } | <code>{   &quot;1557327756&quot;: 10 }</code> |              |</p><blockquote><p>q(“count:test.host.2{dc=dal,host=*}”, “24h”, “”)</p></blockquote><p>| group                  | result                  | computations |<br>| :——————— | :———————- | :———– |<br>| { dc=dal, host=web01 } | <code>{   &quot;1557327756&quot;: 1 }</code> |              |<br>| { dc=dal, host=web02 } | <code>{   &quot;1557327756&quot;: 1 }</code> |              |<br>| { dc=dal, host=web03 } | <code>{   &quot;1557327756&quot;: 1 }</code> |              |</p></li><li><p>正则|查询</p><blockquote><p>q(“sum:test.host.2{dc=dal|lax}”, “24h”, “”)</p></blockquote><blockquote><p>匹配结果：1，2，3，6，7</p></blockquote><p>| group      | result                   | computations |<br>| :——— | :———————– | :———– |<br>| { dc=dal } | <code>{   &quot;1557327756&quot;: 15 }</code> |              |<br>| { dc=lax } | <code>{   &quot;1557327756&quot;: 12 }</code> |              |</p><blockquote><p>q(“avg:test.host.2{dc=dal|lax}”, “24h”, “”)</p></blockquote><p>| group      | result                  | computations |<br>| :——— | :———————- | :———– |<br>| { dc=dal } | <code>{   &quot;1557327756&quot;: 5 }</code> |              |<br>| { dc=lax } | <code>{   &quot;1557327756&quot;: 6 }</code> |              |</p><blockquote><p>q(“count:test.host.2{dc=dal|lax}”, “24h”, “”)</p></blockquote><p>| group      | result                  | computations |<br>| :——— | :———————- | :———– |<br>| { dc=dal } | <code>{   &quot;1557327756&quot;: 3 }</code> |              |<br>| { dc=lax } | <code>{   &quot;1557327756&quot;: 2 }</code> |              |</p></li></ol><h3 id="rate测试"><a href="#rate测试" class="headerlink" title="rate测试"></a>rate测试</h3><table><thead><tr><th>序号</th><th>metric</th><th>tag</th><th>value</th><th>Time</th></tr></thead><tbody><tr><td>1</td><td>test.host.3</td><td>host=host1</td><td>4</td><td>1557327757</td></tr><tr><td>2</td><td>test.host.3</td><td>host=host1</td><td>8</td><td>1557327758</td></tr><tr><td>3</td><td>test.host.3</td><td>host=host1</td><td>12</td><td>1557327759</td></tr><tr><td>4</td><td>test.host.3</td><td>host=host1</td><td>16</td><td>1557327760</td></tr><tr><td>5</td><td>test.host.3</td><td>host=host1</td><td>16</td><td>1557327761</td></tr><tr><td>6</td><td>test.host.3</td><td>host=host1</td><td>17</td><td>1557327763</td></tr></tbody></table><blockquote><p>q(“avg:rate:test.host.3{host=host1}”, “24h”, “”)</p></blockquote><table><thead><tr><th style="text-align:left">group</th><th style="text-align:left">result</th><th style="text-align:left">computations</th></tr></thead><tbody><tr><td style="text-align:left">{ host=host1 }</td><td style="text-align:left"><code>{   &quot;1557327757&quot;: 4,   &quot;1557327758&quot;: 4,   &quot;1557327759&quot;: 4,   &quot;1557327760&quot;: 4,   &quot;1557327761&quot;: 0,   &quot;1557327763&quot;: 0.5 }</code></td></tr></tbody></table>]]></content>
      
      
      <categories>
          
          <category> OpenTSDB </category>
          
      </categories>
      
      
        <tags>
            
            <tag> OpenTSDB </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Sync.Pool浅析</title>
      <link href="/posts/61660/"/>
      <url>/posts/61660/</url>
      
        <content type="html"><![CDATA[<p>sync pool使用来存放临时变量的一个缓冲区，但是这个缓冲区并不可靠，每次gc的时候，都会首先清除缓冲区，所以，假如一个slice仅仅存放在 Pool 中，而没有其他地方引用，则会被当成垃圾清理掉。</p><a id="more"></a><h2 id="概念"><a href="#概念" class="headerlink" title="概念"></a>概念</h2><blockquote><p>A Pool is a set of temporary objects that may be individually saved and retrieved.</p><p>Any item stored in the Pool may be removed automatically at any time without notification. If the Pool holds the only reference when this happens, the item might be deallocated.</p><p>A Pool is safe for use by multiple goroutines simultaneously.</p><p>Pool’s purpose is to cache allocated but unused items for later reuse, relieving pressure on the garbage collector. That is, it makes it easy to build efficient, thread-safe free lists. However, it is not suitable for all free lists.</p><p>An appropriate use of a Pool is to manage a group of temporary items silently shared among and potentially reused by concurrent independent clients of a package. Pool provides a way to amortize allocation overhead across many clients.</p><p>An example of good use of a Pool is in the fmt package, which maintains a dynamically-sized store of temporary output buffers. The store scales under load (when many goroutines are actively printing) and shrinks when quiescent.</p></blockquote><h2 id="图示"><a href="#图示" class="headerlink" title="图示"></a>图示</h2><p><img src="http://note-1253518569.cossh.myqcloud.com/20190519203029.png" alt></p><p>sync.pool的结构组成如上图所示，在这里可能会有两个问题</p><ol><li>我们实例化 Sync.Pool的时候，为什么实例化了一个LocalPool数组，怎么确定我的数据应该存储在LocalPool数组的哪个单元？</li><li>PoolLocalInternal 里面的成员有private和shared，为什么要做这两种区分？</li></ol><h2 id="源码分析"><a href="#源码分析" class="headerlink" title="源码分析"></a>源码分析</h2><h3 id="Put"><a href="#Put" class="headerlink" title="Put"></a>Put</h3><h4 id="Put-1"><a href="#Put-1" class="headerlink" title="Put()"></a>Put()</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line">func (p *Pool) Put(x interface&#123;&#125;) &#123;</span><br><span class="line">if x == nil &#123;</span><br><span class="line">return</span><br><span class="line">&#125;</span><br><span class="line">// race检测 先忽略这一块</span><br><span class="line">if race.Enabled &#123;</span><br><span class="line">if fastrand()%4 == 0 &#123;</span><br><span class="line">// Randomly drop x on floor.</span><br><span class="line">return</span><br><span class="line">&#125;</span><br><span class="line">race.ReleaseMerge(poolRaceAddr(x))</span><br><span class="line">race.Disable()</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">// 根据自身的goroutine的id，获取对应的PoolLocal的地址，后面具体分析</span><br><span class="line">l := p.pin()</span><br><span class="line">// 如果private字段为空的话，首先给private字段赋值</span><br><span class="line">if l.private == nil &#123;</span><br><span class="line">l.private = x</span><br><span class="line">x = nil</span><br><span class="line">&#125;</span><br><span class="line">runtime_procUnpin()</span><br><span class="line">// 如果private字段, 则添加到shared字段，因为 shared字段可以被其他goroutine获取，所以这里需要加锁</span><br><span class="line">if x != nil &#123;</span><br><span class="line">l.Lock()</span><br><span class="line">l.shared = append(l.shared, x)</span><br><span class="line">l.Unlock()</span><br><span class="line">&#125;</span><br><span class="line">if race.Enabled &#123;</span><br><span class="line">race.Enable()</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="pin"><a href="#pin" class="headerlink" title="pin()"></a>pin()</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">func (p *Pool) pin() *poolLocal &#123;</span><br><span class="line">   // 获取当前的Pid/P，数量由</span><br><span class="line">pid := runtime_procPin()</span><br><span class="line">// LocalPool的数量</span><br><span class="line">s := atomic.LoadUintptr(&amp;p.localSize) // load-acquire</span><br><span class="line">l := p.local                          // load-consume</span><br><span class="line">// 如果获取到的pid比LocalPool数组的长度小，返回对应的LocalPool</span><br><span class="line">if uintptr(pid) &lt; s &#123;</span><br><span class="line">return indexLocal(l, pid)</span><br><span class="line">&#125;</span><br><span class="line">// 如果pid比LocalPool数组的长度大，进一步确认，这个函数后面讨论</span><br><span class="line">return p.pinSlow()</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>runtime_procPin()</code> 这个是获取当前运行的pid，具体实现没有查到， 但是<code>runtime_procPin()</code>返回的数值范围是由 <code>runtime.GOMAXPROCS(0)</code> 决定的。网上有篇文章可以参考一下<a href="https://juejin.im/post/5b7678f451882533110e8948" target="_blank" rel="noopener">《Golang 的 协程调度机制 与 GOMAXPROCS 性能调优》</a>，这里暂不深入</p><h4 id="PinSlow"><a href="#PinSlow" class="headerlink" title="PinSlow()"></a>PinSlow()</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line">func (p *Pool) pinSlow() *poolLocal &#123;</span><br><span class="line">// Retry under the mutex.</span><br><span class="line">// Can not lock the mutex while pinned.</span><br><span class="line">runtime_procUnpin()</span><br><span class="line">allPoolsMu.Lock()</span><br><span class="line">defer allPoolsMu.Unlock()</span><br><span class="line">pid := runtime_procPin()</span><br><span class="line">// poolCleanup won&apos;t be called while we are pinned.</span><br><span class="line">// 再次检查是否LocalPool是否有对应的索引，避免其他的线程造成影响</span><br><span class="line">s := p.localSize</span><br><span class="line">l := p.local</span><br><span class="line">if uintptr(pid) &lt; s &#123;</span><br><span class="line">return indexLocal(l, pid)</span><br><span class="line">&#125;</span><br><span class="line">// 如果local为nil，说明是新构建的Pool结构体，加紧allPools slice里面</span><br><span class="line">if p.local == nil &#123;</span><br><span class="line">allPools = append(allPools, p)</span><br><span class="line">&#125;</span><br><span class="line">// If GOMAXPROCS changes between GCs, we re-allocate the array and lose the old one.</span><br><span class="line">// 重新获取 GOMAXPROCS，并根据这个设置PoolLocal的大小</span><br><span class="line">size := runtime.GOMAXPROCS(0)</span><br><span class="line">local := make([]poolLocal, size)</span><br><span class="line">atomic.StorePointer(&amp;p.local, unsafe.Pointer(&amp;local[0])) // store-release</span><br><span class="line">atomic.StoreUintptr(&amp;p.localSize, uintptr(size))         // store-release</span><br><span class="line">// 找到当前goroutine对应的地址，并返回</span><br><span class="line">return &amp;local[pid]</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="Put-逻辑"><a href="#Put-逻辑" class="headerlink" title="Put 逻辑"></a>Put 逻辑</h4><p>综上，Put的基本操作逻辑就是</p><ul><li>获取当前执行的<code>Pid</code></li><li>根据Pid，找到对应的<code>PoolLocal</code>，接着使用里面<code>PoolLocalInternal</code></li><li>优先存入 <code>PoolLocalInternal</code> 的 <code>private</code>属性，其次粗如 <code>PoolLocalInternal</code> 的 <code>shared</code> 这个slice里面</li></ul><h3 id="Get"><a href="#Get" class="headerlink" title="Get"></a>Get</h3><h4 id="Get-1"><a href="#Get-1" class="headerlink" title="Get()"></a>Get()</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line">func (p *Pool) Get() interface&#123;&#125; &#123;</span><br><span class="line">if race.Enabled &#123;</span><br><span class="line">race.Disable()</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">// 获取到LocalPool</span><br><span class="line">l := p.pin()</span><br><span class="line"></span><br><span class="line">// 把private数据值拷贝一份，然后把private设置为nil，因为如果private有数据，把private数据返回后，要把private设置为nil，如果private没有数据，则原先就是nil，添加这一步也没有关系</span><br><span class="line">x := l.private</span><br><span class="line">l.private = nil</span><br><span class="line">runtime_procUnpin()</span><br><span class="line">// 如果private里面没有数据，则从shared里面去找</span><br><span class="line">if x == nil &#123;</span><br><span class="line">l.Lock()</span><br><span class="line">last := len(l.shared) - 1</span><br><span class="line">if last &gt;= 0 &#123;</span><br><span class="line">x = l.shared[last]</span><br><span class="line">l.shared = l.shared[:last]</span><br><span class="line">&#125;</span><br><span class="line">l.Unlock()</span><br><span class="line">// 如果当前线程下对应的LocalPool，没有数据，则调用getSlow()，从其他的LocalPool的shared里面获取数据，后面解析 getSlow</span><br><span class="line">if x == nil &#123;</span><br><span class="line">x = p.getSlow()</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">if race.Enabled &#123;</span><br><span class="line">race.Enable()</span><br><span class="line">if x != nil &#123;</span><br><span class="line">race.Acquire(poolRaceAddr(x))</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">// 如果 从private shared及其他的LocalPool的shared里面都获取不到数据，且注册的New函数不为空，则执行注册的New函数</span><br><span class="line">if x == nil &amp;&amp; p.New != nil &#123;</span><br><span class="line">x = p.New()</span><br><span class="line">&#125;</span><br><span class="line">return x</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="getSlow"><a href="#getSlow" class="headerlink" title="getSlow()"></a>getSlow()</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">func (p *Pool) getSlow() (x interface&#123;&#125;) &#123;</span><br><span class="line">// See the comment in pin regarding ordering of the loads.</span><br><span class="line">// 获取LocalPool的size</span><br><span class="line">size := atomic.LoadUintptr(&amp;p.localSize) // load-acquire</span><br><span class="line">local := p.local                         // load-consume</span><br><span class="line">// Try to steal one element from other procs.</span><br><span class="line">pid := runtime_procPin()</span><br><span class="line">runtime_procUnpin()</span><br><span class="line">// 便利LocalPool，获取shared里面的数据，找到就返回</span><br><span class="line">for i := 0; i &lt; int(size); i++ &#123;</span><br><span class="line">l := indexLocal(local, (pid+i+1)%int(size))</span><br><span class="line">l.Lock()</span><br><span class="line">last := len(l.shared) - 1</span><br><span class="line">if last &gt;= 0 &#123;</span><br><span class="line">x = l.shared[last]</span><br><span class="line">l.shared = l.shared[:last]</span><br><span class="line">l.Unlock()</span><br><span class="line">break</span><br><span class="line">&#125;</span><br><span class="line">l.Unlock()</span><br><span class="line">&#125;</span><br><span class="line">return x</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>通过上面的逻辑可以看出，<code>shared</code> 里面的数据是会被其他的P检索到的，而 <code>private</code>里面的数据是不会的，所以在获取<code>shared</code>里面数据的时候，需要加锁</p><h3 id="poolCleanup"><a href="#poolCleanup" class="headerlink" title="poolCleanup"></a>poolCleanup</h3><p>这个函数是Pool包里面提供的，用来清理Pool的，但是官方的实现略显粗暴</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line">func poolCleanup() &#123;</span><br><span class="line">// This function is called with the world stopped, at the beginning of a garbage collection.</span><br><span class="line">// It must not allocate and probably should not call any runtime functions.</span><br><span class="line">// Defensively zero out everything, 2 reasons:</span><br><span class="line">// 1. To prevent false retention of whole Pools.</span><br><span class="line">// 2. If GC happens while a goroutine works with l.shared in Put/Get,</span><br><span class="line">//    it will retain whole Pool. So next cycle memory consumption would be doubled.</span><br><span class="line">// 便利所有的Sync.Pool</span><br><span class="line">for i, p := range allPools &#123;</span><br><span class="line">allPools[i] = nil</span><br><span class="line">// 遍历Pool里面的LocalPool，并清空里面的数据</span><br><span class="line">for i := 0; i &lt; int(p.localSize); i++ &#123;</span><br><span class="line">l := indexLocal(p.local, i)</span><br><span class="line">l.private = nil</span><br><span class="line">for j := range l.shared &#123;</span><br><span class="line">l.shared[j] = nil</span><br><span class="line">&#125;</span><br><span class="line">l.shared = nil</span><br><span class="line">&#125;</span><br><span class="line">p.local = nil</span><br><span class="line">p.localSize = 0</span><br><span class="line">&#125;</span><br><span class="line">// 清空allPools</span><br><span class="line">allPools = []*Pool&#123;&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这个函数会在GC之前调用，这也就解释了官方的下面一句话</p><blockquote><p>Any item stored in the Pool may be removed automatically at any time without<br>notification. If the Pool holds the only reference when this happens, the<br>item might be deallocated.</p></blockquote><p>如果一个数据仅仅在Pool中有引用，那么就需要担心这个数据被GC清理掉</p><h3 id="问题分析"><a href="#问题分析" class="headerlink" title="问题分析"></a>问题分析</h3><p>针对于上面提出的两个问题，做一下简单的分析</p><blockquote><p>我们实例化 Sync.Pool的时候，为什么实例化了一个LocalPool数组，怎么确定我的数据应该存储在LocalPool数组的哪个单元？</p></blockquote><p>这里的LocalPool是根据不同的pid来区分的，保证private数据的线程安全，程序运行的时候可以获取到pid，然后使用pid作为LocalPool的索引，找到对应的地址即可</p><blockquote><p>PoolLocalInternal 里面的成员有private和shared，为什么要做这两种区分？</p></blockquote><p><code>private</code> 是 P 专属的， <code>shared</code>是可以被其他的P获取到的</p><h2 id="参考文档"><a href="#参考文档" class="headerlink" title="参考文档"></a>参考文档</h2><p><a href="http://www.mckee.cn/golang/pkg/syncpool" target="_blank" rel="noopener">《sync.Pool源码实现》</a><br>《Go 语言学习笔记 - 雨痕》</p>]]></content>
      
      
      <categories>
          
          <category> Go </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Go </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>GraphQL学习</title>
      <link href="/posts/42393/"/>
      <url>/posts/42393/</url>
      
        <content type="html"><![CDATA[<p>GraphQL 既是一种用于 API 的查询语言也是一个满足你数据查询的运行时。 GraphQL 对你的 API 中的数据提供了一套易于理解的完整描述，使得客户端能够准确地获得它需要的数据，而且没有任何冗余，也让 API 更容易地随着时间推移而演进，还能用于构建强大的开发者工具。</p><a id="more"></a><h2 id="对象类型和字段"><a href="#对象类型和字段" class="headerlink" title="对象类型和字段"></a>对象类型和字段</h2><pre><code>type Character {  name: String!  appearsIn: [Episode!]!}</code></pre><ul><li><strong>Character</strong> 是一个 GraphQL 对象类型，表示其是一个拥有一些字段的类型。你的 schema 中的大多数类型都会是对象类型。<br>name 和 appearsIn 是 Character 类型上的字段。这意味着在一个操作 Character 类型的 GraphQL 查询中的任何部分，都只能出现 name 和 appearsIn 字段。</li><li><strong>String</strong> 是内置的标量类型之一 —— 标量类型是解析到单个标量对象的类型，无法在查询中对它进行次级选择。后面我们将细述标量类型。</li><li><strong>String!</strong> 表示这个字段是非空的，GraphQL 服务保证当你查询这个字段后总会给你返回一个值。在类型语言里面，我们用一个感叹号来表示这个特性。</li><li><strong>[Episode!]!</strong> 表示一个 Episode 数组。因为它也是非空的，所以当你查询 appearsIn 字段的时候，你也总能得到一个数组（零个或者多个元素）。且由于 Episode! 也是非空的，你总是可以预期到数组中的每个项目都是一个 Episode 对象。</li></ul><h2 id="标量类型"><a href="#标量类型" class="headerlink" title="标量类型"></a>标量类型</h2><ul><li><strong>Int</strong>：有符号 32 位整数。</li><li><strong>Float</strong>：有符号双精度浮点值。</li><li><strong>String</strong>：UTF‐8 字符序列。</li><li><strong>Boolean</strong>：true 或者 false。</li><li><strong>ID</strong>：ID 标量类型表示一个唯一标识符，通常用以重新获取对象或者作为缓存中的键。ID 类型使用和 String 一样的方式序列化；然而将其定义为 ID 意味着并不需要人类可读型。</li></ul><h2 id="基本查询"><a href="#基本查询" class="headerlink" title="基本查询"></a>基本查询</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">type Account &#123;   // 定义一个接收返回的类型，包含返回的所需要的字段</span><br><span class="line">    name: String // 返回的字段名称及类型</span><br><span class="line">    age: Int</span><br><span class="line">    sex: String</span><br><span class="line">    department: String</span><br><span class="line">&#125;</span><br><span class="line">type Query &#123;   // 定义查询函数及返回类型</span><br><span class="line">    hello: String  // key是函数， value是标准类型或者上述定义的类型</span><br><span class="line">    accountName: String</span><br><span class="line">    age: Int</span><br><span class="line">    account: Account  // 此时返回是上述定义的类型</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="参数传递"><a href="#参数传递" class="headerlink" title="参数传递"></a>参数传递</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">type Account &#123;</span><br><span class="line">    name: String</span><br><span class="line">    age: Int</span><br><span class="line">    sex: String</span><br><span class="line">    department: String</span><br><span class="line">    salary(city: String): Int  // 左侧可以还是函数</span><br><span class="line">&#125;</span><br><span class="line">type Query &#123;</span><br><span class="line">    getClassMates(classNo: Int!): [String] // classNo是参数名， Int是参数类型 !表示必传参数 [string]表示返回的是string数组</span><br><span class="line">    account(username: String): Account</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="查询示例"><a href="#查询示例" class="headerlink" title="查询示例"></a>查询示例</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">&quot;operationName&quot;:&quot;getuserid&quot;,  // 去掉也是ok的</span><br><span class="line">&quot;variables&quot;:&#123;   // 这里是变量的key value， key可以不用，但是query中组要的key必须存在</span><br><span class="line">    &quot;id&quot;:&quot;1&quot;,</span><br><span class="line">    &quot;date&quot;:&quot;2019.03.26&quot;,</span><br><span class="line">    &quot;start&quot;:&quot;1553563272&quot;,</span><br><span class="line">    &quot;end&quot;:&quot;1553566872&quot;,</span><br><span class="line">    &quot;limit&quot;:20 // 多余的字段不影响</span><br><span class="line">&#125;,</span><br><span class="line">&quot;query&quot;:&quot;query getuserid($id: ID!)&#123;  // 执行一个query 这里的 getuserid 可以是任意名字，没有限制， 参数里面制定类型</span><br><span class="line">    getUser(id : $id) &#123; // 这个是query里面声明的函数及参数形式</span><br><span class="line">        id,  // 这里是需要的返回字段，也可以是声明的type，但是字段必须被包含在Account中</span><br><span class="line">        name</span><br><span class="line">    &#125;</span><br><span class="line">&#125;&quot;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="Mutation-变更"><a href="#Mutation-变更" class="headerlink" title="Mutation(变更)"></a>Mutation(变更)</h2><h3 id="示例"><a href="#示例" class="headerlink" title="示例"></a>示例</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">input AccountInput &#123; // 这是输入类型, 使用input定义</span><br><span class="line">    name: String</span><br><span class="line">    age: Int</span><br><span class="line">    sex: String</span><br><span class="line">    department: String</span><br><span class="line">&#125;</span><br><span class="line">type Account &#123;  // 定义输出类型</span><br><span class="line">    name: String</span><br><span class="line">    age: Int</span><br><span class="line">    sex: String</span><br><span class="line">    department: String</span><br><span class="line">&#125;</span><br><span class="line">type Mutation &#123;</span><br><span class="line">    createAccount(input: AccountInput): Account</span><br><span class="line">    updateAccount(id: ID!, input: AccountInput): Account</span><br><span class="line">&#125;</span><br><span class="line">type Query &#123;</span><br><span class="line">    accounts: [Account]</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="请求示例"><a href="#请求示例" class="headerlink" title="请求示例"></a>请求示例</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">&quot;variables&quot;:&#123;   // 这里是变量的key value， key可以不用，但是query中组要的key必须存在</span><br><span class="line">    &quot;name&quot;:&quot;test&quot;,</span><br><span class="line">    &quot;age&quot;:18,</span><br><span class="line">    &quot;sex&quot;:&quot;male&quot;,</span><br><span class="line">    &quot;department&quot;:&quot;luban&quot;,</span><br><span class="line">&#125;,</span><br><span class="line">&quot;mutation&quot;:&quot;mutation createAccount($input: AccountInput)&#123;  // 执行一个query 这里的 getuserid 可以是任意名字，没有限制， 参数里面制定类型</span><br><span class="line">    createAccount(input : $input) &#123;</span><br><span class="line">        age,</span><br><span class="line">        name</span><br><span class="line">    &#125;</span><br><span class="line">&#125;&quot;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> GraphQL </category>
          
      </categories>
      
      
        <tags>
            
            <tag> GraphQL </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>深入理解Go的interface</title>
      <link href="/posts/2647/"/>
      <url>/posts/2647/</url>
      
        <content type="html"><![CDATA[<p>简单介绍一下我对interface的理解，涉及指针类型转换，指针运算，interface结构及反射等</p><a id="more"></a><h2 id="Unsafe-Pointer-和-uintptr"><a href="#Unsafe-Pointer-和-uintptr" class="headerlink" title="Unsafe.Pointer 和 uintptr"></a>Unsafe.Pointer 和 uintptr</h2><h3 id="指针类型转换"><a href="#指针类型转换" class="headerlink" title="指针类型转换"></a>指针类型转换</h3><p>我们一般使用 <code>*T</code> 来表示一个指向类型T变量的指针， 类似于 <code>*int</code> 表示 int型指针。但是指针类型并不能进行类型转换<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">func main() &#123;</span><br><span class="line">var i *int</span><br><span class="line">p := 10</span><br><span class="line">i = &amp;p</span><br><span class="line"></span><br><span class="line">m := (*float64)(i)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">cannot convert i (type *int) to type *float64</span><br></pre></td></tr></table></figure><p>如上，在进行类型转换的时候就会报上述的错误</p><h3 id="unsafe-Pointer"><a href="#unsafe-Pointer" class="headerlink" title="unsafe.Pointer"></a>unsafe.Pointer</h3><p>unsafe.Pointer 是特别定义的一种指针类型（译注：类似C语言中的void类型的指针），它可以包含任意类型变量的地址，是各个指针类型转换的桥梁，所以上述的指针类型转换就可以通过 unsafe.Pointer 实现<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">func main() &#123;</span><br><span class="line">var i *int</span><br><span class="line">p := 10</span><br><span class="line">i = &amp;p</span><br><span class="line"></span><br><span class="line">m := (*float64)(unsafe.Pointer(i))</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>unsafe.Pointer的最终实现其实就是一个 *int<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">type ArbitraryType int</span><br><span class="line"></span><br><span class="line">type Pointer *ArbitraryType</span><br></pre></td></tr></table></figure></p><p>当然，pointer的转换也是有规则的</p><blockquote><p>A safe pointer can be explicitly converted to an unsafe pointer, and vice versa.（安全指针可以显式转换为不安全指针，反之亦然。）<br>An uintptr value can be explicitly converted to an unsafe pointer, and vice versa. But please note, a nil unsafe.Pointer shouldn’t be converted to uintptr and back with arithmetic.（uintptr值可以显式转换为不安全指针，反之亦然。）</p></blockquote><h3 id="uintptr"><a href="#uintptr" class="headerlink" title="uintptr"></a>uintptr</h3><p>一个可以容纳任何指针类型的整型，可以进行指针运算，而Go的指针是不支持运算的，这个也是上述转换的第二条规则的意义，转换成 unintptr 进行指针运算，然后再转换为对应的 类型的指针，以显示变量</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">type User struct &#123;</span><br><span class="line">Name string</span><br><span class="line">Age int</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">func main() &#123;</span><br><span class="line">u := new(User)</span><br><span class="line">name :=(*string)(unsafe.Pointer(u))</span><br><span class="line">*name = &quot;test&quot;</span><br><span class="line"></span><br><span class="line">age := (*int)(unsafe.Pointer(uintptr(unsafe.Pointer(u)) + unsafe.Offsetof(u.Age)))</span><br><span class="line">*age = 18</span><br><span class="line">fmt.Println(u)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>思路: 如果想对Name和 Age进行赋值，那首先应该先拿到相应的地址，然后对地址内容修改，所以我们可以分别定义一个 <em>string 和 </em>int 分别指向 Name 和 Age的地址<br>对于 u这个结构体，u的首地址就是Name的地址，但是u是结构体指针，所以只需要将u转换成 *string 即可<br>对于 Age，我们已经拿到了Name的地址，在此基础上进行偏移即可，也就是 unsafe.Offsetof(u.Age) 的偏移量， 但是 <code>Pointer</code>不能进行指针运算，随意需要将 <code>Pointer</code> 转换成 <code>uintptr</code></p><h2 id="interface"><a href="#interface" class="headerlink" title="interface"></a>interface</h2><h3 id="interface的坑"><a href="#interface的坑" class="headerlink" title="interface的坑"></a>interface的坑</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br></pre></td><td class="code"><pre><span class="line">package main</span><br><span class="line"></span><br><span class="line">import (</span><br><span class="line">&quot;fmt&quot;</span><br><span class="line">)</span><br><span class="line"></span><br><span class="line">type Err struct&#123;&#125;</span><br><span class="line"></span><br><span class="line">func (err *Err) Error() string &#123;</span><br><span class="line">return &quot;&quot;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">func main() &#123;</span><br><span class="line">var i interface&#123;&#125;</span><br><span class="line">i = nil</span><br><span class="line">if i == nil &#123;</span><br><span class="line">fmt.Println(&quot;i is nil&quot;)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">var a *int</span><br><span class="line">a = nil</span><br><span class="line">if a == nil &#123;</span><br><span class="line">fmt.Println(&quot;a is nil&quot;)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">a1 := testInterface()</span><br><span class="line">if a1 == nil &#123;</span><br><span class="line">fmt.Println(&quot;test interface return nil&quot;)</span><br><span class="line">&#125; else &#123;</span><br><span class="line">fmt.Println(&quot;test interface return not nil&quot;)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">a2 := testInterfacePointer()</span><br><span class="line">if a2 == nil &#123;</span><br><span class="line">fmt.Println(&quot;test interface pointer return nil&quot;)</span><br><span class="line">&#125; else &#123;</span><br><span class="line">fmt.Println(&quot;test interface pointer return not nil&quot;)</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">func testInterface() error &#123;</span><br><span class="line">return nil</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">func testInterfacePointer() error &#123;</span><br><span class="line">var p *Err = nil</span><br><span class="line">return p</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>以上面一个代码为例，打印结果如下</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">i is nil</span><br><span class="line">a is nil</span><br><span class="line">test interface return nil</span><br><span class="line">test interface pointer return not nil</span><br></pre></td></tr></table></figure><p>前面三个结果比较好理解，但是为什么 <code>testInterfacePointer</code> 返回结果不是 <code>nil</code><br>我们用gdb调试，看一下</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">i = &#123;_type = 0x0, data = 0x0&#125;</span><br><span class="line">a = 0x0</span><br><span class="line">a1 = &#123;tab = 0x0, data = 0x0&#125;</span><br><span class="line">a2 = &#123;tab = 0x4c8c40 &lt;*main.Err,error&gt;, data = 0x0&#125;</span><br></pre></td></tr></table></figure><p>可以看出来，a2 结构体中的 <code>tab</code> 不是 <code>0x0</code>， 所以，运行结果判断 <code>a2 != nil</code></p><p>为什么i的结构体包含的是 <code>_type</code> <code>data</code>, 但是 a1 和 a2包含的结构体内容是 <code>tab</code> <code>data</code></p><h3 id="interface结构体"><a href="#interface结构体" class="headerlink" title="interface结构体"></a>interface结构体</h3><h4 id="eface-empty-interface"><a href="#eface-empty-interface" class="headerlink" title="eface (empty interface)"></a>eface (empty interface)</h4><p>顾名思义，就是空的interfae, 使用 <code>interface{}</code> 声明的都是 empty interface<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">type eface struct &#123;</span><br><span class="line">_type *_type</span><br><span class="line">data  unsafe.Pointer</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">type _type struct &#123;</span><br><span class="line">size       uintptr // Size returns the number of bytes needed to store a value of the given type，it is analogous to unsafe.Sizeof.可通过 reflec</span><br><span class="line">ptrdata    uintptr // size of memory prefix holding all pointers</span><br><span class="line">hash       uint32 // 类型的hash值，所有的type会存放在hashType表中，以hash为索引</span><br><span class="line">tflag      tflag //  额外类型信息标志</span><br><span class="line">align      uint8 // 此类型type的对齐</span><br><span class="line">fieldalign uint8 // 这个type的结构体字段的对齐</span><br><span class="line">kind       uint8 // 类型编号 定义于runtime/typekind.go</span><br><span class="line">alg        *typeAlg</span><br><span class="line">// gcdata stores the GC type data for the garbage collector.</span><br><span class="line">// If the KindGCProg bit is set in kind, gcdata is a GC program.</span><br><span class="line">// Otherwise it is a ptrmask bitmap. See mbitmap.go for details.</span><br><span class="line">gcdata    *byte</span><br><span class="line">str       nameOff // 类型名字的偏移</span><br><span class="line">ptrToThis typeOff</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h4 id="iface-带函数的interface"><a href="#iface-带函数的interface" class="headerlink" title="iface (带函数的interface)"></a>iface (带函数的interface)</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">type iface struct &#123;</span><br><span class="line">tab  *itab</span><br><span class="line">data unsafe.Pointer</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">type itab struct &#123;</span><br><span class="line">inter *interfacetype // interface的类型</span><br><span class="line">_type *_type // 同上的type</span><br><span class="line">hash  uint32 // copy of _type.hash. Used for type switches.</span><br><span class="line">_     [4]byte</span><br><span class="line">fun   [1]uintptr // variable sized. fun[0]==0 means _type does not implement inter.， fun在栈上偏移地址，因为 fun都是指针，所以长度都是4个字节， 找到fun的首地址后，每偏移4个地址便存储一个函数地址</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">type interfacetype struct &#123;</span><br><span class="line">typ     _type</span><br><span class="line">pkgpath name // 包信息</span><br><span class="line">mhdr    []imethod // method slice，这里是排序后的，方便检测 struct是否继承了 interface</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">type imethod struct &#123;</span><br><span class="line">name nameOff // 函数名字的偏移，这里是int32,后面查找的时候会根据这个数值，计算出偏移量， 存放在 firstmoduledata 这个符号表中</span><br><span class="line">ityp typeOff // type类型的偏移量，对应interface的_type</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li><p><code>size</code>: 存储一个指定类型的值需要的bytes， 可通过 reflect.TypeOf(int8(1)).Size() 或 unsafe.Sizeof(x interface{})来获取</p>  <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">So(unsafe.Sizeof(true), ShouldEqual, 1)</span><br><span class="line">So(unsafe.Sizeof(int8(0)), ShouldEqual, 1)</span><br><span class="line">So(unsafe.Sizeof(int16(0)), ShouldEqual, 2)</span><br><span class="line">So(unsafe.Sizeof(int32(0)), ShouldEqual, 4)</span><br><span class="line">So(unsafe.Sizeof(int64(0)), ShouldEqual, 8)</span><br><span class="line">So(unsafe.Sizeof(int(0)), ShouldEqual, 8)</span><br><span class="line">So(unsafe.Sizeof(float32(0)), ShouldEqual, 4)</span><br><span class="line">So(unsafe.Sizeof(float64(0)), ShouldEqual, 8)</span><br><span class="line">So(unsafe.Sizeof(&quot;&quot;), ShouldEqual, 16)</span><br><span class="line">So(unsafe.Sizeof(&quot;hello world&quot;), ShouldEqual, 16)</span><br><span class="line">So(unsafe.Sizeof([]int&#123;&#125;), ShouldEqual, 24)</span><br><span class="line">So(unsafe.Sizeof([]int&#123;1, 2, 3&#125;), ShouldEqual, 24)</span><br><span class="line">So(unsafe.Sizeof([3]int&#123;1, 2, 3&#125;), ShouldEqual, 24)</span><br><span class="line">So(unsafe.Sizeof(map[string]string&#123;&#125;), ShouldEqual, 8)</span><br><span class="line">So(unsafe.Sizeof(map[string]string&#123;&quot;1&quot;: &quot;one&quot;, &quot;2&quot;: &quot;two&quot;&#125;), ShouldEqual, 8)</span><br><span class="line">So(unsafe.Sizeof(struct&#123;&#125;&#123;&#125;), ShouldEqual, 0)</span><br></pre></td></tr></table></figure></li><li><p><code>_type</code>: 就是表示结构体的类型，这些类型会被存放在 firstmoduledata 这个符号表中，反射其实就是根据 _type 里面偏移量或者索引，到对应地方获取我们认知的数据并返回</p></li><li><code>data</code>: 就是指向 数据存放的地址的指针，例如上面的 i interface{} = 3, 其实就是在堆或栈上分配一个空间存放这些数据，然后 data中存放这个地址（这里可以优化，如果 数据占用空间比指针还小的话，可以直接存放在data里面，以节约空间）</li><li><code>iface:inter</code>: 其实是定义的interface的类型</li><li><code>iface:inter:mhdr</code>: 这里是interface里面定义的函数，某个struct是否继承了这个interface，就是通过 struct的函数与 mhdr里面的函数进行对比，（这里为了提高比对的效率，这个slice会进行排序，将原本 m*n 的效率提升至 m + n）</li><li><p><code>fun</code>:<br>  这里是 结构体函数的平铺，如下代码所示，首先我们存储好函数后，把函数的地址，追加到 <code>fun[0]</code> 的地址指向的空间后面</p>  <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">...</span><br><span class="line">ifn := typ.textOff(t.ifn)</span><br><span class="line"></span><br><span class="line">*(*unsafe.Pointer)(add(unsafe.Pointer(&amp;m.fun[0]), uintptr(k)*sys.PtrSize)) = ifn</span><br><span class="line">...</span><br></pre></td></tr></table></figure><p>  同时，我们不会用到 fun的长度，而是根据指定的索引去获取我们需要的函数，也就是如下使用</p>  <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">fn = unsafe.Pointer(&amp;iface.itab.fun[i])</span><br></pre></td></tr></table></figure><p>  所以在这里，我们不需要知道 fun 的长度，及fun的结束地址</p></li></ul><h3 id="反射"><a href="#反射" class="headerlink" title="反射"></a>反射</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line">type Err struct &#123;</span><br><span class="line">Msg string</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">func (err *Err) Error() string &#123;</span><br><span class="line">return &quot;&quot;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">func main() &#123;</span><br><span class="line">err := &amp;Err&#123;&quot;error&quot;&#125;</span><br><span class="line"></span><br><span class="line">// get method</span><br><span class="line">method, _ := reflect.TypeOf(err).MethodByName(&quot;Error&quot;)</span><br><span class="line">fmt.Println(method)</span><br><span class="line"></span><br><span class="line">// get method by method index</span><br><span class="line">method0 := reflect.TypeOf(err).Method(0)</span><br><span class="line">fmt.Println(method0)</span><br><span class="line"></span><br><span class="line">// get kind</span><br><span class="line">kind := reflect.TypeOf(err).Kind()</span><br><span class="line">fmt.Println(&quot;unknow kind &quot;, kind)</span><br><span class="line"></span><br><span class="line">// change value</span><br><span class="line">reflect.ValueOf(err).Elem().Field(0).SetString(&quot;test&quot;)</span><br><span class="line">fmt.Println(*err)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>返回结果：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">&#123;Error  func(*main.Err) string &lt;func(*main.Err) string Value&gt; 0&#125;</span><br><span class="line">&#123;Error  func(*main.Err) string &lt;func(*main.Err) string Value&gt; 0&#125;</span><br><span class="line">unknow kind  ptr</span><br><span class="line">&#123;test&#125;</span><br></pre></td></tr></table></figure></p><p>接下来，根据上面的例子，分别追踪一下 <code>TypeOf</code> <code>MethodByName</code> <code>Method</code> <code>Method</code> <code>Elem</code> <code>Field</code> <code>SetString</code> 这些函数在我们的执行流程中华，都做了些什么，加深一下对interface的理解</p><h4 id="相关结构体"><a href="#相关结构体" class="headerlink" title="相关结构体"></a>相关结构体</h4><p>这里是<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br></pre></td><td class="code"><pre><span class="line">type Value struct &#123;</span><br><span class="line">// typ holds the type of the value represented by a Value.</span><br><span class="line">typ *rtype</span><br><span class="line"></span><br><span class="line">// Pointer-valued data or, if flagIndir is set, pointer to data.</span><br><span class="line">// Valid when either flagIndir is set or typ.pointers() is true.</span><br><span class="line">ptr unsafe.Pointer</span><br><span class="line"></span><br><span class="line">// flag holds metadata about the value.</span><br><span class="line">// The lowest bits are flag bits:</span><br><span class="line">//- flagStickyRO: obtained via unexported not embedded field, so read-only</span><br><span class="line">//- flagEmbedRO: obtained via unexported embedded field, so read-only</span><br><span class="line">//- flagIndir: val holds a pointer to the data</span><br><span class="line">//- flagAddr: v.CanAddr is true (implies flagIndir)</span><br><span class="line">//- flagMethod: v is a method value.</span><br><span class="line">// The next five bits give the Kind of the value.</span><br><span class="line">// This repeats typ.Kind() except for method values.</span><br><span class="line">// The remaining 23+ bits give a method number for method values.</span><br><span class="line">// If flag.kind() != Func, code can assume that flagMethod is unset.</span><br><span class="line">// If ifaceIndir(typ), code can assume that flagIndir is set.</span><br><span class="line">flag</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">type Type interface &#123;</span><br><span class="line">Align() int</span><br><span class="line">FieldAlign() int</span><br><span class="line">Method(int) Method</span><br><span class="line">NumMethod() int</span><br><span class="line">Name() string</span><br><span class="line">PkgPath() string</span><br><span class="line">Size() uintptr</span><br><span class="line">String() string</span><br><span class="line">Kind() Kind</span><br><span class="line">Implements(u Type) bool</span><br><span class="line">AssignableTo(u Type) bool</span><br><span class="line">ConvertibleTo(u Type) bool</span><br><span class="line">Comparable() bool</span><br><span class="line">Bits() int</span><br><span class="line">ChanDir() ChanDir</span><br><span class="line">IsVariadic() boolElem() Type</span><br><span class="line">Field(i int) StructField</span><br><span class="line">FieldByIndex(index []int) StructField</span><br><span class="line">FieldByName(name string) (StructField, bool)</span><br><span class="line">FieldByNameFunc(match func(string) bool) (StructField, bool)</span><br><span class="line">In(i int) Type</span><br><span class="line">Key() Type</span><br><span class="line">Len() int</span><br><span class="line">NumField() int</span><br><span class="line">NumIn() int</span><br><span class="line">NumOut() int</span><br><span class="line">common() *rtype</span><br><span class="line">uncommon() *uncommonType</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">type emptyInterface struct &#123;</span><br><span class="line">typ  *rtype</span><br><span class="line">word unsafe.Pointer</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">type interfaceType struct &#123;</span><br><span class="line">rtype</span><br><span class="line">pkgPath name      // import path</span><br><span class="line">methods []imethod // sorted by hash</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">type rtype struct &#123;</span><br><span class="line">size       uintptr</span><br><span class="line">ptrdata    uintptr  // number of bytes in the type that can contain pointers</span><br><span class="line">hash       uint32   // hash of type; avoids computation in hash tables</span><br><span class="line">tflag      tflag    // extra type information flags</span><br><span class="line">align      uint8    // alignment of variable with this type</span><br><span class="line">fieldAlign uint8    // alignment of struct field with this type</span><br><span class="line">kind       uint8    // enumeration for C</span><br><span class="line">alg        *typeAlg // algorithm table</span><br><span class="line">gcdata     *byte    // garbage collection data</span><br><span class="line">str        nameOff  // string form</span><br><span class="line">ptrToThis  typeOff  // type for pointer to this type, may be zero</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">type name struct &#123;</span><br><span class="line">bytes *byte</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h4 id="TypeOf-err-MethodByName-“Error”"><a href="#TypeOf-err-MethodByName-“Error”" class="headerlink" title="TypeOf(err).MethodByName(“Error”)"></a>TypeOf(err).MethodByName(“Error”)</h4><p><strong>TypeOf</strong><br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">func TypeOf(i interface&#123;&#125;) Type &#123;</span><br><span class="line">eface := *(*emptyInterface)(unsafe.Pointer(&amp;i))</span><br><span class="line">return toType(eface.typ)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">func toType(t *rtype) Type &#123;</span><br><span class="line">if t == nil &#123;</span><br><span class="line">return nil</span><br><span class="line">&#125;</span><br><span class="line">return t</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>根据上面的逻辑，<code>TypeOf</code> 就是把 interface{} 转成了 emptyInterface， 然后 返回了 <code>rtype</code>结构， 在 <code>func toType(t *rtype) Type</code> 中，要求返回的是 <code>Type</code> 接口，也就是说 <code>rtype</code> 继承了 <code>Type</code>，那我们就可以继续使用<code>Type</code>中的函数了</p><p><strong>MethodByName</strong><br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">func (t *rtype) MethodByName(name string) (m Method, ok bool) &#123;</span><br><span class="line">if t.Kind() == Interface &#123;</span><br><span class="line">tt := (*interfaceType)(unsafe.Pointer(t))</span><br><span class="line">return tt.MethodByName(name)</span><br><span class="line">&#125;</span><br><span class="line">ut := t.uncommon()</span><br><span class="line">if ut == nil &#123;</span><br><span class="line">return Method&#123;&#125;, false</span><br><span class="line">&#125;</span><br><span class="line">// TODO(mdempsky): Binary search.</span><br><span class="line">for i, p := range ut.exportedMethods() &#123;</span><br><span class="line">if t.nameOff(p.name).name() == name &#123;</span><br><span class="line">return t.Method(i), true</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">return Method&#123;&#125;, false</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p><code>interfaceType</code> 在上面已经贴出来了</p><ul><li>在第3行判断是否是 interface 类型，如果是的话，继续调用 interface的 tt.MethodByName，后面继续追踪</li><li>如果不是interface，则拿到存储的函数地址的slice，遍历这个slice，并跟name的地址获取函数的 name，匹配是否相同</li></ul><p><strong>interfaceType.MethodByName</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">func (t *interfaceType) MethodByName(name string) (m Method, ok bool) &#123;</span><br><span class="line">if t == nil &#123;</span><br><span class="line">return</span><br><span class="line">&#125;</span><br><span class="line">var p *imethod</span><br><span class="line">for i := range t.methods &#123;</span><br><span class="line">p = &amp;t.methods[i]</span><br><span class="line">if t.nameOff(p.name).name() == name &#123;</span><br><span class="line">return t.Method(i), true</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">return</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这个跟上面的逻辑一样，这里有一个<code>nameOff</code>的函数，这里是根据地址及偏移量计算出目标地址，也就是进行指针运算</p><h4 id="TypeOf-err-Method-0"><a href="#TypeOf-err-Method-0" class="headerlink" title="TypeOf(err).Method(0)"></a>TypeOf(err).Method(0)</h4><p><code>TypeOf(err).Method()</code>跟<code>MethodByName</code>一样，如果是interface，则转到 <code>interfaceType.MethodByName</code>，如此，直接追踪即可<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">func (t *interfaceType) Method(i int) (m Method) &#123;</span><br><span class="line">if i &lt; 0 || i &gt;= len(t.methods) &#123;</span><br><span class="line">return</span><br><span class="line">&#125;</span><br><span class="line">p := &amp;t.methods[i]</span><br><span class="line">pname := t.nameOff(p.name)</span><br><span class="line">m.Name = pname.name()</span><br><span class="line">if !pname.isExported() &#123;</span><br><span class="line">m.PkgPath = pname.pkgPath()</span><br><span class="line">if m.PkgPath == &quot;&quot; &#123;</span><br><span class="line">m.PkgPath = t.pkgPath.name()</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">m.Type = toType(t.typeOff(p.typ))</span><br><span class="line">m.Index = i</span><br><span class="line">return</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><ul><li>直接根据索引，找到对应的<code>imethod</code>的结构体</li><li>然后根据<code>imethod</code>结构体中的<code>nameOff</code>偏移指针，找到<code>name</code>结构体</li><li>然后调用 <code>name</code> 的  <code>name()</code> 方法获取名字</li><li>isExported暂时忽略，设计 <code>name</code>下<code>bytes</code>属性的设计</li><li>转换m.Type</li><li>添加m.Index</li><li>返回<br>所以，在使用 <code>MethodByName</code> 和 <code>Method</code> 都是在 <code>methods</code> 中查找，不一样的是，<code>MethodByName</code>需要遍历 <code>methods</code> 这个slice<br>我们在上面说过， <code>methods</code>这里slice是会进行hash排序的，所以<strong>这里面的索引并不是按照函数的声明顺序来排列的！！！</strong></li></ul><h2 id="参考文档"><a href="#参考文档" class="headerlink" title="参考文档"></a>参考文档</h2><ul><li><a href="http://legendtkl.com/2017/07/01/golang-interface-implement/" target="_blank" rel="noopener">《Go Interface 源码剖析》</a></li><li><a href="https://research.swtch.com/interfaces" target="_blank" rel="noopener">《Go Data Structures: Interfaces》</a></li></ul>]]></content>
      
      
      <categories>
          
          <category> Go </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Go </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Go值拷贝的一些思考</title>
      <link href="/posts/50287/"/>
      <url>/posts/50287/</url>
      
        <content type="html"><![CDATA[<blockquote><p><a href="文档地址：https://golang.org/ref/spec#Calls">In a function call, the function value and arguments are evaluated in the usual order. After they are evaluated, the parameters of the call are passed by value to the function and the called function begins execution.</a></p></blockquote><p>官方文档已经明确说明：Go里边函数传参只有值传递一种方式: 值传递<br>那么为什么会引发Go的值拷贝的讨论？<br><a id="more"></a></p><h2 id="现象"><a href="#现象" class="headerlink" title="现象"></a>现象</h2><p>用下面的代码做一下展示<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">package main</span><br><span class="line"></span><br><span class="line">import (</span><br><span class="line">&quot;fmt&quot;</span><br><span class="line">)</span><br><span class="line"></span><br><span class="line">func main() &#123;</span><br><span class="line">arr := [5]int&#123;0, 1, 2, 3, 4&#125;</span><br><span class="line">s := arr[1:]</span><br><span class="line">changeSlice(s)</span><br><span class="line">fmt.Println(s)</span><br><span class="line">fmt.Println(arr)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">func changeSlice(arr []int) &#123;</span><br><span class="line">for i := range arr &#123;</span><br><span class="line">arr[i] = 10</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>输出结果</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">[10 10 10 10]</span><br><span class="line">[0 10 10 10 10]</span><br></pre></td></tr></table></figure><p>如果Go是值拷贝的，那么我修改了函数 <code>changeSlice</code> 里面的<code>slice s</code> 的值，为什么main函数里面的<code>slice</code>和 <code>array</code>也被修改了</p><h2 id="原因"><a href="#原因" class="headerlink" title="原因"></a>原因</h2><p><img src="https://github-1253518569.cos.ap-shanghai.myqcloud.com/address.jpg" alt></p><p>以上图为例，a 是初始变量，b 是引用变量(Go中并不存在)，p 是指针变量<br>变量a被拷贝后，地址发生了变化，地址上存储的是原先地址存储的值 10<br>变量p被拷贝后，地址发生了变化，地址上存储的还是原先地址存储的值 ）0X001, 然后按照这个地址去查找，找到的是 0X001 上面存储的值</p><p>所以，当你去修改拷贝后的*p的值，其实修改的还是0X001地址上的值，而不是 拷贝后a的值</p><p><img src="https://github-1253518569.cos.ap-shanghai.myqcloud.com/slice-array.jpg" alt></p><p>那么我们接下来看slice，slice在实现的时候，其实是对array的映射，也就是说slice存对应的是原array的地址，就类似于p与a的关系，那么整个slice拷贝后，拷贝后的slice中存储的还是array的地址，去修改拷贝后的slice，其实跟修改slice，和原array是一样的</p><h2 id="试验"><a href="#试验" class="headerlink" title="试验"></a>试验</h2><p>我们用下面一个例子，实现以下我们上面的想法<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">package main</span><br><span class="line"></span><br><span class="line">import (</span><br><span class="line">&quot;fmt&quot;</span><br><span class="line">)</span><br><span class="line"></span><br><span class="line">func main() &#123;</span><br><span class="line">var a *int</span><br><span class="line">b := 10</span><br><span class="line">a = &amp;b</span><br><span class="line">change(a)</span><br><span class="line">fmt.Println(a, b)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">func change(a *int) &#123;</span><br><span class="line">*a = 30</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>打印结果<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">0xc000096000 30</span><br></pre></td></tr></table></figure></p><p>符合猜想</p><h2 id="More"><a href="#More" class="headerlink" title="More"></a>More</h2><p>这里的东西，其实用dlv调试会看的很方便，有兴趣可以动一下手</p><h2 id="结论"><a href="#结论" class="headerlink" title="结论"></a>结论</h2><p>Go的拷贝都是值拷贝，只是slice中存储的是原array的地址，所以在拷贝的时候，其实是把地址拷贝的新的slice，那么此时修改slice的时候，还是根据slice中存储的地址，找到要修改的内容</p>]]></content>
      
      
      <categories>
          
          <category> Go </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Go </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Go的调试工具:gdb vs dlv</title>
      <link href="/posts/8063/"/>
      <url>/posts/8063/</url>
      
        <content type="html"><![CDATA[<p>GoLand编辑器虽然很强大，但是在展示内存及堆栈信息这一块还是比较的弱，有可能是我的姿势不对，所以，开始切入了gdb调试，但是gdb踩到了坑，并没有解决，也就引发了gdb与dlv的对比了</p><a id="more"></a><h2 id="gdb"><a href="#gdb" class="headerlink" title="gdb"></a>gdb</h2><h3 id="安装"><a href="#安装" class="headerlink" title="安装"></a>安装</h3><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">yum install ncures-devel</span><br><span class="line">wget http://ftp.gnu.org/gnu/gdb/gdb-8.2.tar.gz</span><br><span class="line">tar zxf gdb-8.2.tar.gz</span><br><span class="line">cd gdb-8.2</span><br><span class="line">make &amp;&amp; make install</span><br></pre></td></tr></table></figure><h3 id="进入调试"><a href="#进入调试" class="headerlink" title="进入调试"></a>进入调试</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">go build -gcflags &apos;-N -l&apos; main.go</span><br><span class="line">gdb main</span><br></pre></td></tr></table></figure><h3 id="使用"><a href="#使用" class="headerlink" title="使用"></a>使用</h3><ol><li><p>启动调试程序（<code>gdb</code>）</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">[lday@alex GoDbg]$ gdb ./GoDbg</span><br></pre></td></tr></table></figure></li><li><p>在main函数上设置断点（<code>b</code>）</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">(gdb) b main.main</span><br><span class="line">Breakpoint 1 at 0x401000: file /home/lday/Works/Go_Works/GoLocalWorks/src/GoWorks/GoDbg/main.go, line 9.</span><br></pre></td></tr></table></figure></li><li><p>带参数启动程序（<code>r</code>）</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">(gdb) r arg1 arg2</span><br><span class="line">Starting program: /home/lday/Works/Go_Works/GoLocalWorks/src/GoWorks/GoDbg/GoDbg arg1 arg2</span><br><span class="line">[New LWP 8412]</span><br><span class="line">[New LWP 8413]</span><br><span class="line">[New LWP 8414]</span><br><span class="line">[New LWP 8415]</span><br><span class="line"></span><br><span class="line">Breakpoint 1, main.main () at /home/lday/Works/Go_Works/GoLocalWorks/src/GoWorks/GoDbg/main.go:9</span><br><span class="line">9    func main() &#123;</span><br></pre></td></tr></table></figure></li><li><p>在文件dbgTest.go上通过行号设置断点（<code>b</code>）</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">(gdb) b dbgTest.go:16</span><br><span class="line">Breakpoint 3 at 0x457960: file /home/lday/Works/Go_Works/GoLocalWorks/src/GoWorks/GoDbg/mylib/dbgTest.go, line 16.</span><br></pre></td></tr></table></figure></li><li><p>查看断点设置情况（<code>info b</code>）</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">(gdb) info b</span><br><span class="line">Num     Type           Disp Enb Address            What</span><br><span class="line">1       breakpoint     keep y   0x0000000000401000 in main.main </span><br><span class="line">                                                   at /home/lday/Works/Go_Works/GoLocalWorks/src/GoWorks/GoDbg/main.go:9</span><br><span class="line">    breakpoint already hit 1 time</span><br><span class="line">2       breakpoint     keep y   0x0000000000401000 in main.main </span><br><span class="line">                                                   at /home/lday/Works/Go_Works/GoLocalWorks/src/GoWorks/GoDbg/main.go:9</span><br><span class="line">    breakpoint already hit 1 time</span><br><span class="line">3       breakpoint     keep y   0x0000000000457960 in GoWorks/GoDbg/mylib.DBGTestRun </span><br><span class="line">                                                   at /home/lday/Works/Go_Works/GoLocalWorks/src/GoWorks/GoDbg/mylib/dbgTest.go:16</span><br></pre></td></tr></table></figure></li><li><p>禁用断点（<code>dis n</code>）</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">(gdb) dis 1   </span><br><span class="line">(gdb) info b</span><br><span class="line">Num     Type           Disp Enb Address            What</span><br><span class="line">1       breakpoint     keep n   0x0000000000401000 in main.main </span><br><span class="line">                                                   at /home/lday/Works/Go_Works/GoLocalWorks/src/GoWorks/GoDbg/main.go:9</span><br><span class="line">    breakpoint already hit 1 time</span><br><span class="line">2       breakpoint     keep y   0x0000000000401000 in main.main </span><br><span class="line">                                                   at /home/lday/Works/Go_Works/GoLocalWorks/src/GoWorks/GoDbg/main.go:9</span><br><span class="line">    breakpoint already hit 1 time</span><br><span class="line">3       breakpoint     keep y   0x0000000000457960 in GoWorks/GoDbg/mylib.DBGTestRun </span><br><span class="line">                                                   at /home/lday/Works/Go_Works/GoLocalWorks/src/GoWorks/GoDbg/mylib/dbgTest.go:16</span><br></pre></td></tr></table></figure></li><li><p>删除断点（<code>del n</code>）</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">(gdb) del 1</span><br><span class="line">(gdb) info b</span><br><span class="line">Num     Type           Disp Enb Address            What</span><br><span class="line">2       breakpoint     keep y   0x0000000000401000 in main.main </span><br><span class="line">                                                   at /home/lday/Works/Go_Works/GoLocalWorks/src/GoWorks/GoDbg/main.go:9</span><br><span class="line">    breakpoint already hit 1 time</span><br><span class="line">3       breakpoint     keep y   0x0000000000457960 in GoWorks/GoDbg/mylib.DBGTestRun </span><br><span class="line">                                                   at /home/lday/Works/Go_Works/GoLocalWorks/src/GoWorks/GoDbg/mylib/dbgTest.go:16</span><br></pre></td></tr></table></figure></li><li><p>断点后继续执行（<code>c</code>）</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">(gdb) c</span><br><span class="line">Continuing.</span><br><span class="line">Golang dbg test...</span><br><span class="line">argc:3</span><br><span class="line">argv:[/home/lday/Works/Go_Works/GoLocalWorks/src/GoWorks/GoDbg/GoDbg arg1 arg2]</span><br><span class="line"></span><br><span class="line">Breakpoint 3, GoWorks/GoDbg/mylib.DBGTestRun (var1=1, var2=&quot;golang dbg test&quot;)</span><br><span class="line">    at /home/lday/Works/Go_Works/GoLocalWorks/src/GoWorks/GoDbg/mylib/dbgTest.go:16</span><br><span class="line">16    func DBGTestRun(var1 int, var2 string, var3 []int, var4 MyStruct) &#123;</span><br><span class="line">(gdb)</span><br></pre></td></tr></table></figure></li><li><p>显示代码（<code>l</code>）</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">(gdb) l</span><br><span class="line">11        B string</span><br><span class="line">12        C map[int]string</span><br><span class="line">13        D []string</span><br><span class="line">14    &#125;</span><br><span class="line">15    </span><br><span class="line">16    func DBGTestRun(var1 int, var2 string, var3 []int, var4 MyStruct) &#123;</span><br><span class="line">17        fmt.Println(&quot;DBGTestRun Begin!\n&quot;)</span><br><span class="line">18        waiter := &amp;sync.WaitGroup&#123;&#125;</span><br><span class="line">19    </span><br><span class="line">20        waiter.Add(1)</span><br></pre></td></tr></table></figure></li><li><p>单步执行（<code>n</code>）</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">(gdb) n</span><br><span class="line">DBGTestRun Begin!</span><br><span class="line"></span><br><span class="line">18        waiter := &amp;sync.WaitGroup&#123;&#125;</span><br></pre></td></tr></table></figure></li><li><p>打印变量信息（<code>print/p</code>）<br>在进入DBGTestRun的地方设置断点(<code>b dbgTest.go:16</code>)，进入该函数后，通过p命令显示对应变量：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">(gdb) l 17</span><br><span class="line">12        C map[int]string</span><br><span class="line">13        D []string</span><br><span class="line">14    &#125;</span><br><span class="line">15    </span><br><span class="line">16    func DBGTestRun(var1 int, var2 string, var3 []int, var4 MyStruct) &#123;</span><br><span class="line">17        fmt.Println(&quot;DBGTestRun Begin!\n&quot;)</span><br><span class="line">18        waiter := &amp;sync.WaitGroup&#123;&#125;</span><br><span class="line">19    </span><br><span class="line">20        waiter.Add(1)</span><br><span class="line">21        go RunFunc1(var1, waiter)</span><br><span class="line">(gdb) p var1 </span><br><span class="line">$3 = 1</span><br><span class="line">(gdb) p var2</span><br><span class="line">$4 = &quot;golang dbg test&quot;</span><br><span class="line">(gdb) p var3</span><br><span class="line">No symbol &quot;var3&quot; in current context.</span><br></pre></td></tr></table></figure><p><strong>从上面的输出我们可以看到一个很奇怪的事情，虽然DBGTestRun有4个参数传入，但是，似乎var3和var4 gdb无法识别，在后续对dlv的实验操作中，我们发现，dlv能够识别var3， var4.</strong></p></li><li><p>查看调用栈（<code>bt</code>），切换调用栈（<code>f n</code>），显示当前栈变量信息</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line">(gdb) bt</span><br><span class="line">#0  GoWorks/GoDbg/mylib.DBGTestRun (var1=1, var2=&quot;golang dbg test&quot;)</span><br><span class="line">    at /home/lday/Works/Go_Works/GoLocalWorks/src/GoWorks/GoDbg/mylib/dbgTest.go:17</span><br><span class="line">#1  0x00000000004018c2 in main.main () at /home/lday/Works/Go_Works/GoLocalWorks/src/GoWorks/GoDbg/main.go:27</span><br><span class="line">(gdb) f 1</span><br><span class="line">#1  0x00000000004018c2 in main.main () at /home/lday/Works/Go_Works/GoLocalWorks/src/GoWorks/GoDbg/main.go:27</span><br><span class="line">27        mylib.DBGTestRun(var1, var2, var3, var4)</span><br><span class="line">(gdb) l</span><br><span class="line">22        var4.A = 1</span><br><span class="line">23        var4.B = &quot;golang dbg my struct field B&quot;</span><br><span class="line">24        var4.C = map[int]string&#123;1: &quot;value1&quot;, 2: &quot;value2&quot;, 3: &quot;value3&quot;&#125;</span><br><span class="line">25        var4.D = []string&#123;&quot;D1&quot;, &quot;D2&quot;, &quot;D3&quot;&#125;</span><br><span class="line">26    </span><br><span class="line">27        mylib.DBGTestRun(var1, var2, var3, var4)</span><br><span class="line">28        fmt.Println(&quot;Golang dbg test over&quot;)</span><br><span class="line">29    &#125;</span><br><span class="line">(gdb) print var1 </span><br><span class="line">$5 = 1</span><br><span class="line">(gdb) print var2</span><br><span class="line">$6 = &quot;golang dbg test&quot;</span><br><span class="line">(gdb) print var3</span><br><span class="line">$7 =  []int = &#123;1, 2, 3&#125;</span><br><span class="line"></span><br><span class="line">(gdb) print var4</span><br><span class="line">$8 = &#123;A = 1, B = &quot;golang dbg my struct field B&quot;, C = map[int]string = &#123;[1] = &quot;value1&quot;, [2] = &quot;value2&quot;, [3] = &quot;value3&quot;&#125;, </span><br><span class="line">D =  []string = &#123;&quot;D1&quot;, &quot;D2&quot;, &quot;D3&quot;&#125;&#125;</span><br></pre></td></tr></table></figure></li></ol><h2 id="dlv-推荐"><a href="#dlv-推荐" class="headerlink" title="dlv(推荐)"></a>dlv(推荐)</h2><h3 id="安装-1"><a href="#安装-1" class="headerlink" title="安装"></a>安装</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">go get -u github.com/go-delve/delve/cmd/dlv</span><br></pre></td></tr></table></figure><h3 id="进入调试-1"><a href="#进入调试-1" class="headerlink" title="进入调试"></a>进入调试</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">dlv debug main.go</span><br></pre></td></tr></table></figure><h3 id="使用-1"><a href="#使用-1" class="headerlink" title="使用"></a>使用</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line">args ------------------------ Print function arguments.</span><br><span class="line">break (alias: b) ------------ Sets a breakpoint.</span><br><span class="line">breakpoints (alias: bp) ----- Print out info for active breakpoints.</span><br><span class="line">call ------------------------ Resumes process, injecting a function call (EXPERIMENTAL!!!)</span><br><span class="line">clear ----------------------- Deletes breakpoint.</span><br><span class="line">clearall -------------------- Deletes multiple breakpoints.</span><br><span class="line">condition (alias: cond) ----- Set breakpoint condition.</span><br><span class="line">config ---------------------- Changes configuration parameters.</span><br><span class="line">continue (alias: c) --------- Run until breakpoint or program termination.</span><br><span class="line">deferred -------------------- Executes command in the context of a deferred call.</span><br><span class="line">disassemble (alias: disass) - Disassembler.</span><br><span class="line">down ------------------------ Move the current frame down.</span><br><span class="line">edit (alias: ed) ------------ Open where you are in $DELVE_EDITOR or $EDITOR</span><br><span class="line">exit (alias: quit | q) ------ Exit the debugger.</span><br><span class="line">frame ----------------------- Set the current frame, or execute command on a different frame.</span><br><span class="line">funcs ----------------------- Print list of functions.</span><br><span class="line">goroutine ------------------- Shows or changes current goroutine</span><br><span class="line">goroutines ------------------ List program goroutines.</span><br><span class="line">help (alias: h) ------------- Prints the help message.</span><br><span class="line">libraries ------------------- List loaded dynamic libraries</span><br><span class="line">list (alias: ls | l) -------- Show source code.</span><br><span class="line">locals ---------------------- Print local variables.</span><br><span class="line">next (alias: n) ------------- Step over to next source line.</span><br><span class="line">on -------------------------- Executes a command when a breakpoint is hit.</span><br><span class="line">print (alias: p) ------------ Evaluate an expression.</span><br><span class="line">regs ------------------------ Print contents of CPU registers.</span><br><span class="line">restart (alias: r) ---------- Restart process.</span><br><span class="line">set ------------------------- Changes the value of a variable.</span><br><span class="line">source ---------------------- Executes a file containing a list of delve commands</span><br><span class="line">sources --------------------- Print list of source files.</span><br><span class="line">stack (alias: bt) ----------- Print stack trace.</span><br><span class="line">step (alias: s) ------------- Single step through program.</span><br><span class="line">step-instruction (alias: si)  Single step a single cpu instruction.</span><br><span class="line">stepout --------------------- Step out of the current function.</span><br><span class="line">thread (alias: tr) ---------- Switch to the specified thread.</span><br><span class="line">threads --------------------- Print out info for every traced thread.</span><br><span class="line">trace (alias: t) ------------ Set tracepoint.</span><br><span class="line">types ----------------------- Print list of types</span><br><span class="line">up -------------------------- Move the current frame up.</span><br><span class="line">vars ------------------------ Print package variables.</span><br><span class="line">whatis ---------------------- Prints type of an expression.</span><br></pre></td></tr></table></figure><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><ol><li><p>dlv对goroutine的支持更好，我使用gdb的没有找到goroutine的调试方法，可能姿势不对</p></li><li><p>gdb对于局部引用变量无法调试，dlv不会</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">  i := <span class="number">10</span></span><br><span class="line">  j := &amp;i</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>如上代码，gdb 使用 <code>p j</code> 打印变量j的时候报错，dlv却可以</p></li><li><p>dlv无法调试interface等Go内部实现的一些结构，gdb是可以的</p></li></ol><h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><p><a href="http://lday.me/2017/02/27/0005_gdb-vs-dlv/" target="_blank" rel="noopener">《Golang程序调试工具介绍(gdb vs dlv)》</a></p>]]></content>
      
      
      <categories>
          
          <category> Go </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Go </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Golang常见错误之goroutine使用变量问题</title>
      <link href="/posts/22138/"/>
      <url>/posts/22138/</url>
      
        <content type="html"><![CDATA[<p><a href="https://www.jb51.net/article/128539.htm" target="_blank" rel="noopener">https://www.jb51.net/article/128539.htm</a><br>针对这篇文章引发的一些实验<br><a id="more"></a></p><p>在看这篇文章的时候，总感觉用文章中的例子说明值拷贝和指针拷贝是有问题的，而且go官方说，他们的拷贝只有值拷贝一种，那么为什么使用指针类型和非指针类型，会出现不同的现象，在追踪的过程了就发现了下面的奇葩实例</p><h2 id="试验代码"><a href="#试验代码" class="headerlink" title="试验代码"></a>试验代码</h2><pre><code>package mainimport (    &quot;fmt&quot;    &quot;time&quot;)type fieldNoPointer struct {    name string}func (p fieldNoPointer) Print() {    fmt.Println(p.name)}type fieldPointer struct {    name string}func (p *fieldPointer) Print() {    fmt.Println(p.name)}func main() {    printDataWithPointerUseFieldPointerWithFunc()    printDataWithPointerUseFieldPointerWithNoFunc()    printDataWithNoPointerUseFieldPointerWithFunc()    printDataWithNoPointerUseFieldPointerWithNoFunc()    printDataWithPointerUseFieldNoPointerWithFunc()    printDataWithPointerUseFieldNoPointerWithNoFunc()    printDataWithNoPointerUseFieldNoPointerWithFunc()    printDataWithNoPointerUseFieldNoPointerWithNoFunc()    time.Sleep(1)}func printDataWithPointerUseFieldPointerWithFunc()  {    fmt.Println(&quot;print by get printDataWithPointerUseFieldPointerWithFunc&quot;)    data := []*fieldPointer{{"one"},{"two"},{"three"}}    for _,v := range data {        go func() {            v.Print()        }()    }    time.Sleep(time.Second)}func printDataWithPointerUseFieldPointerWithNoFunc()  {    fmt.Println(&quot;print by get printDataWithPointerUseFieldPointerWithNoFunc&quot;)    data := []*fieldPointer{{"one"},{"two"},{"three"}}    for _,v := range data {        go v.Print()    }    time.Sleep(time.Second)}func printDataWithNoPointerUseFieldPointerWithFunc()  {    fmt.Println(&quot;print by get printDataWithNoPointerUseFieldPointerWithFunc&quot;)    data := []fieldPointer{{"one"},{"two"},{"three"}}    for _,v := range data {        go func() {            v.Print()        }()    }    time.Sleep(time.Second)}func printDataWithNoPointerUseFieldPointerWithNoFunc()  {    fmt.Println(&quot;print by get printDataWithNoPointerUseFieldPointerWithNoFunc&quot;)    data := []fieldPointer{{"one"},{"two"},{"three"}}    for _,v := range data {        go v.Print()    }    time.Sleep(time.Second)}func printDataWithPointerUseFieldNoPointerWithFunc()  {    fmt.Println(&quot;print by get printDataWithPointerUseFieldNoPointerWithFunc&quot;)    data := []*fieldNoPointer{{"one"},{"two"},{"three"}}    for _,v := range data {        go func() {            v.Print()        }()    }    time.Sleep(time.Second)}func printDataWithPointerUseFieldNoPointerWithNoFunc()  {    fmt.Println(&quot;print by get printDataWithPointerUseFieldNoPointerWithNoFunc&quot;)    data := []*fieldNoPointer{{"one"},{"two"},{"three"}}    for _,v := range data {        go v.Print()    }    time.Sleep(time.Second)}func printDataWithNoPointerUseFieldNoPointerWithFunc()  {    fmt.Println(&quot;print by get printDataWithNoPointerUseFieldNoPointerWithFunc&quot;)    data := []fieldNoPointer{{"one"},{"two"},{"three"}}    for _,v := range data {        go func() {            v.Print()        }()    }    time.Sleep(time.Second)}func printDataWithNoPointerUseFieldNoPointerWithNoFunc()  {    fmt.Println(&quot;print by get printDataWithNoPointerUseFieldNoPointerWithNoFunc&quot;)    data := []fieldNoPointer{{"one"},{"two"},{"three"}}    for _,v := range data {        go v.Print()    }    time.Sleep(time.Second)}</code></pre><h2 id="实验结果"><a href="#实验结果" class="headerlink" title="实验结果"></a>实验结果</h2><pre><code>print by get printDataWithPointerUseFieldPointerWithFuncthreethreethreeprint by get printDataWithPointerUseFieldPointerWithNoFunconetwothreeprint by get printDataWithNoPointerUseFieldPointerWithFuncthreethreethreeprint by get printDataWithNoPointerUseFieldPointerWithNoFuncthreethreethreeprint by get printDataWithPointerUseFieldNoPointerWithFuncthreethreethreeprint by get printDataWithPointerUseFieldNoPointerWithNoFuncthreeonetwoprint by get printDataWithNoPointerUseFieldNoPointerWithFuncthreethreethreeprint by get printDataWithNoPointerUseFieldNoPointerWithNoFuncthreeonetwo</code></pre><p>在这里，我以 我以 <code>struct的func是否指针类型</code> <code>struc的数据是否是指针类型</code> 以及 <code>goroutine 是否使用匿名函数</code> 为例作为测试的，上面的测试例子都是无意中发现的</p><p>图表</p><table><thead><tr><th></th><th>Goroutine func 且 struct数据是指针类型</th><th>Goroutine且 struct数据是指针类型</th><th>Goroutine func 且 struct数据不是指针类型</th><th>Goroutine且 struct数据不是指针类型</th></tr></thead><tbody><tr><td>Struct func指针类型</td><td>异常</td><td>正常</td><td>异常</td><td>异常</td></tr><tr><td>Struct func非指针类型</td><td>异常</td><td>异常</td><td>异常</td><td>正常</td></tr></tbody></table><h2 id="结论"><a href="#结论" class="headerlink" title="结论"></a>结论</h2><p>在goroutine里面使用变量的时候，需要传递，上面案例中不传递变量直接使用的方法都是错误的</p>]]></content>
      
      
      <categories>
          
          <category> Go </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Go </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>头条面经-PHP/Golang</title>
      <link href="/posts/55859/"/>
      <url>/posts/55859/</url>
      
        <content type="html"><![CDATA[<p>好像这里必须要写点什么，以下是今日头条杭州研发岗位（PHP/Golang）的面试记录</p><a id="more"></a><h1 id="一面（约1h）"><a href="#一面（约1h）" class="headerlink" title="一面（约1h）"></a>一面（约1h）</h1><ol><li>在面对未知的流量暴增，可以预先怎么处理</li><li>如何限流，限流算法，对于ddos攻击怎么处理</li><li>PHP数组的底层实现</li><li>分布式事务</li><li>RPC相对于传统的API调用的优点</li><li>服务调度中心的感知与动态上下线</li><li>MySQL的索引，为什么是B+而不是平衡二叉树</li><li>索引查找在Linux的磁盘上是怎么操作的</li><li>聚簇索引相对于B+索引的优点</li><li>如何分析SQL执行慢的原因</li><li>Redis连接时的connect与pconnect的区别</li><li>Redis有哪些结构时间复杂度较高</li><li>Redis hash的实现</li><li>算法题： 在1个10G大小的文件中，存储的都是int型的数据，如何在内存使用小于8M的情况下进行排序</li><li>设计题： 以微博为例，有1个亿的用户，同时用户之间有关注和粉丝，用户的关注和取关操作比较频繁，如何设计架构和API接口</li></ol><h1 id="二面（约1-5h）"><a href="#二面（约1-5h）" class="headerlink" title="二面（约1.5h）"></a>二面（约1.5h）</h1><p>二面主要以自己的项目为切入点，进一步考察你对项目中知识点的把握程度，我这里是以一个 自己撸的小项目 <a href="https://github.com/tyloafer/ProcessManager" target="_blank" rel="noopener">进程管理工具</a> 为项目背景</p><ol><li>守护进程是什么，怎么实现</li><li>PHP是否适合做守护进程，为什么（内存管理这一块）</li><li>PHP的垃圾回收机制</li><li>进程间通信方式</li><li>共享内存是怎么实现的</li><li>怎么查看Linux服务器的负载，及判断哪些操作引起的负载过高</li><li>MySQL的IO过高怎么优化，分库分表及分区</li><li>MySQL的索引结构，myisam的索引结构， innodb的索引结构，innodb为什么必须要有主键索引</li><li>添加索引，为什么可以减少io操作（磁盘页）</li><li>nginx的负载均衡算法</li><li>算法题： 忘了</li><li>算法题：查找一个字符串中最长的无重复字串</li></ol><p>上面是我基本还记得的一些题目，考察的力度相对比较深，所以，请选择一个自己比较熟悉的项目，因为面试官是会剖析到底层的</p><h1 id="三面（约0-6h）"><a href="#三面（约0-6h）" class="headerlink" title="三面（约0.6h）"></a>三面（约0.6h）</h1><p>三面与二面的内容差不多，没有更深的问题，但是，需要注重细节，同时三面面试官有时间会放烟雾弹，坚定自己的立场就好</p><ol><li>面试题： 在一个横向和纵向都是递增的有界二维坐标轴中，如何快速判断某个数是否存在于这个二维坐标中</li><li>面试题：设计一个定时任务管理器（从我同事那打听到的，我只有上面一个算法题）</li></ol><h1 id="Hr面（约0-5h）"><a href="#Hr面（约0-5h）" class="headerlink" title="Hr面（约0.5h）"></a>Hr面（约0.5h）</h1><p>hr小姐姐：你有什么心仪的公司吗</p><p>我： 大厂，类似于BAT这种</p><p>hr小姐姐：为什么呢？</p><p>我： 我感觉 阿里的架构不错，微博鸟哥待过，技术架构肯定吊吊的。。。</p><p>hr小姐姐：你跟我在北京面的其他候选人都不太一样啊，他们都不屑于去这些公司，感觉想进就进，他们比较倾向于滴滴，头条这些年轻，发展比较快速的公司</p><p>我：卒。。。（毕竟我毕业才一年半啊-_-，校招还因为自己不在意，完美错过了所有大厂的招聘）</p><h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><p>头条面试，算法是必考项，但是面试官都是让我给出思路，也没写多少行代码</p><p>涉猎范围一般，基本就是Redis MySQL ，Nginx比较少，可能配置简单吧</p><p>深度较深，很少人会去关注PHP的垃圾回收，何为垃圾，线程安全，array的HashTable实现这些内容, Redis Hash表等</p>]]></content>
      
      
      <categories>
          
          <category> 面经 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 面经 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Linux终端科学上网</title>
      <link href="/posts/31170/"/>
      <url>/posts/31170/</url>
      
        <content type="html"><![CDATA[<p>对于经常在服务商使用git 和 composer 的我来说，实在受不了那几k的网速，但是毕竟使用较少，而且，还可以使用国内镜像源，但是近期要使用Google API，这个就有点头疼了。所以，废话不多话，直接上步骤，没什么技术含量。</p><a id="more"></a><h1 id="Proxychains4版本"><a href="#Proxychains4版本" class="headerlink" title="Proxychains4版本"></a>Proxychains4版本</h1><h2 id="安装配置shadowsocks"><a href="#安装配置shadowsocks" class="headerlink" title="安装配置shadowsocks"></a>安装配置shadowsocks</h2><h3 id="安装"><a href="#安装" class="headerlink" title="安装"></a>安装</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">pip install shadowsocks</span><br></pre></td></tr></table></figure><h3 id="配置"><a href="#配置" class="headerlink" title="配置"></a>配置</h3><p>编辑配置文件 <code>/etc/sslocal.json</code>，配置文件可以放在任意位置，启动的时候 指定对应位置即可</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">    &quot;server&quot;:&quot;xxx.xxx.xxx.xxx&quot;, // ss 服务器ip</span><br><span class="line">    &quot;server_port&quot;:xxx,  // ss 端口</span><br><span class="line">    &quot;local_address&quot;: &quot;127.0.0.1&quot;, // 本机代理</span><br><span class="line">    &quot;local_port&quot;:1080, // 本机代理端口</span><br><span class="line">    &quot;password&quot;:&quot;*******&quot;, // ss 密码</span><br><span class="line">    &quot;timeout&quot;:300,</span><br><span class="line">    &quot;method&quot;:&quot;rc4-md5&quot; // ss 加密方式</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>配置时请把后面的注释去掉</p><h3 id="使用"><a href="#使用" class="headerlink" title="使用"></a>使用</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">启动：sslocal -c /etc/sslocal.json -d start</span><br><span class="line"></span><br><span class="line">停止：sslocal -c /etc/sslocal.json -d stop</span><br><span class="line"></span><br><span class="line">重启：sslocal -c /etc/sslocal.json -d restart</span><br></pre></td></tr></table></figure><h2 id="安装配置-Proxychains4"><a href="#安装配置-Proxychains4" class="headerlink" title="安装配置 Proxychains4"></a>安装配置 Proxychains4</h2><p>项目地址： <a href="https://github.com/rofl0r/proxychains-ng" target="_blank" rel="noopener">https://github.com/rofl0r/proxychains-ng</a></p><p>编译安装即可</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">git clone https://github.com/rofl0r/proxychains-ng.git</span><br><span class="line">cd proxychains-ng</span><br><span class="line">./configure</span><br><span class="line">make &amp;&amp; make install</span><br><span class="line">cp ./src/proxychains.conf /etc/proxychains.conf</span><br></pre></td></tr></table></figure><p>修改 <code>/etc/proxychains.conf</code> 将 <strong>socks4 127.0.0.1 9095</strong> 改成 <strong>socks5 127.0.0.1 1080</strong> </p><p>这里<strong>127.0.0.1</strong> 与 shadowsock配置文件中 <strong>local_address</strong> 对应 <strong>1080</strong> 与 <strong>local_port</strong> 对应即可</p><p>至此，安装完成，只要在使用的命令前 加上 <code>proxychains4</code> 即可实现科学上网</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">proxychains4 wget https://www.google.com</span><br></pre></td></tr></table></figure><h1 id="HTTP-PROXY-推荐"><a href="#HTTP-PROXY-推荐" class="headerlink" title="HTTP_PROXY(推荐)"></a>HTTP_PROXY(推荐)</h1><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">http:</span><br><span class="line">export http_proxy=http://proxyAddress:port</span><br><span class="line">export http_proxy=socks5://127.0.0.1:1087</span><br><span class="line"></span><br><span class="line">https:</span><br><span class="line">export https_proxy=https://proxyAddress:port</span><br><span class="line">export https_proxy=socks5://127.0.0.1:1087</span><br><span class="line"></span><br><span class="line">http &amp;&amp; https</span><br><span class="line">export all_proxy=http://proxyAddress:port</span><br><span class="line">export all_proxy=socks5://127.0.0.1:1087</span><br></pre></td></tr></table></figure><p>如果http代理需要验证的话</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">http_proxy=http://userName:password@proxyAddress:port</span><br></pre></td></tr></table></figure><p>其他代理方式相同</p>]]></content>
      
      
      <categories>
          
          <category> ShadowSock </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 科学上网 </tag>
            
            <tag> ShadowSock </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>SeLinux引发的问题小记</title>
      <link href="/posts/15998/"/>
      <url>/posts/15998/</url>
      
        <content type="html"><![CDATA[<p>以前自己在部署服务器的时候，忘了遇到了什么坑，导致后来习惯性把新服务器上的 <strong>SeLinux</strong> 服务直接关闭，今天处理了一台不是我部署的服务器，又踩了两个坑，这里做一下记录，后面有时间还是要好好了解一下这块。</p><h1 id="FastCGI-sent-in-stderr-“Primary-script-unknown”-while-reading-response-header-from-upstream"><a href="#FastCGI-sent-in-stderr-“Primary-script-unknown”-while-reading-response-header-from-upstream" class="headerlink" title="FastCGI sent in stderr: “Primary script unknown” while reading response header from upstream"></a>FastCGI sent in stderr: “Primary script unknown” while reading response header from upstream</h1><blockquote><p> 这个问题一般是 <strong>SCRIPT_FILENAME</strong>   这个变量没有设置好，但是打印出来其实是正确的，也就是证明nginx的配置时没有问题的，可以考虑是 <strong>SeLinux</strong> 的原因</p></blockquote><p>处理： chcon -R -t httpd_sys_content_t /path/to/webroot</p><h1 id="chmod-777-后依旧-failed-to-open-stream-Permission-denied"><a href="#chmod-777-后依旧-failed-to-open-stream-Permission-denied" class="headerlink" title="chmod 777 后依旧 failed to open stream: Permission denied"></a>chmod 777 后依旧 failed to open stream: Permission denied</h1><p>处理： </p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">setenforce Permissive</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> Linux </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Linux </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>深入理解PHP系列之线程安全</title>
      <link href="/posts/56229/"/>
      <url>/posts/56229/</url>
      
        <content type="html"><![CDATA[<p>进程: 进程拥有自己独立的堆和栈，既不共享堆，亦不共享栈，进程由操作系统调度。</p><p>线程: 线程拥有自己独立的栈和共享的堆，共享堆，不共享栈，线程亦由操作系统调度(标准线程是的)。</p><p>根据前面三篇文章《<a href="https://tyloafer.github.io/posts/30726/">浅析堆栈和内存溢出</a>》 《<a href="https://tyloafer.github.io/posts/17570/">深入PHP系列之PHP数组底层的实现</a>》《<a href="https://tyloafer.github.io/posts/47934/">深入PHP系列-变量分离与引用</a>》可以得知，PHP的变量是由zval结构体构成的，数组则是hash表和链表构成的，这些，都是程序员进行分配销毁的内存，也即堆内存。由此可得，在不同的线程中，PHP其实是共享变量的，如果线程1修改了变量a， 则线程2使用变量a的时候，就是线程1修改后的结果，所谓线程安全也就是，如何保障，各个线程之间可以安全的使用公共的资源，不受影响且不影响其他线程。因此，PHP实现了一个线程安全资源管理器（Thread Safe Resource Manager, TSRM），用于解决这个问题，实现线程之间安全的操作公共资源。</p><a id="more"></a><h1 id="核心思想"><a href="#核心思想" class="headerlink" title="核心思想"></a>核心思想</h1><p><img src="https://github-1253518569.cos.ap-shanghai.myqcloud.com/thread_1.png" alt="thread_1"></p><p>如图，如果三个线程的内存地址不同，那么在 Thread1 里面操作的是Thread1对应的内存地址，就不会影响 Thread2 和 Thread3 对应的内存地址的值。</p><p>TSRM的核心思想就是为不同的线程分配独立的内存空间，如果一个资源会被多线程使用，那么首先需要预先向TSRM注册资源，然后TSRM为这个资源分配一个唯一的编号，并把这种资源的大小、初始化函数等保存到一个<code>tsrm_resource_type</code>结构中，各线程只能通过TSRM分配的那个编号访问这个资源；然后当线程拿着这个编号获取资源时TSRM如果发现是第一次请求，则会根据注册时的资源大小分配一块内存，然后调用初始化函数进行初始化，并把这块资源保存下来供这个线程后续使用。</p><h1 id="基本实现"><a href="#基本实现" class="headerlink" title="基本实现"></a>基本实现</h1><p><img src="https://github-1253518569.cos.ap-shanghai.myqcloud.com/thread_safe.png" alt="线程安全结构"></p><p>TSRM的整体结构主要如上图所示，现从左向右开始梳理</p><h2 id="tsrm-tls-table"><a href="#tsrm-tls-table" class="headerlink" title="tsrm_tls_table"></a>tsrm_tls_table</h2><p>左侧第一个结构是 <code>tsrm_tls_table</code>, tsrm_tls_table 是一个数组，数组每个索引对应的值是一个地址，也就是为线程申请内存地址。那么如何确定线程在 tsrm_tls_table  的哪个索引下面呢，在PHP的数组的实现中，通过hash散列取模来确定索引，这里也是一样，只是简化了，直接通过线程id % tsrm_tls_table_size 来确定索引。</p><p>我们以上图为例， tsrm_tls_table_size 为 2， 如果新的一个线程， 线程id（后面用 thread_id来替代）， 3 % 2 = 1， 所以 我们在 tsrm_tls_table[1] 下面去寻找这个线程内存地址。进而，这里就会引发一个问题， 5 % 2 = 1，那是不是就冲突了?</p><h2 id="tsrm-tls-entry"><a href="#tsrm-tls-entry" class="headerlink" title="tsrm_tls_entry"></a>tsrm_tls_entry</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">struct _tsrm_tls_entry &#123;</span><br><span class="line">    void **storage; //资源数组</span><br><span class="line">    int count; //拥有的资源数:storage数组大小</span><br><span class="line">    THREAD_T thread_id; //所属线程id</span><br><span class="line">    tsrm_tls_entry *next;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>按照上面的情况来考虑，肯定会存在冲突的情况，除非这个数组特别大，但是那样内存耗费就得不偿失了。</p><p>所以，<code>tsrm_tls_entry</code> 的结构体 有一个这样的 属性 <code>tsrm_tls_entry *next;</code>，这样就可以把各个冲突的 <code>tsrm_tls_entry</code> 串成链表来解决冲突了，这也是hash冲突时，常用的解决方法。</p><h3 id="tsrm-resource-type"><a href="#tsrm-resource-type" class="headerlink" title="tsrm_resource_type"></a>tsrm_resource_type</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">typedef struct &#123;</span><br><span class="line">    size_t size; //资源的大小</span><br><span class="line">    ts_allocate_ctor ctor; //初始化函数</span><br><span class="line">    ts_allocate_dtor dtor;</span><br><span class="line">    int done;</span><br><span class="line">&#125; tsrm_resource_type;</span><br></pre></td></tr></table></figure><p><code>tsrm_resource_type</code> 这个结构体好像在上图中并没有体现出来具体是干什么的，接下来，先看一下，TSRM的初始化过程，应该就能知道这个结构体的作用了</p><p><strong>初始化</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">TSRM_API int tsrm_startup(int expected_threads, int expected_resources, int debug_level, char *debug_filename)</span><br><span class="line">&#123;</span><br><span class="line">    pthread_key_create( &amp;tls_key, 0 );</span><br><span class="line"></span><br><span class="line">    //分配tsrm_tls_table</span><br><span class="line">    tsrm_tls_table_size = expected_threads;</span><br><span class="line">    tsrm_tls_table = (tsrm_tls_entry **) calloc(tsrm_tls_table_size, sizeof(tsrm_tls_entry *));</span><br><span class="line">    ...</span><br><span class="line">    //初始化资源的递增id，注册资源时就是用的这个值</span><br><span class="line">    id_count=0;</span><br><span class="line"></span><br><span class="line">    //分配资源类型数组：resource_types_table</span><br><span class="line">    resource_types_table_size = expected_resources;</span><br><span class="line">    resource_types_table = (tsrm_resource_type *) calloc(resource_types_table_size, sizeof(tsrm_resource_type));</span><br><span class="line">    ...</span><br><span class="line">    //创建锁</span><br><span class="line">    tsmm_mutex = tsrm_mutex_alloc();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>注册资源</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">#ifdef ZTS</span><br><span class="line">ZEND_API int executor_globals_id;</span><br><span class="line">#endif</span><br><span class="line"></span><br><span class="line">int zend_startup(zend_utility_functions *utility_functions, char **extensions)</span><br><span class="line">&#123;</span><br><span class="line">    ...</span><br><span class="line">#ifdef ZTS</span><br><span class="line">    ts_allocate_id(&amp;executor_globals_id, sizeof(zend_executor_globals), (ts_allocate_ctor) executor_globals_ctor, (ts_allocate_dtor) executor_globals_dtor);</span><br><span class="line">    </span><br><span class="line">    executor_globals = ts_resource(executor_globals_id);</span><br><span class="line">    ...</span><br><span class="line">#endif</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line">TSRM_API ts_rsrc_id ts_allocate_id(ts_rsrc_id *rsrc_id, size_t size, ts_allocate_ctor ctor, ts_allocate_dtor dtor)</span><br><span class="line">&#123;</span><br><span class="line">    //加锁，保证各线程串行调用此函数</span><br><span class="line">    tsrm_mutex_lock(tsmm_mutex);</span><br><span class="line"></span><br><span class="line">    //分配id，即id_count当前值，然后把id_count加1</span><br><span class="line">    *rsrc_id = TSRM_SHUFFLE_RSRC_ID(id_count++);</span><br><span class="line"></span><br><span class="line">    //检查resource_types_table数组当前大小是否已满</span><br><span class="line">    if (resource_types_table_size &lt; id_count) &#123;</span><br><span class="line">        //需要对resource_types_table扩容</span><br><span class="line">        resource_types_table = (tsrm_resource_type *) realloc(resource_types_table, sizeof(tsrm_resource_type)*id_count);</span><br><span class="line">        ...</span><br><span class="line">        //把数组大小修改新的大小</span><br><span class="line">        resource_types_table_size = id_count;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    //将新注册的资源插入resource_types_table数组，下标就是分配的资源id</span><br><span class="line">    resource_types_table[TSRM_UNSHUFFLE_RSRC_ID(*rsrc_id)].size = size;</span><br><span class="line">    resource_types_table[TSRM_UNSHUFFLE_RSRC_ID(*rsrc_id)].ctor = ctor;</span><br><span class="line">    resource_types_table[TSRM_UNSHUFFLE_RSRC_ID(*rsrc_id)].dtor = dtor;</span><br><span class="line">    resource_types_table[TSRM_UNSHUFFLE_RSRC_ID(*rsrc_id)].done = 0;</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>根据上面的初始化和注册资源流程可以看出， <code>tsrm_tls_entry</code>  结构是 <code>resource_types_table</code> 的基本组成单位，<code>resource_types_table</code> 就是线程的资源聚集地， 在注册资源的时候，tsrm会给资源分配一个id，然后线程再去使用这个资源的时候，首先根据tread_id找到 分配的线程内存地址，然后再根据 资源id，找到资源在线程内存地址里面的地址</p><h1 id="流程优化"><a href="#流程优化" class="headerlink" title="流程优化"></a>流程优化</h1><p>梳理一下，线程里面查找一个资源可以分为三步</p><ol><li>获取当前线程的thread_id</li><li>根据thread_id获取tsrm_tls_entry，这个过程需要对tsrm_tls_table加锁，遍历链表</li><li>根据资源id，获取tsrm_tls_entry里面的对应的资源</li></ol><p>线程对资源的操作是频繁的，每次都要进行上面三步操作是很费时的，而且第二步还需要加锁，这个将严重的影响性能。</p><p>TSRM通过线程私有数据（Thread-Specific Data, TSD）优化了这个问题，TSD是由POSIX数据库维护的，使用同一名称为不同线程保存数据的一种存储形式，即各线程根据同名的key可以获取到不同的变量地址。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">// 创建名为key的TSD</span><br><span class="line">int pthread_key_create(pthread_key_t* keyp, void (*destructor)(void*) );</span><br><span class="line">// 销毁名为key的TSD</span><br><span class="line">int pthread_key_delete(pthread_key_t* key);</span><br><span class="line">// 根据key设置TSD</span><br><span class="line">int pthread_setspecific(pthread_key_t key, const void* value);</span><br><span class="line">// 根据key获取</span><br><span class="line">int pthread_setspecific(pthread_key_t key, const void* value);</span><br></pre></td></tr></table></figure><p>如此，便可以将上面三步优化为下面两步</p><ol><li>根据资源id获取资源的地址</li><li>根据资源地址，获取资源内容</li></ol>]]></content>
      
      
      <categories>
          
          <category> PHP </category>
          
      </categories>
      
      
        <tags>
            
            <tag> PHP </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>浅析堆栈和内存溢出</title>
      <link href="/posts/30726/"/>
      <url>/posts/30726/</url>
      
        <content type="html"><![CDATA[<p>对于一个PHPer来说，PHP已经帮我们处理好了GC，线程安全等内存相关的操作，完全不需要我们去考虑，让我们更加注重于代码的实现。再加上大学原本就是混的嗨皮，学的心塞，也对这些概念没什么了解，但是近期在看PHP的源码的时候，感慨还是逃不掉这些概念。</p><a id="more"></a><h1 id="内存分布"><a href="#内存分布" class="headerlink" title="内存分布"></a>内存分布</h1><p>一个C语言的内存布局：</p><ol><li>栈区（stack）: 由编译器自动分配释放 ，存放函数的参数值，局部变量的值等。其操作方式类似于数据结构中的栈。</li><li>堆区（heap） : 一般由程序员分配释放， 若程序员不释放，程序结束时可能由OS回收 。注意它与数据结构中的堆是两回事，分配方式倒是类似于链表。</li><li>全局区（静态区）（static）: 全局变量和静态变量的存储是放在一块的，初始化的全局变量和静态变量在一块区域， 未初始化的全局变量和未初始化的静态变量在相邻的另一块区域。 - 程序结束后由系统释放。</li><li>文字常量区 : 常量字符串就是放在这里的。 程序结束后由系统释放</li><li>程序代码区 : 存放函数体的二进制代码。</li></ol><p>内存分布如下图所示</p><p><img src="https://github-1253518569.cos.ap-shanghai.myqcloud.com/1609713-eaa6e0729938352f.webp" alt="img"></p><p>上图是网上搜索堆栈很常见的一个图，在这个图里面，栈区和堆区就是对应内存分配中的栈区和堆区，其余的可参照下面对应</p><p>可读写取 =&gt; 全局区</p><p>文字常量区 =&gt; 只读区</p><p>程序代码去 =&gt; 只读区</p><h1 id="例子"><a href="#例子" class="headerlink" title="例子"></a>例子</h1><p>下面，我们结合网上非常经典的一个例子来分析</p><p><img src="https://github-1253518569.cos.ap-shanghai.myqcloud.com/1470646448_1244.PNG" alt="https://github-1253518569.cos.ap-shanghai.myqcloud.com/1470646448_1244.PNG"></p><ul><li>int a = 0 : 这里是写在main函数外面的全局变量，属于初始化过的全局变量，所以应该存在在 <code>全局区</code></li><li>char *p1 : 这里同上，区别是没有经过初始化，所以属于未初始化的全局变量，所以应该也存在 <code>全局区</code></li><li>int b : 这一行是在main函数里面，也没有声明全局变量，属于局部变量，所以应该是存放在 <code>栈区</code> 上面</li><li>char s[] = “abc” : 同上，s 变量是 局部变量，也就是存放在 <code>栈区</code> 上面，分配的内存里面存储的就是 “abc”</li><li>char *p2 : 同 <code>int b</code> 分析可得，存放在 <code>栈区</code> 上面</li><li>char *p3 :  同上分析可得， p3 是存放在 <code>栈区</code> 上面，p3所在的内存就存储了它所指向的地址，也就是说并不是存储的”123456”，这时候 “123456” 就可以看成一个常量字符串，应该是存放在 <code>文字常量区</code></li><li>static int c = 0 : 初始化的静态变量应该存放在 <code>全局区</code></li><li>p1 = (char * )malloc(10) : p1 这个变量肯定是被压入 <code>栈内</code> 的，其值也就是申请的内存的首地址， 那 malloc 分配的地址呢， 这个地址是由程序员分配的，所以是存放在 <code>堆区</code> 上的一块内存</li><li>p2 = (char *) malloc(20) : 同上分析</li><li>strcpy(p1, “123456”) : 对于编译器的优化，个人并不清楚，所以可依据图中的注释 </li></ul><h1 id="内存泄漏"><a href="#内存泄漏" class="headerlink" title="内存泄漏"></a>内存泄漏</h1><p>在上面的内存分布中会发现，除了<code>堆区</code>以外，其他区的内存区会在程序结束时，由系统释放，所以内 <strong>内存泄漏</strong>是指由于疏忽或错误造成程序未能释放已经不再使用的<a href="https://zh.wikipedia.org/wiki/%E5%86%85%E5%AD%98" target="_blank" rel="noopener">内存</a>。内存泄漏并非指内存在物理上的消失，而是应用程序分配某段内存后，由于设计错误，导致在释放该段内存之前就失去了对该段内存的控制，从而造成了内存的浪费。</p><p>所以，在C语言中，内存的释放是由 <strong>free()</strong> 来处理完成的，</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">void free(void *ptr)  </span><br><span class="line">&#123; </span><br><span class="line">    struct mem_control_block *free; </span><br><span class="line">    free = ptr - sizeof(struct mem_control_block); </span><br><span class="line">    free-&gt;is_available = 1; </span><br><span class="line">    return; </span><br><span class="line">&#125;</span><br><span class="line">struct mem_control_block &#123; </span><br><span class="line">int is_available;    //这是一个标记？ </span><br><span class="line">int size;            //这是实际空间的大小 </span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>上面是 <strong>free()</strong>， 其实是把对应内存块设置为可用，同时把指针再向前偏移 <strong>内存块控制头</strong> 的长度，也就是实际分配的内存块首地址，所以，这里引出一个问题，如果我们给 <strong>free()</strong> 的不是<strong>malloc()</strong> 返回给我们的地址，这时候去释放内存是不时会存在问题 ，所以，综上，内存泄漏可以总结出两种原因</p><ol><li>malloc 之后 没有 free</li><li>free 是 给的地址不是 malloc 返回给我们的首地址</li></ol>]]></content>
      
      
      <categories>
          
          <category> 内存 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 内存 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>深入PHP系列之PHP数组底层的实现</title>
      <link href="/posts/17570/"/>
      <url>/posts/17570/</url>
      
        <content type="html"><![CDATA[<p>数组是PHP中非常强大、灵活的一种数据类型，它的底层实现为散列表(HashTable，也称作：哈希表)，除了我们熟悉的PHP用户空间的Array类型之外，内核中也随处用到散列表，比如函数、类、常量、已include文件的索引表、全局符号表等都用的HashTable存储。</p><p>散列表是根据关键码值(Key value)而直接进行访问的数据结构，它的key - value之间存在一个映射函数，可以根据key通过映射函数直接索引到对应的value值，它不以关键字的比较为基本操作，采用直接寻址技术（就是说，它是直接通过key映射到内存地址上去的），从而加快查找速度，在理想情况下，无须任何比较就可以找到待查关键字，查找的期望时间为O(1)。</p><a id="more"></a><h1 id="数组结构"><a href="#数组结构" class="headerlink" title="数组结构"></a>数组结构</h1><h2 id="Array-结构体（zend-type-h）"><a href="#Array-结构体（zend-type-h）" class="headerlink" title="Array 结构体（zend_type.h）"></a>Array 结构体（<strong>zend_type.h</strong>）</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">struct _zend_array &#123;</span><br><span class="line">    zend_refcounted_h gc;</span><br><span class="line">    union &#123;</span><br><span class="line">        struct &#123;</span><br><span class="line">            ZEND_ENDIAN_LOHI_4(</span><br><span class="line">                zend_uchar    flags,</span><br><span class="line">                zend_uchar    _unused,</span><br><span class="line">                zend_uchar    nIteratorsCount,</span><br><span class="line">                zend_uchar    _unused2)</span><br><span class="line">        &#125; v;</span><br><span class="line">        uint32_t flags;</span><br><span class="line">    &#125; u;</span><br><span class="line">    uint32_t          nTableMask; // 哈希值计算掩码 等于 -nTableSize</span><br><span class="line">    Bucket           *arData;  // 存储元素数组，指向第一个bucket</span><br><span class="line">    uint32_t          nNumUsed; // 已用的bucket数量</span><br><span class="line">    uint32_t          nNumOfElements; // 哈希表中全部元素数</span><br><span class="line">    uint32_t          nTableSize;  // 哈希表的总大小</span><br><span class="line">    uint32_t          nInternalPointer;</span><br><span class="line">    zend_long         nNextFreeElement; // 下一个可用的数值索引， 例 arr[] = 1; 这里就是1</span><br><span class="line">    dtor_func_t       pDestructor;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>这个了结构体里面 在第2行 引入了 <strong>zend_refcounted_h</strong> 结构体，这个是垃圾回收时用到的</p><p>在第14行的时候 引入了 <strong>Bucket</strong> 结构体，我们继续看一下 <strong>Bucket</strong> 结构体</p><h2 id="Bucket结构体-（zend-type-h）"><a href="#Bucket结构体-（zend-type-h）" class="headerlink" title="Bucket结构体 （zend_type.h）"></a>Bucket结构体 （zend_type.h）</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">typedef struct _Bucket &#123;</span><br><span class="line">zval              val;</span><br><span class="line">zend_ulong        h;                /* hash value (or numeric index)   */</span><br><span class="line">zend_string      *key;              /* string key or NULL for numerics */</span><br><span class="line">&#125; Bucket;</span><br></pre></td></tr></table></figure><p>在第2行的时候，引入了 zval 结构体，</p><h2 id="zval结构体（zend-type-h）"><a href="#zval结构体（zend-type-h）" class="headerlink" title="zval结构体（zend_type.h）"></a>zval结构体（zend_type.h）</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line">struct _zval_struct &#123;</span><br><span class="line">    zend_value        value;            /* value */</span><br><span class="line">    union &#123;</span><br><span class="line">        struct &#123;</span><br><span class="line">            ZEND_ENDIAN_LOHI_3(</span><br><span class="line">                zend_uchar    type,         /* active type */</span><br><span class="line">                zend_uchar    type_flags,</span><br><span class="line">                union &#123;</span><br><span class="line">                    uint16_t  call_info;    /* call info for EX(This) */</span><br><span class="line">                    uint16_t  extra;        /* not further specified */</span><br><span class="line">                &#125; u)</span><br><span class="line">        &#125; v;</span><br><span class="line">        uint32_t type_info;</span><br><span class="line">    &#125; u1;</span><br><span class="line">    union &#123;</span><br><span class="line">        uint32_t     next;                 /* hash collision chain */</span><br><span class="line">        uint32_t     cache_slot;           /* cache slot (for RECV_INIT) */</span><br><span class="line">        uint32_t     opline_num;           /* opline number (for FAST_CALL) */</span><br><span class="line">        uint32_t     lineno;               /* line number (for ast nodes) */</span><br><span class="line">        uint32_t     num_args;             /* arguments number for EX(This) */</span><br><span class="line">        uint32_t     fe_pos;               /* foreach position */</span><br><span class="line">        uint32_t     fe_iter_idx;          /* foreach iterator index */</span><br><span class="line">        uint32_t     access_flags;         /* class constant access flags */</span><br><span class="line">        uint32_t     property_guard;       /* single property guard */</span><br><span class="line">        uint32_t     constant_flags;       /* constant flags */</span><br><span class="line">        uint32_t     extra;                /* not further specified */</span><br><span class="line">    &#125; u2;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h2 id="字段解释"><a href="#字段解释" class="headerlink" title="字段解释"></a>字段解释</h2><p>首先从 array结构体开始说起</p><ul><li>nTableMask : 哈希值计算掩码， 数组的索引计算出来的long 与这个值进行位运算，从而计算出这个数据应该存放在索引表的位置</li><li>arData: 数组中的值都存放在这里，这个也是数组hash表的实现的地方</li><li>nNumUsed: 使用的bucket的总数</li><li>nNumOfElements: hash表中的有效数据，在PHP中，删除数组中的一个元素，并不会直接将这个元素从hash表里面删除，而是在bucket里面的zval结构体里面修改为 <code>IS_UNDEF</code>， 在 <code>ht-&gt;nNumUsed &gt; ht-&gt;nNumOfElements + (ht-&gt;nNumOfElements &gt;&gt; 5)</code> 的时候进行整理</li><li>nTableSize: 分配的hash表的大小</li><li>nNextFreeElement: 下一个可用的hash数值索引</li><li>pDestructor: 一个回调函数，当覆盖/删除一个key或者释放zend_array时，用于释放Bucket中的val。</li></ul><p>Bucket</p><ul><li>val：存储的zval数据。</li><li>h：当元素保存在整形下标时，下标保存在该字段，并且本身充当hash值，对其取模得到哈希表的槽位。</li><li>key：当保存的key是字符串时，保存在该字段，通过某个哈希算法生成hash值保存到h字段，对h取模得到哈希表的槽位。</li></ul><h1 id="hash表"><a href="#hash表" class="headerlink" title="hash表"></a>hash表</h1><h2 id="hash表图示"><a href="#hash表图示" class="headerlink" title="hash表图示"></a>hash表图示</h2><p>首先在这里展示一下，数组的hash表大致的实现图示，然后结合插入操作来具体分析</p><p><img src="https://github-1253518569.cos.ap-shanghai.myqcloud.com/php-hash-table.png" alt="hash表图示"></p><h2 id="hash表实现（zend-hash-c）"><a href="#hash表实现（zend-hash-c）" class="headerlink" title="hash表实现（zend_hash.c）"></a>hash表实现（zend_hash.c）</h2><p>这里首要分析了 数组的插入操作，插入的时候，是如何创建使用hash表的索引及选择bucket的位置的，插入操作主要通过 <code>_zend_hash_add_or_update_i</code> 实现的，如下：</p><p>首先先将一些可能会用用到的常量和函数先在这里声明一下，后面查看源码的时候会用到</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line">#define Z_NEXT(zval)                (zval).u2.next</span><br><span class="line">#define Z_NEXT_P(zval_p)            Z_NEXT(*(zval_p))</span><br><span class="line"></span><br><span class="line">#define HT_HASH_EX(data, idx) \</span><br><span class="line">    ((uint32_t*)(data))[(int32_t)(idx)]</span><br><span class="line">#define HT_HASH(ht, idx) \</span><br><span class="line">    HT_HASH_EX((ht)-&gt;arData, idx)</span><br><span class="line"># define HT_IDX_TO_HASH(idx) \</span><br><span class="line">    ((idx) * sizeof(Bucket))</span><br><span class="line"></span><br><span class="line">#define HT_FLAGS(ht) (ht)-&gt;u.flags</span><br><span class="line"></span><br><span class="line">#define HT_IS_PACKED(ht) \</span><br><span class="line">    ((HT_FLAGS(ht) &amp; HASH_FLAG_PACKED) != 0)</span><br><span class="line"></span><br><span class="line">#define HASH_UPDATE (1&lt;&lt;0)</span><br><span class="line">#define HASH_ADD(1&lt;&lt;1)</span><br><span class="line">#define HASH_UPDATE_INDIRECT(1&lt;&lt;2)</span><br><span class="line">#define HASH_ADD_NEW(1&lt;&lt;3)</span><br><span class="line">#define HASH_ADD_NEXT(1&lt;&lt;4)</span><br><span class="line"></span><br><span class="line">#define HASH_FLAG_CONSISTENCY      ((1&lt;&lt;0) | (1&lt;&lt;1))</span><br><span class="line">#define HASH_FLAG_PACKED           (1&lt;&lt;2)</span><br><span class="line">#define HASH_FLAG_INITIALIZED      (1&lt;&lt;3)</span><br><span class="line">#define HASH_FLAG_STATIC_KEYS      (1&lt;&lt;4) /* long and interned strings */</span><br><span class="line">#define HASH_FLAG_HAS_EMPTY_IND    (1&lt;&lt;5)</span><br><span class="line">#define HASH_FLAG_ALLOW_COW_VIOLATION (1&lt;&lt;6)</span><br></pre></td></tr></table></figure><p>源码如下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br></pre></td><td class="code"><pre><span class="line">static zend_always_inline zval *_zend_hash_add_or_update_i(HashTable *ht, zend_string *key, zval *pData, uint32_t flag)</span><br><span class="line">&#123;</span><br><span class="line">zend_ulong h;</span><br><span class="line">uint32_t nIndex;</span><br><span class="line">uint32_t idx;</span><br><span class="line">Bucket *p, *arData;</span><br><span class="line"></span><br><span class="line">IS_CONSISTENT(ht);</span><br><span class="line">HT_ASSERT_RC1(ht);</span><br><span class="line">// 检查hashtable是否初始化</span><br><span class="line">if (UNEXPECTED(!(HT_FLAGS(ht) &amp; HASH_FLAG_INITIALIZED))) &#123;</span><br><span class="line">    // 如果数组还没有分配ardata内存， 这时需要分配内存，包括中间映射表和元素数组</span><br><span class="line">zend_hash_real_init_mixed(ht);</span><br><span class="line">if (!ZSTR_IS_INTERNED(key)) &#123;</span><br><span class="line">zend_string_addref(key);</span><br><span class="line">HT_FLAGS(ht) &amp;= ~HASH_FLAG_STATIC_KEYS;</span><br><span class="line">zend_string_hash_val(key);</span><br><span class="line">&#125;</span><br><span class="line">goto add_to_hash;</span><br><span class="line">&#125; else if (HT_FLAGS(ht) &amp; HASH_FLAG_PACKED) &#123;</span><br><span class="line">    // 这里将packed array转换成等效的hash array</span><br><span class="line">zend_hash_packed_to_hash(ht);</span><br><span class="line">if (!ZSTR_IS_INTERNED(key)) &#123;</span><br><span class="line">zend_string_addref(key);</span><br><span class="line">HT_FLAGS(ht) &amp;= ~HASH_FLAG_STATIC_KEYS;</span><br><span class="line">zend_string_hash_val(key);</span><br><span class="line">&#125;</span><br><span class="line">&#125; else if ((flag &amp; HASH_ADD_NEW) == 0) &#123;</span><br><span class="line">p = zend_hash_find_bucket(ht, key, 0);</span><br><span class="line"></span><br><span class="line">if (p) &#123;</span><br><span class="line">zval *data;</span><br><span class="line">// key已经存在的情况，且标志位 是HASH_ADD</span><br><span class="line">if (flag &amp; HASH_ADD) &#123;</span><br><span class="line">if (!(flag &amp; HASH_UPDATE_INDIRECT)) &#123;</span><br><span class="line">return NULL;</span><br><span class="line">&#125;</span><br><span class="line">// 新更新的值不与原先相同，继续执行</span><br><span class="line">ZEND_ASSERT(&amp;p-&gt;val != pData);</span><br><span class="line">data = &amp;p-&gt;val;</span><br><span class="line">// IS_INDIRECT是间接zval，不明白什么意思，继续学习</span><br><span class="line">if (Z_TYPE_P(data) == IS_INDIRECT) &#123;</span><br><span class="line">data = Z_INDIRECT_P(data);</span><br><span class="line">if (Z_TYPE_P(data) != IS_UNDEF) &#123;</span><br><span class="line">return NULL;</span><br><span class="line">&#125;</span><br><span class="line">&#125; else &#123;</span><br><span class="line">return NULL;</span><br><span class="line">&#125;</span><br><span class="line">&#125; else &#123;</span><br><span class="line">ZEND_ASSERT(&amp;p-&gt;val != pData);</span><br><span class="line">data = &amp;p-&gt;val;</span><br><span class="line">if ((flag &amp; HASH_UPDATE_INDIRECT) &amp;&amp; Z_TYPE_P(data) == IS_INDIRECT) &#123;</span><br><span class="line">data = Z_INDIRECT_P(data);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">// 释放掉原来的data</span><br><span class="line">if (ht-&gt;pDestructor) &#123;</span><br><span class="line">ht-&gt;pDestructor(data);</span><br><span class="line">&#125;</span><br><span class="line">// 将新的pData值复制给原来的data</span><br><span class="line">ZVAL_COPY_VALUE(data, pData);</span><br><span class="line">return data;</span><br><span class="line">&#125;</span><br><span class="line">if (!ZSTR_IS_INTERNED(key)) &#123;</span><br><span class="line">zend_string_addref(key);</span><br><span class="line">HT_FLAGS(ht) &amp;= ~HASH_FLAG_STATIC_KEYS;</span><br><span class="line">&#125;</span><br><span class="line">&#125; else if (!ZSTR_IS_INTERNED(key)) &#123;</span><br><span class="line">zend_string_addref(key);</span><br><span class="line">HT_FLAGS(ht) &amp;= ~HASH_FLAG_STATIC_KEYS;</span><br><span class="line">zend_string_hash_val(key);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">// 如果hash表满了，对hash表进行扩容</span><br><span class="line">ZEND_HASH_IF_FULL_DO_RESIZE(ht);/* If the Hash table is full, resize it */</span><br><span class="line"></span><br><span class="line">// 添加hash表</span><br><span class="line">add_to_hash:</span><br><span class="line">    // ardata数组的顺序索引</span><br><span class="line">idx = ht-&gt;nNumUsed++;</span><br><span class="line">ht-&gt;nNumOfElements++;</span><br><span class="line">arData = ht-&gt;arData;</span><br><span class="line">// arData的指针偏移到 idx</span><br><span class="line">p = arData + idx;</span><br><span class="line">// 设置 hash表里面的bucket结构体的 key和 h</span><br><span class="line">p-&gt;key = key;</span><br><span class="line">p-&gt;h = h = ZSTR_H(key);</span><br><span class="line">// 与tablemask进行计算得出hash索引</span><br><span class="line">nIndex = h | ht-&gt;nTableMask;</span><br><span class="line">Z_NEXT(p-&gt;val) = HT_HASH_EX(arData, nIndex);</span><br><span class="line">// 新的元素放到当前hash冲突链表的头部</span><br><span class="line">HT_HASH_EX(arData, nIndex) = HT_IDX_TO_HASH(idx);</span><br><span class="line">ZVAL_COPY_VALUE(&amp;p-&gt;val, pData);</span><br><span class="line"></span><br><span class="line">return &amp;p-&gt;val;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>从上面的<code>api _zend_hash_add_or_update_i</code>可以看出，其实更新操作很简单的，验证key是否存在，key存在的情况下如果值相等的话不做任何的操作，值不相同做更新操作。<br>这里比较重要的是hash表的新增，这里会涉及hash索引以及hash冲突链表。</p><p><code>nIndex = h | ht-&gt;nTableMask;</code> </p><p>这里由于 <strong>nTableMask</strong> 是 <strong>-TableSize</strong>， 所以 <strong>nIndex</strong> 的计算结果范围，也就落到了-2^0 - -2^(tableSize-1)范围里从而将整个 <strong>arData</strong> 分成上图所示的左右两部分，左边是索引表，右边是元素数组，每次新增数据（非更新）的时候，首先把这个数据，顺序的插入到<strong>arData</strong> 右侧的元素数组里面，这样做的目的是为了保证数组的顺序性，在foreach的时候，只需要顺序遍历 <strong>arData</strong> 右侧的数组即可，但是这里有一个问题就是 查找怎么办， 所以就引入了<strong>arData</strong> 左侧的索引表，计算出key的hash索引，然后再指向 刚刚插入的<strong>arData</strong>右侧元素数组的地址</p><p>既然使用了hash表，就避免不了hash冲突的问题</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Z_NEXT(p-&gt;val) = HT_HASH_EX(arData, nIndex);</span><br><span class="line">HT_HASH_EX(arData, nIndex) = HT_IDX_TO_HASH(idx);</span><br></pre></td></tr></table></figure><p>结合上面可能用到的一些定义，这行就可以翻译成</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">p-&gt;val.u2.next = *arData[nIndex]</span><br><span class="line">*arData[nIndex] = arData[idx]</span><br></pre></td></tr></table></figure><p>索引bucket指向新插入的元素，新插入的元素里阿米你的zval结构体里面的next指针再指向原先 索引bucket指向的位置，这样就把新插入的元素放在了冲突链表的头位置了</p><h1 id="扩展-遍历"><a href="#扩展-遍历" class="headerlink" title="扩展-遍历"></a>扩展-遍历</h1><p>根据上面的插入思路，可以很清晰的看到，数组在内存中是个有序的数组，hash表实现了位置的索引，zval的u2结构体帮助实现了 hash冲突的链表解决方案</p><p>如果此时去遍历数组，就只需要顺序遍历<code>arData</code>的右侧元素数据即可，还是有序的</p>]]></content>
      
      
      <categories>
          
          <category> PHP </category>
          
      </categories>
      
      
        <tags>
            
            <tag> PHP </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>深入PHP系列之PHP排序sort函数实现</title>
      <link href="/posts/30174/"/>
      <url>/posts/30174/</url>
      
        <content type="html"><![CDATA[<p>PHP的数组是个很强大的存在，而且使用PHP的数组的时候，只要你能想到，基本都已实现，所以也让我慢慢忘记了排序算法的存在。近期，有个人问我，PHP的sort函数是怎么实现的，尴尬，在重温了一遍算法之后，根据我大学依稀存在的C语言基础，尝试阅读了一下PHP的sort函数实现的源码，以下是以PHP7.3源码为例，个人技术水平有限，仅供参考</p><a id="more"></a><h1 id="sort"><a href="#sort" class="headerlink" title="sort"></a>sort</h1><blockquote><p>bool <strong>sort</strong>    ( array <code>&amp;$array</code>   [, int <code>$sort_flags</code> = SORT_REGULAR  ] )</p></blockquote><p>首先我们在 <code>php_srray.h</code> 中可以看到array 中 相关 排序函数的定义</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">PHP_FUNCTION(ksort);</span><br><span class="line">PHP_FUNCTION(krsort);</span><br><span class="line">PHP_FUNCTION(natsort);</span><br><span class="line">PHP_FUNCTION(natcasesort);</span><br><span class="line">PHP_FUNCTION(asort);</span><br><span class="line">PHP_FUNCTION(arsort);</span><br><span class="line">PHP_FUNCTION(sort);</span><br><span class="line">PHP_FUNCTION(rsort);</span><br><span class="line">PHP_FUNCTION(usort);</span><br><span class="line">....</span><br></pre></td></tr></table></figure><p>然后进入<code>array.c</code> 找到 <code>PHP_FUNCTION(sort)</code> 的实现</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">PHP_FUNCTION(sort)</span><br><span class="line">&#123;</span><br><span class="line">    zval *array;</span><br><span class="line">    zend_long sort_type = PHP_SORT_REGULAR;</span><br><span class="line">    compare_func_t cmp;</span><br><span class="line"></span><br><span class="line">    ZEND_PARSE_PARAMETERS_START(1, 2)</span><br><span class="line">        Z_PARAM_ARRAY_EX(array, 0, 1)</span><br><span class="line">        Z_PARAM_OPTIONAL</span><br><span class="line">        Z_PARAM_LONG(sort_type)</span><br><span class="line">    ZEND_PARSE_PARAMETERS_END_EX(RETURN_FALSE);</span><br><span class="line"></span><br><span class="line">    cmp = php_get_data_compare_func(sort_type, 0);</span><br><span class="line"></span><br><span class="line">    if (zend_hash_sort(Z_ARRVAL_P(array), cmp, 1) == FAILURE) &#123;</span><br><span class="line">        RETURN_FALSE;</span><br><span class="line">    &#125;</span><br><span class="line">    RETURN_TRUE;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ol><li><code>ZEND_PARSE_PARAMETERS_START</code>  <code>ZEND_PARSE_PARAMETERS_END_EX</code> ，在 <code>zend_api.h</code> 中有定义及实现， 主要是进行参数的校验转换等操作</li><li><code>php_get_data_compare_func</code> 设置比较函数， 也就是根据 sort_flag 来决定</li><li><code>zend_hash_sort</code> 这里开始了正式的排序</li></ol><h1 id="zend-hash-sort"><a href="#zend-hash-sort" class="headerlink" title="zend_hash_sort"></a>zend_hash_sort</h1><p>这个定义在 <code>zend_hash.h</code> 中</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">#define zend_hash_sort(ht, compare_func, renumber) \</span><br><span class="line">    zend_hash_sort_ex(ht, zend_sort, compare_func, renumber)</span><br></pre></td></tr></table></figure><p>这里将 <code>zend_hash_sort</code>  的方法转到了 <code>zend_hash_sort_ex</code> 的方法，接下来继续查看 <code>zend_hash_sort_ex</code> 即可</p><h1 id="zend-hash-sort-ex"><a href="#zend-hash-sort-ex" class="headerlink" title="zend_hash_sort_ex"></a>zend_hash_sort_ex</h1><p>这个定义在 <code>zend_hash.h</code> 中，在<code>zend_hash.c</code> 中实现</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br></pre></td><td class="code"><pre><span class="line">ZEND_API int ZEND_FASTCALL zend_hash_sort_ex(HashTable *ht, sort_func_t sort, compare_func_t compar, zend_bool renumber)</span><br><span class="line">&#123;</span><br><span class="line">    Bucket *p;</span><br><span class="line">    uint32_t i, j;</span><br><span class="line"></span><br><span class="line">    IS_CONSISTENT(ht);</span><br><span class="line">    HT_ASSERT_RC1(ht);</span><br><span class="line"></span><br><span class="line">    if (!(ht-&gt;nNumOfElements&gt;1) &amp;&amp; !(renumber &amp;&amp; ht-&gt;nNumOfElements&gt;0)) &#123; /* Doesn&apos;t require sorting */</span><br><span class="line">        return SUCCESS;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    if (HT_IS_WITHOUT_HOLES(ht)) &#123;</span><br><span class="line">        i = ht-&gt;nNumUsed;</span><br><span class="line">    &#125; else &#123;</span><br><span class="line">        for (j = 0, i = 0; j &lt; ht-&gt;nNumUsed; j++) &#123;</span><br><span class="line">            p = ht-&gt;arData + j;</span><br><span class="line">            if (UNEXPECTED(Z_TYPE(p-&gt;val) == IS_UNDEF)) continue;</span><br><span class="line">            if (i != j) &#123;</span><br><span class="line">                ht-&gt;arData[i] = *p;</span><br><span class="line">            &#125;</span><br><span class="line">            i++;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    sort((void *)ht-&gt;arData, i, sizeof(Bucket), compar,</span><br><span class="line">            (swap_func_t)(renumber? zend_hash_bucket_renum_swap :</span><br><span class="line">                ((HT_FLAGS(ht) &amp; HASH_FLAG_PACKED) ? zend_hash_bucket_packed_swap : zend_hash_bucket_swap)));</span><br><span class="line"></span><br><span class="line">    ht-&gt;nNumUsed = i;</span><br><span class="line">    ht-&gt;nInternalPointer = 0;</span><br><span class="line"></span><br><span class="line">    if (renumber) &#123;</span><br><span class="line">        for (j = 0; j &lt; i; j++) &#123;</span><br><span class="line">            p = ht-&gt;arData + j;</span><br><span class="line">            p-&gt;h = j;</span><br><span class="line">            if (p-&gt;key) &#123;</span><br><span class="line">                zend_string_release(p-&gt;key);</span><br><span class="line">                p-&gt;key = NULL;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        ht-&gt;nNextFreeElement = i;</span><br><span class="line">    &#125;</span><br><span class="line">    if (HT_FLAGS(ht) &amp; HASH_FLAG_PACKED) &#123;</span><br><span class="line">        if (!renumber) &#123;</span><br><span class="line">            zend_hash_packed_to_hash(ht);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; else &#123;</span><br><span class="line">        if (renumber) &#123;</span><br><span class="line">            void *new_data, *old_data = HT_GET_DATA_ADDR(ht);</span><br><span class="line">            Bucket *old_buckets = ht-&gt;arData;</span><br><span class="line"></span><br><span class="line">            new_data = pemalloc(HT_SIZE_EX(ht-&gt;nTableSize, HT_MIN_MASK), (GC_FLAGS(ht) &amp; IS_ARRAY_PERSISTENT));</span><br><span class="line">            HT_FLAGS(ht) |= HASH_FLAG_PACKED | HASH_FLAG_STATIC_KEYS;</span><br><span class="line">            ht-&gt;nTableMask = HT_MIN_MASK;</span><br><span class="line">            HT_SET_DATA_ADDR(ht, new_data);</span><br><span class="line">            memcpy(ht-&gt;arData, old_buckets, sizeof(Bucket) * ht-&gt;nNumUsed);</span><br><span class="line">            pefree(old_data, GC_FLAGS(ht) &amp; IS_ARRAY_PERSISTENT);</span><br><span class="line">            HT_HASH_RESET_PACKED(ht);</span><br><span class="line">        &#125; else &#123;</span><br><span class="line">            zend_hash_rehash(ht);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    return SUCCESS;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ol><li>第13行开始，判断这个hash表是否有空洞， 如果有的话，遍历整个hash表并填补空洞</li><li>使用sort方法来进行 这个hash表的排序， 这里的sort其实是个指针，由<code>zend_hash_sort_ex</code> 的第二个参数 <strong>sort_func_t sort</strong> 传递过来，根据上一部分 <code>zend_hash_sort</code> 的实现代码，可以看出，这里的sort，其实是指向了 <strong>zend_sort</strong> 这个方法</li><li>30行以后就是排序完成后的操作了，不是主要，就不多废话了</li></ol><h1 id="zend-sort"><a href="#zend-sort" class="headerlink" title="zend_sort"></a>zend_sort</h1><p>这个在<code>zend_sort.h</code>中定义，在 <code>zend_sort.c</code> 中实现</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br></pre></td><td class="code"><pre><span class="line">ZEND_API void zend_sort(void *base, size_t nmemb, size_t siz, compare_func_t cmp, swap_func_t swp)</span><br><span class="line">&#123;</span><br><span class="line">while (1) &#123;</span><br><span class="line">if (nmemb &lt;= 16) &#123;</span><br><span class="line">zend_insert_sort(base, nmemb, siz, cmp, swp);</span><br><span class="line">return;</span><br><span class="line">&#125; else &#123;</span><br><span class="line">char *i, *j;</span><br><span class="line">char *start = (char *)base;</span><br><span class="line">char *end = start + (nmemb * siz);</span><br><span class="line">size_t offset = (nmemb &gt;&gt; Z_L(1));</span><br><span class="line">char *pivot = start + (offset * siz);</span><br><span class="line"></span><br><span class="line">if ((nmemb &gt;&gt; Z_L(10))) &#123;</span><br><span class="line">size_t delta = (offset &gt;&gt; Z_L(1)) * siz;</span><br><span class="line">zend_sort_5(start, start + delta, pivot, pivot + delta, end - siz, cmp, swp);</span><br><span class="line">&#125; else &#123;</span><br><span class="line">zend_sort_3(start, pivot, end - siz, cmp, swp);</span><br><span class="line">&#125;</span><br><span class="line">swp(start + siz, pivot);</span><br><span class="line">pivot = start + siz;</span><br><span class="line">i = pivot + siz;</span><br><span class="line">j = end - siz;</span><br><span class="line">while (1) &#123;</span><br><span class="line">while (cmp(pivot, i) &gt; 0) &#123;</span><br><span class="line">i += siz;</span><br><span class="line">if (UNEXPECTED(i == j)) &#123;</span><br><span class="line">goto done;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">j -= siz;</span><br><span class="line">if (UNEXPECTED(j == i)) &#123;</span><br><span class="line">goto done;</span><br><span class="line">&#125;</span><br><span class="line">while (cmp(j, pivot) &gt; 0) &#123;</span><br><span class="line">j -= siz;</span><br><span class="line">if (UNEXPECTED(j == i)) &#123;</span><br><span class="line">goto done;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">swp(i, j);</span><br><span class="line">i += siz;</span><br><span class="line">if (UNEXPECTED(i == j)) &#123;</span><br><span class="line">goto done;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">done:</span><br><span class="line">swp(pivot, i - siz);</span><br><span class="line">if ((i - siz) - start &lt; end - i) &#123;</span><br><span class="line">zend_sort(start, (i - start)/siz - 1, siz, cmp, swp);</span><br><span class="line">base = i;</span><br><span class="line">nmemb = (end - i)/siz;</span><br><span class="line">&#125; else &#123;</span><br><span class="line">zend_sort(i, (end - i)/siz, siz, cmp, swp);</span><br><span class="line">nmemb = (i - start)/siz - 1;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ol><li>4-7行进行了判断， 如果元素总数 &lt;= 16 ，则进行插入排序，这是很正常的，因为插入排序在最好的情况下时O(n) 级的算法，而数据量小的情况下，数据有序的可能性就越高，也就符合了最好的情况</li><li>后面就是 如果元素总数  &gt; 16， 则开始了另外一种排序，首先确定了头元素和尾元素，并让元素总数右移一位作为基准， 这里涉及一个函数 <code>Z_L</code> ，后面做补充解释</li><li>继续判断 <code>nmemb &gt;&gt; Z_L(10)</code> 如果 元素总数 右移 10位，依然大于 0的话，选取的偏移数 再向右偏移 1位 作为 delta， 然后  <code>zend_sort_5(start, start + delta, pivot, pivot + delta, end - siz, cmp, swp);</code> 进行交换，否则 执行 <code>zend_sort_3(start, pivot, end - siz, cmp, swp);</code> 执行排序</li><li>下面就是标准的快速排序的操作思路了，只是一般我们会使用递归来处理，但是递归会消耗空间，所以 PHP源码里面选择了非递归的方式</li></ol><h1 id="Z-L"><a href="#Z-L" class="headerlink" title="Z_L"></a>Z_L</h1><p>这里在 <code>zend_long.h</code> 中有定义</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"># define Z_L(i) INT64_C(i)</span><br></pre></td></tr></table></figure><p>然后继续看 <code>INT64_C</code> </p><h1 id="INI64-C"><a href="#INI64-C" class="headerlink" title="INI64_C"></a>INI64_C</h1><p>这个在 <code>php_stdint.h</code> 中有定义</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">#ifndef INT64_C</span><br><span class="line"># if SIZEOF_INT &gt;= 8</span><br><span class="line">#  define INT64_C(c) c</span><br><span class="line"># elif SIZEOF_LONG &gt;= 8</span><br><span class="line">#  define INT64_C(c) c ## L</span><br><span class="line"># elif SIZEOF_LONG_LONG &gt;= 8</span><br><span class="line">#  define INT64_C(c) c ## LL</span><br><span class="line"># endif</span><br><span class="line">#endif</span><br></pre></td></tr></table></figure><h1 id="zend-sort-3"><a href="#zend-sort-3" class="headerlink" title="zend_sort_3"></a>zend_sort_3</h1><p>这个函数也是在 <code>zend_sort.c</code>中实现的，主要就是判断，然后交换</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">static inline void zend_sort_3(void *a, void *b, void *c, compare_func_t cmp, swap_func_t swp) /* &#123;&#123;&#123; */ &#123;</span><br><span class="line">if (!(cmp(a, b) &gt; 0)) &#123;</span><br><span class="line">if (!(cmp(b, c) &gt; 0)) &#123;</span><br><span class="line">return;</span><br><span class="line">&#125;</span><br><span class="line">swp(b, c);</span><br><span class="line">if (cmp(a, b) &gt; 0) &#123;</span><br><span class="line">swp(a, b);</span><br><span class="line">&#125;</span><br><span class="line">return;</span><br><span class="line">&#125;</span><br><span class="line">if (!(cmp(c, b) &gt; 0)) &#123;</span><br><span class="line">swp(a, c);</span><br><span class="line">return;</span><br><span class="line">&#125;</span><br><span class="line">swp(a, b);</span><br><span class="line">if (cmp(b, c) &gt; 0) &#123;</span><br><span class="line">swp(b, c);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><p>综上分析，php的sort函数在元素数 较小(16个及以下)的时候，使用插入排序，否则使用非递归的快速排序来进行排序。</p>]]></content>
      
      
      <categories>
          
          <category> PHP </category>
          
      </categories>
      
      
        <tags>
            
            <tag> PHP </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>深入PHP系列-变量分离与引用</title>
      <link href="/posts/47934/"/>
      <url>/posts/47934/</url>
      
        <content type="html"><![CDATA[<p>近期在看鸟哥的博客的时候，发现自己对PHP内核方面还真是一窍不通，就以PHP变量来说，一直都知道PHP变量是写时复制，但是真的去分析这个变量的refcount和is_ref的时候，又是一脸懵逼，学习道路漫漫，戒骄戒躁。</p><a id="more"></a><p>PHP7和PHP5的zval结构具有不同，这里分开来理解</p><h1 id="PHP5"><a href="#PHP5" class="headerlink" title="PHP5"></a>PHP5</h1><h2 id="zval结构"><a href="#zval结构" class="headerlink" title="zval结构"></a>zval结构</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">struct _zval_struct &#123;</span><br><span class="line">        /* Variable information */</span><br><span class="line">        zvalue_value value;             /* value */</span><br><span class="line">        zend_uint refcount;</span><br><span class="line">        zend_uchar type;        /* active type */</span><br><span class="line">        zend_uchar is_ref;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>一个变量在创建的时候创建了一个结构体，这个结构体里面的</p><ul><li><strong>value</strong> 代表的这个变量的值，</li></ul><ul><li><strong>refcount</strong>用于标识此zval被多少个变量引用，当值为0的时候会被销毁</li><li><strong>is_ref</strong>标识是不是用户使用 &amp; 的强制引用</li></ul><h3 id="赋值"><a href="#赋值" class="headerlink" title="赋值"></a>赋值</h3><p>我们以下面的代码为例</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">&lt;?php</span><br><span class="line">   $val = &apos;tyloafer&apos;;</span><br><span class="line">   $ref = $val;</span><br></pre></td></tr></table></figure><p>首先 第一行代码创建了一个变量，并申请了8个字节大小的内存，（这里暂不考虑结构体的其他占用）</p><p>第二行又创建了一个变量，与第一个变量 $val 相同，则此时是否应该占用16个字节呢</p><p>实际情况并不是这样的，这也就是 结构体中的 <strong>refcount</strong> 和 <strong>is_ref</strong> 的作用</p><p>我们使用 <code>xdebug_debug_zval</code> 调试一下变量</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">$val = &apos;tyloafer&apos;</span><br><span class="line">$val : val: (refcount=1, is_ref=0)=&apos;tyloafer&apos;</span><br><span class="line"></span><br><span class="line">$ref = $val</span><br><span class="line">$val : val: (refcount=2, is_ref=0)=&apos;tyloafer&apos;</span><br><span class="line">$ref : ref: (refcount=2, is_ref=0)=&apos;tyloafer&apos;</span><br></pre></td></tr></table></figure><p>这里并没有新申请一块内存，复制结构体，而是将原有的refcount 进行了 +1 操作，那如果此时对变量进行unset操作，其实就是对refcount 进行 -1 操作了</p><h3 id="引用赋值"><a href="#引用赋值" class="headerlink" title="引用赋值"></a>引用赋值</h3><p>在PHP里面，还有一种赋值方式，即引用赋值，我们以下面代码为例</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">&lt;?php</span><br><span class="line">   $val = &apos;tyloafer&apos;;</span><br><span class="line">   $ref = &amp;$val;</span><br></pre></td></tr></table></figure><p>调试变量结果</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">$val = &apos;tyloafer&apos;</span><br><span class="line">$val : val: (refcount=1, is_ref=0)=&apos;tyloafer&apos;</span><br><span class="line"></span><br><span class="line">$ref = &amp;$val</span><br><span class="line">$val : val: (refcount=2, is_ref=1)=&apos;tyloafer&apos;</span><br><span class="line">$ref : ref: (refcount=2, is_ref=1)=&apos;tyloafer&apos;</span><br></pre></td></tr></table></figure><p>这里不仅 <strong>refcount</strong> 进行了 +1 操作， <strong>is_ref</strong> 也进行了 +1 操作，因为我们这里使用了 <strong>&amp;</strong> 操作 </p><p>针对于 赋值 操作，val 和 ref 两个变量均是指向同一个 zval 结构体，当我们对 ref 进行修改的时候，这时候两个变量的值就会不一样</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">&lt;?php</span><br><span class="line">   $val = &apos;tyloafer&apos;;</span><br><span class="line">   $ref = $val;</span><br><span class="line">   $ref = 1;</span><br></pre></td></tr></table></figure><p>从而可以推断，当执行到 <code>$ref = 1</code> 的时候， ref 和 val 两个变量指向的就不是同一个 zval 结构体了，此时 debug 结果如下</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">$val = &apos;tyloafer&apos;</span><br><span class="line">$val : val: (refcount=1, is_ref=0)=&apos;tyloafer&apos;</span><br><span class="line"></span><br><span class="line">$ref = $val</span><br><span class="line">$val : val: (refcount=1, is_ref=0)=&apos;tyloafer&apos;</span><br><span class="line">$ref : ref: (refcount=1, is_ref=0)=1</span><br></pre></td></tr></table></figure><p>这个过程就被称作 写时复制 (Copy On Write)</p><h2 id="写时复制-Copy-On-Write"><a href="#写时复制-Copy-On-Write" class="headerlink" title="写时复制(Copy On Write)"></a>写时复制(Copy On Write)</h2><p>PHP在修改一个变量以前，会首先查看这个变量的refcount，如果refcount大于1，PHP就会执行一个分离的例程。这个机制就是所谓的copy on write(写时复制)。</p><p>其中赋值函数如下</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br></pre></td><td class="code"><pre><span class="line">static inline zval* zend_assign_to_variable(zval **variable_ptr_ptr, zval *value TSRMLS_DC)</span><br><span class="line">&#123;</span><br><span class="line">zval *variable_ptr = *variable_ptr_ptr;</span><br><span class="line">zval garbage;</span><br><span class="line"></span><br><span class="line">if (Z_TYPE_P(variable_ptr) == IS_OBJECT &amp;&amp;</span><br><span class="line">    UNEXPECTED(Z_OBJ_HANDLER_P(variable_ptr, set) != NULL)) &#123;</span><br><span class="line">Z_OBJ_HANDLER_P(variable_ptr, set)(variable_ptr_ptr, value TSRMLS_CC);</span><br><span class="line">return variable_ptr;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"> if (EXPECTED(!PZVAL_IS_REF(variable_ptr))) &#123;  // 非引用赋值逻辑</span><br><span class="line">if (Z_REFCOUNT_P(variable_ptr)==1) &#123;</span><br><span class="line">if (UNEXPECTED(variable_ptr == value)) &#123;</span><br><span class="line">return variable_ptr;</span><br><span class="line">&#125; else if (EXPECTED(!PZVAL_IS_REF(value))) &#123;</span><br><span class="line">Z_ADDREF_P(value);</span><br><span class="line">*variable_ptr_ptr = value;</span><br><span class="line">ZEND_ASSERT(variable_ptr != &amp;EG(uninitialized_zval));</span><br><span class="line">GC_REMOVE_ZVAL_FROM_BUFFER(variable_ptr);</span><br><span class="line">zval_dtor(variable_ptr);</span><br><span class="line">efree(variable_ptr);</span><br><span class="line">return value;</span><br><span class="line">&#125; else &#123;</span><br><span class="line">goto copy_value;</span><br><span class="line">&#125;</span><br><span class="line">&#125; else &#123; /* we need to split */  // 这里是引用的相关赋值逻辑</span><br><span class="line">Z_DELREF_P(variable_ptr);</span><br><span class="line">GC_ZVAL_CHECK_POSSIBLE_ROOT(variable_ptr);</span><br><span class="line">if (PZVAL_IS_REF(value)) &#123;</span><br><span class="line">ALLOC_ZVAL(variable_ptr);</span><br><span class="line">*variable_ptr_ptr = variable_ptr;</span><br><span class="line">INIT_PZVAL_COPY(variable_ptr, value);</span><br><span class="line">zval_copy_ctor(variable_ptr);</span><br><span class="line">return variable_ptr;</span><br><span class="line">&#125; else &#123;</span><br><span class="line">*variable_ptr_ptr = value;</span><br><span class="line">Z_ADDREF_P(value);</span><br><span class="line">return value;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"> &#125; else &#123;</span><br><span class="line">if (EXPECTED(variable_ptr != value)) &#123;</span><br><span class="line">copy_value:</span><br><span class="line">if (EXPECTED(Z_TYPE_P(variable_ptr) &lt;= IS_BOOL)) &#123;</span><br><span class="line">/* nothing to destroy */</span><br><span class="line">ZVAL_COPY_VALUE(variable_ptr, value);</span><br><span class="line">zendi_zval_copy_ctor(*variable_ptr);</span><br><span class="line">&#125; else &#123;</span><br><span class="line">ZVAL_COPY_VALUE(&amp;garbage, variable_ptr);</span><br><span class="line">ZVAL_COPY_VALUE(variable_ptr, value);</span><br><span class="line">zendi_zval_copy_ctor(*variable_ptr);</span><br><span class="line">_zval_dtor_func(&amp;garbage ZEND_FILE_LINE_CC);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">return variable_ptr;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这里的<code>EXPECTED(var)</code> 就相当于 <code>val == 1</code></p><p>我们根据这个特性，做一下 下面的代码的分析</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">&lt;?php</span><br><span class="line">    $val = &apos;tyloafer&apos;;</span><br><span class="line">    $ref = &amp;$val;</span><br><span class="line">    $copy = $val;</span><br><span class="line">    $copy = &apos;1111&apos;;</span><br></pre></td></tr></table></figure><p>首先代码执行到第一行 <code>$val = &#39;tyloafer&#39;;</code> ， 这时候 PHP会创建一个zval结构体，此时他的值应该是 </p><blockquote><p> refcount = 1, is_ref = 0</p></blockquote><p>执行到第二行的时候，根据上面结果可以知道 </p><blockquote><p>$val : val: (refcount=2, is_ref=1)=’tyloafer’<br>$ref : ref: (refcount=2, is_ref=1)=’tyloafer’</p></blockquote><p>接下来执行第三行，此时val 的 refcount = 2， is_ref = 1， 满足了<strong>写时复制</strong>的条件， 但是这里是使用val 的变量，赋值给新的变量，是否会 触发 <strong>COW</strong> 呢，其实是会触发的，我们照此思路处理下去的话</p><p>如果这个脚本就 <code>$copy = $val;</code> 一行的话， 这两个变量 val copy 是会共用一个 结构体的，但是此时 val 结构满足了 分离的条件，所以 这两个变量就需要进行分离，也就是 copy 不能共用 val 的结构体 分离出去，但是原先的 val 和 ref 没有修改， 所以不会触发分离的条件，所以 此时的结果就是</p><blockquote><p>$val : val: (refcount=2, is_ref=1)=’tyloafer’<br>$ref : ref: (refcount=2, is_ref=1)=’tyloafer’<br>$copy : copy: (refcount=1, is_ref=0)=’tyloafer’</p></blockquote><p>最后一步， <code>$copy = 111;</code>  ，此时的copy 已经分离出来了，是个独立的结构体，也不满足分离条件，直接修改 结构体里面的 value即可</p><blockquote><p>$copy : copy: (refcount=1, is_ref=0)=’1111’<br>$val : val: (refcount=2, is_ref=1)=’tyloafer’</p></blockquote><h3 id="经典性能问题"><a href="#经典性能问题" class="headerlink" title="经典性能问题"></a>经典性能问题</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line">&lt;?php</span><br><span class="line"></span><br><span class="line">$array = range(1, 100000);</span><br><span class="line">function dummy($array) &#123;&#125;</span><br><span class="line"></span><br><span class="line">function test(&amp;$arr)</span><br><span class="line">&#123;</span><br><span class="line">    dummy($arr);</span><br><span class="line">&#125;</span><br><span class="line">function test1($arr)</span><br><span class="line">&#123;</span><br><span class="line">    dummy($arr);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">$array = range(1, 100000);</span><br><span class="line">$start = microtime(true);</span><br><span class="line">$i     = 0;</span><br><span class="line">while ($i++ &lt; 100) &#123;</span><br><span class="line">    test1($array);</span><br><span class="line">&#125;</span><br><span class="line">printf(&quot;Used %s s\n&quot;, microtime(true) - $start);</span><br><span class="line"></span><br><span class="line">$start = microtime(true);</span><br><span class="line">$i     = 0;</span><br><span class="line">while ($i++ &lt; 100) &#123;</span><br><span class="line">    test($array);</span><br><span class="line">&#125;</span><br><span class="line">printf(&quot;Used %s s\n&quot;, microtime(true) - $start);</span><br></pre></td></tr></table></figure><p>鸟哥的博客里，针对这个写个一个比较简单的例子，但是我感觉用的最多的场景还是 函数套函数 的场景，所以自己修改了一下 案例</p><p>输出结果：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">引用传值共消耗： 1.7663018703461 s</span><br><span class="line">传值共消耗： 0.00076103210449219 s</span><br></pre></td></tr></table></figure><p>根据 <code>zend_assign_to_variable</code> 的函数逻辑及上面的分析，就可以看出来是因为复发了 分离 的操作，所以会 拷贝 $i 次数组，这个问题在PHP7的时候已经做了修改。</p><h1 id="PHP7"><a href="#PHP7" class="headerlink" title="PHP7"></a>PHP7</h1><h2 id="zval结构-1"><a href="#zval结构-1" class="headerlink" title="zval结构"></a>zval结构</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line">struct _zval_struct &#123;</span><br><span class="line">     union &#123;</span><br><span class="line">          zend_long         lval;             /* long value */</span><br><span class="line">          double            dval;             /* double value */</span><br><span class="line">          zend_refcounted  *counted;</span><br><span class="line">          zend_string      *str;</span><br><span class="line">          zend_array       *arr;</span><br><span class="line">          zend_object      *obj;</span><br><span class="line">          zend_resource    *res;</span><br><span class="line">          zend_reference   *ref;</span><br><span class="line">          zend_ast_ref     *ast;</span><br><span class="line">          zval             *zv;</span><br><span class="line">          void             *ptr;</span><br><span class="line">          zend_class_entry *ce;</span><br><span class="line">          zend_function    *func;</span><br><span class="line">          struct &#123;</span><br><span class="line">               uint32_t w1;</span><br><span class="line">               uint32_t w2;</span><br><span class="line">          &#125; ww;</span><br><span class="line">     &#125; value;</span><br><span class="line">    union &#123;</span><br><span class="line">        struct &#123;</span><br><span class="line">            ZEND_ENDIAN_LOHI_4(</span><br><span class="line">                zend_uchar    type,         /* active type */</span><br><span class="line">                zend_uchar    type_flags,</span><br><span class="line">                zend_uchar    const_flags,</span><br><span class="line">                zend_uchar    reserved)     /* call info for EX(This) */</span><br><span class="line">        &#125; v;</span><br><span class="line">        uint32_t type_info;</span><br><span class="line">    &#125; u1;</span><br><span class="line">    union &#123;</span><br><span class="line">        uint32_t     var_flags;</span><br><span class="line">        uint32_t     next;                 /* hash collision chain */</span><br><span class="line">        uint32_t     cache_slot;           /* literal cache slot */</span><br><span class="line">        uint32_t     lineno;               /* line number (for ast nodes) */</span><br><span class="line">        uint32_t     num_args;             /* arguments number for EX(This) */</span><br><span class="line">        uint32_t     fe_pos;               /* foreach position */</span><br><span class="line">        uint32_t     fe_iter_idx;          /* foreach iterator index */</span><br><span class="line">    &#125; u2;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>而引用计数部分保存在 <code>zend_refcounted_h</code> 的结构体中</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">typedef struct _zend_refcounted_h &#123;</span><br><span class="line">    uint32_t         refcount;          /* reference counter 32-bit */</span><br><span class="line">    union &#123;</span><br><span class="line">        struct &#123;</span><br><span class="line">            ZEND_ENDIAN_LOHI_3(</span><br><span class="line">                zend_uchar    type,</span><br><span class="line">                zend_uchar    flags,    /* used for strings &amp; objects */</span><br><span class="line">                uint16_t      gc_info)  /* keeps GC root number (or 0) and color */</span><br><span class="line">        &#125; v;</span><br><span class="line">        uint32_t type_info;</span><br><span class="line">    &#125; u;</span><br><span class="line">&#125; zend_refcounted_h;</span><br></pre></td></tr></table></figure><p>也即如图所示</p><p><img src="https://github-1253518569.cos.ap-shanghai.myqcloud.com/zval1.png" alt="https://github-1253518569.cos.ap-shanghai.myqcloud.com/zval1.png"></p><h2 id="写时改变-Change-On-Write"><a href="#写时改变-Change-On-Write" class="headerlink" title="写时改变(Change On Write)"></a>写时改变(Change On Write)</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">&lt;?php</span><br><span class="line">$val = &quot;laruence&quot;;</span><br><span class="line">$ref = &amp;$val;</span><br><span class="line">$copy = $val;</span><br></pre></td></tr></table></figure><p>以上面代码为例</p><p>当代码执行到第二行 <code>$ref = &amp;$val;</code> 的时候， 生成一个 IS_REFERNCE 类型，然后因为此时有俩个变量引用它所以zend_reference这个结构的引用计数zval.value.ref-&gt;gc.refcount为2.</p><p>当代码执行到 <code>$copy = $val;</code> 的时候， 发现 <code>$val</code> 是一个引用， 于是，直接让 <code>$copy</code> 指向的是zval.value.ref-&gt;val, 也就是字符串值为laruence的zval, 然后把zval的引用计数+1, 也就是zval.value.ref-&gt;val.value.str.gc.refcount为2. 并没有产生复制.</p><p>xdebug结果</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">$val = &apos;laruence&apos;</span><br><span class="line">$val : val: (refcount=0, is_ref=0)=&apos;laruence&apos;</span><br><span class="line">$ref = &amp;$val</span><br><span class="line">$val : val: (refcount=2, is_ref=1)=&apos;laruence&apos;</span><br><span class="line">$ref : ref: (refcount=2, is_ref=1)=&apos;laruence&apos;</span><br><span class="line">$copy = $val</span><br><span class="line">$val : val: (refcount=2, is_ref=1)=&apos;laruence&apos;</span><br><span class="line">$ref : ref: (refcount=2, is_ref=1)=&apos;laruence&apos;</span><br><span class="line">$copy : copy: (refcount=0, is_ref=0)=&apos;laruence&apos;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> PHP </category>
          
      </categories>
      
      
        <tags>
            
            <tag> PHP </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>PHP实现基于Swoole的MySQL连接池</title>
      <link href="/posts/55187/"/>
      <url>/posts/55187/</url>
      
        <content type="html"><![CDATA[<p>对于共享资源，有一个很著名的设计模式：资源池（Resource Pool）。该模式正是为了解决资源的频繁分配﹑释放所造成的问题。数据库连接池的基本思想就是为数据库连接建立一个“池”子，在使用的时候，从“池子”中获取资源，用完后将连接放回“池子”，减少了数据库连接建立与释放造成的损耗。</p><a id="more"></a><p>而对于PHP而言，每一个请求过来都是由php-fpm调起来一个cgi来处理，处理完后就会被释放，所以并没办法在代码中实现连接池的，但是由运行方式，我们可以自然而然的推想，既然php-fpm是常驻内存的，那我们将数据库连接交给php-fpm托管，也就实现了理论上的数据库连接池，而这种实现方式也就是MySQL的<strong>pconnect</strong>的实现方式，而且经测试，效果并没有显著的提升。那么，接下来便可以考虑基于<strong>Swoole</strong>的常驻内存的特性来帮忙实现了</p><h1 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h1><ol><li>首先基于Swoole的channel实现一个<strong>内存队列</strong> <strong>quene</strong>，（也可以通过php的共享内存实现，这里不讨论这种方式），用于存放MySQL连接的线程id，<strong>thread_id</strong></li><li>建立一定数量的MySQL连接存放在数组中，然后将 <strong>thread_id</strong>（mysqli::$thread_id）推进<strong>内存队列</strong> <strong>quene</strong>,</li><li>每个请求过来的时候，从<strong>quene</strong>中 pop 出一个 <strong>thread_id</strong>， 根据<strong>thread_id</strong>找到对应数组中对应的数据库连接</li><li>请求结束后，将<strong>thread_id</strong>再push进<strong>quene</strong></li></ol><h1 id="代码实现"><a href="#代码实现" class="headerlink" title="代码实现"></a>代码实现</h1><h2 id="数据库连接管理者"><a href="#数据库连接管理者" class="headerlink" title="数据库连接管理者"></a>数据库连接管理者</h2><blockquote><p>这个类是用来管理连接的，增加和删除以及获取链接使用</p></blockquote><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br></pre></td><td class="code"><pre><span class="line">class MysqlConnections &#123;</span><br><span class="line">    private $config = [</span><br><span class="line">        &apos;host&apos; =&gt; &apos;127.0.0.1&apos;,</span><br><span class="line">        &apos;username&apos; =&gt; &apos;root&apos;,</span><br><span class="line">        &apos;password&apos; =&gt; &apos;ifind@13579&apos;,</span><br><span class="line">        &apos;dbname&apos; =&gt; &apos;test&apos;,</span><br><span class="line">        &apos;charset&apos; =&gt; &apos;utf8&apos;,</span><br><span class="line">    ];</span><br><span class="line">    private $connectionsNum = 0;</span><br><span class="line"></span><br><span class="line">    private $connections = [];</span><br><span class="line">    function __construct($config = []) &#123;</span><br><span class="line">        $this-&gt;config = array_merge($this-&gt;config, $config);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    /**</span><br><span class="line">     * 增加一个mysql连接到连接池</span><br><span class="line">     */</span><br><span class="line">    public function addConnection()</span><br><span class="line">    &#123;</span><br><span class="line">        $mysql = new Mysqli($this-&gt;config[&apos;host&apos;], $this-&gt;config[&apos;username&apos;], $this-&gt;config[&apos;password&apos;], $this-&gt;config[&apos;dbname&apos;]);</span><br><span class="line">        $this-&gt;connections[$mysql-&gt;thread_id] = $mysql;</span><br><span class="line">        echo &apos;add &apos; . $mysql-&gt;thread_id . &apos; into pool &apos; . PHP_EOL;</span><br><span class="line">        $this-&gt;connectionsNum ++;</span><br><span class="line">        return $mysql-&gt;thread_id;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public function getConnection($id = 0)</span><br><span class="line">    &#123;</span><br><span class="line">        if ($id == 0) &#123;</span><br><span class="line">            $id = $this-&gt;addConnection();</span><br><span class="line">        &#125;</span><br><span class="line">        return $this-&gt;connections[$id];</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public function releaseConnection($id)</span><br><span class="line">    &#123;</span><br><span class="line">        $this-&gt;connectionsNum--;</span><br><span class="line">        unset($this-&gt;connections[$id]);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public function __get($name)</span><br><span class="line">    &#123;</span><br><span class="line">        if ($name == &apos;connectionsNum&apos;) &#123;</span><br><span class="line">            return $this-&gt;connectionsNum;</span><br><span class="line">        &#125; else &#123;</span><br><span class="line">            return null;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="内存队列"><a href="#内存队列" class="headerlink" title="内存队列"></a>内存队列</h2><blockquote><p>这里是以数据库连接属性的thread_id 组成的内存队列</p></blockquote><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><span class="line">class Quene &#123;</span><br><span class="line">    private $length; // 队长</span><br><span class="line">    private $size;</span><br><span class="line"></span><br><span class="line">    private $chan;</span><br><span class="line">    /**</span><br><span class="line">     * 构造函数</span><br><span class="line">     */</span><br><span class="line">    public function __construct($size = 64 * 1024) </span><br><span class="line">    &#123;</span><br><span class="line">        $this-&gt;chan = new \Swoole\Channel($size);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    /**</span><br><span class="line">     * 入队操作</span><br><span class="line">     * @param  [type] $id [description]</span><br><span class="line">     * @return [type]     [description]</span><br><span class="line">     */</span><br><span class="line">    public function push($id)</span><br><span class="line">    &#123;</span><br><span class="line">        $this-&gt;length ++;</span><br><span class="line">        $this-&gt;chan-&gt;push($id);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    /**</span><br><span class="line">     * 出队操作</span><br><span class="line">     * @return [type] [description]</span><br><span class="line">     */</span><br><span class="line">    public function pop()</span><br><span class="line">    &#123;</span><br><span class="line">        $this-&gt;length --;</span><br><span class="line">        $id = $this-&gt;chanpop();</span><br><span class="line">        return $id;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public function __get($name)</span><br><span class="line">    &#123;</span><br><span class="line">        if ($name == &apos;length&apos;) &#123;</span><br><span class="line">            return $this-&gt;length;</span><br><span class="line">        &#125; else &#123;</span><br><span class="line">            return null;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="数据库连接池"><a href="#数据库连接池" class="headerlink" title="数据库连接池"></a>数据库连接池</h2><blockquote><p>结合上面的连接管理者和队列，实现对连接的分发和归还</p></blockquote><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br></pre></td><td class="code"><pre><span class="line">class DbPool &#123;</span><br><span class="line">    private $max; // 最大的mysql连接数</span><br><span class="line">    private $min = 0; // 建立最小的mysql连接数</span><br><span class="line">    private $connections;</span><br><span class="line">    private $quene;</span><br><span class="line"></span><br><span class="line">    public function __construct($max, $min = 0)</span><br><span class="line">    &#123;</span><br><span class="line">        if (!empty($max)) &#123;</span><br><span class="line">            $this-&gt;max = $max;</span><br><span class="line">        &#125; else &#123;</span><br><span class="line">            throw new Exception(&apos;please set max connnections&apos;, &apos;-1&apos;);</span><br><span class="line">        &#125;</span><br><span class="line">        $this-&gt;min = $min;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public function setConnection(MysqlConnections $connections)</span><br><span class="line">    &#123;</span><br><span class="line">        $this-&gt;connections = $connections;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public function setQuene(Quene $quene)</span><br><span class="line">    &#123;</span><br><span class="line">        $this-&gt;quene = $quene;</span><br><span class="line">        $this-&gt;initQuene();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public function initQuene($min = 0, $max = 0)</span><br><span class="line">    &#123;</span><br><span class="line">        for ($i = 0; $i &lt; $this-&gt;min; $i++) &#123;</span><br><span class="line">            $this-&gt;quene-&gt;push($this-&gt;connections-&gt;addConnection());</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public function obtain()</span><br><span class="line">    &#123;</span><br><span class="line">        if ($this-&gt;connections-&gt;connectionsNum &gt;= $this-&gt;max) &#123;</span><br><span class="line">            // 超出链接最大限制，等待mysql链接释放</span><br><span class="line">            $id = !$this-&gt;quene-&gt;pop();</span><br><span class="line">            while (!$id) &#123;</span><br><span class="line">                usleep(200000);</span><br><span class="line">                $id = $this-&gt;quene-&gt;pop();</span><br><span class="line">            &#125;</span><br><span class="line">            return $this-&gt;connections-&gt;getConnection($id);</span><br><span class="line">        &#125; else &#123;</span><br><span class="line">            $id = $this-&gt;quene-&gt;pop();</span><br><span class="line">            return $this-&gt;connections-&gt;getConnection($id);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public function restitute(Mysqli $db)</span><br><span class="line">    &#123;</span><br><span class="line">        echo &apos;restitute thread_id : &apos; . $db-&gt;thread_id . PHP_EOL;</span><br><span class="line">        $this-&gt;quene-&gt;push($db-&gt;thread_id);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="Swoole-Http-Server"><a href="#Swoole-Http-Server" class="headerlink" title="Swoole Http Server"></a>Swoole Http Server</h2><blockquote><p>基于swoole开启一个http server，获取相应的数据库连接，并相应</p></blockquote><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">class SwooleServer</span><br><span class="line">&#123;</span><br><span class="line">    private $config = [</span><br><span class="line">        &apos;Connections&apos; =&gt; [</span><br><span class="line">            &apos;min&apos; =&gt; 5,</span><br><span class="line">            &apos;max&apos; =&gt; 10,</span><br><span class="line">        ],</span><br><span class="line">        &apos;Db&apos; =&gt; [</span><br><span class="line">            &apos;host&apos; =&gt; &apos;127.0.0.1&apos;,</span><br><span class="line">            &apos;username&apos; =&gt; &apos;test&apos;,</span><br><span class="line">            &apos;password&apos; =&gt; &apos;123456&apos;,</span><br><span class="line">            &apos;dbname&apos; =&gt; &apos;test&apos;,</span><br><span class="line">            &apos;charset&apos; =&gt; &apos;utf8&apos;,</span><br><span class="line">        ],</span><br><span class="line">        &apos;Swoole&apos; =&gt; [</span><br><span class="line">            &apos;enable_static_handler&apos; =&gt; true,</span><br><span class="line">            &apos;document_root&apos; =&gt; &quot;/home/lixy/basic/web/&quot;,</span><br><span class="line">            &apos;worker_num&apos; =&gt; 5,</span><br><span class="line">            &apos;task_worker_num&apos; =&gt; 5,</span><br><span class="line">            &apos;log_level&apos; =&gt; 3,</span><br><span class="line">        ],</span><br><span class="line">        &apos;Channel&apos; =&gt; [</span><br><span class="line">            &apos;size&apos; =&gt; 256 * 1024,</span><br><span class="line">        ],</span><br><span class="line">    ];</span><br><span class="line">    private $db_pool;   // mysql链接内存队列</span><br><span class="line">    public function __construct()</span><br><span class="line">    &#123;</span><br><span class="line">        $this-&gt;swoole = new \Swoole\Http\Server(&apos;0.0.0.0&apos;, 9502);</span><br><span class="line">        $this-&gt;swoole-&gt;set($this-&gt;config[&apos;Swoole&apos;]);</span><br><span class="line">        $this-&gt;swoole-&gt;on(&apos;task&apos;, [$this, &apos;task&apos;]);</span><br><span class="line">        $this-&gt;swoole-&gt;on(&apos;finish&apos;, [$this, &apos;finish&apos;]);</span><br><span class="line">        $this-&gt;swoole-&gt;on(&apos;request&apos;, [$this, &apos;request&apos;]);</span><br><span class="line">        $this-&gt;getDbPool();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public function getDbPool()</span><br><span class="line">    &#123;</span><br><span class="line">        $connections = new MysqlConnections($this-&gt;config[&apos;Db&apos;]);</span><br><span class="line">        $quene = new Quene();</span><br><span class="line">        $this-&gt;db_pool = new DbPool($this-&gt;config[&apos;Connections&apos;][&apos;max&apos;], $this-&gt;config[&apos;Connections&apos;][&apos;min&apos;]);</span><br><span class="line">        $this-&gt;db_pool-&gt;setConnection($connections);</span><br><span class="line">        $this-&gt;db_pool-&gt;setQuene($quene);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public function __call($name, $args)</span><br><span class="line">    &#123;</span><br><span class="line">        return call_user_func_array([$this-&gt;swoole, $name], $args);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    /**</span><br><span class="line">     * onrequest事件</span><br><span class="line">     * @param  [type] $request  请求对象</span><br><span class="line">     * @param  [type] $response 相应对象</span><br><span class="line">     * @return [type]</span><br><span class="line">     */</span><br><span class="line">    public function request($request, $response)</span><br><span class="line">    &#123;</span><br><span class="line">        $db = $this-&gt;db_pool-&gt;obtain();</span><br><span class="line">        echo &apos;get thread id : &apos; . $db-&gt;thread_id . PHP_EOL;</span><br><span class="line">        $sql = &apos;select * from test&apos;;</span><br><span class="line">        $result = $db-&gt;query($sql);</span><br><span class="line">        $this-&gt;db_pool-&gt;restitute($db);</span><br><span class="line">        $response-&gt;end(&apos;hello, response from swoole server&apos;);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public function task($serv, $task_id, $from_id, $data)</span><br><span class="line">    &#123;</span><br><span class="line">        echo $task_id;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public function finish($serv, $task_id, $data)</span><br><span class="line">    &#123;</span><br><span class="line">        echo $task_id;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">$swoole_index = new SwooleServer();</span><br><span class="line">$swoole_index-&gt;start();</span><br></pre></td></tr></table></figure><h1 id="测试"><a href="#测试" class="headerlink" title="测试"></a>测试</h1><blockquote><p>ab -n 10 -c 5 <a href="http://127.0.0.1:9502/" target="_blank" rel="noopener">http://127.0.0.1:9502/</a></p></blockquote><p>结果</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line">add 6879 into pool </span><br><span class="line">add 6880 into pool </span><br><span class="line">add 6881 into pool </span><br><span class="line">add 6882 into pool </span><br><span class="line">add 6883 into pool </span><br><span class="line"></span><br><span class="line">get thread id : 6879</span><br><span class="line">restitute thread_id : 6879</span><br><span class="line">get thread id : 6880</span><br><span class="line">get thread id : 6881</span><br><span class="line">restitute thread_id : 6880</span><br><span class="line">get thread id : 6882</span><br><span class="line">restitute thread_id : 6881</span><br><span class="line">restitute thread_id : 6882</span><br><span class="line">get thread id : 6883</span><br><span class="line">get thread id : 6879</span><br><span class="line">restitute thread_id : 6879</span><br><span class="line">get thread id : 6881</span><br><span class="line">get thread id : 6880</span><br><span class="line">restitute thread_id : 6881</span><br><span class="line">restitute thread_id : 6880</span><br><span class="line">restitute thread_id : 6883</span><br><span class="line">get thread id : 6882</span><br><span class="line">get thread id : 6879</span><br><span class="line">restitute thread_id : 6882</span><br><span class="line">restitute thread_id : 6879</span><br><span class="line">get thread id : 6881</span><br><span class="line">restitute thread_id : 6881</span><br></pre></td></tr></table></figure><p>完美符合预期</p>]]></content>
      
      
      <categories>
          
          <category> PHP </category>
          
      </categories>
      
      
        <tags>
            
            <tag> PHP </tag>
            
            <tag> Swoole </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>MyISAM与InnoDB性能测试对比</title>
      <link href="/posts/51443/"/>
      <url>/posts/51443/</url>
      
        <content type="html"><![CDATA[<p>MyISAM与InnoDB的优缺点在此就不再多说了，网上可以搜出一堆，而这种文章的最后一般都是推荐，读的多的使用MyISAM，写与更新多的推荐InnoDB，但是，了解过两种存储引擎之后，就会产生一种疑惑，InnoDB采用的是聚簇索引，无论是索引还是数据都是存放在内存中的，MyISAM引擎使用B+Tree作为索引结构，叶节点的data域存放的是数据记录的地址，找到了之后还要到硬盘上去获取数据，这样肯定会造成时间损耗的，所以，还是准备用实验数据来解决疑惑</p><a id="more"></a><p>我的MySQL的版本是 5.7.22， 服务器是1G1核</p><h1 id="单进程写"><a href="#单进程写" class="headerlink" title="单进程写"></a>单进程写</h1><blockquote><p>commit = 0 表示 my.cnf 中 <strong>innodb_flush_log_at_trx_commit</strong> 的属性值为0</p><p>no index  表示除主键索引为无其他索引 这里有四个索引</p><p>index 表示只有主键索引</p></blockquote><table><thead><tr><th>数据（w）</th><th>MyISAM (index)</th><th>MyISAM  (no index)</th><th>InnoDB (commit=0) (index)</th><th>InnoDB (commit=0) (no index)</th></tr></thead><tbody><tr><td>1</td><td>6.39</td><td>3.90</td><td>4.99</td><td>4.89</td></tr><tr><td>5</td><td>26.89</td><td>22.73</td><td>29.80</td><td>22.33</td></tr><tr><td>10</td><td>49.55</td><td>34.96</td><td>53.40</td><td>33.21</td></tr><tr><td>50</td><td>189.20</td><td>139.93</td><td>260.78</td><td>200.74</td></tr></tbody></table><p>综上可以看出，单进程一条一条的插入的时间，MyISAM的性能略占优势，但是并不太明显， 而无索引比有索引的又略占优势，这也是因为插入的时候同时还要注意维护索引树导致的，所以，索引虽好，可不要太贪了。</p><table><thead><tr><th>数据（w）</th><th>MyISAM (index)</th><th>MyISAM  (no index)</th><th>InnoDB (commit=0) (index)</th><th>InnoDB (commit=0) (no index)</th></tr></thead><tbody><tr><td>1</td><td>9.70</td><td>4.91</td><td>60.9</td><td>49.8</td></tr><tr><td>5</td><td>32.01</td><td>18.33</td><td>306.55</td><td>243.17</td></tr></tbody></table><p>还有10w和50w的数据就不再比较了，因为性能差距太明显了，那这里就有一个问题了， <strong>innodb_flush_log_at_trx_commit</strong>  这个参数是什么意思，为什么会有那么大的影响</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">innodb_flush_log_at_trx_commit=0 （延迟写、实时刷）：log_buffer --每隔1秒--&gt; log_file --实时--&gt; disk</span><br><span class="line">innodb_flush_log_at_trx_commit=1 （实时写、实时刷）：log_buffer --实时--&gt; log_file --实时--&gt; disk</span><br><span class="line">innodb_flush_log_at_trx_commit=2 （实时写、延迟刷）：log_buffer --实时--&gt; log_file --每隔1秒 --&gt; disk</span><br></pre></td></tr></table></figure><p>所以，这里其实是刷日志到硬盘导致的性能下降，这里还是需要注意的，性能影响还是很大的</p><h1 id="多进程写"><a href="#多进程写" class="headerlink" title="多进程写"></a>多进程写</h1><p>这里以每个进程写1w条数据为例</p><table><thead><tr><th>进程数</th><th>MyISAM(s/进程)</th><th>InnoDB(s/进程)</th></tr></thead><tbody><tr><td>20</td><td>90.00</td><td>29.66</td></tr><tr><td>50</td><td>255.89</td><td>74.52</td></tr><tr><td>100</td><td>545.385</td><td>201.94</td></tr></tbody></table><p>上面充分可以展示出来<strong>InnoDB</strong> 引擎在多进程下的优势</p><h1 id="单进程读"><a href="#单进程读" class="headerlink" title="单进程读"></a>单进程读</h1><table><thead><tr><th>总次数(w)</th><th>MyISAM(总时间 s)</th><th>InnoDB(总时间 s)</th></tr></thead><tbody><tr><td>1</td><td>67.14</td><td>77.15</td></tr><tr><td>5</td><td>110.58</td><td>104.21</td></tr><tr><td>10</td><td>136.02</td><td>146.26</td></tr></tbody></table><h1 id="多进程读"><a href="#多进程读" class="headerlink" title="多进程读"></a>多进程读</h1><p>这里以每个进程读5k条数据为例</p><table><thead><tr><th>进程数</th><th>MyISAM(s/进程)</th><th>InnoDB(s/进程)</th></tr></thead><tbody><tr><td>20</td><td>140.89</td><td>140.37</td></tr><tr><td>50</td><td>366.32</td><td>308.76</td></tr><tr><td>100</td><td>766.37</td><td>615.50</td></tr></tbody></table><p>可以看出，在单进程的读中，MyISAM战友微弱的优势，但这种微弱的优势在多进程中也荡然无存了</p><p>再考虑<strong>InnoDB</strong> 支持 <strong>事务</strong>， <strong>外键</strong>， <strong>崩溃恢复</strong> 一系列高级特性，还有什么犹豫的吗？</p>]]></content>
      
      
      <categories>
          
          <category> MySQL </category>
          
      </categories>
      
      
        <tags>
            
            <tag> MySQL </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Nginx倒腾笔记（七）：Nginx限制访问频率</title>
      <link href="/posts/34870/"/>
      <url>/posts/34870/</url>
      
        <content type="html"><![CDATA[<p>面对而已的DDOS攻击是一种很让人头疼的问题，其中CC攻击是DDOS的一种，也是一种常见的网站攻击方法，通过有限的IP不断的去请求对方服务器，造成对方服务器资源耗尽直至宕机。</p><p>而通过Nginx的<strong>HttpLimitReqModul</strong>和<strong>HttpLimitZoneModule</strong> 来限制同一IP在同一时间段内的访问次数来降低CC攻击带来的危害</p><a id="more"></a><p>下面是一种简单的频率限制在nginx里面的配置</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">http &#123;</span><br><span class="line">    limit_req_zone $binary_remote_addr zone=one:10m rate=1r/s;</span><br><span class="line"></span><br><span class="line">    ...</span><br><span class="line"></span><br><span class="line">    server &#123;</span><br><span class="line"></span><br><span class="line">        ...</span><br><span class="line"></span><br><span class="line">        location /search/ &#123;</span><br><span class="line">            limit_req zone=one burst=5;</span><br><span class="line">        &#125;</span><br></pre></td></tr></table></figure><h1 id="limit-req-zone"><a href="#limit-req-zone" class="headerlink" title="limit_req_zone"></a>limit_req_zone</h1><p>limit_req_zone的使用规则是 </p><p><strong>limit_req_zone</strong> <em>key</em> zone=<em>name</em>:<em>size</em> rate=<em>rate</em></p><p><code>limit_req_zone $binary_remote_addr zone=one:10m rate=1r/s;</code></p><p>这一段是定义了一个名为<em>one</em> 的zone空间，空间大小为10m， 以$binary_remote_addr 为key,限制平均每秒的请求为1个，1M能存储16000个状态，rate的值必须为整数</p><h1 id="limit-req"><a href="#limit-req" class="headerlink" title="limit_req"></a>limit_req</h1><p>limit_req的使用规则是</p><p><strong>limit_req</strong> zone=<em>name</em> [burst=<em>number</em>] [nodelay];</p><p><code>limit_req zone=one burst=5;</code></p><p>zone: zone是指使用我们上面定义的zone，这个很好理解</p><p>burst: burst其实是一个桶的概念，以我们的设置为例，我们设置的是1request/s，如果一次性来了3个request，nginx会在第一秒处理一个请求，另外两个请求放到这个<strong>burst</strong>桶里，然后下一秒先处理桶里的请求，后面来的请求继续放进桶里，如果桶满了，这时候的请求就会返回503了</p><p>nodelay: 如果不希望在请求受限的情况下延迟过多的请求，可以使用这个参数，同时配合burst，他会在第一秒的时候，处理限制的请求数和burst里面的请求数</p>]]></content>
      
      
      <categories>
          
          <category> Nginx </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Nginx </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>HTTP协议：HTTP1.0、HTTP1.1、HTTP2.0对比</title>
      <link href="/posts/43499/"/>
      <url>/posts/43499/</url>
      
        <content type="html"><![CDATA[<p>早在HTTP建立之初，主要就是为了将超文本标记语言(HTML)文档从Web服务器传送到客户端的浏览器。也是说对于前端来说，我们所写的HTML页面将要放在我们的web服务器上，用户端通过浏览器访问url地址来获取网页的显示内容，但是到了WEB2.0以来，我们的页面变得复杂，不仅仅单纯的是一些简单的文字和图片，同时我们的HTML页面有了CSS，Javascript，来丰富我们的页面展示，当ajax的出现，我们又多了一种向服务器端获取数据的方法，这些其实都是基于HTTP协议的。同样到了移动互联网时代，我们页面可以跑在手机端浏览器里面，但是和PC相比，手机端的网络情况更加复杂，这使得我们开始了不得不对HTTP进行深入理解并不断优化过程中。</p><a id="more"></a><p>#对比</p><table><thead><tr><th></th><th>HTTP1.0</th><th>HTTP1.1</th><th>HTTP2.0</th></tr></thead><tbody><tr><td>Host头</td><td>✗</td><td>✔</td><td>✔</td></tr><tr><td>Range头</td><td>✗</td><td>✔</td><td>✔</td></tr><tr><td>长连接</td><td>✗</td><td>✔</td><td>✔</td></tr><tr><td>request method</td><td>GET  HEAD POST</td><td>以上+ OPTIONS  PUT  DELETE TRACE CONNECT</td><td>以上全部</td></tr><tr><td>cache</td><td>Expire  Last-Modefied  Pragma</td><td>以上+ETag   Cache-Control</td><td>以上全部</td></tr><tr><td>header压缩</td><td>✗</td><td>✗</td><td>✔</td></tr><tr><td>多路复用</td><td>✗</td><td>✗</td><td>✔</td></tr><tr><td>服务器推送</td><td>✗</td><td>✗</td><td>✔</td></tr></tbody></table><h1 id="解析"><a href="#解析" class="headerlink" title="解析"></a>解析</h1><p>我们这里主要选取了几个点来进行分析</p><h2 id="Range"><a href="#Range" class="headerlink" title="Range"></a>Range</h2><p>这里的<strong>Range</strong> 和 <strong>Content-Range</strong> 是针对于HTTP1.0的宽带浪费现象而提出来的一个解决方案。</p><p>在这里，我们接触的最多的便是断点续传了， 我们在请求下载某一个较大文件的时候，秉着耐心终于等到了99%了，但是这时候却突然断网了，如果再让你等待几十分钟去等待他重新下载完成，我们估计都要爆发了，而如果客户端，知道本地已经下了99%，只去请求服务端剩余的部分，这样不仅节约了用户的时间，还解决了服务器传输多余的重复数据而导致的宽带浪费</p><h2 id="长连接"><a href="#长连接" class="headerlink" title="长连接"></a>长连接</h2><p>一个web页面上面可能包含几十个图片文件或js、css文件，在HTTP1.0的时代，规定了浏览器与服务器只能保持短暂的连接，浏览器的每个请求都要与服务器建立一个新的TCP连接，TCP的连接需要三次握手，https还需要校验证书，那么问题就暴漏出来了，这几十次图片、js、css文件其实是在同一个web页面里面的，如果我们去除多余的几十次三次握手，那么访问速度就会提升上来，HTTP1.1使用了<strong>长连接</strong>来解决这个问题，我们可以配置后台服务器的长连接的时间，超时无内容传输才会断开连接，从而，在一定时间内的浏览器的请求可以使用同一个TCP连接或者几个TCP连接，减少了握手带来的时间损耗</p><h2 id="多路复用"><a href="#多路复用" class="headerlink" title="多路复用"></a>多路复用</h2><p>既然上面解析了长连接，这里就把多路复用提上来吧。HTTP2.0使用了多路复用的技术，做到同一个连接并发处理多个请求，而且并发请求的数量比HTTP1.1大了好几个数量级。</p><p>以chrome为例，每个页面，浏览器最多允许建立6个TCP连接，发起请求-&gt;服务端处理-&gt;响应请求 这样算是完成了一个浏览器请求。但是如果一个页面同时发起几百个请求，其中前几个请求又比较耗时，则会把这6个TCP连接全部占用，同时阻塞了后面的请求，这样整体请求都会慢下来了。</p><p>HTTP2采用多路复用是指，在同一个域名下，开启一个TCP的connection，每个请求以stream的方式传输，每个stream有唯一标识，connection一旦建立，后续的请求都可以复用这个connection并且可以同时发送，server端可以根据stream的唯一标识来相应对应的请求。这样上面请求阻塞的问题就可以得到解决。</p><p>##服务器推送</p><p>意思是说，当我们对支持HTTP2.0的web server请求数据的时候，服务器会顺便把一些客户端需要的资源一起推送到客户端，免得客户端再次创建连接发送请求到服务器端获取。这种方式非常合适加载静态资源。</p><h2 id="header压缩"><a href="#header压缩" class="headerlink" title="header压缩"></a>header压缩</h2><p>我们在传输文本等静态资源的时候，一般会开启压缩，gzip等，这样会减少宽带的占用，对于一些较大的文本文件，压缩后会减少的特别明显，相应也会感觉提升了很多。而header头信息的传输却一直使用字符串来传输，HTTP2.0使用HPACK算法对header的数据进行压缩，这样数据体积小了，在网络上传输就会更快。</p><h1 id="对比"><a href="#对比" class="headerlink" title="对比"></a>对比</h1><p><a href="https://http2.akamai.com/demo" target="_blank" rel="noopener">https://http2.akamai.com/demo</a> 是Akamai公司建立的一个官方演示，我们可以很明显的看出HTTP2.0对HTTP1.1上的性能提升</p><p><img src="https://github-1253518569.cos.ap-shanghai.myqcloud.com/http_beyond_http1.png" alt="http速度对比图"></p><h1 id="全站启用HTTP2"><a href="#全站启用HTTP2" class="headerlink" title="全站启用HTTP2"></a>全站启用HTTP2</h1><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">server &#123;</span><br><span class="line">    listen 83 http2;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在你的nginx配置文件的 <code>listen</code> 后面加上 <code>http2</code> 就可以启用HTTP2.0了，请放心使用，HTTP2.0已经兼容了HTTP1.1，如果你的浏览器不支持HTTP2.0的话，服务器使用HTTP1.1的协议进行传输</p>]]></content>
      
      
      <categories>
          
          <category> HTTP </category>
          
      </categories>
      
      
        <tags>
            
            <tag> HTTP </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>PHP实现断点续传</title>
      <link href="/posts/13685/"/>
      <url>/posts/13685/</url>
      
        <content type="html"><![CDATA[<p>断点续传指的是在上传/下载时，将任务（一个文件或压缩包）人为的划分为几个部分，每一个部分采用一个线程进行上传/下载，如果碰到网络故障，可以从已经上传/下载的部分开始继续上传/下载未完成的部分，而没有必要从头开始上传/下载。可以节省时间，提高速度。</p><a id="more"></a><h1 id="实现原理"><a href="#实现原理" class="headerlink" title="实现原理"></a>实现原理</h1><p>HTTP1.1 协议（RFC2616）开始支持获取文件的部分内容，这为并行下载以及断点续传提供了技术支持。它通过在 Header 里两个参数实现的，客户端发请求时对应的是 Range ，服务器端响应时对应的是 Content-Range。</p><p><strong>Range</strong></p><p>用于请求头中，指定第一个字节的位置和最后一个字节的位置，一般格式：</p><blockquote><p>Range:(unit=first byte pos)-[last byte pos]</p></blockquote><p>Range 头部的格式有以下几种情况：</p><blockquote><p>Range: bytes=0-499 表示第 0-499 字节范围的内容<br>Range: bytes=500-999 表示第 500-999 字节范围的内容<br>Range: bytes=-500 表示最后 500 字节的内容<br>Range: bytes=500- 表示从第 500 字节开始到文件结束部分的内容<br>Range: bytes=0-0,-1 表示第一个和最后一个字节<br>Range: bytes=500-600,601-999 同时指定几个范围</p></blockquote><p><strong>Content-Range</strong></p><p>用于响应头中，在发出带 Range 的请求后，服务器会在 Content-Range 头部返回当前接受的范围和文件总大小。一般格式：</p><blockquote><p>Content-Range: bytes (unit first byte pos) - [last byte pos]/[entity legth]</p></blockquote><p>例如：</p><blockquote><p>Content-Range: bytes 0-499/22400</p></blockquote><p>0－499 是指当前发送的数据的范围，而 22400 则是文件的总大小。</p><p>而在响应完成后，返回的响应头内容也不同：</p><blockquote><p>HTTP/1.1 200 Ok（不使用断点续传方式）<br>HTTP/1.1 206 Partial Content（使用断点续传方式）</p></blockquote><h1 id="增强校验"><a href="#增强校验" class="headerlink" title="增强校验"></a>增强校验</h1><p>在实际场景中，会出现一种情况，即在终端发起续传请求时，URL 对应的文件内容在服务器端已经发生变化，此时续传的数据肯定是错误的。如何解决这个问题了？显然此时需要有一个标识文件唯一性的方法。</p><p>在 RFC2616 中也有相应的定义，比如实现 Last-Modified 来标识文件的最后修改时间，这样即可判断出续传文件时是否已经发生过改动。同时 FC2616 中还定义有一个 ETag 的头，可以使用 ETag 头来放置文件的唯一标识。</p><h2 id="Last-Modified"><a href="#Last-Modified" class="headerlink" title="Last-Modified"></a>Last-Modified</h2><p>If-Modified-Since，和 Last-Modified 一样都是用于记录页面最后修改时间的 HTTP 头信息，只是 Last-Modified 是由服务器往客户端发送的 HTTP 头，而 If-Modified-Since 则是由客户端往服务器发送的头，可以看到，再次请求本地存在的 cache 页面时，客户端会通过 If-Modified-Since 头将先前服务器端发过来的 Last-Modified 最后修改时间戳发送回去，这是为了让服务器端进行验证，通过这个时间戳判断客户端的页面是否是最新的，如果不是最新的，则返回新的内容，如果是最新的，则返回 304 告诉客户端其本地 cache 的页面是最新的，于是客户端就可以直接从本地加载页面了，这样在网络上传输的数据就会大大减少，同时也减轻了服务器的负担。</p><h2 id="Etag"><a href="#Etag" class="headerlink" title="Etag"></a>Etag</h2><p>Etag（Entity Tags）主要为了解决 Last-Modified 无法解决的一些问题。</p><ol><li>一些文件也许会周期性的更改，但是内容并不改变（仅改变修改时间），这时候我们并不希望客户端认为这个文件被修改了，而重新 GET。</li><li>某些文件修改非常频繁，例如：在秒以下的时间内进行修改（1s 内修改了 N 次），If-Modified-Since 能检查到的粒度是 s 级的，这种修改无法判断（或者说 UNIX 记录 MTIME 只能精确到秒）。</li><li>某些服务器不能精确的得到文件的最后修改时间。</li></ol><p>为此，HTTP/1.1 引入了 Etag。Etag 仅仅是一个和文件相关的标记，可以是一个版本标记，例如：v1.0.0；或者说 “627-4d648041f6b80” 这么一串看起来很神秘的编码。但是 HTTP/1.1 标准并没有规定 Etag 的内容是什么或者说要怎么实现，唯一规定的是 Etag 需要放在 “” 内。</p><h2 id="If-Range"><a href="#If-Range" class="headerlink" title="If-Range"></a>If-Range</h2><p>用于判断实体是否发生改变，如果实体未改变，服务器发送客户端丢失的部分，否则发送整个实体。一般格式：</p><blockquote><p>If-Range: Etag | HTTP-Date</p></blockquote><p>也就是说，If-Range 可以使用 Etag 或者 Last-Modified 返回的值。当没有 ETage 却有 Last-modified 时，可以把 Last-modified 作为 If-Range 字段的值。</p><p>例如：</p><blockquote><p>If-Range: “627-4d648041f6b80”<br>If-Range: Fri, 22 Feb 2013 03:45:02 GMT</p></blockquote><p>If-Range 必须与 Range 配套使用。如果请求报文中没有 Range，那么 If-Range 就会被忽略。如果服务器不支持 If-Range，那么 Range 也会被忽略。</p><p>如果请求报文中的 Etag 与服务器目标内容的 Etag 相等，即没有发生变化，那么应答报文的状态码为 206。如果服务器目标内容发生了变化，那么应答报文的状态码为 200。</p><p>用于校验的其他 HTTP 头信息：If-Match/If-None-Match、If-Modified-Since/If-Unmodified-Since。</p><h2 id="工作原理"><a href="#工作原理" class="headerlink" title="工作原理"></a>工作原理</h2><p>Etag 由服务器端生成，客户端通过 If-Range 条件判断请求来验证资源是否修改。请求一个文件的流程如下：</p><p>第一次请求：</p><ol><li>客户端发起 HTTP GET 请求一个文件。</li><li>服务器处理请求，返回文件内容以及相应的 Header，其中包括 Etag（例如：627-4d648041f6b80）（假设服务器支持 Etag 生成并已开启了 Etag）状态码为 200。</li></ol><p>第二次请求（断点续传）：</p><ol><li>客户端发起 HTTP GET 请求一个文件，同时发送 If-Range（该头的内容就是第一次请求时服务器返回的 Etag：627-4d648041f6b80）。</li><li>服务器判断接收到的 Etag 和计算出来的 Etag 是否匹配，如果匹配，返回range返回的内容，响应的状态码为 206；否则，状态码为 200。</li></ol><h1 id="PHP实现"><a href="#PHP实现" class="headerlink" title="PHP实现"></a>PHP实现</h1><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line">$filename = &apos;1.txt&apos;;</span><br><span class="line">$file = fopen($filename, &apos;r&apos;);</span><br><span class="line">$output = fopen(&apos;php://stdout&apos;, &apos;w&apos;);</span><br><span class="line">$size = filesize($filename);</span><br><span class="line"></span><br><span class="line">if (isset($_SERVER[&apos;HTTP_RANGE&apos;])) &#123;</span><br><span class="line">    // 断点续传，获取续传的开头和结尾</span><br><span class="line">    $range = str_replace(&apos;bytes=&apos;, &apos;&apos;, $_SERVER[&apos;HTTP_RANGE&apos;]);</span><br><span class="line">    list($start, $end) = explode(&apos;-&apos;, $range);</span><br><span class="line">    $start = empty($start) ? 0 : $start;</span><br><span class="line">    $end = empty($end) ? ($size - 1) : $end;</span><br><span class="line">    $length = $end - $start + 1;</span><br><span class="line">    if ($length &gt;= 0) &#123;</span><br><span class="line">        // 返回断点续传code及相关头信息</span><br><span class="line">        header(&apos;HTTP/1.1 206 Partial Content&apos;);</span><br><span class="line">        header(&apos;Accept-Ranges: bytes&apos;);</span><br><span class="line">        header(&apos;Last-Modified: &apos;.gmdate(&apos;D, d M Y 01:01:01&apos;, filemtime($filename)).&apos; GMT&apos;);</span><br><span class="line">        header(&apos;Etags: &apos; . fileinode($filename));</span><br><span class="line">        header(&apos;Content-Length:&apos; . $length);</span><br><span class="line">        header(&apos;Content-Range: bytes &apos; . $length . &apos;/&apos; . $size);</span><br><span class="line">        // 偏移文件指针读取固定长度返回</span><br><span class="line">        fseek($file, $start);</span><br><span class="line">        echo fread($file, $length);</span><br><span class="line">    &#125;</span><br><span class="line">&#125; else &#123;</span><br><span class="line">    // 非断点续传</span><br><span class="line">    header(&apos;cache-control:public&apos;);</span><br><span class="line">    header(&apos;content-type:application/octet-stream&apos;);</span><br><span class="line">    header(&apos;Content-Length: &apos; . $size);</span><br><span class="line">    header(&apos;Etags: &apos; . fileinode($filename));</span><br><span class="line">    header(&apos;Last-Modified: &apos;.gmdate(&apos;D, d M Y 01:01:01&apos;, filemtime($filename)).&apos; GMT&apos;);</span><br><span class="line">    header(&apos;content-disposition:attachment; filename=&apos; . $filename);</span><br><span class="line">    echo fread($file, $size);</span><br><span class="line">&#125;</span><br><span class="line">fclose($file);</span><br><span class="line">fclose($output);</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> PHP </category>
          
          <category> HTTP </category>
          
      </categories>
      
      
        <tags>
            
            <tag> PHP </tag>
            
            <tag> HTTP </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>免费SSL证书制作-Lets Encrypt</title>
      <link href="/posts/28158/"/>
      <url>/posts/28158/</url>
      
        <content type="html"><![CDATA[<p>腾讯云一年的免费SSL证书到期了，在老大的推荐下看了一下<code>Let&#39;s Encrypt</code> 家的免费证书，虽然只有三个月，但是支持免费续期，而且支持通配符证书，这倒是很大的福利了</p><a id="more"></a><p>首先声明，我的系统是<code>CentOS7</code> ，系统不一致，可自行Google其他或直接官网教程<a href="https://certbot.eff.org/lets-encrypt/centosrhel7-nginx" target="_blank" rel="noopener">https://certbot.eff.org/lets-encrypt/centosrhel7-nginx</a></p><h1 id="下载certbot"><a href="#下载certbot" class="headerlink" title="下载certbot"></a>下载certbot</h1><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">$ wget https://dl.eff.org/certbot-auto</span><br><span class="line">$ chmod +x certbot-auto</span><br></pre></td></tr></table></figure><h1 id="制作通配符证书"><a href="#制作通配符证书" class="headerlink" title="制作通配符证书"></a>制作通配符证书</h1><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ ./certbot-auto certonly  -d &quot;*.example.com&quot; -d &quot;example.com&quot;  --manual --preferred-challenges dns-01  --server https://acme-v02.api.letsencrypt.org/directory</span><br></pre></td></tr></table></figure><p>这里会自动运行yum安装必要的包，然后会提示如下</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">Please choose an account</span><br><span class="line">- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -</span><br><span class="line">1: dev_test@2016-04-18T23:21:19Z (911e)</span><br><span class="line">2: ip-10-164-131-233.ap-southeast-1.compute.internal@2016-06-13T11:02:16Z (5c1b)</span><br><span class="line">- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -</span><br><span class="line">Select the appropriate number [1-2] then [enter] (press &apos;c&apos; to cancel): 1</span><br><span class="line">Obtaining a new certificate</span><br><span class="line">Performing the following challenges:</span><br><span class="line">dns-01 challenge for example.com</span><br><span class="line">dns-01 challenge for example.com</span><br><span class="line"></span><br><span class="line">- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -</span><br><span class="line">NOTE: The IP of this machine will be publicly logged as having requested this</span><br><span class="line">certificate. If you&apos;re running certbot in manual mode on a machine that is not</span><br><span class="line">your server, please ensure you&apos;re okay with that.</span><br><span class="line"></span><br><span class="line">Are you OK with your IP being logged?</span><br><span class="line">- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -</span><br><span class="line">(Y)es/(N)o: Y</span><br></pre></td></tr></table></figure><p>注意这里</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">Please deploy a DNS TXT record under the name</span><br><span class="line">_acme-challenge.example.com with the following value:</span><br><span class="line"></span><br><span class="line">e35fqmCZcB8L56ID4801hlA3aLx3viXtZo1yA3WVSmg</span><br><span class="line"></span><br><span class="line">Before continuing, verify the record is deployed.</span><br><span class="line">- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -</span><br><span class="line">Press Enter to Continue</span><br></pre></td></tr></table></figure><p>需要在后台域名解析之后再按Enter</p><p>制作完成后，将制作后的证书拿过用即可</p><p>配置如下</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">ssl_certificate cert/fullchain1.pem;</span><br><span class="line">ssl_certificate_key cert/privkey1.pem;</span><br><span class="line">ssl_trusted_certificate cert/chain1.pem;</span><br></pre></td></tr></table></figure><p>重启后就能看到HTTPS的安全绿色小球了</p><h1 id="续期"><a href="#续期" class="headerlink" title="续期"></a>续期</h1><p>上面提到了，这个证书有效期只有三个月，所以需要定时重新生成新的证书，然后完成后重启nginx</p><p>完整命令：<code>certbot-auto renew [--cert-name CERTNAME] [options]</code><br>可选参数：</p><ul><li><code>--cert-name CERTNAME</code>：指定要更新的证书。Certbot 用这个名称来管理证书文件。名称不影响证书内容。可以用 <code>certbot certificates</code> 命令查看证书名。</li><li><code>--dry-run</code>：用于测试，只获取测试证书，不保存至磁盘。只有 certonly 和 renew 两个子命令可以用这个参数。仍然会会改写 Apache 或 Nginx 服务器的配置文件并重启服务器。仍然会调用 <code>--pre-hook</code> 和 <code>--post-hook</code> 命令（只要定义过）。只是不再调用 <code>--deploy-hook</code> 命令。</li><li><code>--force-renewal, --renew-by-default</code>：强制更新域名的证书，即使离过期时间还远得很。</li><li><code>--allow-subset-of-names</code>：在域名所有权认证时，即使认证失败，也产生证书。在更新多个域名时有效，因为有可能部分域名不再指向当前主机。注意：不能和参数 <code>--csr</code> 同时使用。</li><li><code>-q, --quiet</code>：静默执行。</li><li><code>--debug-challenges</code>：调试模式，提交至 CA 前需要用户确认。</li><li><code>--preferred-challenges</code>：验证域名所有权的方式，”dns” 或 “tls-sni-01,http,dns” 等。每个服务器插件支持有限种类的方式。</li><li><code>--pre-hook PRE_HOOK</code>：在获取证书前要执行的 shell 命令。比如暂时关闭服务器软件以防止可能的冲突。只有在自动获取/更新证书时才会执行。如果更新多个证书时，只执行第一个命令。</li><li><code>--post-hook POST_HOOK</code>：在获取证书后要执行的 shell 命令。比如<strong>部署新证书，或重启服务器软件。</strong>如果更新多个证书时，只执行第一个命令。</li><li><code>--deploy-hook DEPLOY_HOOK</code>：每个有效的认证都会触发一次的 shell 命令。对这个命令，shell 变量 <code>$RENEWED_LINEAGE</code> 表示包含域名证书和私钥的配置目录，比如 <code>/etc/letsencrypt/live/example.com</code>。<code>$RENEWED_DOMAINS</code> 表示空格分隔的刚更新的域名列表，比如 <code>example.com www.example.com</code>。</li><li><code>--disable-hook-validation</code>：验证 <code>--pre-hook/--post-hook/--deploy-hook</code> 的 shell 命令是否有效，提前发现错误。</li><li><code>--no-directory-hooks</code>：更新证书时不执行 hook 目录中的命令。</li></ul><p>写个脚本加入到定时任务里面即可</p>]]></content>
      
      
      <categories>
          
          <category> SSL </category>
          
      </categories>
      
      
        <tags>
            
            <tag> SSL </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>PHP性能分析工具xhgui+tideways实践</title>
      <link href="/posts/7748/"/>
      <url>/posts/7748/</url>
      
        <content type="html"><![CDATA[<p>自从线上接口报内存溢出的问题后，就一直想搭建一个性能分析的平台，但后来一直没有时间，知道后来出现了接口调用时间过长，才将这个任务提上议程。</p><p>我同事先前所在的部门使用了<code>xhprof</code>  + <code>xhgui</code> 的处理方式，但是研究后发现 <code>xhprof</code> 只支持到php5.6，无奈放弃了，同时，虽然 <code>tideways</code> 自己也提供了UI，但是炫酷的都是要收费的，综合考虑后，选用了 <code>tideways</code> + <code>xhgui</code>  的解决方案</p><a id="more"></a><h1 id="安装Tideways"><a href="#安装Tideways" class="headerlink" title="安装Tideways"></a>安装Tideways</h1><h2 id="安装PHP及扩展"><a href="#安装PHP及扩展" class="headerlink" title="安装PHP及扩展"></a>安装PHP及扩展</h2><p>在<code>https://webtatic.com/</code> 有每个版本的php的源，这里就简单过一下</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">yum install epel-release</span><br><span class="line">rpm -Uvh https://mirror.webtatic.com/yum/el7/webtatic-release.rpm</span><br><span class="line">yum install php72w* --skip-broken</span><br></pre></td></tr></table></figure><h2 id="安装Tideways-1"><a href="#安装Tideways-1" class="headerlink" title="安装Tideways"></a>安装Tideways</h2><p>我这里存放源码的目录是 <code>/data/local/</code> 下，目录是不会产生任何影响的，phpize编译完扩展后会自动拷贝到php的modules对应的目录的， 拷贝命令请去除注释</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">git clone https://github.com/tideways/php-xhprof-extension.git   // 克隆下git文件</span><br><span class="line">cd php-xhprof-extension </span><br><span class="line">phpize  // 生成configure文件</span><br><span class="line">./configure</span><br><span class="line">make &amp;&amp; make install  // 安装</span><br><span class="line"></span><br><span class="line">// 开启php扩展</span><br><span class="line">echo &apos;</span><br><span class="line">; enable tideways_xhprof</span><br><span class="line">extension=tideways_xhprof.so</span><br><span class="line">tideways.auto_prepend_library=0&apos; &gt; /etc/php.d/tideways_xhprof.ini</span><br><span class="line"></span><br><span class="line">// 重启php-fpm</span><br><span class="line">service php-fpm restart</span><br></pre></td></tr></table></figure><h1 id="安装xhgui"><a href="#安装xhgui" class="headerlink" title="安装xhgui"></a>安装xhgui</h1><p>这个项目放到一个web可访问的路径，这个最终是通过浏览器展示的</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">git clone https://github.com/laynefyc/xhgui-branch.git // 汉化版</span><br><span class="line">// git clone https://github.com/perftools/xhgui.git  // 原版</span><br><span class="line">mv xhgui-branch xhgui</span><br><span class="line">cd xhgui</span><br><span class="line">chmod 777 cache // 把cache目录给与代码可读写的权限</span><br><span class="line">php install.php  // 安装xhgui</span><br></pre></td></tr></table></figure><h1 id="安装MongoDB"><a href="#安装MongoDB" class="headerlink" title="安装MongoDB"></a>安装MongoDB</h1><h2 id="安装MongoDB-1"><a href="#安装MongoDB-1" class="headerlink" title="安装MongoDB"></a>安装MongoDB</h2><p>创建 <code>/etc/yum.repos.d/mongo.repo</code> 文件， 内容如下</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">[mongodb-org-4.0]</span><br><span class="line">name=MongoDB Repository</span><br><span class="line">baseurl=https://repo.mongodb.org/yum/redhat/$releasever/mongodb-org/4.0/x86_64/</span><br><span class="line">gpgcheck=1</span><br><span class="line">enabled=1</span><br><span class="line">gpgkey=https://www.mongodb.org/static/pgp/server-4.0.asc</span><br></pre></td></tr></table></figure><p>使用yum安装</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">yum install -y mongodb-org</span><br></pre></td></tr></table></figure><p>启动</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">service mongod start</span><br></pre></td></tr></table></figure><h2 id="添加索引"><a href="#添加索引" class="headerlink" title="添加索引"></a>添加索引</h2><p>tideways会将结果集存放在MongoDB中，当然是可以选择的，权衡一下，我们这里使用MongoDB</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">mongo</span><br><span class="line">&gt; use xhprof</span><br><span class="line">&gt; db.results.ensureIndex( &#123; &apos;meta.SERVER.REQUEST_TIME&apos; : -1 &#125; )</span><br><span class="line">&gt; db.results.ensureIndex( &#123; &apos;profile.main().wt&apos; : -1 &#125; )</span><br><span class="line">&gt; db.results.ensureIndex( &#123; &apos;profile.main().mu&apos; : -1 &#125; )</span><br><span class="line">&gt; db.results.ensureIndex( &#123; &apos;profile.main().cpu&apos; : -1 &#125; )</span><br><span class="line">&gt; db.results.ensureIndex( &#123; &apos;meta.url&apos; : 1 &#125; )</span><br><span class="line">&gt; db.results.ensureIndex( &#123; &apos;meta.simple_url&apos; : 1 &#125; )</span><br></pre></td></tr></table></figure><h1 id="整合Tideways和Xhgui到项目"><a href="#整合Tideways和Xhgui到项目" class="headerlink" title="整合Tideways和Xhgui到项目"></a>整合Tideways和Xhgui到项目</h1><h2 id="整合代码"><a href="#整合代码" class="headerlink" title="整合代码"></a>整合代码</h2><p>汉化版xhgui的作者是建议如下使用</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">server &#123;</span><br><span class="line">  listen 80;</span><br><span class="line">  server_name site.localhost;</span><br><span class="line">  root /Users/markstory/Sites/awesome-thing/app/webroot/;  // 汉化xhgui作者的目录，仅拷贝</span><br><span class="line">  fastcgi_param PHP_VALUE &quot;auto_prepend_file=/Users/markstory/Sites/xhgui/external/header.php&quot;; // 汉化xhgui作者的目录，仅拷贝</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这里是你的需要做性能监控的web服务的nginx的配置</p><p>但是，我在这样使用的时候，php-fpm在我调用的接口的时候就会自动挂掉，然后看了一下文件 <code>xhgui/external/header.php</code> ， 在这个里面，作者注册了<code>register_shutdown_function</code> 函数，我使用的框架是Yii2，其次，里面还会做判断各种扩展及存储方案，这个对于我已经确定了方案的用户来说，这种判断是没用的，相对还要消耗性能，所以这里根据header.php的逻辑，直接写入代码</p><p>在beforeAction中加入 </p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line">private function startXhprof()</span><br><span class="line">&#123;</span><br><span class="line">    $dir = &apos;/data/www/html/xhgui&apos;;</span><br><span class="line">    // Use the callbacks defined in the configuration file</span><br><span class="line">    // to determine whether or not XHgui should enable profiling.</span><br><span class="line">    //</span><br><span class="line">    // Only load the config class so we don&apos;t pollute the host application&apos;s</span><br><span class="line">    // autoloaders.</span><br><span class="line">    require_once $dir . &apos;/src/Xhgui/Config.php&apos;;</span><br><span class="line">    \Xhgui_Config::load($dir . &apos;/config/config.default.php&apos;);</span><br><span class="line">    if (file_exists($dir . &apos;/config/config.php&apos;)) &#123;</span><br><span class="line">        \Xhgui_Config::load($dir . &apos;/config/config.php&apos;);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    $filterPath = \Xhgui_Config::read(&apos;profiler.filter_path&apos;);</span><br><span class="line">    if(is_array($filterPath)&amp;&amp;in_array($_SERVER[&apos;DOCUMENT_ROOT&apos;],$filterPath))&#123;</span><br><span class="line">        return;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    if (!isset($_SERVER[&apos;REQUEST_TIME_FLOAT&apos;])) &#123;</span><br><span class="line">        $_SERVER[&apos;REQUEST_TIME_FLOAT&apos;] = microtime(true);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    tideways_xhprof_enable(TIDEWAYS_XHPROF_FLAGS_MEMORY | TIDEWAYS_XHPROF_FLAGS_MEMORY_MU | TIDEWAYS_XHPROF_FLAGS_MEMORY_PMU | TIDEWAYS_XHPROF_FLAGS_CPU);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">public function beforeAction($action)</span><br><span class="line">&#123;</span><br><span class="line">  $this-&gt;startXhprof();</span><br><span class="line">  return parent::beforeAction($action);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在 <code>afterAction</code> 中获取分析数据并存入MongoDB</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br></pre></td><td class="code"><pre><span class="line">private function stopXhprof()</span><br><span class="line">&#123;</span><br><span class="line">    $data[&apos;profile&apos;] = tideways_xhprof_disable();</span><br><span class="line">    </span><br><span class="line">    // ignore_user_abort(true) allows your PHP script to continue executing, even if the user has terminated their request.</span><br><span class="line">    // Further Reading: http://blog.preinheimer.com/index.php?/archives/248-When-does-a-user-abort.html</span><br><span class="line">    // flush() asks PHP to send any data remaining in the output buffers. This is normally done when the script completes, but</span><br><span class="line">    // since we&apos;re delaying that a bit by dealing with the xhprof stuff, we&apos;ll do it now to avoid making the user wait.</span><br><span class="line">    ignore_user_abort(true);</span><br><span class="line">    flush();</span><br><span class="line">    </span><br><span class="line">    if (!defined(&apos;XHGUI_ROOT_DIR&apos;)) &#123;</span><br><span class="line">        require &apos;/data/www/html/xhgui/src/bootstrap.php&apos;;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    $uri = array_key_exists(&apos;REQUEST_URI&apos;, $_SERVER)</span><br><span class="line">        ? $_SERVER[&apos;REQUEST_URI&apos;]</span><br><span class="line">        : null;</span><br><span class="line">    if (empty($uri) &amp;&amp; isset($_SERVER[&apos;argv&apos;])) &#123;</span><br><span class="line">        $cmd = basename($_SERVER[&apos;argv&apos;][0]);</span><br><span class="line">        $uri = $cmd . &apos; &apos; . implode(&apos; &apos;, array_slice($_SERVER[&apos;argv&apos;], 1));</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    $time = array_key_exists(&apos;REQUEST_TIME&apos;, $_SERVER)</span><br><span class="line">        ? $_SERVER[&apos;REQUEST_TIME&apos;]</span><br><span class="line">        : time();</span><br><span class="line">    $requestTimeFloat = explode(&apos;.&apos;, $_SERVER[&apos;REQUEST_TIME_FLOAT&apos;]);</span><br><span class="line">    if (!isset($requestTimeFloat[1])) &#123;</span><br><span class="line">        $requestTimeFloat[1] = 0;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    $requestTs = new \MongoDate($time);</span><br><span class="line">    $requestTsMicro = new \MongoDate($requestTimeFloat[0], $requestTimeFloat[1]);</span><br><span class="line"></span><br><span class="line">    $data[&apos;meta&apos;] = array(</span><br><span class="line">        &apos;url&apos; =&gt; $uri,</span><br><span class="line">        &apos;SERVER&apos; =&gt; $_SERVER,</span><br><span class="line">        &apos;get&apos; =&gt; $_GET,</span><br><span class="line">        &apos;env&apos; =&gt; $_ENV,</span><br><span class="line">        &apos;simple_url&apos; =&gt; \Xhgui_Util::simpleUrl($uri),</span><br><span class="line">        &apos;request_ts&apos; =&gt; $requestTs,</span><br><span class="line">        &apos;request_ts_micro&apos; =&gt; $requestTsMicro,</span><br><span class="line">        &apos;request_date&apos; =&gt; date(&apos;Y-m-d&apos;, $time),</span><br><span class="line">    );</span><br><span class="line"></span><br><span class="line">    try &#123;</span><br><span class="line">        $config = \Xhgui_Config::all();</span><br><span class="line">        $config += array(&apos;db.options&apos; =&gt; array());</span><br><span class="line">        $saver = \Xhgui_Saver::factory($config);</span><br><span class="line">        $saver-&gt;save($data);</span><br><span class="line">    &#125; catch (\Exception $e) &#123;</span><br><span class="line">        error_log(&apos;xhgui - &apos; . $e-&gt;getMessage());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">public function afterAction($action, $result)</span><br><span class="line">&#123;</span><br><span class="line">    $this-&gt;stopXhprof();</span><br><span class="line">    return parent::afterAction($action, $result);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="整理nginx"><a href="#整理nginx" class="headerlink" title="整理nginx"></a>整理nginx</h2><p>我们需要添加一个server，指向<code>xhgui/webroot/</code> 目录，用于展示</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">server &#123;</span><br><span class="line">    listen       80;</span><br><span class="line">    server_name  xx.xxx.com;</span><br><span class="line">    root  /data/www/html/xhgui/webroot;   //指向自身的目录</span><br><span class="line"></span><br><span class="line">    location / &#123;</span><br><span class="line">        index  index.php;</span><br><span class="line">        if (!-e $request_filename) &#123;</span><br><span class="line">            rewrite . /index.php last;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"># 下面这段可根据自身配置的php解析进行相应的修改</span><br><span class="line">    location ~ \.php$ &#123;</span><br><span class="line">        fastcgi_pass   127.0.0.1:9000;</span><br><span class="line">        fastcgi_index  index.php;</span><br><span class="line">        fastcgi_param SCRIPT_FILENAME $document_root$fastcgi_script_name;</span><br><span class="line">        include        fastcgi_params;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>到此为止，访问配置的域名就可以看到性能分析平台了</p><h1 id="异常"><a href="#异常" class="headerlink" title="异常"></a>异常</h1><p>有可能你会遇到如下的问题</p><p><img src="http://github-1253518569.cossh.myqcloud.com/mongo-exception.png" alt="mongo异常"></p><p>修改 <code>/path/to/xhgui/src/Xhgui/Profiles.php</code> 的<strong>aggregate</strong> 的传参，约172行</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line">137         $results = $this-&gt;_collection-&gt;aggregate(array(</span><br><span class="line">138             array(&apos;$match&apos; =&gt; $match),</span><br><span class="line">139             array(</span><br><span class="line">140                 &apos;$project&apos; =&gt; array(</span><br><span class="line">141                     &apos;date&apos; =&gt; $col,</span><br><span class="line">142                     &apos;profile.main()&apos; =&gt; 1</span><br><span class="line">143                 )</span><br><span class="line">144             ),</span><br><span class="line">145             array(</span><br><span class="line">146                 &apos;$group&apos; =&gt; array(</span><br><span class="line">147                     &apos;_id&apos; =&gt; &apos;$date&apos;,</span><br><span class="line">148                     &apos;row_count&apos; =&gt; array(&apos;$sum&apos; =&gt; 1),</span><br><span class="line">149                     &apos;wall_times&apos; =&gt; array(&apos;$push&apos; =&gt; &apos;$profile.main().wt&apos;),</span><br><span class="line">150                     &apos;cpu_times&apos; =&gt; array(&apos;$push&apos; =&gt; &apos;$profile.main().cpu&apos;),</span><br><span class="line">151                     &apos;mu_times&apos; =&gt; array(&apos;$push&apos; =&gt; &apos;$profile.main().mu&apos;),</span><br><span class="line">152                     &apos;pmu_times&apos; =&gt; array(&apos;$push&apos; =&gt; &apos;$profile.main().pmu&apos;),</span><br><span class="line">153                 )</span><br><span class="line">154             ),</span><br><span class="line">155             array(</span><br><span class="line">156                 &apos;$project&apos; =&gt; array(</span><br><span class="line">157                     &apos;date&apos; =&gt; &apos;$date&apos;,</span><br><span class="line">158                     &apos;row_count&apos; =&gt; &apos;$row_count&apos;,</span><br><span class="line">159                     &apos;raw_index&apos; =&gt; array(</span><br><span class="line">160                         &apos;$multiply&apos; =&gt; array(</span><br><span class="line">161                             &apos;$row_count&apos;,</span><br><span class="line">162                             $percentile / 100</span><br><span class="line">163                         )</span><br><span class="line">164                     ),</span><br><span class="line">165                     &apos;wall_times&apos; =&gt; &apos;$wall_times&apos;,</span><br><span class="line">166                     &apos;cpu_times&apos; =&gt; &apos;$cpu_times&apos;,</span><br><span class="line">167                     &apos;mu_times&apos; =&gt; &apos;$mu_times&apos;,</span><br><span class="line">168                     &apos;pmu_times&apos; =&gt; &apos;$pmu_times&apos;,</span><br><span class="line">169                 )</span><br><span class="line">170             ),</span><br><span class="line">171             array(&apos;$sort&apos; =&gt; array(&apos;_id&apos; =&gt; 1)),</span><br><span class="line">172         )</span><br><span class="line">173,array(&apos;cursor&apos; =&gt; array(&apos;batchSize&apos; =&gt; 0)));</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> PHP </category>
          
      </categories>
      
      
        <tags>
            
            <tag> PHP </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>git merge和git merge --no-ff的区别</title>
      <link href="/posts/132/"/>
      <url>/posts/132/</url>
      
        <content type="html"><![CDATA[<p>在很多介绍GItFlow工作流的文章里面，都会推荐在合并分支的时候加上<code>--no-ff</code>参数， 而我们在合并的时候，有时git也会提示 使用了 <strong>fast-forward</strong>， 这里我将介绍一下<code>merge</code>的三种状态及 <code>git merge</code> 和 <code>git merge --no-ff</code> 的区别</p><a id="more"></a><p>Git merge的时候，有几种合并方式可以选择</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">--ff</span><br><span class="line">When the merge resolves as a fast-forward, only update the branch pointer, without creating a merge commit. This is the default behavior.</span><br><span class="line"></span><br><span class="line">--no-ff</span><br><span class="line">Create a merge commit even when the merge resolves as a fast-forward. This is the default behaviour when merging an annotated (and possibly signed) tag.</span><br><span class="line"></span><br><span class="line">--squash</span><br><span class="line">--no-squash</span><br><span class="line">Produce the working tree and index state as if a real merge happened (except for the merge information), but do not actually make a commit, move the HEAD, or record $GIT_DIR/MERGE_HEAD (to cause the next git commit command to create a merge commit). This allows you to create a single commit on top of the current branch whose effect is the same as merging another branch (or more in case of an octopus).</span><br><span class="line"></span><br><span class="line">With --no-squash perform the merge and commit the result. This option can be used to override --squash.</span><br></pre></td></tr></table></figure><p>而我们平常什么都不加的时候，则使用默认的 <code>--ff</code> ， 即 <strong>fast-forward</strong> 方式</p><p>看过官方注释后，我们用一张图来简单描画一下相应的行为</p><p><img src="https://github-1253518569.cos.ap-shanghai.myqcloud.com/2018-09-18_200521.png" alt="merge"></p><ol><li><p>fast-forward</p><p><strong>Git 合并两个分支时，如果顺着一个分支走下去可以到达另一个分支的话，那么 Git 在合并两者时，只会简单地把指针右移，叫做“快进”（fast-forward）不过这种情况如果删除分支，则会丢失merge分支信息。</strong></p></li><li><p>–squash</p><p><strong>把一些不必要commit进行压缩，比如说，你的feature在开发的时候写的commit很乱，那么我们合并的时候不希望把这些历史commit带过来，于是使用–squash进行合并，此时文件已经同合并后一样了，但不移动HEAD，不提交。需要进行一次额外的commit来“总结”一下，然后完成最终的合并。</strong></p></li><li><p>–no-ff</p><p><strong>关闭fast-forward模式，在提交的时候，会创建一个merge的commit信息，然后合并的和master分支</strong></p></li></ol><p>merge的不同行为，向后看，其实最终都会将代码合并到master分支，而区别仅仅只是分支上的简洁清晰的问题，然后，向前看，也就是我们使用<code>reset</code> 的时候，就会发现，不同的行为就带来了不同的影响</p><p><img src="https://github-1253518569.cos.ap-shanghai.myqcloud.com/2018-09-18_201744.png" alt="https://github-1253518569.cos.ap-shanghai.myqcloud.com/2018-09-18_201744.png"></p><p>上图是使用 <code>merge --no-ff</code>的时候的效果，此时<code>git reset HEAD^ --hard</code> 的时候，整个分支会回退到  <strong>dev2-commit-2</strong></p><p><img src="https://github-1253518569.cos.ap-shanghai.myqcloud.com/2018-09-18_201755.png" alt=" dev3-commit-1"></p><p>上图是使用 <strong>fast-forward</strong> 模式的时候，即 <code>git merge</code> ，这时候 <code>git reset HEAD^ --hard</code>，整个分支会回退到 <strong>dev1-commit-3</strong></p><p>通常我们把 master 作为主分支，上面存放的都是比较稳定的代码，提交频率也很低，而 develop 是用来开发特性的，上面会存在许多零碎的提交，快进式合并会把 develop 的提交历史混入到 master 中，搅乱 master 的提交历史。所以如果你根本不在意提交历史，也不爱管 master 干不干净，那么 –no-ff 其实没什么用。不过，如果某一次 master 出现了问题，你需要回退到上个版本的时候，比如上例，你就会发现退一个版本到了 commint-3，而不是想要的 commit-2，因为 feature 的历史合并进了 master 里。这也就是很多人都会推荐 –no-ff 的原因了吧。</p>]]></content>
      
      
      <categories>
          
          <category> GIT </category>
          
      </categories>
      
      
        <tags>
            
            <tag> GIT </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>php的垃圾回收机制</title>
      <link href="/posts/13507/"/>
      <url>/posts/13507/</url>
      
        <content type="html"><![CDATA[<p>每个php变量存在一个叫”zval”的变量容器中。一个zval变量容器，除了包含变量的类型和值，还包括两个字节的额外信息。第一个是”is_ref”，是个bool值，用来标识这个变量是否是属于引用集合(reference set)。通过这个字节，php引擎才能把普通变量和引用变量区分开来，由于php允许用户通过使用&amp;来使用自定义引用，zval变量容器中还有一个内部引用计数机制，来优化内存使用。第二个额外字节是”refcount”，用以表示指向这个zval变量容器的变量(也称符号即symbol)个数。所有的符号存在一个符号表中，其中每个符号都有作用域(scope)，那些主脚本(比如：通过浏览器请求的的脚本)和每个函数或者方法也都有作用域。 </p><a id="more"></a><p>PHP是一种弱类型的脚本语言，弱类型不表示PHP变量没有类型的区别，PHP变量有8种原始类型：<br>四种标量类型：</p><ul><li>boolean（布尔值）</li><li>integer（整型）</li><li>float（浮点型）</li><li>string （字符串）</li></ul><p>两种复合类型：</p><ul><li>array（数组）</li><li>object（对象）</li></ul><p>两种特殊类型：</p><ul><li>resource（资源）</li><li>NULL</li></ul><hr><p>在引擎内部，变量都是用一个结构体来表示的。这个结构体可以在{PHPSRC}/Zend/zend.h中找到：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">struct _zval_struct &#123;  </span><br><span class="line">     /* Variable information */  </span><br><span class="line">     zvalue_value value;     /* value */  </span><br><span class="line">     zend_uint refcount__gc;  //代表一个计数器，表示有多少个变量名指向这个zval容器</span><br><span class="line">     zend_uchar type;    /* active type */  </span><br><span class="line">     zend_uchar is_ref__gc;  //此字段是一个布尔值，用来标识变量是否是一个引用，通过这个字段，PHP引擎可以区分一般变量和引用变量</span><br><span class="line"> &#125;;</span><br></pre></td></tr></table></figure><h2 id="copy-on-write（写时复制技术）"><a href="#copy-on-write（写时复制技术）" class="headerlink" title="copy on write（写时复制技术）"></a>copy on write（写时复制技术）</h2><blockquote><p>父进程fork子进程之后，子进程的地址空间还是简单的指向父进程的地址空间，只有当子进程需要写地址空间中的内容的时候，才会单独分离一份给子进程，这样就算子进程马上调用exec函数也没有关系，因为根本就不需要从父进程的地址空间中拷贝内容，这样就节省了内存同时又提高了速度。</p><p>这个逻辑可以叙述为：对一个一般变量a（isref=0）进行一般的赋值操作，如果a所指向的zval的计数refcount大于1，那么需要为a重新分配一个新的zval，并且把之前的zval的计数refcount减少1。</p></blockquote><h2 id="PHP5-3版本中对于新的GC算法（Concurrent-Cycle-Collection-in-Reference-Counted-Systems）"><a href="#PHP5-3版本中对于新的GC算法（Concurrent-Cycle-Collection-in-Reference-Counted-Systems）" class="headerlink" title="PHP5.3版本中对于新的GC算法（Concurrent Cycle Collection in Reference Counted Systems）"></a>PHP5.3版本中对于新的GC算法（Concurrent Cycle Collection in Reference Counted Systems）</h2><p>几个基本准则：</p><ol><li>如果一个zval的refcount增加，那么此zval还在使用，不属于垃圾</li><li>如果一个zval的refcount减少到0，那么zval可以被释放掉，不属于垃圾</li><li>如果一个zval的refcount减少之后大于0，那么此zval还不能被释放，此zval可能成为一个垃圾。</li></ol><p>新的GC算法目的就是防止循环引用的变量引起内存泄露问题。在PHP中GC算法，当节点缓冲区满了之后，垃圾分析算法就会启动，并且会释放掉发现的垃圾，从而回收内存。</p><p>现在，如果我们试一下，将数组的引用赋值给数组中的一个元素，有意思的事情发生了：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">&lt;?php</span><br><span class="line">$a = array(&quot;one&quot;);</span><br><span class="line">$a[] = &amp;$a;</span><br><span class="line">?&gt;</span><br></pre></td></tr></table></figure><p>这样$a数组就有两个元素，一个索引为0，值为字符one，另一个索引为1，为$a自身的引用，内部存储如下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">a: (refcount=2, is_ref=1)=array (</span><br><span class="line">   0 =&gt; (refcount=1, is_ref=0)=&apos;one&apos;,</span><br><span class="line">   1 =&gt; (refcount=2, is_ref=1)=...</span><br><span class="line">)</span><br></pre></td></tr></table></figure><p>“…”表示1指向a自身，是一个环形引用（循环引用）：<br><img src="https://github-1253518569.cos.ap-shanghai.myqcloud.com/242899734-5ab22a29174e9_articlex.png" alt="图片描述"></p><p>这个时候我们对$a进行unset，那么$a会从符号表中删除，同时$a指向的zval的refcount减少1。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">&lt;?php</span><br><span class="line">$a = array(&apos;one&apos;);</span><br><span class="line">$a[] = &amp;$a;</span><br><span class="line">unset($a);</span><br><span class="line">?&gt;</span><br></pre></td></tr></table></figure><p>那么问题产生了，$a已经不再符号表中了，用户无法再访问此变量，但是$a之前指向的zval的refcount变为1而不是0，因此不能被回收，这样产生了内存泄露：<br><img src="https://github-1253518569.cos.ap-shanghai.myqcloud.com/1915931556-5ab22afde99e3_articlex.png" alt="图片描述"></p><p>这样zval就成为一个垃圾了，新的GC要做的工作就是清理这种垃圾。</p><blockquote><p>在PHP编程中程序员不需要手动处理内存资源分配与释放，意味着PHP本身实现了垃圾回收处理机制。</p></blockquote><h2 id="PHP5-2中的垃圾回收算法—Reference-Counting"><a href="#PHP5-2中的垃圾回收算法—Reference-Counting" class="headerlink" title="PHP5.2中的垃圾回收算法—Reference Counting"></a>PHP5.2中的垃圾回收算法—Reference Counting</h2><blockquote><p>这个算法叫做“引用计数”，其思想非常直观和简洁：为每个内存对象分配一个计数器，当一个内存对象建立时计数器初始化为1（因此此时总是有一个变量引用此对象），以后每有一个新变量引用此内存对象，则计数器加1，而每当减少一个引用此内存对象的变量则计数器减1，当垃圾回收机制运作时，将所有计数器为0的内存对象销毁并回收其占用的内存。而php中内存对象就是zval，而计数器就是refcount__gc。</p></blockquote>]]></content>
      
      
      <categories>
          
          <category> PHP </category>
          
      </categories>
      
      
        <tags>
            
            <tag> PHP </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Nginx倒腾笔记（六）：SSL_do_handshake() failed</title>
      <link href="/posts/34556/"/>
      <url>/posts/34556/</url>
      
        <content type="html"><![CDATA[<p>前几天在倒腾镜像站的时候，在代理ipv4的站点是ok的，但是代理ipv6的https站点的时候，发现一直返回502，也就是说明，nginx代理了，但是代理的时候，下游服务器没有给你正确的响应</p><a id="more"></a><p>首先看一下原始配置</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">location / &#123;</span><br><span class="line">        proxy_cache my_cache;</span><br><span class="line">        proxy_set_header Accept-Encoding &quot;none&quot;;</span><br><span class="line">        proxy_pass https://m.cn.nytimes.com/;</span><br><span class="line">        sub_filter &apos;https://m.cn.nytimes.com&apos; &apos;https://www.xxx.com/&apos;;</span><br><span class="line">        sub_filter &apos;d1f1eryiqyjs0r.cloudfront.net&apos; &apos;www.xxx.com/d1f1eryiqyjs0r&apos;;</span><br><span class="line">        sub_filter_once  off;</span><br><span class="line">&#125;</span><br><span class="line">location ~ /d1f1eryiqyjs0r/(.*)$ &#123;</span><br><span class="line">        proxy_cache my_cache;</span><br><span class="line">        proxy_set_header referer &quot;https://cn.nytimes.com&quot;;</span><br><span class="line">        proxy_pass https://d1f1eryiqyjs0r.cloudfront.net/$1;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>思路很简单，就是通过proxy_pass来代理到目标站点，获取内容后，将不能国内访问的内容的域名替换成自己的域名，后面加上不同的后缀来标识，然后再通过我们的服务器代理内容里面的超链，理论上出了繁琐外，没有什么技术难度，然而返回了502，这就有点不够意思了。</p><p>查看error.log后发现</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">2018/09/01 07:55:24 [error] 485#485: *6372 SSL_do_handshake() failed (SSL: error:14077410:SSL routines:SSL23_GET_SERVER_HELLO:sslv3 alert handshake failure) while SSL handshaking to upstream, client: 122.224.106.25, server: www.xxx.com, request: &quot;GET / HTTP/1.1&quot;, upstream: &quot;https://52.85.131.45:443/&quot;, host: &quot;www.xxx.com&quot;</span><br></pre></td></tr></table></figure><p>SSL的问题，代理的时候加一下SSL处理</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">location / &#123;</span><br><span class="line">        proxy_ssl_server_name on;</span><br><span class="line">        proxy_ssl_protocols TLSv1 TLSv1.1 TLSv1.2;</span><br><span class="line">        proxy_cache my_cache;</span><br><span class="line">        proxy_set_header Accept-Encoding &quot;none&quot;;</span><br><span class="line">        proxy_pass https://m.cn.nytimes.com/;</span><br><span class="line">        sub_filter &apos;https://m.cn.nytimes.com&apos; &apos;https://www.xxx.com/&apos;;</span><br><span class="line">        sub_filter &apos;d1f1eryiqyjs0r.cloudfront.net&apos; &apos;www.xxx.com/d1f1eryiqyjs0r&apos;;</span><br><span class="line">        sub_filter_once  off;</span><br><span class="line">&#125;</span><br><span class="line">location ~ /d1f1eryiqyjs0r/(.*)$ &#123;</span><br><span class="line">proxy_ssl_server_name on;</span><br><span class="line">        proxy_ssl_protocols TLSv1 TLSv1.1 TLSv1.2;</span><br><span class="line">        proxy_cache my_cache;</span><br><span class="line">        proxy_set_header referer &quot;https://cn.nytimes.com&quot;;</span><br><span class="line">        proxy_pass https://d1f1eryiqyjs0r.cloudfront.net/$1;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>综上，再次打开已经OK了。</p>]]></content>
      
      
      <categories>
          
          <category> Nginx </category>
          
      </categories>
      
      
        <tags>
            
            <tag> PHP </tag>
            
            <tag> Nginx </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>php配置xdebug实现内网本地调试远程服务器</title>
      <link href="/posts/15205/"/>
      <url>/posts/15205/</url>
      
        <content type="html"><![CDATA[<p>对于一般的项目来说，<code>print_r() echo file_put_contents() exit</code> 这些函数调试就足够了，但是如果你调试的环境还有其他人，那就略胃疼了</p><p>服务器环境：centos7 php7.0</p><p>本地环境：windows php7.2（压缩包）</p><p>本地环境是公司内网，所以中间会借助xshell做一次tcp的转发</p><a id="more"></a><h1 id="服务器配置"><a href="#服务器配置" class="headerlink" title="服务器配置"></a>服务器配置</h1><h2 id="安装xdebug"><a href="#安装xdebug" class="headerlink" title="安装xdebug"></a>安装xdebug</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">yum install php70w* --skip-broken</span><br><span class="line">yum install php70w-pecl-xdebug</span><br></pre></td></tr></table></figure><h2 id="配置xdebug"><a href="#配置xdebug" class="headerlink" title="配置xdebug"></a>配置xdebug</h2><p>修改xdebug的配置文件 <code>/etc/php.d/xdebug.ini</code></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">; Enable xdebug extension module</span><br><span class="line">zend_extension=/usr/lib64/php/modules/xdebug.so</span><br><span class="line">xdebug.idekey = &quot;PHPSTORM&quot;</span><br><span class="line">; 因为DBGp调试代理是可以做调试分发的，所以，定义一个IDEKEY，目的是让调试器知道，是不是发给自己的请求</span><br><span class="line"></span><br><span class="line">xdebug.remote_enable = 1</span><br><span class="line">; 设置为1的时候，会先参数链接到remote_host和remote_port指定的调试器端口，如果连接不上，就继续执行，类似设置&gt;了0</span><br><span class="line"></span><br><span class="line">xdebug.remote_mode = &quot;req&quot;</span><br><span class="line">xdebug.remote_handler = &quot;dbgp&quot;</span><br><span class="line">; 也就是调试走哪种协议，有老的PHP3协议，也有GDB协议，DBGP是当前的默认协议，也是当前主流支持的协议</span><br><span class="line"></span><br><span class="line">xdebug.remote_connect_back = 0</span><br><span class="line">; 如果为1，xdebug会通过$_SERVER[‘REMOTE_ADDR’]变量，向发起HTTP请求的客户端发起链接，和remote_host功能类似&gt;，但是优先级比remote_host高，所以，设置了这个选项就会忽略remote_host，由于我的运行时服务器不能主动链接IDE所&gt;在PC，所以不能开启自动回连模式(内网访问外网的网页，也不能开启)</span><br><span class="line"></span><br><span class="line">xdebug.remote_host = &quot;127.0.0.1&quot;</span><br><span class="line">; 默认是主机，如果服务器可以直接你的本地电脑，可以直接填写本机ip，我这里使用xshell做tcp转发</span><br><span class="line"></span><br><span class="line">xdebug.remote_port = 9909</span><br><span class="line">; 默认端口是9000，由于担心服务器端口冲突，我修改为9909，建议你没有端口冲突时不修改</span><br><span class="line"></span><br><span class="line">xdebug.remote_autostart = 0</span><br><span class="line">; 这个为1，会忽略COOKIE或者POST/GET中带的XDEBUG_SESSION参数，不管有没有，都会启动调试，所以，还是设置为0比较好，默认0</span><br></pre></td></tr></table></figure><p>重启php-fpm</p><h1 id="Xshell-TCP转发"><a href="#Xshell-TCP转发" class="headerlink" title="Xshell TCP转发"></a>Xshell TCP转发</h1><p>首先连上你需要配置的服务器或者找到目标服务器的会话设置，然后右键找到<code>属性</code> ，然后找到<code>连接 -&gt; ssh -&gt; 隧道 -&gt; 添加</code>，按如图所示添加，上面配置目标服务器，下面配置本机</p><p><img src="http://github-1253518569.cossh.myqcloud.com/xshell-1.png" alt="配置属性"></p><p><img src="http://github-1253518569.cossh.myqcloud.com/xshell-2.png" alt="配置属性"></p><p><img src="http://github-1253518569.cossh.myqcloud.com/xshell-3.png" alt="tcp转发配置"></p><p>配置完成后分别查看一下 目标服务器的9909 是否被监听</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">netstat -ano | grep 9909</span><br></pre></td></tr></table></figure><h1 id="Sublime配置"><a href="#Sublime配置" class="headerlink" title="Sublime配置"></a>Sublime配置</h1><h2 id="Xdebug配置"><a href="#Xdebug配置" class="headerlink" title="Xdebug配置"></a>Xdebug配置</h2><p>首先通过 <code>package controller</code>安装 <code>xdebug client</code></p><p>然后通过菜单栏的 <code>tool -&gt; Xdebug-&gt; Settings-default</code>， 可以找到xdebug的默认配置（简单摘取）</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">    &quot;path_mapping&quot;: &#123;</span><br><span class="line"></span><br><span class="line">    &#125;,</span><br><span class="line"></span><br><span class="line">    // Determine which URL to launch in the default web browser</span><br><span class="line">    // when starting/stopping a session.</span><br><span class="line">    &quot;url&quot;: &quot;&quot;,</span><br><span class="line">    &quot;ide_key&quot;: &quot;sublime.xdebug&quot;,</span><br><span class="line">    &quot;host&quot;: &quot;&quot;,</span><br><span class="line"></span><br><span class="line">    // Which port number Sublime Text should listen</span><br><span class="line">    // to connect with debugger engine.</span><br><span class="line">    &quot;port&quot;: 9000,</span><br><span class="line"></span><br><span class="line">.</span><br><span class="line">.</span><br><span class="line">.</span><br><span class="line">.</span><br><span class="line">    &quot;python_path&quot; : &quot;&quot;,</span><br><span class="line"></span><br><span class="line">    // Show detailed log information about communication</span><br><span class="line">    // between debugger engine and Sublime Text.</span><br><span class="line">    // Log can be found at Packages/User/Xdebug.log</span><br><span class="line">    &quot;debug&quot;: false</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>参考系统的配置及解释，用户可以自行定义 <code>tool -&gt; Xdebug-&gt; Settings-User</code> ，但是用户一般不是只有一个项目，所以个人还是建议针对于每个 project 进行设置，可以通过菜单栏 <code>Project -&gt; Edit Project</code>， 当然，你需要先创建一个project，这都是小事了。</p><p>附上个人project配置</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">&quot;folders&quot;:</span><br><span class="line">[</span><br><span class="line">&#123;</span><br><span class="line">&quot;path&quot;: &quot;.&quot;</span><br><span class="line">&#125;</span><br><span class="line">],</span><br><span class="line">&quot;settings&quot;: &#123;</span><br><span class="line">&quot;xdebug&quot;: &#123;</span><br><span class="line">&quot;path_mapping&quot;: &#123;</span><br><span class="line">    &quot;/data/www/html/httpserver&quot; : &quot;D:/workplace/cloudserver&quot;</span><br><span class="line">&#125;,</span><br><span class="line">&quot;url&quot;: &quot;http://121.xx.xx.xxx/httpserver/&quot;,</span><br><span class="line">&quot;ide_key&quot;: &quot;PHPSTORM&quot;,</span><br><span class="line">&quot;host&quot;: &quot;0.0.0.0&quot;,</span><br><span class="line">&quot;port&quot;: 9050,</span><br><span class="line">&quot;close_on_stop&quot;: true,</span><br><span class="line">&quot;debug_layout&quot; : &#123;</span><br><span class="line">    &quot;cols&quot;: [0.0, 0.5, 1.0],</span><br><span class="line">    &quot;rows&quot;: [0.0, 0.7, 1.0],</span><br><span class="line">    &quot;cells&quot;: [[0, 0, 2, 1], [0, 1, 1, 2], [1, 1, 2, 2]]</span><br><span class="line">&#125;,</span><br><span class="line">&quot;python_path&quot; : &quot;C:\\Program Files\\Python35\\python.exe&quot;,</span><br><span class="line">&quot;debug&quot;: true</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="SFTP配置"><a href="#SFTP配置" class="headerlink" title="SFTP配置"></a>SFTP配置</h2><p>sftp配置就不多废话了，参考另一篇博客<a href="https://tyloafer.github.io/posts/45096/">Sublime倒腾系列：配置sftp实现文件上传下载</a></p><h1 id="PHPStrom配置"><a href="#PHPStrom配置" class="headerlink" title="PHPStrom配置"></a>PHPStrom配置</h1><h2 id="SFTP配置-1"><a href="#SFTP配置-1" class="headerlink" title="SFTP配置"></a>SFTP配置</h2><p><code>Tools-&gt;Deployment-&gt;Configuration</code>，在弹出的对话框里一次填入用户名，密码，</p><p><img src="http://github-1253518569.cossh.myqcloud.com/phpstrome-1.png" alt="phpstrom sft配置"></p><p>然后右边旁边一个标签页 <code>Mappings</code></p><p><img src="http://github-1253518569.cossh.myqcloud.com/phpstrome-29.png" alt="phpstrom-mapping"></p><p>配置完成后，通过 <code>Tools—&gt;Deployment—&gt;Browse Remote Host</code> 看一下右侧是否会列出远程文件，显示绿色表名是对应上了</p><h2 id="Server配置"><a href="#Server配置" class="headerlink" title="Server配置"></a>Server配置</h2><p>通过 <code>File -&gt; Settings -&gt; Languages &amp; Frameworks -&gt; PHP -&gt; Servers</code>   新建一个Server,输入服务器的IP和端口，最关键的是，将本地工程文件夹和服务器上的文件夹对应起来，方便调试的时候找到源码：</p><p><img src="http://github-1253518569.cossh.myqcloud.com/phpstrome-3.png" alt="phpstrome server配置"></p><h2 id="配置Debug"><a href="#配置Debug" class="headerlink" title="配置Debug"></a>配置Debug</h2><p>通过<code>Run -&gt; Edit Configurations -&gt; PHP Remote Debug</code>，创建一个新的配置，Servers就选择刚才配置的，Ide Key设置为php.ini里面xdebug.idekey设置的， 这里就是 <strong>PHPSTROME</strong></p><p><img src="http://github-1253518569.cossh.myqcloud.com/phpstrom-4.png" alt="phpstrom remote debug"></p><h2 id="调试（全部配置结束后测试）"><a href="#调试（全部配置结束后测试）" class="headerlink" title="调试（全部配置结束后测试）"></a>调试（全部配置结束后测试）</h2><p><img src="http://github-1253518569.cossh.myqcloud.com/phpstrom-5.png" alt="调试"></p><h1 id="Postman配置"><a href="#Postman配置" class="headerlink" title="Postman配置"></a>Postman配置</h1><p>Postman 地址： <a href="https://chrome.google.com/webstore/detail/postman/agkicnjkbankpckaomnhfjglafjcegkk?hl=zh-CN" target="_blank" rel="noopener">谷歌商店</a></p><p>Postman Interceptor 地址： <a href="https://chrome.google.com/webstore/detail/postman-interceptor/aicmkgpgakddgnaphhhpliifpcfhicfo?hl=zh-CN" target="_blank" rel="noopener">谷歌商店</a></p><p>安装完成后，打开<strong>Postman</strong>， 在右上角开启 <strong>Postman Interceptor</strong> 即可设置cookie 进行请求了</p><p><img src="http://github-1253518569.cossh.myqcloud.com/postman-1.png" alt="postman"></p><p>这时候，只要在模拟请求的时候设置一下cookie，在 <strong>phpstrom</strong> 或 <strong>sublime</strong> 设置一下断点就ok了</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Cookie:XDEBUG_SESSION=PHPSTORM</span><br></pre></td></tr></table></figure><p><img src="http://github-1253518569.cossh.myqcloud.com/postman-2.png" alt="postman cookie设置"></p>]]></content>
      
      
      <categories>
          
          <category> PHP </category>
          
      </categories>
      
      
        <tags>
            
            <tag> PHP </tag>
            
            <tag> Xdebug </tag>
            
            <tag> Sublime </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Linux权限控制-ACL</title>
      <link href="/posts/45399/"/>
      <url>/posts/45399/</url>
      
        <content type="html"><![CDATA[<p>在Linux进行权限管理接触最多的应该就是 <code>chmod</code> <code>chown</code> ，但是用的时间长了就会发现很多弊端，很明显的就是root用户用的越来越多， 777权限的文件越来越多，部分原因是开发者过懒导致的，但是简单的<code>chmod</code> <code>chown</code> 会误杀很多用户也是一部分原因。那么接下来就介绍一下更为聪明和牛逼的权限控制—-ACL</p><a id="more"></a><p><strong>访问控制表</strong>（Access Control List，ACL），又称<strong>存取控制串列</strong>，是使用以<a href="https://zh.wikipedia.org/wiki/%E5%AD%98%E5%8F%96%E6%8E%A7%E5%88%B6%E7%9F%A9%E9%99%A3" target="_blank" rel="noopener">访问控制矩阵</a>为基础的访问控制方法，每一个对象对应一个串列主体<br>。访问控制表描述每一个对象各自的访问控制，并记录可对此对象进行访问的所有主体对对象的权限。</p><ul><li><p>Linux文件系统ACL功能</p><p>主要的目的是在提供传统的 owner,group,others 的 read,write,execute 权限之外的细部权限设置。ACL 可以针对单一使用者，单一文件或目录来进行 r,w,x 的权限规范，对于需要特殊权限的使用状况非常有帮助。</p><p>简而言之，ACL功能是为了加强Linux系统文件权限管理。</p></li></ul><h1 id="开启-ACL-权限"><a href="#开启-ACL-权限" class="headerlink" title="开启 ACL 权限"></a>开启 ACL 权限</h1><p>对于CentOS6，系统安装时的分区支持acl,额外的文件系统挂载时需添加acl选项。</p><blockquote><p>mount -o remount, acl [mount point]</p></blockquote><p>对于CentOS7，默认支持acl功能。</p><h1 id="查看和设置文件-ACL-权限"><a href="#查看和设置文件-ACL-权限" class="headerlink" title="查看和设置文件 ACL 权限"></a>查看和设置文件 ACL 权限</h1><p>设置 ACL 权限用<code>setfacl -m [u|g]:[用户名|组名]:权限 文件名</code>命令。<br>查看 ACL 权限用<code>getfacl 文件名</code></p><table><thead><tr><th>选项</th><th>说明</th><th>使用</th></tr></thead><tbody><tr><td>m</td><td>设置 ACL 权限</td><td>setfacl -m [u\</td><td>g]:[用户名 \</td><td>组名]: 权限 文件名</td></tr><tr><td>x</td><td>删除指定 ACL 权限</td><td>setfacl -x [u\</td><td>g]:[用户名 \</td><td>组名] 文件名</td></tr><tr><td>b</td><td>删除全部 ACL 权限</td><td>setfacl -b 文件名</td></tr><tr><td>d</td><td>设定默认 ACL 权限 (子文件继承目录 ACL 权限)</td><td>setfacl -m d:[u\</td><td>g]:[用户名 \</td><td>组名]: 权限 文件名</td></tr><tr><td>k</td><td>删除默认 ACL 权限 (子文件继承目录 ACL 权限)</td><td>setfacl -m</td></tr><tr><td>R</td><td>递归设置 ACL 权限 (容易给文件 x 权限)</td><td>setfacl -m [u\</td><td>g]:[用户名 \</td><td>组名]: 权限 -R 目录名</td></tr></tbody></table><p>eg:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"># 1. 创建权限为drwxrwx---, 用户和用户组为root的dir目录</span><br><span class="line">[root@localhost ~]# mkdir ~ahao/dir </span><br><span class="line">[root@localhost ~]# chmod 770 ~ahao/dir</span><br><span class="line">[root@localhost ~]# ll ~ahao</span><br><span class="line">总用量 0</span><br><span class="line">drwxrwx---. 2 root root 6 11月  4 22:32 dir</span><br><span class="line"></span><br><span class="line"># 2. 操作1: ahao用户尝试进入dir目录失败, 权限不足</span><br><span class="line">[ahao@localhost ~]$ cd dir</span><br><span class="line">-bash: cd: dir: 权限不够</span><br><span class="line"></span><br><span class="line"># 3. root用户设置ACL权限, 给ahao用户赋予rx权限</span><br><span class="line">[root@localhost ~]# setfacl -m u:ahao:rx ~ahao/dir</span><br><span class="line">[ahao@localhost ~]$ ll</span><br><span class="line">总用量 0</span><br><span class="line">drwxrwx---+ 2 root root 6 11月  4 22:32 dir</span><br><span class="line"></span><br><span class="line"># 4. 操作2: ahao用户尝试进入dir目录成功, dir的+权限位代表ACL权限</span><br><span class="line">[ahao@localhost ~]$ cd dir</span><br><span class="line">[ahao@localhost dir]$ # 成功进入dir目录 </span><br><span class="line"></span><br><span class="line"># 5. 操作3: 查看ACL权限</span><br><span class="line">[ahao@localhost dir]$ getfacl ~ahao/dir/ </span><br><span class="line">getfacl: Removing leading &apos;/&apos; from absolute path names</span><br><span class="line"># file: home/ahao/dir/</span><br><span class="line"># owner: root</span><br><span class="line"># group: root</span><br><span class="line">user::rwx</span><br><span class="line">user:ahao:r-x # ACL权限</span><br><span class="line">group::rwx</span><br><span class="line">mask::rwx</span><br><span class="line">other::---</span><br></pre></td></tr></table></figure><h1 id="mask-掩码"><a href="#mask-掩码" class="headerlink" title="mask 掩码"></a>mask 掩码</h1><p>上面的例子在使用<code>getfacl dir</code>之后, 可以看到有一项是<code>mask</code>。<br>这个和默认权限<code>umask</code>差不多, 也是一个权限掩码, 表示所能赋予的权限最大值。<br>这里的<code>mask</code>和<code>ACL权限</code>进行<code>&amp;与</code>运算, 得到的才是真正的<code>ACL权限</code>。<br>用人话讲, 就是</p><blockquote><p>你考一百分是因为实力只有一百分<br>我考一百分是因为总分只有一百分</p></blockquote><p><code>mask</code>限制了权限的最高值。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"># 1. 修改ACL权限mask为r-x</span><br><span class="line">[root@localhost ~]# setfacl -m m:rx ~ahao/tmp/av </span><br><span class="line">[root@localhost ~]# getfacl ~ahao/tmp/av</span><br><span class="line">getfacl: Removing leading &apos;/&apos; from absolute path names</span><br><span class="line"># file: home/ahao/tmp/av</span><br><span class="line"># owner: root</span><br><span class="line"># group: root</span><br><span class="line">user::rwx</span><br><span class="line">group::r-x</span><br><span class="line">mask::r-x # 修改ACL权限mask为r-x</span><br><span class="line">other::---</span><br><span class="line"></span><br><span class="line"># 2. 为用户ahao添加ACL权限rwx</span><br><span class="line">[root@localhost ~]# setfacl -m u:ahao:rwx ~ahao/tmp/av/ </span><br><span class="line">[root@localhost ~]# getfacl ~ahao/tmp/av</span><br><span class="line">getfacl: Removing leading &apos;/&apos; from absolute path names</span><br><span class="line"># file: home/ahao/tmp/av</span><br><span class="line"># owner: root</span><br><span class="line"># group: root</span><br><span class="line">user::rwx</span><br><span class="line">user:ahao:rwx</span><br><span class="line">group::r-x</span><br><span class="line">mask::rwx # 注意, 这里的mask掩码会改变, 因为赋予的ACL权限大于mask</span><br><span class="line">other::---</span><br><span class="line"></span><br><span class="line"># 3. 修改ACL权限mask为r-x</span><br><span class="line">[root@localhost ~]# setfacl -m m:rx ~ahao/tmp/av</span><br><span class="line">[root@localhost ~]# getfacl ~ahao/tmp/av</span><br><span class="line">getfacl: Removing leading &apos;/&apos; from absolute path names</span><br><span class="line"># file: home/ahao/tmp/av</span><br><span class="line"># owner: root</span><br><span class="line"># group: root</span><br><span class="line">user::rwx</span><br><span class="line">user:ahao:rwx#effective:r-x # 这里会提示真实的ACL权限为r-x</span><br><span class="line">group::r-x</span><br><span class="line">mask::r-x # 这里mask不会再改变</span><br><span class="line">other::---</span><br></pre></td></tr></table></figure><ol><li><code>mask</code> 会限制 <code>ACL</code> 权限的最大值。</li><li>赋予<code>ACL</code> 权限大于 <code>mask</code> 的时候, 会将 <code>mask</code> <strong>撑大</strong>。</li></ol>]]></content>
      
      
      <categories>
          
          <category> Linux </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Linux </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Nginx倒腾笔记（六）：Nginx tcp/udp转发</title>
      <link href="/posts/27510/"/>
      <url>/posts/27510/</url>
      
        <content type="html"><![CDATA[<p>前两天给部门做了个数据库的主备用于数据分析，但是后来运维不建议直连备份服务器的3306端口，然后就很尴尬了，然后他们就从程序开始入手，脚本处理binlog，导入导出and so on，从我个人角度来说，我是不喜欢这种方式极度曲线救国的方式的，然后我就没事测试了一下Nginx到tcp转发，当然也只能做个人的小实验了。</p><a id="more"></a><h1 id="配置Nginx"><a href="#配置Nginx" class="headerlink" title="配置Nginx"></a>配置Nginx</h1><p>Nginx的stream模块不仅支持TCP转发，也支持UDP，同时还可以通过socket转发，也是很强大的了。</p><p>配置文件配置如下</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">stream &#123;</span><br><span class="line">server &#123;</span><br><span class="line">listen 1008;</span><br><span class="line"># listen 1008 udp; 通过后面添加udp，可以进行udp的转发</span><br><span class="line">proxy_pass 127.0.0.1:3306;</span><br><span class="line"># proxy_pass unix:/var/lib/mysql/mysql.sock; 将数据转发给socket处理</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="测试"><a href="#测试" class="headerlink" title="测试"></a>测试</h1><p>我们通过<code>1008</code> 端口进行连接数据库尝试一下</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">➜  httpserver master ✗ mysql -uxxxx -pxxxxx -P1008 </span><br><span class="line">mysql: [Warning] Using a password on the command line interface can be insecure.</span><br><span class="line">Reading table information for completion of table and column names</span><br><span class="line">You can turn off this feature to get a quicker startup with -A</span><br><span class="line"></span><br><span class="line">Welcome to the MySQL monitor.  Commands end with ; or \g.</span><br><span class="line">Your MySQL connection id is 5399</span><br><span class="line">Server version: 5.7.22-log MySQL Community Server (GPL)</span><br><span class="line"></span><br><span class="line">Copyright (c) 2000, 2018, Oracle and/or its affiliates. All rights reserved.</span><br><span class="line"></span><br><span class="line">Oracle is a registered trademark of Oracle Corporation and/or its</span><br><span class="line">affiliates. Other names may be trademarks of their respective</span><br><span class="line">owners.</span><br><span class="line"></span><br><span class="line">Type &apos;help;&apos; or &apos;\h&apos; for help. Type &apos;\c&apos; to clear the current input statement.</span><br><span class="line"></span><br><span class="line">mysql&gt; quit</span><br></pre></td></tr></table></figure><p>尝试ok</p><h1 id="进阶"><a href="#进阶" class="headerlink" title="进阶"></a>进阶</h1><p>既然nginx可以进行tcp和udp的转发，那我是否可以代理shadowsock呢？</p><p>配置如下</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">stream &#123;</span><br><span class="line">    server &#123;</span><br><span class="line">        listen 80;</span><br><span class="line">        listen 80 udp;</span><br><span class="line">        proxy_pass 127.0.0.1:xxxx;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>最终，并没有尝试成功，后期有时间找朋友一起抓下包分析一下，暂时就先倒腾到这了</p>]]></content>
      
      
      <categories>
          
          <category> Nginx </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Nginx </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Nginx倒腾笔记（五）：Nginx制作镜像站</title>
      <link href="/posts/42698/"/>
      <url>/posts/42698/</url>
      
        <content type="html"><![CDATA[<p>最开始接触镜像站还是当初在实验室的时候，当时还是一枚小菜鸟，不懂科学上网，然后在学姐的带领下，知道了镜像站的存在，现在虽然已经用不上镜像站了，但是还是想倒腾一下，而Nginx的反向代理正好也可以实现这个功能</p><a id="more"></a><h1 id="代理实现镜像站"><a href="#代理实现镜像站" class="headerlink" title="代理实现镜像站"></a>代理实现镜像站</h1><p>其实，nginx的 <em>proxy_pass</em> 模块就可以实现，配置如下</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">location / &#123;</span><br><span class="line">    proxy_pass https://www.google.com/;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这样，将所有网站的请求都代理到谷歌，然后等待谷歌返回给我们，我们再展示就ok了，效果如下</p><p><img src="http://github-1253518569.cossh.myqcloud.com/mirror-google.png" alt="mirror-google"></p><h1 id="进阶-小偷站"><a href="#进阶-小偷站" class="headerlink" title="进阶-小偷站"></a>进阶-小偷站</h1><p>对于镜像站的实现原理其实是这样的</p><pre class="mermaid">graph TDst(开始)-->op1(用户)    op1--数据-->op2(我的服务器)    op2--用户的信息-->op3(google服务器)    op3--谷歌返回数据-->op2    op2--谷歌返回的数据-->op1</pre><p>那么，既然数据是从我的服务器上经过的，我能不能将数据修改一下，伪装成我自己的站呢，连数据库都省的装了，答案当然是可以的</p><p>我们这里可以借助Nginx自带的模块 <em>ngx_http_sub_module</em> ，但是这个有点弱，也可以选用 github上的第三方模块  <a href="https://github.com/yaoweibin/ngx_http_substitutions_filter_module" target="_blank" rel="noopener"><em>ngx_http_substitutions_filter_module</em></a>  来处理，安装过程就不赘述了</p><p>配置如下</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">location / &#123;</span><br><span class="line">    proxy_pass https://www.baidu.com/;</span><br><span class="line">    proxy_set_header Accept-Encoding &quot;none&quot;;  # 防止gzip导致的替换失败</span><br><span class="line">    subs_filter_types text/plain text/css text/xml; #替换html、css、xml内容</span><br><span class="line">    subs_filter &apos;百度一下&apos; &apos;tyloafer&apos; g;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>效果如下</p><p><img src="http://github-1253518569.cossh.myqcloud.com/baidu_sub_filter.png" alt="百度替换结果"></p>]]></content>
      
      
      <categories>
          
          <category> Nginx </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Nginx </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>MySQL主从配置</title>
      <link href="/posts/42030/"/>
      <url>/posts/42030/</url>
      
        <content type="html"><![CDATA[<p><strong>MySQL主从复制原理：</strong>master服务器将数据的改变记录二进制日志，当master上的数据发生改变时，则将其改变写入二进制日志中，salve服务器会在一定时间间隔内对master二进制日志进行探测其是否发生改变，如果发生改变，则开始一个I/OThread请求master二进制事件，同时主节点为每个I/O线程启动一个dump线程，用于向其发送二进制事件，并保存至从节点本地的中继日志中，从节点将启动SQL线程从中继日志中读取二进制日志，在本地重放，使得其数据和主节点的保持一致，最后I/OThread和SQLThread将进入睡眠状态，等待下一次被唤醒。</p><p>接下来将会记录一下具体实现</p><a id="more"></a><h1 id="Master设置"><a href="#Master设置" class="headerlink" title="Master设置"></a>Master设置</h1><ol><li><p>开启mysql的bin-log，主备是基于二进制日志的</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"># master</span><br><span class="line">log-bin=/var/lib/mysql/mysql-bin</span><br><span class="line">server-id=1</span><br></pre></td></tr></table></figure><p>配置里面的<em>server-id</em> 是可以随意设置的，但是要保证在集群中的唯一性，</p></li><li><p>重启mysql，让设置生效</p></li><li><p>创建一个备份账号</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">GRANT REPLICATION SLAVE ON *.* to &apos;username&apos;@&apos;ip&apos; identified by &apos;password&apos;;</span><br></pre></td></tr></table></figure></li><li><p>导出master的数据，并且记录导出时的bin-log偏移</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">mysqldump -uroot -p --master-data=2  --all-databases &gt; all_databases.sql</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">➜  /data/www/html  ✗ more httpserver.sql</span><br><span class="line">--</span><br><span class="line">-- Position to start replication or point-in-time recovery from</span><br><span class="line">--</span><br><span class="line"></span><br><span class="line">-- CHANGE MASTER TO MASTER_LOG_FILE=&apos;mysql-bin.000001&apos;, MASTER_LOG_POS=750663;</span><br></pre></td></tr></table></figure><p>命令中的 <em>–master-data=2</em> 是为了将 <em>CHANGE MASTER TO MASTER_LOG_FILE=’mysql-bin.000001’, MASTER_LOG_POS=750663;</em>  进行注释，这里记录的 log_file和 log_pos 将会在备份服务器的设置上使用</p></li></ol><h1 id="Slave设置"><a href="#Slave设置" class="headerlink" title="Slave设置"></a>Slave设置</h1><ol><li><p>首先设置server-id，在 <code>my.cnf</code> 中加入</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"># replicate</span><br><span class="line">log-bin=/var/lib/mysql/mysql-bin   // 可以不开启</span><br><span class="line">server-id=2    // 这个值不可与master相同</span><br><span class="line">replicate-do-db = db1,db2///   // 选择需要同步的数据库，不写则全部同步</span><br></pre></td></tr></table></figure></li><li><p>重启mysql</p></li><li><p>导入数据</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">mysql -uroot -p &lt; all_databases.sql</span><br></pre></td></tr></table></figure></li><li><p>设置master信息</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">mysql root@localhost:(none)&gt;  change master to master_host=&apos;ip&apos;,master_user=&apos;user&apos;,master_password=&apos;password&apos;, master_log_file=&apos;mysql-bin.000001&apos;,master_log_pos=750663;</span><br></pre></td></tr></table></figure><p>这天命令中的 <em>master_log_file=’mysql-bin.000001’,master_log_pos=750663;</em>  便是上面sql文件中注释的内容</p></li><li><p>开启同步</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">mysql root@localhost:(none)&gt;  start slave</span><br></pre></td></tr></table></figure></li><li><p>查看slave状态</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">mysql root@localhost:(none)&gt; show slave status\G</span><br><span class="line"></span><br><span class="line">   *************************** 1. row ***************************</span><br><span class="line"></span><br><span class="line">              Slave_IO_State: Waiting for master to send event</span><br><span class="line">              Master_Host: ip  //主服务器地址</span><br><span class="line">              Master_User: user   //授权帐户名，尽量避免使用root</span><br><span class="line">              Master_Port: 3306    //数据库端口，部分版本没有此行</span><br><span class="line">              Connect_Retry: 60</span><br><span class="line">              Master_Log_File: mysql-bin.000004</span><br><span class="line">              Read_Master_Log_Pos: 600     //#同步读取二进制日志的位置，大于等于Exec_Master_Log_Pos</span><br><span class="line">              Relay_Log_File: ddte-relay-bin.000003</span><br><span class="line">              Relay_Log_Pos: 251</span><br><span class="line">              Relay_Master_Log_File: mysql-bin.000004</span><br><span class="line">              Slave_IO_Running: Yes    //此状态必须YES</span><br><span class="line">              Slave_SQL_Running: Yes     //此状态必须YES</span><br></pre></td></tr></table></figure></li></ol>]]></content>
      
      
      <categories>
          
          <category> DataBase </category>
          
      </categories>
      
      
        <tags>
            
            <tag> MySQL </tag>
            
            <tag> DataBase </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>使用binlog还原MySQL中的误操作</title>
      <link href="/posts/39337/"/>
      <url>/posts/39337/</url>
      
        <content type="html"><![CDATA[<p>在操作数据库的时候，总会有些时候那么的手贱，导致数据丢失，如果是测试环境还好，但是要是正式环境，那就删库跑路吧。其实，如果你打开的bin-log，这些操作还是可以被还原的。</p><a id="more"></a><h1 id="开启bin-log"><a href="#开启bin-log" class="headerlink" title="开启bin-log"></a>开启bin-log</h1><p>bin-log是MySQL的主从复制中开启的一个选项，在 <code>/etc/my.cnf</code> 中有两个配置如下</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"># Remove leading # to turn on a very important data integrity option: logging</span><br><span class="line"># changes to the binary log between backups.</span><br><span class="line"># log_bin</span><br><span class="line"></span><br><span class="line"># These are commonly set, remove the # and set as required.</span><br><span class="line"># basedir = .....</span><br><span class="line">#datadir = .....</span><br><span class="line"># port = .....</span><br><span class="line"># server_id = .....</span><br><span class="line"># socket = .....</span><br></pre></td></tr></table></figure><p>其中 我们需要关注的 <code>log_bin</code>  <code>server_id</code> 这两个，配置到你需要的地方即可，<code>server_id</code> 可以随意，主从不要冲突即可，个人配置如下</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">log_bin=/data/logs/mysql/mysql-bin.log   # binlog日志文件</span><br><span class="line">server_id=1</span><br></pre></td></tr></table></figure><p>重启一下MySQL，然后进入数据库，查看一下bin-log的状态</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">mysql&gt; show variables like &apos;log_bin%&apos;;</span><br><span class="line">+---------------------------------+-----------------------------+</span><br><span class="line">| Variable_name                   | Value                       |</span><br><span class="line">+---------------------------------+-----------------------------+</span><br><span class="line">| log_bin                         | ON                          |</span><br><span class="line">| log_bin_basename                | /data/mysql/mysql-bin       |</span><br><span class="line">| log_bin_index                   | /data/mysql/mysql-bin.index |</span><br><span class="line">| log_bin_trust_function_creators | OFF                         |</span><br><span class="line">| log_bin_use_v1_row_events       | OFF                         |</span><br><span class="line">+---------------------------------+-----------------------------+</span><br></pre></td></tr></table></figure><p>其中 <code>log_bin</code> 的值为<code>On</code> 即表明已经开启了 <code>log_bin</code> </p><h1 id="开始手贱吧"><a href="#开始手贱吧" class="headerlink" title="开始手贱吧"></a>开始手贱吧</h1><h2 id="制作点假数据"><a href="#制作点假数据" class="headerlink" title="制作点假数据"></a>制作点假数据</h2><p>我们开始创建点假数据，用于我们的测试</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">mysql&gt; create database test;</span><br><span class="line">mysql&gt; use test;</span><br><span class="line">mysql&gt; create table binlog_test (id int unsigned not null);</span><br><span class="line">mysql&gt; insert into binlog_test values (1), (2), (3), (4), (5);</span><br></pre></td></tr></table></figure><p>先来5条数据，然后我们备份一下这个表，备份之前，先介绍一下<code>--master-data</code>这个参数</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">--master-data[=#]   This causes the binary log position and filename to be</span><br><span class="line">                    appended to the output. If equal to 1, will print it as a</span><br><span class="line">                    CHANGE MASTER command; if equal to 2, that command will</span><br><span class="line">                    be prefixed with a comment symbol. </span><br><span class="line">                    这个参数会在导出的文件中加入此时bin-log的偏移文件和偏移量，</span><br><span class="line">                    如果这个值是1的，会打印出这条命令，如果等于2的话，这条命令</span><br><span class="line">                    将被注释掉</span><br></pre></td></tr></table></figure><p>我们在备份的时候，需要加上这条参数，并将其设置为2，以方便我们查找我们丢失的那部分数据</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">mysqldump -uroot -p --master-data=2 test &gt; test.sql</span><br></pre></td></tr></table></figure><p>备份完成了，我们再加点假数据，最后看一下这些数据会不会还在</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">mysql&gt; insert into binlog_test values (6), (7), (8), (9), (10);</span><br></pre></td></tr></table></figure><h2 id="手贱吧"><a href="#手贱吧" class="headerlink" title="手贱吧"></a>手贱吧</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">mysql&gt; delete from binlog_test;</span><br><span class="line">mysql&gt; drop table binlog_test;</span><br></pre></td></tr></table></figure><p>这样的话，binlog_test表的数据应该全部都没有了。</p><h1 id="开始正文了-恢复数据"><a href="#开始正文了-恢复数据" class="headerlink" title="开始正文了-恢复数据"></a>开始正文了-恢复数据</h1><ol><li><p>先查看一下 备份的偏移</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">λ  /data/mysql  more test.sql </span><br><span class="line">-- MySQL dump 10.13  Distrib 5.7.18, for Linux (x86_64)</span><br><span class="line">--</span><br><span class="line">-- Host: localhost    Database: test</span><br><span class="line">-- ------------------------------------------------------</span><br><span class="line">-- Server version5.7.18-log</span><br><span class="line"></span><br><span class="line">/*!40101 SET @OLD_CHARACTER_SET_CLIENT=@@CHARACTER_SET_CLIENT */;</span><br><span class="line">/*!40101 SET @OLD_CHARACTER_SET_RESULTS=@@CHARACTER_SET_RESULTS */;</span><br><span class="line">/*!40101 SET @OLD_COLLATION_CONNECTION=@@COLLATION_CONNECTION */;</span><br><span class="line">/*!40101 SET NAMES utf8 */;</span><br><span class="line">/*!40103 SET @OLD_TIME_ZONE=@@TIME_ZONE */;</span><br><span class="line">/*!40103 SET TIME_ZONE=&apos;+00:00&apos; */;</span><br><span class="line">/*!40014 SET @OLD_UNIQUE_CHECKS=@@UNIQUE_CHECKS, UNIQUE_CHECKS=0 */;</span><br><span class="line">/*!40014 SET @OLD_FOREIGN_KEY_CHECKS=@@FOREIGN_KEY_CHECKS, FOREIGN_KEY_CHECKS=0 */;</span><br><span class="line">/*!40101 SET @OLD_SQL_MODE=@@SQL_MODE, SQL_MODE=&apos;NO_AUTO_VALUE_ON_ZERO&apos; */;</span><br><span class="line">/*!40111 SET @OLD_SQL_NOTES=@@SQL_NOTES, SQL_NOTES=0 */;</span><br><span class="line"></span><br><span class="line">--</span><br><span class="line">-- Position to start replication or point-in-time recovery from</span><br><span class="line">--</span><br><span class="line"></span><br><span class="line">-- CHANGE MASTER TO MASTER_LOG_FILE=&apos;mysql-bin.000002&apos;, MASTER_LOG_POS=627;</span><br></pre></td></tr></table></figure><p>从备份的sql文件可以看到，我们备份的偏移文件是 <em>mysql-bin.000002</em> ，偏移量是 <em>627</em></p></li><li><p>查看手贱命令的偏移</p><p>我们这时候应该就是查找一下 我们执行的delete操作的偏移</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">λ  /data/mysql  mysqlbinlog --base64-output=decode-rows mysql-bin.000002 | grep Delete -8</span><br><span class="line"># at 974</span><br><span class="line">#180717 16:37:59 server id 1  end_log_pos 1046 CRC32 0x19b80686 Querythread_id=6exec_time=0error_code=0</span><br><span class="line">SET TIMESTAMP=1531816679/*!*/;</span><br><span class="line">BEGIN</span><br><span class="line">/*!*/;</span><br><span class="line"># at 1046</span><br><span class="line">#180717 16:37:59 server id 1  end_log_pos 1100 CRC32 0x2daa51e1 Table_map: `test`.`binlog_test` mapped to number 514</span><br><span class="line"># at 1100</span><br><span class="line">#180717 16:37:59 server id 1  end_log_pos 1185 CRC32 0x05ebafa5 Delete_rows: table id 514 flags: STMT_END_F</span><br><span class="line"># at 1185</span><br><span class="line">#180717 16:37:59 server id 1  end_log_pos 1216 CRC32 0x56c7fe9e Xid = 80</span><br><span class="line">COMMIT/*!*/;</span><br><span class="line"># at 1216</span><br><span class="line">#180717 16:44:14 server id 1  end_log_pos 1281 CRC32 0xa285c84c Anonymous_GTIDlast_committed=4sequence_number=5</span><br><span class="line">SET @@SESSION.GTID_NEXT= &apos;ANONYMOUS&apos;/*!*/;</span><br><span class="line"># at 1281</span><br><span class="line">#180717 16:44:14 server id 1  end_log_pos 1405 CRC32 0x4474e0a7 Querythread_id=10exec_time=0error_code=0</span><br></pre></td></tr></table></figure><p>我们可以看到，在第10行的时候进行了删除操作，在第8行进行了表的map映射查找，那我们这时候，将结束的偏移就可以定位到 <em>mysql-bin.000002</em> 的 <em>1100</em> position</p></li><li><p>生成备份到手贱这段时间的数据</p><p>由于，我们仅仅对test库进行处理，所以我们可以在使用<code>mysqbinlog</code> 处理的时候指定<code>test</code> 库即可，主要用到了以下几个参数，可参考</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">λ  /data/mysql  mysqlbinlog --help | grep position -8</span><br><span class="line"> -j, --start-position=# </span><br><span class="line">                      Start reading the binlog at position N. Applies to the</span><br><span class="line">                      first binlog passed on the command line.</span><br><span class="line"> --stop-position=#   Stop reading the binlog at position N. Applies to the</span><br><span class="line">                      last binlog passed on the command line.</span><br><span class="line"> -d, --database=name List entries for just this database (local log only).</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">mysqlbinlog --start-position=627 --stop-position=1100 --database=test  mysql-bin.000002 &gt; binlog_test_drop.sql</span><br></pre></td></tr></table></figure><p>这样，我们需要的原始备份文件，和中间缺失的时间段的备份文件就都生成好了，下一步就可以恢复了</p></li><li><p>恢复</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">mysql -uroot -p test &lt; test.sql</span><br><span class="line"> mysql -uroot -p test &lt; binlog_test_drop.sql</span><br></pre></td></tr></table></figure></li><li><p>查看一下吧</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">mysql&gt; select * from binlog_test;</span><br><span class="line">+----+</span><br><span class="line">| id |</span><br><span class="line">+----+</span><br><span class="line">|  1 |</span><br><span class="line">|  2 |</span><br><span class="line">|  3 |</span><br><span class="line">|  4 |</span><br><span class="line">|  5 |</span><br><span class="line">|  6 |</span><br><span class="line">|  7 |</span><br><span class="line">|  8 |</span><br><span class="line">|  9 |</span><br><span class="line">| 10 |</span><br><span class="line">+----+</span><br></pre></td></tr></table></figure><p>至此，基本大功告成了，当然bin-log不仅仅是用来恢复数据的，上文也讲过了，MySQL的主从就是要依靠他来完成的，下一篇文章<a href="http://tyloafer.github.io/posts/42030/">《MySQL主从配置》</a>将会简单的介绍一下</p></li></ol>]]></content>
      
      
      <categories>
          
          <category> DataBase </category>
          
      </categories>
      
      
        <tags>
            
            <tag> MySQL </tag>
            
            <tag> DataBase </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Nginx倒腾笔记（四）：rewrite使用介绍</title>
      <link href="/posts/25652/"/>
      <url>/posts/25652/</url>
      
        <content type="html"><![CDATA[<h2 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h2><table><thead><tr><th>key</th><th>value</th></tr></thead><tbody><tr><td>语法:</td><td><code>rewrite regex replacement [flag];</code></td></tr><tr><td>默认值:</td><td>—</td></tr><tr><td>上下文:</td><td><code>server</code>, <code>location</code>, <code>if</code></td></tr></tbody></table><a id="more"></a><h2 id="flag"><a href="#flag" class="headerlink" title="flag"></a>flag</h2><ul><li><code>last</code>       # 停止执行当前这一轮的<code>ngx_http_rewrite_module</code>指令集，然后查找匹配改变后URI的新location；</li><li><code>break</code>      # 停止执行当前这一轮的<code>ngx_http_rewrite_module</code>指令集；</li><li><code>redirect</code>         # 在replacement字符串未以“<code>http://</code>”或“<code>https://</code>”开头时，使用返回状态码为302的临时重定向；</li><li><code>permanent</code>        # 返回状态码为301的永久重定向。</li></ul><h2 id="例"><a href="#例" class="headerlink" title="例"></a>例</h2><p>针对于<code>last</code> 和 <code>break</code> 举例</p><ol><li><p>先测试last</p><p>nginx配置</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">location ~ /rewrite/last &#123;</span><br><span class="line">    rewrite .* /rewrite/break.html last;</span><br><span class="line">&#125;   </span><br><span class="line"></span><br><span class="line">location ~ /rewrite/break &#123;</span><br><span class="line">retorn 200 &apos;break&apos;;</span><br><span class="line">    rewrite .* /last.html break;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>GET <a href="http://test.tyloafer.cn/rewrite/last" target="_blank" rel="noopener">http://test.tyloafer.cn/rewrite/last</a></p><p>结果： break</p></blockquote><p>上面结果表明，当我们第一次请求匹配到 <code>/rewrite/last</code> 的时候，我们此时应该把uri 重写成了 <code>http://test.tyloafer.cn/rewrite/break.html</code>, 然后拿着这个uri后找 nginx解析，从而匹配到了 第二个location</p><p>即， 当我们使用 <code>last</code> 的时候，nginx会拿着解析后的uri再次进行解析</p></li><li><p>再测试last</p><p>nginx配置</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">location ~ /rewrite/last &#123;</span><br><span class="line">return 200 'last';</span><br><span class="line">    rewrite .* /rewrite/break.html last;</span><br><span class="line">&#125;   </span><br><span class="line"></span><br><span class="line">location ~ /rewrite/break &#123;</span><br><span class="line">    rewrite .* /last.html break;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>last.html</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">this is last.html</span><br></pre></td></tr></table></figure><blockquote><p>GET <a href="http://test.tyloafer.cn/rewrite/break" target="_blank" rel="noopener">http://test.tyloafer.cn/rewrite/break</a></p><p>结果： this is last.html</p></blockquote><p>上面结果表明，当我们第一次请求匹配到 <code>/rewrite/break的时候，我们此时应该把uri 重写成了</code><a href="http://test.tyloafer.cn/rewrite/blast.html`" target="_blank" rel="noopener">http://test.tyloafer.cn/rewrite/blast.html`</a>, 然后拿着这个uri后， 直接去找相应的文件了</p><p>即， 当我们使用 <code>break</code> 的时候，nginx会拿着解析后的uri不在解析，就随他去吧</p></li></ol>]]></content>
      
      
      <categories>
          
          <category> Nginx </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Nginx </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>在Vultr（centos7）上安装shadowsock及Google BBR实现全速翻墙</title>
      <link href="/posts/561/"/>
      <url>/posts/561/</url>
      
        <content type="html"><![CDATA[<p>对于程序猿来说，百度就是一个坑的存在，找一个问题，前面几页都是抄袭、雷同的问题，还有若干的百度经验，但是，对于近期的墙是越来越厚了，各种ss账号都失效了，无奈开始自己动手搭梯子吧。通过网上各种对比后，最后选了了<a href="https://www.vultr.com/?ref=7290537" target="_blank" rel="noopener"> Vultr</a> , 安装Google BBR后基本可以满速翻墙，而且，最强大的是，可以更换IP，现在最便宜的套餐 2.5$每月，500G的流量，也是足够了</p><blockquote><p><a href="https://www.vultr.com/?ref=7540935" target="_blank" rel="noopener">Vultr官网注册地址</a></p></blockquote><a id="more"></a><p>下面开始介绍安装配置过程，当然不仅局限于 Vultr的服务器，CentOS7的都可以参考。</p><h1 id="安装pip"><a href="#安装pip" class="headerlink" title="安装pip"></a>安装pip</h1><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">yum install python python-pip</span><br><span class="line">pip install --upgrade pip</span><br></pre></td></tr></table></figure><h1 id="安装配置shadowsock"><a href="#安装配置shadowsock" class="headerlink" title="安装配置shadowsock"></a>安装配置shadowsock</h1><h2 id="安装shadowsock"><a href="#安装shadowsock" class="headerlink" title="安装shadowsock"></a>安装shadowsock</h2><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">pip install shadowsocks</span><br></pre></td></tr></table></figure><p>这样就安装完成了shadowsock</p><h2 id="配置shadowsock"><a href="#配置shadowsock" class="headerlink" title="配置shadowsock"></a>配置shadowsock</h2><p>首先要创建配置文件，然后shadowsock用这个配置文件启动即可</p><p>个人习惯将配置文件放在 <code>/etc</code> 目录下</p><p>所以，这里首先创建文件 <code>/etc/shadowsocks.json</code> ，并添加一下内容</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">      &quot;server&quot;:&quot;0.0.0.0&quot;,</span><br><span class="line">      &quot;server_port&quot;:2082,</span><br><span class="line">      &quot;local_port&quot;:1080,</span><br><span class="line">      &quot;password&quot;:&quot;yourpass&quot;,</span><br><span class="line">      &quot;timeout&quot;:600,</span><br><span class="line">      &quot;method&quot;:&quot;rc4-md5&quot;</span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure><p>如果想要创建多用户的， 可以使用下面的配置文件格式</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">#### 多用户版本</span><br><span class="line">&#123;</span><br><span class="line">    &quot;server&quot;:&quot;0.0.0.0&quot;,</span><br><span class="line">    &quot;local_port&quot;:1080,</span><br><span class="line">    &quot;port_password&quot;:&#123;</span><br><span class="line">         &quot;8989&quot;:&quot;password0&quot;,</span><br><span class="line">         &quot;9001&quot;:&quot;password1&quot;,</span><br><span class="line">         &quot;9002&quot;:&quot;password2&quot;,</span><br><span class="line">         &quot;9003&quot;:&quot;password3&quot;,</span><br><span class="line">         &quot;9004&quot;:&quot;password4&quot;</span><br><span class="line">    &#125;,</span><br><span class="line">    &quot;timeout&quot;:300,</span><br><span class="line">    &quot;method&quot;:&quot;aes-256-cfb&quot;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>说明：</p><ul><li><code>method</code>为加密方法，可选<code>aes-128-cfb, aes-192-cfb, aes-256-cfb, bf-cfb, cast5-cfb, des-cfb, rc4-md5, chacha20, salsa20, rc4, table</code></li><li><code>server_port</code>  为服务监听端口， 这个需要在 vultr或者服务器管理界面开启</li><li><code>port_password</code> 为多用户的时候，配置的 port: pass 的json串</li></ul><h2 id="配置自启动"><a href="#配置自启动" class="headerlink" title="配置自启动"></a>配置自启动</h2><p>新建启动脚本文件<code>/etc/systemd/system/shadowsocks.service</code>，内容如下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">[Unit]</span><br><span class="line">Description=Shadowsocks</span><br><span class="line"></span><br><span class="line">[Service]</span><br><span class="line">TimeoutStartSec=0</span><br><span class="line">ExecStart=/usr/bin/ssserver -c /etc/shadowsocks.json</span><br><span class="line"></span><br><span class="line">[Install]</span><br><span class="line">WantedBy=multi-user.target</span><br></pre></td></tr></table></figure><p>执行以下命令启动 shadowsocks 服务：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">systemctl enable shadowsocks  # 启用服务</span><br><span class="line">systemctl start shadowsocks   # 启动服务</span><br><span class="line">systemctl stop shadowsocks   # 停止服务</span><br></pre></td></tr></table></figure><p>注： 如果使用多用户的模式，有可能无法使用 system 来启动，可以使用下面的命令来启动</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">/usr/bin/ssserver -c /etc/shadowsocks.json -d start # 启动</span><br><span class="line">/usr/bin/ssserver -c /etc/shadowsocks.json -d stop  # 停止</span><br><span class="line">echo &quot;/usr/bin/ssserver -c /etc/shadowsocks.json -d start&quot; &gt;&gt; /etc/rc.local # 添加到开机自启动</span><br></pre></td></tr></table></figure><h1 id="安装BBR加速"><a href="#安装BBR加速" class="headerlink" title="安装BBR加速"></a>安装BBR加速</h1><blockquote><p><strong>注意: </strong>需要内核4.9及以上版本，可使用<code>uname -r</code>查看。</p></blockquote><p>最简单的方法就是使用Google BBR一键安装脚本。</p><ol><li><p>获取脚本并执行(root)</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">wget --no-check-certificate https://github.com/teddysun/across/raw/master/bbr.sh</span><br><span class="line">sh ./bbr.sh</span><br></pre></td></tr></table></figure></li><li><p>查看内核版本是否 &gt; 4.9 </p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">uname -r</span><br></pre></td></tr></table></figure></li><li><p>执行 <code>sysctl net.ipv4.tcp_available_congestion_control</code> ， 查看是否返回</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">net.ipv4.tcp_available_congestion_control = reno cubic bbr</span><br></pre></td></tr></table></figure></li><li><p>执行<code>sysctl net.core.default_qdisc</code> ， 查看是否返回</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">net.core.default_qdisc = fq</span><br></pre></td></tr></table></figure></li><li><p>执行 <code>lsmod | grep bbr</code>， 返回值有tcp_bbr 即已启动</p></li></ol><p>安装完成后，脚本会提示需要重启 VPS，输入 y 并回车后重启。</p><h1 id="附"><a href="#附" class="headerlink" title="附"></a>附</h1><p>近期的服务器老是被尝试暴力破解，然后ip被封，提供一下脚本进行处理</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">#! /bin/bash</span><br><span class="line">cat /var/log/secure|awk &apos;/Failed/&#123;print $(NF-3)&#125;&apos;|sort|uniq -c|awk &apos;&#123;print $2&quot;=&quot;$1;&#125;&apos; &gt; /home/sxdgy/lastb</span><br><span class="line">for i in `cat  /home/sxdgy/lastb`</span><br><span class="line">do</span><br><span class="line">  IP=`echo $i |awk -F= &apos;&#123;print $1&#125;&apos;`</span><br><span class="line">  NUM=`echo $i|awk -F= &apos;&#123;print $2&#125;&apos;`</span><br><span class="line">  if [ $&#123;#NUM&#125; -gt 1 ]; then</span><br><span class="line">    grep $IP /etc/hosts.deny &gt; /dev/null</span><br><span class="line">    if [ $? -gt 0 ];then</span><br><span class="line">      echo &quot;sshd:$IP:deny&quot; &gt;&gt; /etc/hosts.deny</span><br><span class="line">    fi</span><br><span class="line">  fi</span><br><span class="line">done</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 科学上网 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 科学上网 </tag>
            
            <tag> ShadowSock </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Nginx倒腾笔记（三）：条件判断及运算符</title>
      <link href="/posts/211/"/>
      <url>/posts/211/</url>
      
        <content type="html"><![CDATA[<h2 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h2><table><thead><tr><th>key</th><th>value</th></tr></thead><tbody><tr><td>语法:</td><td><code>if (condition) { ... }</code></td></tr><tr><td>默认值:</td><td>—</td></tr><tr><td>上下文:</td><td><code>server</code>, <code>location</code></td></tr></tbody></table><a id="more"></a><h2 id="condition"><a href="#condition" class="headerlink" title="condition"></a>condition</h2><ul><li>变量名；如果变量值为空或者是以“<code>0</code>”开始的字符串，则条件为假；</li><li>使用“<code>=</code>”和“<code>!=</code>”运算符比较变量和字符串；</li><li>使用“<code>~</code>”（大小写敏感）和“<code>~*</code>”（大小写不敏感）运算符匹配变量和正则表达式。正则表达式可以包含匹配组，匹配结果后续可以使用变量<code>$1</code>..<code>$9</code>引用。如果正则表达式中包含字符“<code>}</code>”或者“<code>;</code>”，整个表达式应该被包含在单引号或双引号的引用中。</li><li>使用“<code>-f</code>”和“<code>!-f</code>”运算符检查文件是否存在；</li><li>使用“<code>-d</code>”和“<code>!-d</code>”运算符检查目录是否存在；</li><li>使用“<code>-e</code>”和“<code>!-e</code>”运算符检查文件、目录或符号链接是否存在；</li><li>使用“<code>-x</code>”和“<code>!-x</code>”运算符检查可执行文件；</li></ul><h2 id="例"><a href="#例" class="headerlink" title="例"></a>例</h2><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">if ($http_user_agent ~ MSIE) &#123;</span><br><span class="line">    return 200 'IE &gt;_&gt;';</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">if ($http_cookie ~* "id=([^;]+)(?:;|$)") &#123;</span><br><span class="line">    set $id $1;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">if ($http_refer != 'test.tyloafer.cn') &#123;</span><br><span class="line">    return 403;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">if ($vip) &#123;</span><br><span class="line">    limit_rate 10k;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">if (!-e $request_uri) &#123;</span><br><span class="line">    rewrite /(.*)$ /index.php?r=$request_uri;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="扩展（逻辑运算实现）"><a href="#扩展（逻辑运算实现）" class="headerlink" title="扩展（逻辑运算实现）"></a>扩展（逻辑运算实现）</h2><p>有时间为了实现需求，我们可能避免不了要使用逻辑运算， 但是nginx并未提供，所以，我们这时候只有通过 设置变量的值 来变相的实现逻辑运算了</p><p>需求</p><figure class="highlight nginx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="attribute">if</span> (!-e <span class="variable">$request_uri</span> &amp;&amp; !-d <span class="variable">$request_uri</span>) &#123;</span><br><span class="line">    <span class="attribute">return</span> <span class="number">404</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>实现</p><figure class="highlight nginx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="attribute">set</span> <span class="variable">$flag</span>  <span class="number">0</span>;</span><br><span class="line"><span class="attribute">if</span> (!-e <span class="variable">$request_uri</span>) &#123;</span><br><span class="line">    <span class="attribute">set</span> set <span class="variable">$flag</span> <span class="string">"<span class="variable">$&#123;flag&#125;</span>1"</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="attribute">if</span> (!-d <span class="variable">$request_uri</span>) &#123;</span><br><span class="line">    <span class="attribute">set</span> <span class="variable">$flag</span> <span class="string">"<span class="variable">$&#123;flag&#125;</span>1"</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="attribute">if</span> (<span class="variable">$flag</span> = <span class="string">'011'</span>) &#123;</span><br><span class="line">    <span class="attribute">return</span> <span class="number">404</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> Nginx </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Nginx </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Nginx倒腾笔记（二）：状态码</title>
      <link href="/posts/48459/"/>
      <url>/posts/48459/</url>
      
        <content type="html"><![CDATA[<p>这里记录了一下Nginx使用过程中常见的状态码，仅仅是做了一下解释，如果遇到下面的问题，可以到根据所代表的意义，去相应的应用程序查看 error log，以此来找出对应的解决方案</p><a id="more"></a><table><thead><tr><th>类别</th><th>状态码</th><th>状态意义</th></tr></thead><tbody><tr><td><strong>消息类(1字头)</strong></td><td></td><td></td></tr><tr><td><strong>成功类（2字头）</strong></td><td>200</td><td>成功处理请求</td></tr><tr><td><strong>重定向累（3字头）</strong></td><td>301</td><td>永久重定向</td></tr><tr><td></td><td>302</td><td>临时重定向</td></tr><tr><td></td><td>304</td><td>未修改，走缓存</td></tr><tr><td><strong>请求错误类（4字头）</strong></td><td>400</td><td>服务器不理解请求的语法。</td></tr><tr><td></td><td>401</td><td>请求要求身份验证。 对于需要登录的网页，服务器可能返回此响应。</td></tr><tr><td></td><td>403</td><td>服务器拒绝请求</td></tr><tr><td></td><td>404</td><td>没有找到资源</td></tr><tr><td></td><td>499</td><td>客户端主动断开连接</td></tr><tr><td><strong>服务器错误类（5字头）</strong></td><td>500</td><td>服务器遇到错误，无法完成请求</td></tr><tr><td></td><td>502</td><td>网关出错</td></tr><tr><td></td><td>504</td><td>服务端处理请求超时</td></tr></tbody></table>]]></content>
      
      
      <categories>
          
          <category> Nginx </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Nginx </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Nginx倒腾笔记（一）：变量</title>
      <link href="/posts/62480/"/>
      <url>/posts/62480/</url>
      
        <content type="html"><![CDATA[<p>nginx在使用过程中最基础的应该就是 变量了， 不然在rewite或location匹配的时候，有可能就无从下手了，在这里，个人整理了一下nginx的变量，并做了一下简单的测试，仅供参考</p><a id="more"></a><h1 id="内置变量"><a href="#内置变量" class="headerlink" title="内置变量"></a>内置变量</h1><h2 id="介绍"><a href="#介绍" class="headerlink" title="介绍"></a>介绍</h2><ul><li><p>$args ： 这个变量等于请求行中的参数，同\$query_string</p></li><li><p>$content_length ： 请求头中的Content-length字段。</p></li><li><p>$content_type ： 请求头中的Content-Type字段。</p></li><li><p>$document_root ： 当前请求在root指令中指定的值。</p></li><li><p>$host ： 请求主机头字段，否则为服务器名称。</p></li><li><p>$http_user_agent ： 客户端agent信息</p></li><li><p>$http_cookie ： 客户端cookie信息</p></li><li><p>$limit_rate ： 这个变量可以限制连接速率。</p></li><li><p>$request_method ： 客户端请求的动作，通常为GET或POST。</p></li><li><p>$remote_addr ： 客户端的IP地址。</p></li><li><p>$remote_port ： 客户端的端口。</p></li><li><p>$remote_user ： 已经经过Auth Basic Module验证的用户名。</p></li><li><p>$request_filename ： 当前请求的文件路径，由root或alias指令与URI请求生成。</p></li><li><p>$scheme ： HTTP方法（如http，https）。</p></li><li><p>$server_protocol ： 请求使用的协议，通常是HTTP/1.0或HTTP/1.1。</p></li><li><p>$server_addr ： 服务器地址，在完成一次系统调用后可以确定这个值。</p></li><li><p>$server_name ： 服务器名称。</p></li><li><p>$server_port ： 请求到达服务器的端口号。</p></li><li><p>$request_uri ： 包含请求参数的原始URI，不包含主机名，如：”/foo/bar.php?arg=baz”。</p></li><li><p>$uri ： 不带请求参数的当前URI，\$uri不包含主机名，如”/foo/bar.html”。</p></li><li><p>\$document_uri ： 与$uri相同。</p></li></ul><h2 id="例"><a href="#例" class="headerlink" title="例"></a>例</h2><p>我们以GET方式请求 <code>http://test.tyloafer.cn/variable?a=1&amp;b=2&amp;c=3</code> 为例</p><p>nginx配置如下</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line">location = /variable &#123;</span><br><span class="line">    add_header  Content-Type &apos;text/html; charset=utf-8&apos;;</span><br><span class="line">    return 200 &quot;</span><br><span class="line">        args = $args&lt;br /&gt;</span><br><span class="line">        binary_remote_addr = $binary_remote_addr&lt;br /&gt;</span><br><span class="line">        body_bytes_sent = $body_bytes_sent&lt;br /&gt;</span><br><span class="line">        content_length = $content_length&lt;br /&gt;</span><br><span class="line">        content_type= $content_type&lt;br /&gt;</span><br><span class="line">        document_root = $document_root&lt;br /&gt;</span><br><span class="line">        document_uri = $document_uri&lt;br /&gt;</span><br><span class="line">        host = $host&lt;br /&gt;</span><br><span class="line">        hostname   = $hostname&lt;br /&gt;</span><br><span class="line">        http_user_agent = $http_user_agent&lt;br /&gt;</span><br><span class="line">        is_args = $is_args&lt;br /&gt;</span><br><span class="line">        limit_rate  = $limit_rate&lt;br /&gt;</span><br><span class="line">        nginx_version  = $nginx_version&lt;br /&gt;</span><br><span class="line">        query_string  = $query_string&lt;br /&gt;</span><br><span class="line">        remote_addr  = $remote_addr&lt;br /&gt;</span><br><span class="line">        remote_port  = $remote_port&lt;br /&gt;</span><br><span class="line">        request_filename = $request_filename&lt;br /&gt;</span><br><span class="line">        request_body  = $request_body&lt;br /&gt;</span><br><span class="line">        request_body_file  = $request_body_file&lt;br /&gt;</span><br><span class="line">        request_completion  = $request_completion&lt;br /&gt;</span><br><span class="line">        request_method  = $request_method&lt;br /&gt;</span><br><span class="line">        request_uri  = $request_uri&lt;br /&gt;</span><br><span class="line">        scheme  = $scheme&lt;br /&gt;</span><br><span class="line">        server_addr  = $server_addr&lt;br /&gt;</span><br><span class="line">        server_name  = $server_name&lt;br /&gt;</span><br><span class="line">        server_port  = $server_port&lt;br /&gt;</span><br><span class="line">        server_protocol  = $server_protocol&lt;br /&gt;&quot;;</span><br><span class="line">    </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>GET <a href="http://test.tyloafer.cn/variable?a=1&amp;b=2&amp;c=3" target="_blank" rel="noopener">http://test.tyloafer.cn/variable?a=1&amp;b=2&amp;c=3</a></p></blockquote><p>返回</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line">args = a=1&amp;b=2&amp;c=3</span><br><span class="line">binary_remote_addr = s�i�</span><br><span class="line">body_bytes_sent = 0</span><br><span class="line">content_length = </span><br><span class="line">content_type= </span><br><span class="line">document_root = /usr/share/nginx/html</span><br><span class="line">document_uri = /variable</span><br><span class="line">host = test.tyloafer.cn</span><br><span class="line">hostname = vm_248_128_centos</span><br><span class="line">http_user_agent = Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/66.0.3359.170 Safari/537.36</span><br><span class="line">is_args = ?</span><br><span class="line">limit_rate = 0</span><br><span class="line">nginx_version = 1.12.2</span><br><span class="line">query_string = a=1&amp;b=2&amp;c=3</span><br><span class="line">remote_addr = 115.216.105.144</span><br><span class="line">remote_port = 10212</span><br><span class="line">request_filename = /usr/share/nginx/html/variable</span><br><span class="line">request_body = </span><br><span class="line">request_body_file = </span><br><span class="line">request_completion = </span><br><span class="line">request_method = GET</span><br><span class="line">request_uri = /variable?a=1&amp;b=2&amp;c=3</span><br><span class="line">scheme = http</span><br><span class="line">server_addr = 10.105.248.128</span><br><span class="line">server_name = test.tyloafer.cn</span><br><span class="line">server_port = 80</span><br><span class="line">server_protocol = HTTP/1.1</span><br></pre></td></tr></table></figure><h1 id="自定义变量"><a href="#自定义变量" class="headerlink" title="自定义变量"></a>自定义变量</h1><p>nginx配置如下</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">location ~ /self-variable &#123;</span><br><span class="line">    set $path &apos;tyloafer&apos;;</span><br><span class="line">    return 200 $path;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>GET <a href="http://test.tyloafer.cn/self-variable" target="_blank" rel="noopener">http://test.tyloafer.cn/self-variable</a></p></blockquote><p>返回</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">tyloafer</span><br></pre></td></tr></table></figure><p>注：nginx的变量赋值跟 <em>shell</em> 是一样的，一样也可以使用 <em>{}</em> ，例： ${path} </p><h1 id="自动设置的变量"><a href="#自动设置的变量" class="headerlink" title="自动设置的变量"></a>自动设置的变量</h1><p>我们在使用正则匹配的时候，会自动将匹配结果 赋值给 \$1 \$2 这样的 \${<em>num</em>} 这样类型的变量</p><p>nginx配置如下</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">location ~ /self-variable(/)(.*)$ &#123;            </span><br><span class="line">     set $path &apos;tyloafer&apos;;                      </span><br><span class="line">     return 200 &quot;path = $path , 1 = $1 , 2 = $2&quot;;</span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure><blockquote><p>GET <a href="http://test.tyloafer.cn/self-variable/haha" target="_blank" rel="noopener">http://test.tyloafer.cn/self-variable/haha</a></p></blockquote><p>返回</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">path = tyloafer , 1 = / , 2 = haha</span><br></pre></td></tr></table></figure><p>例：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">location ~ /self-variable(/)(.*)$ &#123;            </span><br><span class="line">    set $path &apos;tyloafer&apos;;</span><br><span class="line">    if ($request_uri ~ &apos;haha&apos;) &#123;</span><br><span class="line">        return 200 $1;</span><br><span class="line">    &#125; </span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure><p>这时候 在进行第一次location正则匹配是产生的\$1， 在进行第二次 <code>$request_uri ~ &#39;haha&#39;</code> 正则匹配的时候会被覆盖，所以这时候，返回的是空白的，并不是上面的 <code>/</code></p>]]></content>
      
      
      <categories>
          
          <category> Nginx </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Nginx </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>记一次被黑的经历</title>
      <link href="/posts/52665/"/>
      <url>/posts/52665/</url>
      
        <content type="html"><![CDATA[<p>某天的某时某刻，我收到了服务商的邮件，告知我出网流量过大，我次奥，我的博客站（另一个，非github）已经好久没有维护了，更何况上面也就几篇刚入门的时候写的几篇小打小闹的文章，怎么会那么火爆？</p><p>当然没有那么火爆了，登上去后发现有个程序资源基本占用100%，好吗，毫无压力的被黑了。。。</p><a id="more"></a><h1 id="处理"><a href="#处理" class="headerlink" title="处理"></a>处理</h1><p>幸好这个程序并不是什么复杂的程序，也仅仅就是一个脚本，把我的服务器当成了肉鸡，攻击别人的服务器，把这个脚本kill并删除后，服务器的load和cpu也就下来了，幸好不是什么牛逼或恶意点的病毒</p><h1 id="分析"><a href="#分析" class="headerlink" title="分析"></a>分析</h1><p>通过<code>last</code> 和 <code>lastb</code> 这两个命令，发现近期有很多尝试登陆，那么攻击手段也就明了了，肉鸡的暴力破解</p><h1 id="处理-1"><a href="#处理-1" class="headerlink" title="处理"></a>处理</h1><h1 id="修改密码并仅允许通过私钥登陆"><a href="#修改密码并仅允许通过私钥登陆" class="headerlink" title="修改密码并仅允许通过私钥登陆"></a>修改密码并仅允许通过私钥登陆</h1><p>其实，Linux服务器的密码登录并不是一个明智的选择，我们这里可以把用户名密码登录给关了，然后通过私钥登陆</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">vim /etc/ssh/sshd_config</span><br></pre></td></tr></table></figure><p>在这个文件里面有两个配置，分别按照如下设置即可</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">RSAAuthentication yes      # RSA 验证</span><br><span class="line">PubkeyAuthentication yes   # 公钥验证</span><br><span class="line">PasswordAuthentication no  # 不允许密码登录</span><br></pre></td></tr></table></figure><p>然后我们需要将自己的公钥添加到 公钥验证列表文件里面</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">cat id_rsa.pub &gt;&gt; ~/.ssh/authorized_keys</span><br></pre></td></tr></table></figure><h2 id="添加IP黑名单"><a href="#添加IP黑名单" class="headerlink" title="添加IP黑名单"></a>添加IP黑名单</h2><p>上述的攻击主要就是找很多肉鸡来宝鸡破解密码，而这些IP大部分都是黑名单里面的，所以我们时刻更新最新的IP黑名单，那么就可以再加上一层防御</p><p>Linux上黑名单可以直接添加到 <code>/etc/hosts.deny</code> 里面，这样就可以拦截了，但是我们不可能每天去更新啊，所以，我们可以写一个脚本，放在crontab里面执行一下，这样就可以继续懒下去了，这里分享一个东北大学网络中心的脚本<code>fetch_neusshbl.sh</code></p><p>直接附上代码：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#!/bin/sh</span></span><br><span class="line"><span class="comment"># Fetch NEU SSH Black list to /etc/hosts.deny</span></span><br><span class="line"><span class="comment">#</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">export</span> PATH=/bin:/sbin:/usr/bin:/usr/sbin:/usr/<span class="built_in">local</span>/bin:/usr/<span class="built_in">local</span>/sbin</span><br><span class="line"></span><br><span class="line">URL=http://antivirus.neu.edu.cn/ssh/lists/neu_sshbl_hosts.deny.gz</span><br><span class="line">HOSTSDENY=/etc/hosts.deny</span><br><span class="line">TMP_DIR=/dev/shm</span><br><span class="line">FILE=hosts.deny</span><br><span class="line"></span><br><span class="line">[ -d <span class="variable">$TMP_DIR</span> ] || TMP_DIR=/tmp</span><br><span class="line"></span><br><span class="line"><span class="built_in">cd</span> <span class="variable">$TMP_DIR</span></span><br><span class="line"></span><br><span class="line">curl --connect-timeout 60 <span class="variable">$URL</span> 2&gt; /dev/null | gzip -dc &gt; <span class="variable">$FILE</span> 2&gt; /dev/null</span><br><span class="line"></span><br><span class="line">LINES=`grep <span class="string">"^sshd:"</span> <span class="variable">$FILE</span> | wc -l`</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> [ <span class="variable">$LINES</span> -gt 10 ]</span><br><span class="line"><span class="keyword">then</span></span><br><span class="line">    sed -i <span class="string">'/^####SSH BlackList START####/,/^####SSH BlackList END####/d'</span> <span class="variable">$HOSTSDENY</span></span><br><span class="line">    <span class="built_in">echo</span> <span class="string">"####SSH BlackList START####"</span> &gt;&gt; <span class="variable">$HOSTSDENY</span></span><br><span class="line">    cat <span class="variable">$FILE</span> &gt;&gt; <span class="variable">$HOSTSDENY</span></span><br><span class="line">    <span class="built_in">echo</span> <span class="string">"####SSH BlackList END####"</span> &gt;&gt; <span class="variable">$HOSTSDENY</span></span><br><span class="line"><span class="keyword">fi</span></span><br></pre></td></tr></table></figure><p>然后将这个脚本放在<code>/etc/cron.daily/</code> 目录下面，每天执行即可</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">cp fetch_neusshbl.sh /etc/cron.daily/</span><br><span class="line">chmod +x fetch_neusshbl.sh</span><br></pre></td></tr></table></figure><h2 id="登录邮件通知"><a href="#登录邮件通知" class="headerlink" title="登录邮件通知"></a>登录邮件通知</h2><p>上面的两个步骤完成后，面对这种暴力攻击，也就安全很多了，但是返回忧则生，所以我又加了最后一道防线，如果有人登录了我的服务器，就自动给我的邮箱发送一条邮件</p><p>邮件发送的服务器配置可参考我的另一篇文章<a href="https://tyloafer.github.io/posts/47206/">《Linux下使用mail发送邮件》</a></p><p><em>本文还是着重从防御方面做了一点处理，可能相对来说，方法都比较的low，还请谅解，学海无涯，继续苦作舟吧！</em></p>]]></content>
      
      
      <categories>
          
          <category> Linux </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Linux </tag>
            
            <tag> Mail </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Redis哨兵</title>
      <link href="/posts/51207/"/>
      <url>/posts/51207/</url>
      
        <content type="html"><![CDATA[<p>Sentinel（哨兵）是Redis 的高可用性解决方案：由一个或多个Sentinel 实例 组成的Sentinel 系统可以监视任意多个主服务器，以及这些主服务器属下的所有从服务器，并在被监视的主服务器进入下线状态时，自动将下线主服务器属下的某个从服务器升级为新的主服务器。</p><a id="more"></a><p>在介绍哨兵之前，我们先看一下一些中小型的Redis的一个简单的主从架构</p><p><img src="http://github-1253518569.cossh.myqcloud.com/redis-master-slave.png" alt="http://github-1253518569.cossh.myqcloud.com/redis-master-slave.png"></p><p>我们的程序，在进程写入操作的时候，可能会直连Master，但是，如果这时候Master宕了，就会导致数据写入不进去，而等我们反应过来并处理好，说不定十几分钟甚至更长时间就过去了。但是，如果我们引入哨兵，采用下面的架构</p><p><img src="http://github-1253518569.cossh.myqcloud.com/redis-sentinal2.png" alt="http://github-1253518569.cossh.myqcloud.com/redis-sentinal2.png"></p><p>我们设置多台哨兵，我们的程序去连接哨兵，加入Master宕掉了，哨兵们去帮我们选一台Slave当新的Master，这样也就能实现快速的故障转移及处理了，毕竟线上是耽误不起每分每秒的。</p><h1 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h1><p>Redis-Sentinel是用于管理Redis集群,该系统执行以下三个任务:</p><ol><li>监控(Monitoring):Sentinel会不断地检查你的主服务器和从服务器是否运作正常</li><li>提醒(Notification):当被监控的某个Redis服务器出现问题时,Sentinel可以通过API向管理员或者其他应用程序发送通知</li><li>自动故障迁移(Automatic failover):当一个主服务器不能正常工作时,Sentinel 会开始一次自动故障迁移操作,它会将失效主</li></ol><p>服务器的其中一个从服务器升级为新的主服务器,并让失效主服务器的其他从服务器改为复制新的主服务器;当客户端试图连接失效的主服务器时,集群也会向客户端返回新主服务器的地址,使得集群可以使用新主服务器代替失效服务器</p><h1 id="搭建"><a href="#搭建" class="headerlink" title="搭建"></a>搭建</h1><p>Redis2.8和3.0已经附带了稳定版本的哨兵，通过yum安装后，在<code>redis-server</code>的同一目录下会有一个<code>redis-sentinel</code>的可执行脚本，这个就是Redis的哨兵了，后面用<code>sentinel</code>来代替哨兵这个名词，因为这是人家的正式的名字。</p><h1 id="配置"><a href="#配置" class="headerlink" title="配置"></a>配置</h1><p>在<code>/etc/</code>目录下，也就是redis.conf的同级目录下，会有一个<code>redis-sentinel.conf</code> , 这个就是 sentinel 的配置文件</p><p>我们通过下面的命令查看一下他的主要内容</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">cat sentinel-26379.conf | grep -v &quot;#&quot; | grep -v &quot;^$&quot;</span><br></pre></td></tr></table></figure><p>输出如下（# 为我的注释）：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"># 哨兵监听的端口</span><br><span class="line">port 26379</span><br><span class="line"># 工作目录</span><br><span class="line">dir /tmp</span><br><span class="line"># sentinel monitor &lt;master-name&gt; &lt;ip&gt; &lt;redis-port&gt; &lt;quorum&gt;</span><br><span class="line"># 后面的参数分别是master的名字，这个在redis的conf文件里面有设置的</span><br><span class="line"># redis的ip</span><br><span class="line"># redis监听的端口</span><br><span class="line"># quorum 是指，有几个哨兵认为master down了，才会认为这个master真正的down了，从而执行后面的灾备方案，一# 般这里设置的是总共 sentinel-num/2 + 1</span><br><span class="line">sentinel monitor mymaster 127.0.0.1 6379 2</span><br><span class="line"># 这个是指 sentinel 多少毫秒连接不上 master，就会认为它 down了</span><br><span class="line">sentinel down-after-milliseconds mymaster 30000</span><br><span class="line"></span><br><span class="line"># 表示如果master重新选出来后，其它slave节点能同时并行从新master同步缓存的台数有多少个，显然该值越大，所有slave节点完成同步切换的整体速度越快，但如果此时正好有人在访问这些slave，可能造成读取失败，影响面会更广。最保定的设置为1，只同一时间，只能有一台干这件事，这样其它slave还能继续服务，但是所有slave全部完成缓存更新同步的进程将变慢</span><br><span class="line">sentinel parallel-syncs mymaster 1</span><br><span class="line"></span><br><span class="line"># 表示多长时间后, master仍没活过来，则启动failover，从剩下的slave中选一个升级为master</span><br><span class="line">sentinel failover-timeout mymaster 180000</span><br><span class="line"></span><br><span class="line"># sentinel的日志</span><br><span class="line">logfile /var/log/redis/sentinel.log</span><br></pre></td></tr></table></figure><p>注：</p><p>我们一般以守护进程的方式开启哨兵，但是配置文件里面没有写，我们可以在配置文件的开始加上</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">daemonize yes</span><br></pre></td></tr></table></figure><h1 id="实战"><a href="#实战" class="headerlink" title="实战"></a>实战</h1><h2 id="主从配置"><a href="#主从配置" class="headerlink" title="主从配置"></a>主从配置</h2><p>了解了上面的配置后，我们可以先撘一个主从服务器</p><blockquote><p>思路如下：</p><ol><li>开启三台服务器，分别监听 6379 6380 6381 端口</li><li>将6379 设置为master， 6380和6381 分别slaveof 6379</li></ol></blockquote><p>6379.conf</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br></pre></td><td class="code"><pre><span class="line">bind 127.0.0.1</span><br><span class="line">protected-mode yes</span><br><span class="line">port 6379</span><br><span class="line">tcp-backlog 511</span><br><span class="line">timeout 0</span><br><span class="line">tcp-keepalive 300</span><br><span class="line">daemonize yes</span><br><span class="line">supervised no</span><br><span class="line">pidfile &quot;/var/run/redis_6379-6379.pid&quot;</span><br><span class="line">loglevel notice</span><br><span class="line">logfile &quot;/var/log/redis/redis-6379.log&quot;</span><br><span class="line">databases 16</span><br><span class="line">save 900 1</span><br><span class="line">save 300 10</span><br><span class="line">save 60 10000</span><br><span class="line">stop-writes-on-bgsave-error yes</span><br><span class="line">rdbcompression yes</span><br><span class="line">rdbchecksum yes</span><br><span class="line">dbfilename &quot;dump-6379.rdb&quot;</span><br><span class="line">dir &quot;/var/lib/redis&quot;</span><br><span class="line">slave-serve-stale-data yes</span><br><span class="line">slave-read-only yes</span><br><span class="line">repl-diskless-sync no</span><br><span class="line">repl-diskless-sync-delay 5</span><br><span class="line">repl-disable-tcp-nodelay no</span><br><span class="line">slave-priority 100</span><br><span class="line">appendonly yes</span><br><span class="line">appendfilename &quot;appendonly-6379.aof&quot;</span><br><span class="line">appendfsync everysec</span><br><span class="line">no-appendfsync-on-rewrite no</span><br><span class="line">auto-aof-rewrite-percentage 100</span><br><span class="line">auto-aof-rewrite-min-size 64mb</span><br><span class="line">aof-load-truncated yes</span><br><span class="line">lua-time-limit 5000</span><br><span class="line">slowlog-log-slower-than 10000</span><br><span class="line">slowlog-max-len 128</span><br><span class="line">latency-monitor-threshold 0</span><br><span class="line">notify-keyspace-events &quot;&quot;</span><br><span class="line">hash-max-ziplist-entries 512</span><br><span class="line">hash-max-ziplist-value 64</span><br><span class="line">list-max-ziplist-size -2</span><br><span class="line">list-compress-depth 0</span><br><span class="line">set-max-intset-entries 512</span><br><span class="line">zset-max-ziplist-entries 128</span><br><span class="line">zset-max-ziplist-value 64</span><br><span class="line">hll-sparse-max-bytes 3000</span><br><span class="line">activerehashing yes</span><br><span class="line">client-output-buffer-limit normal 0 0 0</span><br><span class="line">client-output-buffer-limit slave 256mb 64mb 60</span><br><span class="line">client-output-buffer-limit pubsub 32mb 8mb 60</span><br><span class="line">hz 10</span><br><span class="line">aof-rewrite-incremental-fsync yes</span><br></pre></td></tr></table></figure><p>6380的配置</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br></pre></td><td class="code"><pre><span class="line">bind 127.0.0.1</span><br><span class="line">protected-mode yes</span><br><span class="line">port 6381</span><br><span class="line">tcp-backlog 511</span><br><span class="line">timeout 0</span><br><span class="line">tcp-keepalive 300</span><br><span class="line">daemonize yes</span><br><span class="line">supervised no</span><br><span class="line">pidfile &quot;/var/run/redis_6381-6381.pid&quot;</span><br><span class="line">loglevel notice</span><br><span class="line">logfile &quot;/var/log/redis/redis-6381.log&quot;</span><br><span class="line">databases 16</span><br><span class="line">save 900 1</span><br><span class="line">save 300 10</span><br><span class="line">save 60 10000</span><br><span class="line">stop-writes-on-bgsave-error yes</span><br><span class="line">rdbcompression yes</span><br><span class="line">rdbchecksum yes</span><br><span class="line">dbfilename &quot;dump-6381.rdb&quot;</span><br><span class="line">dir &quot;/var/lib/redis&quot;</span><br><span class="line">slave-serve-stale-data yes</span><br><span class="line">slave-read-only yes</span><br><span class="line">repl-diskless-sync no</span><br><span class="line">repl-diskless-sync-delay 5</span><br><span class="line">repl-disable-tcp-nodelay no</span><br><span class="line">slave-priority 100</span><br><span class="line">appendonly yes</span><br><span class="line">appendfilename &quot;appendonly-6381.aof&quot;</span><br><span class="line">appendfsync everysec</span><br><span class="line">no-appendfsync-on-rewrite no</span><br><span class="line">auto-aof-rewrite-percentage 100</span><br><span class="line">auto-aof-rewrite-min-size 64mb</span><br><span class="line">aof-load-truncated yes</span><br><span class="line">lua-time-limit 5000</span><br><span class="line">slowlog-log-slower-than 10000</span><br><span class="line">slowlog-max-len 128</span><br><span class="line">latency-monitor-threshold 0</span><br><span class="line">notify-keyspace-events &quot;&quot;</span><br><span class="line">hash-max-ziplist-entries 512</span><br><span class="line">hash-max-ziplist-value 64</span><br><span class="line">list-max-ziplist-size -2</span><br><span class="line">list-compress-depth 0</span><br><span class="line">set-max-intset-entries 512</span><br><span class="line">zset-max-ziplist-entries 128</span><br><span class="line">zset-max-ziplist-value 64</span><br><span class="line">hll-sparse-max-bytes 3000</span><br><span class="line">activerehashing yes</span><br><span class="line">client-output-buffer-limit normal 0 0 0</span><br><span class="line">client-output-buffer-limit slave 256mb 64mb 60</span><br><span class="line">client-output-buffer-limit pubsub 32mb 8mb 60</span><br><span class="line">hz 10</span><br><span class="line">aof-rewrite-incremental-fsync yes</span><br><span class="line">slaveof 127.0.0.1 6379</span><br></pre></td></tr></table></figure><p>6381的配置与6380基本相同，只是修改一下端口和log，rdb，aof的名字而已</p><p>然后我们开启了三台redis，并且设置好了主从关系</p><blockquote><p>redis-server /path/to/6379.conf</p><p>redis-server  /path/to/6380.conf</p><p>redis-server  /path/to/6381.conf</p></blockquote><h1 id="哨兵配置"><a href="#哨兵配置" class="headerlink" title="哨兵配置"></a>哨兵配置</h1><blockquote><p>思路如下：</p><ol><li>我们一样开启三台 sentinel 分别监听 26379 26380 26381</li><li>将这三台 sentinel 全部监控我们的master 6379端口的Redis</li></ol></blockquote><p>26379.conf</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">port 26379</span><br><span class="line">dir /tmp</span><br><span class="line">sentinel monitor mymaster 127.0.0.1 6379 2</span><br><span class="line">sentinel down-after-milliseconds mymaster 30000</span><br><span class="line">sentinel parallel-syncs mymaster 1</span><br><span class="line">sentinel failover-timeout mymaster 180000</span><br><span class="line">logfile /var/log/redis/sentinel-26379.log</span><br></pre></td></tr></table></figure><p>其余两个配置，除端口和logfile外，均一样，可参考着写</p><p>然后我们开启这三台哨兵</p><blockquote><p>redis-sentinel /path/to/26379.conf</p><p>redis-sentinel  /path/to/26380.conf</p><p>redis-sentinel  /path/to/26381.conf</p></blockquote><h1 id="分析日志"><a href="#分析日志" class="headerlink" title="分析日志"></a>分析日志</h1><p>我们查看任一个哨兵的日志，启动后可以发现，日志里面输入了一下内容</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">2739:X 23 May 09:00:15.188 # Sentinel ID is 41b05827fdb8f7f8e88e74aa7070190c3c8f84f6</span><br><span class="line">2739:X 23 May 09:00:15.188 # +monitor master mymaster 127.0.0.1 6379 quorum 2</span><br><span class="line">2739:X 23 May 09:00:22.026 * +sentinel sentinel 50c453e7f9fa3acbab3f685621dabf26c02b53e3 127.0.0.1 26380 @ mymaster 127.0.0.1 6379</span><br><span class="line">2739:X 23 May 09:00:24.191 * +sentinel sentinel 3d8d577704e9c0f6ac4cde7febab25180b7d7cc5 127.0.0.1 26381 @ mymaster 127.0.0.1 6379</span><br></pre></td></tr></table></figure><p>也就是说sentinel 跟我我们配置的 找到了master ，并且找到了另外的两台 Sentinel ，这时候，我们去看 我们原先配置的 sentinel 的配置文件，应该也发生了变化</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"># Generated by CONFIG REWRITE</span><br><span class="line">sentinel known-slave mymaster 127.0.0.1 6379</span><br><span class="line">sentinel known-slave mymaster 127.0.0.1 6380</span><br><span class="line">sentinel known-sentinel mymaster 127.0.0.1 26381 3d8d577704e9c0f6ac4cde7febab25180b7d7cc5</span><br><span class="line">sentinel known-sentinel mymaster 127.0.0.1 26380 50c453e7f9fa3acbab3f685621dabf26c02b53e3</span><br></pre></td></tr></table></figure><p>这时候，Sentinel 集群监控已经开启并且开始监控了。</p><p>那么，Sentinel 是如何工作的呢，又是怎么投票选举新的master的呢，其实还是要继续依赖他锁打印的日志</p><p>我们这时候，主动下线一台，然后继续分析一下 Sentinel 的日志</p><blockquote><p>redis-cli -p 6379 shutdown</p></blockquote><p>这时候，日志又会继续打印内容</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">2739:X 23 May 09:05:02.978 # +sdown master mymaster 127.0.0.1 6379</span><br><span class="line">2739:X 23 May 09:05:03.108 # +new-epoch 1</span><br><span class="line">2739:X 23 May 09:05:03.116 # +vote-for-leader 3d8d577704e9c0f6ac4cde7febab25180b7d7cc5 1</span><br><span class="line">2739:X 23 May 09:05:04.077 # +odown master mymaster 127.0.0.1 6379 #quorum 3/2</span><br><span class="line">2739:X 23 May 09:05:04.078 # Next failover delay: I will not start a failover before Wed May 23 09:11:03 2018</span><br><span class="line">2739:X 23 May 09:05:04.208 # +config-update-from sentinel 3d8d577704e9c0f6ac4cde7febab25180b7d7cc5 127.0.0.1 26381 @ mymaster 127.0.0.1 6379</span><br><span class="line">2739:X 23 May 09:05:04.208 # +switch-master mymaster 127.0.0.1 6379 127.0.0.1 6381</span><br></pre></td></tr></table></figure><p>流程可参考：</p><ol><li>Sentinel 发现了master宕掉了</li><li>然后给另一台 slave 投票了</li><li>另外一个又发现 master 宕了，超过我们的设定了</li><li>开始协商：某个时间点之后 master还没有起，我们就另立新主吧</li><li>哎哟歪，时间到了，我们把其他的配置文件都更新一下吧，不然重启了我们的决议又失效了咋办</li><li>最后，我们欢迎新主降临</li></ol><p>我们这时候把6379再开启，又会发生什么情况了</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">2739:X 23 May 09:05:04.209 * +slave slave 127.0.0.1:6380 127.0.0.1 6380 @ mymaster 127.0.0.1 6381</span><br><span class="line">2739:X 23 May 09:05:04.209 * +slave slave 127.0.0.1:6379 127.0.0.1 6379 @ mymaster 127.0.0.1 6381</span><br></pre></td></tr></table></figure><p>其实，在上面的宕机并另立master的时候 6379 的配置已经被 Sentinel 修改了，这时候，就只有乖乖的当 slave了</p>]]></content>
      
      
      <categories>
          
          <category> Redis </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Linux </tag>
            
            <tag> Redis </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>PHP基于共享内存实现single信号量控制脚本启停</title>
      <link href="/posts/41236/"/>
      <url>/posts/41236/</url>
      
        <content type="html"><![CDATA[<p>我们在使用nginx的时候，有<code>-s reload</code>实现配置的重载，别的应用也有<code>kill -USR1</code> 实现配置的重载，但是在php的脚本在执行的时候，就只有简单粗暴的<code>kill</code> 来杀死，再启动。所以，是否可以实现 类似于 nginx的<code>-s</code>一样，给与一个信号量，来进行平滑重启或杀死？</p><a id="more"></a><h1 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h1><p>我们在写死循环的时候一般是<code>while(true)</code>, 那么只要在<code>while(true)</code>紧接着给他一个变量，然后在根据这个变量的值来判断是否需要结束不久可以实现程序的自动结束了吗？</p><p>这样的话，php程序内自定义变量肯定是不行了，我们可以借助一个文件或redis或mysql等来实现，例如，a脚本在执行开始的时候，在redis里面设置一个key a，然后每次while的时候，读取redis里面a的值，如果改变了，便执行相关的操作</p><p>这当然是可行的，但是在测试的时候，你就会发现，cpu会占用很高，所以这个就被kill了</p><h1 id="共享内存"><a href="#共享内存" class="headerlink" title="共享内存"></a>共享内存</h1><p>既然php的所有变量都是放在内存里面的，那一个php脚本a在执行的时候，设置一个变量$flag, 然后其他脚本可以访问这个变量并修改变量的值，这样的话，资源的消耗就是几乎为0了，这也就引进了一个概念：<strong>共享内存</strong></p><p>共享内存的使用主要是为了能够在同一台机器不同的进程中共享一些数据，比如在多个 php-fpm 进程中共享当前进程的使用情况。这种通信也称为进程间通信（Inter-Process Communication），简称 IPC。</p><p>PHP 内置的 <a href="http://php.net/manual/zh/book.shmop.php" target="_blank" rel="noopener">shmop 扩展</a> (Shared Memory Operations) 提供了一系列共享内存操作的函数。当然这也是基于Linux共享内存实现的，具体的就自行google吧。</p><h2 id="函数列表及简介"><a href="#函数列表及简介" class="headerlink" title="函数列表及简介"></a>函数列表及简介</h2><ol><li>int <strong>ftok</strong> ( string <code>$pathname</code> , string <code>$proj</code> )  把一个执行的文件或项目转换成一个系统上的IPC key，同一个系统上，每个文件对应的IPC key是相同的，所以也就让信号量控制成为了可能</li><li>resource <strong>shmop_open</strong> ( int <code>$key</code> , string <code>$flags</code> , int <code>$mode</code> , int <code>$size</code> ) 创建一个指定大小的内存块</li><li>string <strong>shmop_read</strong> ( resource <code>$shmid</code> , int <code>$start</code> , int <code>$count</code> ) 从一个共享内存块中读取数据 如果填充的数据比共享内存的size小的话，会自动给数据填充空白符，所以记得套trim()</li><li>int <strong>shmop_size</strong> ( resource <code>$shmid</code> ) 获取一个共享内存的大小 ，参数是 <strong>shmop_open</strong>返回的内容</li><li>int <strong>shmop_write</strong> ( resource <code>$shmid</code> , string <code>$data</code> , int <code>$offset</code> ) 向共享内存中写入数据</li><li>bool <strong>shmop_delete</strong> ( resource <code>$shmid</code> ) 删除一个共享内存块</li><li>void <strong>shmop_close</strong> ( resource <code>$shmid</code> ) 关闭一个共享内存块，并不删除</li></ol><h2 id="注意"><a href="#注意" class="headerlink" title="注意"></a>注意</h2><ol><li><p><strong>ftok()</strong> 函数的第一个<code>pathname</code> 可以使一个文件的全路径， 第二个参数，可以随意给，但必须是<strong>长度为1</strong>的字符</p></li><li><p>在使用<strong>shmop_open</strong>的时候，会注意到 第一个参数 int <code>$key</code> 有可能会一脸迷茫，这里其实是 <strong>fotk()</strong>函数的返回值， 我们前面说过 <strong>fotk()</strong> 是将文件转换成 IPC key，也就是这里的key</p></li><li><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">&quot;a&quot; for access (sets SHM_RDONLY for shmat) use this flag when you need to open an existing shared memory segment for read only</span><br><span class="line">&quot;c&quot; for create (sets IPC_CREATE) use this flag when you need to create a new shared memory segment or if a segment with the same key exists, try to open it for read and write</span><br><span class="line">&quot;w&quot; for read &amp; write access use this flag when you need to read and write to a shared memory segment, use this flag in most cases.</span><br><span class="line">&quot;n&quot; create a new memory segment (sets IPC_CREATE|IPC_EXCL) use this flag when you want to create a new shared memory segment but if one already exists with the same flag, fail. This is useful for security purposes, using this you can prevent race condition exploits.</span><br></pre></td></tr></table></figure><p>我在这里使用”n”的时候，会报错，使用“c”便不会，各位可自行测试</p></li></ol><h1 id="示例"><a href="#示例" class="headerlink" title="示例"></a>示例</h1><p>脚本a.php </p><figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&lt;?php</span></span><br><span class="line"><span class="comment">// 生成IPC key</span></span><br><span class="line">$shm_key = ftok(<span class="keyword">__FILE__</span>, <span class="string">'t'</span>);</span><br><span class="line"><span class="comment">// 信号量的话 0-9也足够了，所以这里分配1byte的大小即可，同时这样也不会产生空白符，省去了使用trim()</span></span><br><span class="line">$shm_id = shmop_open($shm_key, <span class="string">'c'</span>, <span class="number">0644</span>, <span class="number">1</span>);</span><br><span class="line">shmop_write($shm_id, <span class="number">1</span>, <span class="number">0</span>);</span><br><span class="line"><span class="keyword">while</span> (shmop_read($shm_id, <span class="number">0</span>, shmop_size($shm_id)) == <span class="number">1</span>) &#123;</span><br><span class="line">  <span class="comment">// to do</span></span><br><span class="line">&#125;</span><br><span class="line">shmop_close($shm_id);</span><br><span class="line">shmop_delete($shm_id);</span><br></pre></td></tr></table></figure><p>控制启停的脚本 single.php</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">php single.php a.php /data/</span><br></pre></td></tr></table></figure><figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&lt;?php</span></span><br><span class="line"><span class="comment">// 获取需要控制的脚本</span></span><br><span class="line">$args = $_SERVER[<span class="string">'argv'</span>];</span><br><span class="line">array_shift($args);</span><br><span class="line">$file = $args[<span class="number">1</span>] . <span class="string">'/'</span> . $args[<span class="number">0</span>];</span><br><span class="line">$shm_key = ftok(<span class="keyword">__FILE__</span>, <span class="string">'t'</span>);</span><br><span class="line"><span class="comment">// 信号量的话 0-9也足够了，所以这里分配1byte的大小即可，同时这样也不会产生空白符，省去了使用trim()</span></span><br><span class="line">$shm_id = shmop_open($shm_key, <span class="string">'c'</span>, <span class="number">0644</span>, <span class="number">1</span>);</span><br><span class="line">shmop_write($shm_id, <span class="number">0</span>, <span class="number">0</span>);</span><br><span class="line"><span class="keyword">echo</span> <span class="string">"[停止] "</span>;</span><br><span class="line"><span class="keyword">while</span> (@shmop_read($shm_id, <span class="number">0</span>, shmop_size($shm_id)) === <span class="number">0</span>) &#123;</span><br><span class="line">    <span class="keyword">echo</span> <span class="string">'.'</span>;</span><br><span class="line">&#125;</span><br><span class="line">shmop_close($shm_id);</span><br><span class="line">shmop_delete($shm_id);</span><br><span class="line"><span class="keyword">echo</span> <span class="string">"成功"</span>;</span><br></pre></td></tr></table></figure><h1 id="进阶-内存锁"><a href="#进阶-内存锁" class="headerlink" title="进阶-内存锁"></a>进阶-内存锁</h1><h2 id="函数及列表"><a href="#函数及列表" class="headerlink" title="函数及列表"></a>函数及列表</h2><p><strong>ftok</strong> 是必须要用到的</p><ol><li>resource <strong>sem_get</strong> ( int <code>$key</code> [, int <code>$max_acquire</code> = 1 [, int <code>$perm</code> = 0666 [, int <code>$auto_release</code> = 1 ]]] ) 创建一个信号资源</li><li>bool <strong>sem_acquire</strong> ( resource <code>$sem_identifier</code> [, bool <code>$nowait</code> = FALSE ] )  根据信号资源，获得一个信号使用权限</li><li>bool <strong>sem_release</strong> ( resource <code>$sem_identifier</code> ) 释放一个获取的信号使用权限</li></ol><p>上面三个是我使用到的，更多的可以参考PHP手册上的<a href="http://php.net/manual/zh/book.sem.php" target="_blank" rel="noopener">Semaphore</a>，会有更多相关的介绍，但是这里结合上面的共享内存的函数，就完全够用了。</p><h2 id="注意-1"><a href="#注意-1" class="headerlink" title="注意"></a>注意</h2><ol><li><strong>sem_get</strong> 的key也是 <strong>ftok</strong>函数产生的，所以可以与共享内存的共用一个key， 第二个参数 <code>$max_acquire</code> 设置了，这个信号资源，最多一次可以被多少个进程访问，当设置为1的时候，也就实现了锁的机制</li><li><strong>sem_acquire</strong> 是获取一个信号资源的使用权，当这个信号资源被占用，且达到最大的请求数的时候，第二个参数<code>$nowait</code> 决定了接下来的行为，如果为设置true的话，则函数直接返回 false，而如果<code>$nowait</code>设置为false的时候，则会阻塞进程，知道获取资源的使用权限</li></ol><h1 id="进阶-为脚本加上锁"><a href="#进阶-为脚本加上锁" class="headerlink" title="进阶-为脚本加上锁"></a>进阶-为脚本加上锁</h1><p>我们可以根据上面的函数，为脚本加上锁，实现一个脚本的单一执行（当然linux下的<strong>flock</strong>和php的<strong>flock()</strong>也可以实现）</p><p>脚本a.php </p><figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&lt;?php</span></span><br><span class="line"><span class="comment">// 生成IPC key</span></span><br><span class="line">$shm_key = ftok(<span class="keyword">__FILE__</span>, <span class="string">'t'</span>);</span><br><span class="line"><span class="comment">// 信号量的话 0-9也足够了，所以这里分配1byte的大小即可，同时这样也不会产生空白符，省去了使用trim()</span></span><br><span class="line">$shm_id = shmop_open($shm_key, <span class="string">'c'</span>, <span class="number">0644</span>, <span class="number">1</span>);</span><br><span class="line">shmop_write($shm_id, <span class="number">1</span>, <span class="number">0</span>);</span><br><span class="line">$sem_id = sem_get($shm_key);</span><br><span class="line"><span class="keyword">if</span> (!sem_acquire($sem_id, <span class="keyword">true</span>)) &#123;</span><br><span class="line">    <span class="comment">// 有另一个脚本正在执行，结束当前执行</span></span><br><span class="line">    <span class="keyword">echo</span> <span class="string">"another is running..."</span>;</span><br><span class="line">  <span class="keyword">exit</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">while</span> (shmop_read($shm_id, <span class="number">0</span>, shmop_size($shm_id)) == <span class="number">1</span>) &#123;</span><br><span class="line">  <span class="comment">// to do</span></span><br><span class="line">&#125;</span><br><span class="line">sem_release($sem_id);</span><br><span class="line">shmop_close($shm_id);</span><br><span class="line">shmop_delete($shm_id);</span><br></pre></td></tr></table></figure><p>控制启停的脚本 single.php</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">php single.php a.php /data/</span><br></pre></td></tr></table></figure><figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&lt;?php</span></span><br><span class="line"><span class="comment">// 获取需要控制的脚本</span></span><br><span class="line">$args = $_SERVER[<span class="string">'argv'</span>];</span><br><span class="line">array_shift($args);</span><br><span class="line">$file = $args[<span class="number">1</span>] . <span class="string">'/'</span> . $args[<span class="number">0</span>];</span><br><span class="line">$shm_key = ftok(<span class="keyword">__FILE__</span>, <span class="string">'t'</span>);</span><br><span class="line"><span class="comment">// 信号量的话 0-9也足够了，所以这里分配1byte的大小即可，同时这样也不会产生空白符，省去了使用trim()</span></span><br><span class="line">$shm_id = shmop_open($shm_key, <span class="string">'c'</span>, <span class="number">0644</span>, <span class="number">1</span>);</span><br><span class="line">shmop_write($shm_id, <span class="number">0</span>, <span class="number">0</span>);</span><br><span class="line"><span class="keyword">echo</span> <span class="string">"[停止] "</span>;</span><br><span class="line">$sem_id = sem_get($shm_key);</span><br><span class="line"><span class="comment">// 脚本在执行结束的时候，会释放信号资源，所以这里可以通过能否获得信号资源来判断脚本是否结束</span></span><br><span class="line"><span class="keyword">if</span> (!sem_acquire($sem_id, <span class="keyword">true</span>)) &#123;</span><br><span class="line">    <span class="keyword">echo</span> <span class="string">'.'</span>;</span><br><span class="line">&#125;</span><br><span class="line">sem_release($sem_id);</span><br><span class="line">shmop_close($shm_id);</span><br><span class="line">shmop_delete($shm_id);</span><br><span class="line"><span class="keyword">echo</span> <span class="string">"成功"</span>;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> PHP </category>
          
      </categories>
      
      
        <tags>
            
            <tag> PHP </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>玩玩Swoole（一）：Swoole整合Yii</title>
      <link href="/posts/13311/"/>
      <url>/posts/13311/</url>
      
        <content type="html"><![CDATA[<p>PHP是个单线程的脚本的语言，虽然可以通过<em>pcntl-fork</em>实现简单的多线程，但是这个肯定不是最优解，所以也就开始接触了Swoole，但是公司还没有相关的项目，所以也就玩玩而已</p><a id="more"></a><h1 id="入口文件"><a href="#入口文件" class="headerlink" title="入口文件"></a>入口文件</h1><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br></pre></td><td class="code"><pre><span class="line">&lt;?php</span><br><span class="line">/**</span><br><span class="line"> * @woole整合yii </span><br><span class="line"> * @authors Tyloafer (tyloafer@gmail.com)</span><br><span class="line"> * @date    2018-05-09 08:22:21</span><br><span class="line"> */</span><br><span class="line"></span><br><span class="line">class SwooleIndex</span><br><span class="line">&#123;</span><br><span class="line">private $swoole;</span><br><span class="line">private $config;</span><br><span class="line">    public function __construct()</span><br><span class="line">    &#123;</span><br><span class="line">    $option = [</span><br><span class="line">    &apos;enable_static_handler&apos; =&gt; true,</span><br><span class="line">    &apos;document_root&apos; =&gt; &quot;/home/lixy/basic/&quot;,</span><br><span class="line">    &apos;worker_num&apos; =&gt; 5,</span><br><span class="line">    &apos;log_level&apos; =&gt; 3,</span><br><span class="line">    ];</span><br><span class="line">    $this-&gt;swoole = new \Swoole\Http\Server(&apos;0.0.0.0&apos;, 9502);</span><br><span class="line">    $this-&gt;swoole-&gt;set($option);</span><br><span class="line">    $this-&gt;swoole-&gt;on(&apos;workerstart&apos;, [$this, &apos;workerStart&apos;]);</span><br><span class="line">    $this-&gt;swoole-&gt;on(&apos;request&apos;, [$this, &apos;request&apos;]);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public function __call($name, $args)</span><br><span class="line">    &#123;</span><br><span class="line">    return call_user_func_array([$this, $name], $args);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public function workerStart($server, $id)</span><br><span class="line">    &#123;</span><br><span class="line">    defined(&apos;YII_DEBUG&apos;) or define(&apos;YII_DEBUG&apos;, true);</span><br><span class="line">defined(&apos;YII_ENV&apos;) or define(&apos;YII_ENV&apos;, &apos;dev&apos;);</span><br><span class="line"></span><br><span class="line">require __DIR__ . &apos;/../vendor/autoload.php&apos;;</span><br><span class="line">require __DIR__ . &apos;/../vendor/yiisoft/yii2/Yii.php&apos;;</span><br><span class="line"></span><br><span class="line">$this-&gt;config = require __DIR__ . &apos;/../config/web.php&apos;;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public function request($request, $response)</span><br><span class="line">    &#123;</span><br><span class="line">    $this-&gt;initParams($request);</span><br><span class="line">    ob_start();</span><br><span class="line">    (new yii\web\Application($this-&gt;config))-&gt;run();</span><br><span class="line">    $content = ob_get_contents();</span><br><span class="line">    ob_clean();</span><br><span class="line">    $response-&gt;end($content);</span><br><span class="line">    &#125;</span><br><span class="line">    private function initParams($request)</span><br><span class="line">    &#123;</span><br><span class="line">    $mapping = [</span><br><span class="line">    &apos;header&apos; =&gt; [&apos;suffix&apos; =&gt; &apos;http&apos;, &apos;name&apos; =&gt; &apos;_SERVER&apos;, &apos;toupper&apos; =&gt; true, &apos;replace_slash&apos; =&gt; true],</span><br><span class="line">    &apos;server&apos; =&gt; [&apos;suffix&apos; =&gt; &apos;&apos;, &apos;name&apos; =&gt; &apos;_SERVER&apos;, &apos;toupper&apos; =&gt; true, &apos;replace_slash&apos; =&gt; false],</span><br><span class="line">    &apos;request&apos; =&gt; [&apos;suffix&apos; =&gt; &apos;&apos;, &apos;name&apos; =&gt; &apos;_REQUEST&apos;, &apos;toupper&apos; =&gt; true, &apos;replace_slash&apos; =&gt; false],</span><br><span class="line">    &apos;cookie&apos; =&gt; [&apos;suffix&apos; =&gt; &apos;&apos;, &apos;name&apos; =&gt; &apos;_COOKIE&apos;, &apos;toupper&apos; =&gt; false, &apos;replace_slash&apos; =&gt; false],</span><br><span class="line">    &apos;get&apos; =&gt; [&apos;suffix&apos; =&gt; &apos;&apos;, &apos;name&apos; =&gt; &apos;_GET&apos;, &apos;toupper&apos; =&gt; false, &apos;replace_slash&apos; =&gt; false],</span><br><span class="line">    &apos;post&apos; =&gt; [&apos;suffix&apos; =&gt; &apos;&apos;, &apos;name&apos; =&gt; &apos;_POST&apos;, &apos;toupper&apos; =&gt; false, &apos;replace_slash&apos; =&gt; false],</span><br><span class="line">    &apos;files&apos; =&gt; [&apos;suffix&apos; =&gt; &apos;&apos;, &apos;name&apos; =&gt; &apos;_FILES&apos;, &apos;toupper&apos; =&gt; false, &apos;replace_slash&apos; =&gt; false],</span><br><span class="line">    ];</span><br><span class="line"></span><br><span class="line">    // 先赋值为空，防止以前的请求对后面的请求产生影响</span><br><span class="line">    foreach ($mapping as $value) &#123;</span><br><span class="line">    $_GET = [];</span><br><span class="line">    $_POST = [];</span><br><span class="line">    $_FILES = [];</span><br><span class="line">    $_COOKIE = [];</span><br><span class="line">    $_REQUEST = [];</span><br><span class="line">    // $_SERVER = [];</span><br><span class="line">    &#125;</span><br><span class="line">    // 针对mapping里面的循环赋值</span><br><span class="line">    foreach ($mapping as $key =&gt; $value) &#123;</span><br><span class="line">    if (!empty($request-&gt;$key)) &#123;</span><br><span class="line">    foreach ($request-&gt;$key as $name =&gt; $val) &#123;</span><br><span class="line">    if (!empty($value[&apos;suffix&apos;])) &#123;</span><br><span class="line">    $name = $value[&apos;suffix&apos;] . &apos;_&apos; . $name;</span><br><span class="line">    &#125;</span><br><span class="line">    if ($value[&apos;toupper&apos;] === true) &#123;</span><br><span class="line">    $name = strtoupper($name);</span><br><span class="line">    &#125;</span><br><span class="line">    if ($value[&apos;replace_slash&apos;] === true) &#123;</span><br><span class="line">    $name = str_replace(&apos;-&apos;, &apos;_&apos;, $name);</span><br><span class="line">    &#125;</span><br><span class="line">    $&#123;strtoupper($value[&apos;name&apos;])&#125;[$name] = $val;</span><br><span class="line">    &#125;</span><br><span class="line">    &#125; else &#123;</span><br><span class="line">    $&#123;strtoupper($value[&apos;name&apos;])&#125; = [];</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    $data[strtoupper($value[&apos;name&apos;])] = $&#123;strtoupper($value[&apos;name&apos;])&#125;;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"> $_GET = $data[&apos;_GET&apos;];</span><br><span class="line">$_POST = $data[&apos;_POST&apos;];</span><br><span class="line">$_FILES = $data[&apos;_FILES&apos;];</span><br><span class="line">$_COOKIE = $data[&apos;_COOKIE&apos;];</span><br><span class="line">$_REQUEST = $data[&apos;_REQUEST&apos;];</span><br><span class="line">$_SERVER = array_merge($data[&apos;_SERVER&apos;], $_SERVER);</span><br><span class="line">    // return true;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">$swoole_index = new SwooleIndex();</span><br><span class="line">$swoole_index-&gt;start();</span><br></pre></td></tr></table></figure><p>在上面的代码里，我准备通过可变变量来对超全局变量进行赋值的，也就是</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$data[strtoupper($value[&apos;name&apos;])] = $&#123;strtoupper($value[&apos;name&apos;])&#125;;</span><br></pre></td></tr></table></figure><p>改成</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$&#123;strtoupper($value[&apos;name&apos;])&#125; = $&#123;strtoupper($value[&apos;name&apos;])&#125;;</span><br></pre></td></tr></table></figure><p>foreach里面也使用可变变量对超全局变量赋值，依然没成功，但是对非超全局变量却可以起到效果，所以暂时无解决方案。</p><h1 id="配置文件web-php"><a href="#配置文件web-php" class="headerlink" title="配置文件web.php"></a>配置文件web.php</h1><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">$config = [</span><br><span class="line">......</span><br><span class="line">    &apos;components&apos; =&gt; [</span><br><span class="line">    ......</span><br><span class="line">        // swoole task compontents</span><br><span class="line">        &apos;task&apos; =&gt; [</span><br><span class="line">            &apos;class&apos; =&gt; &apos;app\component\Task&apos;,</span><br><span class="line">        ],</span><br><span class="line">    ],</span><br><span class="line">    ......</span><br><span class="line">];</span><br></pre></td></tr></table></figure><p>原有的便不再书写了，这里加上了task的组件。</p><h1 id="任务组件Task-php"><a href="#任务组件Task-php" class="headerlink" title="任务组件Task.php"></a>任务组件Task.php</h1><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line">&lt;?php</span><br><span class="line">/**</span><br><span class="line"> * @任务处理组件 </span><br><span class="line"> * @authors Tyloafer (tyloafer@gmail.com)</span><br><span class="line"> * @date    2018-05-15 08:49:25</span><br><span class="line"> */</span><br><span class="line">namespace app\component;</span><br><span class="line"></span><br><span class="line">use yii;</span><br><span class="line">use yii\base\Component;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">class Task extends Component</span><br><span class="line">&#123;</span><br><span class="line">public function uploadFile($data)</span><br><span class="line">&#123;</span><br><span class="line">try &#123;</span><br><span class="line">file_put_contents(&apos;/home/lixy/upload/1.log&apos;, json_encode($data) . &apos;file : &apos; . file_get_contents($data[&apos;pic&apos;][&apos;tmp_name&apos;]));</span><br><span class="line">move_uploaded_file($data[&apos;pic&apos;][&apos;tmp_name&apos;], &apos;/home/lixy/upload/&apos; . $data[&apos;pic&apos;][&apos;name&apos;]);</span><br><span class="line">&#125; catch (\Exception $e) &#123;</span><br><span class="line">echo $e-&gt;getMessage();</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="结束"><a href="#结束" class="headerlink" title="结束"></a>结束</h1><p>上面就简单的实现了swoole整合Yii框架，实现多线程，任务投递等。</p>]]></content>
      
      
      <categories>
          
          <category> Swoole </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Swoole </tag>
            
            <tag> Yii </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Nginx倒腾笔记（先导）：$1等变量的使用</title>
      <link href="/posts/59969/"/>
      <url>/posts/59969/</url>
      
        <content type="html"><![CDATA[<p>这篇文章的命名也是比较晦涩，这也充分显示了我的语文功底是多么的薄弱。简单解释一下吧，我们在使用nginx里面的正则做匹配及rewrite或proxy_pass的时候，会经常使用\$1,\$2这样的变量，这边文章就是做这个解释的。</p><p>其实我是准备写一个Nginx的系列的，而这个是我近期踩到的一个坑，又想记录下来，所以就变成了先导篇。</p><a id="more"></a><p>#起因</p><p>先贴一下配置的例子吧：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">location ~ ^/lixy/(.*(?&lt;!\.php)$) &#123;</span><br><span class="line">    if ($request_uri ~ (create-group|set-avatar|change-avatar|set-group-avatar|resumable_upload|uploadFile\.php|webUpload\.php|resumable_upload_origin)) &#123;</span><br><span class="line">        access_log /data/logs/access.log file;</span><br><span class="line">    &#125;</span><br><span class="line">    proxy_pass https://tyloafer.github.io/$1;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这里的场景是，我在记录<em>request_body</em>的时候，如果是文件上传的话，就会把二进制流给记录下来，这个没必要骗的，所以，我便做了两个 <em>log_format</em> , 一个记录request_body, 另一个不记录 ，默认使用记录的</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">access_log /data/logs/access.log file;</span><br></pre></td></tr></table></figure><p>这句话，也就是指定<em>access.log</em> 的 <em>log_format</em>, 然后再讲我的请求代理到另一台 服务器上</p><p>例：xxxxx.com/lixy/2018/05/18/nginx-proxy-1 =&gt; <a href="https://tyloafer.github.io/2018/05/18/nginx-proxy-1">https://tyloafer.github.io/2018/05/18/nginx-proxy-1</a> , 我在请求的时候， location会匹配到lixy/后面的字符串并复制给$1这个变量，我在proxy_pass的时候，使用这个变量也就没什么问题了，后来发现，如果请求的接口地址包含上面的   (create-group|set-avatar|change-avatar|set-group-avatar|resumable_upload|uploadFile.php|webUpload.php|resumable_upload_origin) 这些字符的时候，还算正常，但是没有就会出问题。</p><h1 id="调试"><a href="#调试" class="headerlink" title="调试"></a>调试</h1><p>最简单的就是调试，打印参数了，这里我在nginx里面直接返回了$1,</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">location ~ ^/lixy/(.*(?&lt;!\.php)$) &#123;</span><br><span class="line">    if ($request_uri ~ (create-group|set-avatar|change-avatar|set-group-avatar|resumable_upload|uploadFi    le\.php|webUpload\.php|resumable_upload_origin)) &#123;</span><br><span class="line">        access_log /data/logs/access.log file;</span><br><span class="line">    &#125;</span><br><span class="line">    root /home/;   </span><br><span class="line">    add_header  Content-Type &apos;text/html; charset=utf-8&apos;;</span><br><span class="line">    return 200 $1;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>当请求xxxxx.com/lixy/2018/05/18/nginx-proxy-1 返回空白，</p><p>当请求xxxxx.com/lixy/2018/05/18/create-group 返回 create-group，</p><p>由此可见，在经过if的正则匹配的时候，同样会对$1进行赋值，这也就是出错的原因了，变量被重新赋值了。</p><h1 id="解决"><a href="#解决" class="headerlink" title="解决"></a>解决</h1><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">location ~ ^/lixy/(.*(?&lt;!\.php)$) &#123;</span><br><span class="line">    set $path $1;</span><br><span class="line">    if ($request_uri ~ (create-group|set-avatar|change-avatar|set-group-avatar|resumable_upload|uploadFi    le\.php|webUpload\.php|resumable_upload_origin)) &#123;</span><br><span class="line">        access_log /data/logs/access.log file;</span><br><span class="line">    &#125;</span><br><span class="line">    root /home/;   </span><br><span class="line">    proxy_pass https://tyloafer.github.io/$path;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>我们先给 location 匹配到的路由地址，赋值给$path，然后后面使用\$path就可以，\$1你们抢你们玩吧，其他的\$2 \$3 \$4 等参数，在使用的时候也需要注意。</p>]]></content>
      
      
      <categories>
          
          <category> Nginx </category>
          
      </categories>
      
      
        <tags>
            
            <tag> PHP </tag>
            
            <tag> Nginx </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Yii2倒腾系列：邮箱及多邮箱配置</title>
      <link href="/posts/35776/"/>
      <url>/posts/35776/</url>
      
        <content type="html"><![CDATA[<h1 id="起因"><a href="#起因" class="headerlink" title="起因"></a>起因</h1><p>邮件发送，在一个程序中，站着举足轻重的地位，所以，学会配置，Yii2的邮箱，也是入门的一项必要技能，但是，在业务发展过程中，有可能一不小心，邮箱被某些邮件服务上拉近黑名单了，很多这种情况就是因为，给不存在的用户发送邮件或被钓鱼了。这时候就需要设置多个邮箱，一个用于给未验证的用户发送邮件，一个给已验证的邮箱发送邮件，防止主要的邮箱被拉近黑名单。</p><a id="more"></a><h1 id="配置单个邮箱"><a href="#配置单个邮箱" class="headerlink" title="配置单个邮箱"></a>配置单个邮箱</h1><p>邮箱的配置在Yii2的文档中，写的还是比较详细的，可参考这里<a href="http://www.yii-china.com/doc/guide/tutorial_mailing.html" target="_blank" rel="noopener">http://www.yii-china.com/doc/guide/tutorial_mailing.html</a> </p><p>将mailer注册进components中即可使用，个人的配置也先贴出来</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">&apos;mailer&apos; =&gt; [</span><br><span class="line">            &apos;class&apos; =&gt; &apos;yii\swiftmailer\Mailer&apos;,         // 这里是邮件发送需调用的类</span><br><span class="line">            &apos;viewPath&apos; =&gt; &apos;@common/mail&apos;,                // 这个是邮件的模板文件，当你用compose()传入模板文件名称的时候，可以直接根据模板文件进行实例化，而不需要自己再多次重写html或txt 版本的邮件内容</span><br><span class="line">            &apos;useFileTransport&apos; =&gt; false,                 // 如果开启这个选项，会把邮件信息保存在本地文件而不是发送它们</span><br><span class="line">            &apos;transport&apos; =&gt; [                              // 这个便是发送邮箱的验证，这个下面会主要分析的</span><br><span class="line">                &apos;class&apos; =&gt; &apos;Swift_SmtpTransport&apos;,</span><br><span class="line">                &apos;host&apos; =&gt; &apos;xxxxxx&apos;,                      // 邮件服务商的host</span><br><span class="line">                &apos;username&apos; =&gt; &apos;xxxxx&apos;,</span><br><span class="line">                &apos;password&apos; =&gt; &apos;*******&apos;,</span><br><span class="line">                &apos;port&apos; =&gt; 465,                            // 端口 一般 端口是 25 ssl 465 tls 587</span><br><span class="line">                &apos;encryption&apos; =&gt; &apos;ssl&apos;,//tls or ssl</span><br><span class="line">                //&apos;timeout&apos; =&gt; 600,</span><br><span class="line">                &apos;streamOptions&apos; =&gt; [                      // 走ssl验证时的规则</span><br><span class="line">                    &apos;ssl&apos; =&gt; [</span><br><span class="line">                        &apos;allow_self_signed&apos; =&gt; true,</span><br><span class="line">                        &apos;verify_peer&apos; =&gt; false,</span><br><span class="line">                        &apos;verify_peer_name&apos; =&gt; false,</span><br><span class="line">                    ],</span><br><span class="line">                ]</span><br><span class="line">           ]</span><br><span class="line">        ],</span><br></pre></td></tr></table></figure><p>在上面的配置中国，会发现，相对于文档中 多了一个<code>transport</code>的 设置，这个就是邮箱的一些配置，我们可以通过这个配置连接我们的邮件服务器，进而收发邮件，那么，也就是说，我们修改了<code>transport</code>就是修改了我们的发件箱，我们在程序中随时更改<code>transport</code>也就可以实现我们最初的需求了，那么如何修改呢，接下来，我们一起看一下<code>Mailer</code>的实例化过程可能就清晰了。</p><h1 id="分析Mailer实例化"><a href="#分析Mailer实例化" class="headerlink" title="分析Mailer实例化"></a>分析Mailer实例化</h1><p>下面截取了一些 <em>Mailer.php</em> 的 主要实例化用到的函数</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line">/**</span><br><span class="line"> * @return array|\Swift_Mailer Swift mailer instance or array configuration.</span><br><span class="line"> */</span><br><span class="line">public function getSwiftMailer()</span><br><span class="line">&#123;</span><br><span class="line">    if (!is_object($this-&gt;_swiftMailer)) &#123;</span><br><span class="line">        $this-&gt;_swiftMailer = $this-&gt;createSwiftMailer();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    return $this-&gt;_swiftMailer;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">/**</span><br><span class="line"> * @param array|\Swift_Transport $transport</span><br><span class="line"> * @throws InvalidConfigException on invalid argument.</span><br><span class="line"> */</span><br><span class="line">public function setTransport($transport)</span><br><span class="line">&#123;</span><br><span class="line">    if (!is_array($transport) &amp;&amp; !is_object($transport)) &#123;</span><br><span class="line">        throw new InvalidConfigException(&apos;&quot;&apos; . get_class($this) . &apos;::transport&quot; should be either object or array, &quot;&apos; . gettype($transport) . &apos;&quot; given.&apos;);</span><br><span class="line">    &#125;</span><br><span class="line">    $this-&gt;_transport = $transport;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">/**</span><br><span class="line"> * @return array|\Swift_Transport</span><br><span class="line"> */</span><br><span class="line">public function getTransport()</span><br><span class="line">&#123;</span><br><span class="line">    if (!is_object($this-&gt;_transport)) &#123;</span><br><span class="line">        $this-&gt;_transport = $this-&gt;createTransport($this-&gt;_transport);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    return $this-&gt;_transport;</span><br><span class="line">&#125;</span><br><span class="line">/**</span><br><span class="line"> * Creates Swift mailer instance.</span><br><span class="line"> * @return \Swift_Mailer mailer instance.</span><br><span class="line"> */</span><br><span class="line">protected function createSwiftMailer()</span><br><span class="line">&#123;</span><br><span class="line">    return \Swift_Mailer::newInstance($this-&gt;getTransport());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>流程可以简单的如下所示</p><p><pre class="mermaid">graph TD<br>    st(开始)–&gt;op1(getSwiftMailer)<br>    op1–已经实例化–&gt;out1&gt;实例化成功]<br>    op1–还没实例化–&gt;op2(createSwiftMailer)<br>    op2–&gt;op3(getTransport)<br>    op3–返回transport对象–&gt;op2<br>    op3–还未实例化–&gt;op4(createTransport)<br>    op4–开始实例化–&gt;op5(setTransport)<br>    op5–返回对象–&gt;op4<br>    op4–返回对象–&gt;op3<br>    op2–yes–&gt;en<br>    out1–&gt;en(结束)</pre><br>从上面的分析，我们可以看出，我们要更改<code>transport</code>的话，只需要调用<code>setTransport()</code>，并将我们的配置传给他即可。</p><h1 id="配置多邮箱"><a href="#配置多邮箱" class="headerlink" title="配置多邮箱"></a>配置多邮箱</h1><p>既然，整体流程已经清晰，我们可以在params.php中添加一个数组</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line">&apos;mailer&apos; =&gt; [</span><br><span class="line">    &apos;gmail&apos; =&gt; [</span><br><span class="line">        &apos;class&apos; =&gt; &apos;Swift_SmtpTransport&apos;,</span><br><span class="line">        &apos;host&apos; =&gt; &apos;smtp.gmail.com&apos;,</span><br><span class="line">        &apos;username&apos; =&gt; &apos;xxxxxx,</span><br><span class="line">        &apos;password&apos; =&gt; &apos;*****&apos;,</span><br><span class="line">        &apos;port&apos; =&gt; 587,</span><br><span class="line">        &apos;encryption&apos; =&gt; &apos;tls&apos;,//tls or ssl</span><br><span class="line">    ],</span><br><span class="line">    &apos;163&apos; =&gt; [</span><br><span class="line">        &apos;class&apos; =&gt; &apos;Swift_SmtpTransport&apos;,</span><br><span class="line">        &apos;host&apos; =&gt; &apos;smtp.163.com&apos;,</span><br><span class="line">        &apos;username&apos; =&gt; &apos;xxxxxx&apos;,</span><br><span class="line">        &apos;password&apos; =&gt; &apos;****&apos;,</span><br><span class="line">        &apos;port&apos; =&gt; 465,</span><br><span class="line">        &apos;encryption&apos; =&gt; &apos;ssl&apos;,//tls or ssl</span><br><span class="line">        //&apos;timeout&apos; =&gt; 600,</span><br><span class="line">        &apos;streamOptions&apos; =&gt; [</span><br><span class="line">            &apos;ssl&apos; =&gt; [</span><br><span class="line">                &apos;allow_self_signed&apos; =&gt; true,</span><br><span class="line">                &apos;verify_peer&apos; =&gt; false,</span><br><span class="line">                &apos;verify_peer_name&apos; =&gt; false,</span><br><span class="line">            ],</span><br><span class="line">        ]</span><br><span class="line">   ]</span><br><span class="line">],</span><br></pre></td></tr></table></figure><p>在需要用到邮箱发送且需要更换发送邮箱的地方，先用<code>setTransport()</code>设置发件箱配置即可。例：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">$mailer =  Yii::$app-&gt;mailer;</span><br><span class="line">$mailer-&gt;setTransport(Yii::$app-&gt;params[&apos;mailer&apos;][&apos;gmail&apos;]);</span><br><span class="line">$mailer-&gt;compose(&apos;register&apos;, $data)</span><br><span class="line">       -&gt;setSubject(&apos;多邮箱测试&apos;)</span><br><span class="line">       -&gt;setFrom(&apos;xxxxxx&apos;)</span><br><span class="line">       -&gt;setTo(&apos;xxxxxx&apos;)</span><br><span class="line">       -&gt;send();</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> Yii2 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> PHP </tag>
            
            <tag> Yii2 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Elastic Stack倒腾（1）- 使用Logstash从MySQL导入数据到Elastic</title>
      <link href="/posts/41170/"/>
      <url>/posts/41170/</url>
      
        <content type="html"><![CDATA[<h1 id="序言"><a href="#序言" class="headerlink" title="序言"></a>序言</h1><p>Elastic Stack是是Elastic公司的一套开源项目，这套技术栈也被广泛的称之为ELK。包括elasicsearch，logstash，kibana。其主要功能就是对数据进行收集，格式化，索引，分析和可视化。具有搭建简单，配置容易等优点。</p><p>起初，只有elasticsearch是elastic公司的，不过在接下来的一段时间内，elastic公司先后收购了logstash和kibana，统一三者的发布版本号，完善了三者间的配合，将三者打造成了数据收集分析和展示的利器。</p><p>ElasticStack从2014年开始逐渐趋于完善稳定，不过现在（2016年05月16日）仍处在快速迭代中。</p><p><strong>对于分析日志而言，一般分为三个步骤；日志收集，日志整理存储，数据展示。对应ElasticStack中的：L(ogstash)， E(lasticsearch)，K(ibana)。</strong></p><a id="more"></a><h1 id="安装"><a href="#安装" class="headerlink" title="安装"></a>安装</h1><p>本人的所有安装均在CentOs7下进行安装的，如系统不同，请做适当修改。</p><h1 id="安装JAVA"><a href="#安装JAVA" class="headerlink" title="安装JAVA"></a>安装JAVA</h1><p>ELK的运行需要基于Java，其次运行的时候，他会去在环境变量寻找Java，所以还需要设置环境变量。</p><ol><li><p>安装Java</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">yum install java-1.7.0-openjdk</span><br></pre></td></tr></table></figure></li><li><p>查找文件安装位置</p><p>如果我们不熟悉yum安装后的文件位置，可以通过<code>rpm -ql</code>来显示安装后的文件所在位置</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">rpm -ql java-1.8.0-openjdk</span><br></pre></td></tr></table></figure></li><li><p>设置环境变量</p><p>编辑<code>~/.bashrc</code>或<code>/etc/bashrc</code>， 在里面添加 <code>JAVA_HOME</code>和 <code>JRE_HOME</code></p><figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#set java environment </span></span><br><span class="line">JAVA_HOME=/usr/lib/jvm/java<span class="number">-1.7</span><span class="number">.0</span>-openjdk<span class="number">-1.7</span><span class="number">.0</span><span class="number">.75</span>.x86_64 </span><br><span class="line">JRE_HOME=$JAVA_HOME/jre </span><br><span class="line">CLASS_PATH=.:$JAVA_HOME/lib/dt.jar:$JAVA_HOME/lib/tools.jar:$JRE_HOME/lib </span><br><span class="line">PATH=$PATH:$JAVA_HOME/bin:$JRE_HOME/bin </span><br><span class="line">export JAVA_HOME JRE_HOME CLASS_PATH PATH</span><br></pre></td></tr></table></figure></li></ol><h2 id="安装Elastic"><a href="#安装Elastic" class="headerlink" title="安装Elastic"></a>安装Elastic</h2><p>官方提供了两种安装方式，一种是压缩包的方式，这种方式比较的简单，解压后既可以使用</p><h3 id="压缩包安装"><a href="#压缩包安装" class="headerlink" title="压缩包安装"></a>压缩包安装</h3><ol><li><p>从官网下载好 tar.gz 文件 （tar.gz 和 zip文件一样 看个人习惯）</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">wget https://artifacts.elastic.co/downloads/elasticsearch/elasticsearch-6.2.4.tar.gz</span><br></pre></td></tr></table></figure></li><li><p>解压压缩文件并进入文件夹</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">tar -zxf elasticsearch-6.2.4.tar.gz</span><br><span class="line">cd elasticsearch-6.2.4</span><br></pre></td></tr></table></figure></li><li><p>运行</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">bin/elasticsearch</span><br></pre></td></tr></table></figure><p>通过上面的命令运行的时候，你会发现elasticsearch是在前台运行的，终端关闭，elasticsearch也就关闭了，我们可以加个参数 <code>-d</code> 实现以守护进程的方式运行即可</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">bin/elasticsearch -d</span><br></pre></td></tr></table></figure></li><li><p>可能会遇到的问题</p><ol><li><p><strong>can not run elasticsearch as root</strong></p><p>新建一个 用户，并切换到这个用户，然后再启动elastic</p></li><li><p><strong>max file descriptors [4096] for elasticsearch process is too low, increase to at least [65536]</strong></p><p>切换到 root 用户修改</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">vim /etc/security/limits.conf</span><br></pre></td></tr></table></figure><p>在最后面追加下面内容</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">*** hard nofile 65536</span><br><span class="line">*** soft nofile 65536</span><br></pre></td></tr></table></figure></li><li><p><strong>Error occurred during initialization of VM，Could not reserve enough space for 2097152KB object heap</strong></p><p>这里主要是内存不足，将elastic的运行内存调低即可</p><p>切换到 root 用户修改</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">vim /etc/security/limits.conf</span><br></pre></td></tr></table></figure><p>将原文件中的下面内容</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">-Xms2g</span><br><span class="line">-Xms2g</span><br></pre></td></tr></table></figure><p>修改为</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">-Xms1g</span><br><span class="line">-Xms1g</span><br></pre></td></tr></table></figure></li></ol></li></ol><h3 id="YUM安装"><a href="#YUM安装" class="headerlink" title="YUM安装"></a>YUM安装</h3><ol><li><p>下载并安装签名密钥</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">rpm --import https://artifacts.elastic.co/GPG-KEY-elasticsearch</span><br></pre></td></tr></table></figure></li><li><p>添加repo源</p><p>编辑<code>elk.repo</code></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">vim /etc/yum.repos.d/elk.repo</span><br></pre></td></tr></table></figure><p>并添加一下内容</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">[elasticsearch-6.x]</span><br><span class="line">  name=Elasticsearch repository for 6.x packages</span><br><span class="line">baseurl=https://artifacts.elastic.co/packages/6.x/yum</span><br><span class="line">gpgcheck=1</span><br><span class="line">gpgkey=https://artifacts.elastic.co/GPG-KEY-elasticsearch</span><br><span class="line">enabled=1</span><br><span class="line">autorefresh=1</span><br><span class="line">type=rpm-md</span><br></pre></td></tr></table></figure></li><li><p>使用Yum安装</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">yum install elasticsearch</span><br></pre></td></tr></table></figure></li><li><p>测试是否安装成功</p><p>运行后，通过curl访问对应的端口</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">curl -XGET http://localhost:9200</span><br></pre></td></tr></table></figure><p>如果有内容返回，恭喜你。</p><p>​</p></li></ol><h2 id="安装Logstash"><a href="#安装Logstash" class="headerlink" title="安装Logstash"></a>安装Logstash</h2><h3 id="压缩包安装-1"><a href="#压缩包安装-1" class="headerlink" title="压缩包安装"></a>压缩包安装</h3><ol><li><p>从官网下载好 tar.gz 文件 （tar.gz 和 zip文件一样 看个人习惯）</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">wget https://artifacts.elastic.co/downloads/logstash/logstash-6.2.4.tar.gz</span><br></pre></td></tr></table></figure></li><li><p>解压压缩文件并进入文件夹</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">tar -zxf logstash-6.2.4.tar.gz</span><br><span class="line">cd logstash-6.2.4</span><br></pre></td></tr></table></figure></li><li><p>运行</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">bin/logstash -f logstash.conf</span><br></pre></td></tr></table></figure></li></ol><h3 id="YUM安装-1"><a href="#YUM安装-1" class="headerlink" title="YUM安装"></a>YUM安装</h3><ol><li><p>下载并安装签名密钥</p><p>这里其实跟elastic一样，如果上面执行过，可跳过</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">rpm --import https://artifacts.elastic.co/GPG-KEY-elasticsearch</span><br></pre></td></tr></table></figure></li><li><p>添加repo源</p><p>编辑<code>elk.repo</code></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">vim /etc/yum.repos.d/elk.repo</span><br></pre></td></tr></table></figure><p>并添加一下内容</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">[logstash-6.x]</span><br><span class="line">name=Elastic repository for 6.x packages</span><br><span class="line">baseurl=https://artifacts.elastic.co/packages/6.x/yum</span><br><span class="line">gpgcheck=1</span><br><span class="line">gpgkey=https://artifacts.elastic.co/GPG-KEY-elasticsearch</span><br><span class="line">enabled=1</span><br><span class="line">autorefresh=1</span><br><span class="line">type=rpm-md</span><br></pre></td></tr></table></figure></li><li><p>使用Yum安装</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">yum install logstash</span><br></pre></td></tr></table></figure></li></ol><h2 id="安装Kiban"><a href="#安装Kiban" class="headerlink" title="安装Kiban"></a>安装Kiban</h2><h3 id="压缩包安装-2"><a href="#压缩包安装-2" class="headerlink" title="压缩包安装"></a>压缩包安装</h3><ol><li><p>从官网下载好 tar.gz 文件 （tar.gz 和 zip文件一样 看个人习惯）</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">wget https://artifacts.elastic.co/downloads/kibana/kibana-6.2.4-linux-x86_64.tar.gz</span><br></pre></td></tr></table></figure></li><li><p>解压压缩文件并进入文件夹</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">tar -zxf kibana-6.2.4-linux-x86_64.tar.gz</span><br><span class="line">cd kibana-6.2.4-linux-x86_64</span><br></pre></td></tr></table></figure></li><li><p>修改<code>config/kibana.yml</code>里面的<em>elasticsearch.url</em> 指向你的 elastic的地址</p></li><li><p>运行</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">bin/kibana</span><br></pre></td></tr></table></figure></li><li><p>在浏览器查看</p><p>打开浏览器，输入你的服务器的ip:5601， 例<a href="http://127.0.0.1:5601" target="_blank" rel="noopener">http://127.0.0.1:5601</a>, 就可以看到Kibana的页面了，当然，有可能你的服务器没有开放5601端口，这里也可以通过nginx做个代理，进行访问，这个就放在下一篇文章讲解了。</p></li></ol><h3 id="YUM安装-2"><a href="#YUM安装-2" class="headerlink" title="YUM安装"></a>YUM安装</h3><ol><li><p>下载并安装签名密钥</p><p>这里其实跟elastic一样，如果上面执行过，可跳过</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">rpm --import https://artifacts.elastic.co/GPG-KEY-elasticsearch</span><br></pre></td></tr></table></figure></li><li><p>添加repo源</p><p>编辑<code>elk.repo</code></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">vim /etc/yum.repos.d/elk.repo</span><br></pre></td></tr></table></figure><p>并添加一下内容</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">[kibana-6.x]</span><br><span class="line">name=Kibana repository for 6.x packages</span><br><span class="line">baseurl=https://artifacts.elastic.co/packages/6.x/yum</span><br><span class="line">gpgcheck=1</span><br><span class="line">gpgkey=https://artifacts.elastic.co/GPG-KEY-elasticsearch</span><br><span class="line">enabled=1</span><br><span class="line">autorefresh=1</span><br><span class="line">type=rpm-md</span><br></pre></td></tr></table></figure></li><li><p>使用Yum安装</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">yum install kibana</span><br></pre></td></tr></table></figure></li></ol><h1 id="将数据从MySQL导入到elastic"><a href="#将数据从MySQL导入到elastic" class="headerlink" title="将数据从MySQL导入到elastic"></a>将数据从MySQL导入到elastic</h1><p>我们这里安装了Logstash，所以我们这里可以通过Logstash连接数据库，获取数据后推送到elastic，由于我们数据库的数据是递增的，我们使用Logstash的时候，也可以以递增的方式向elastic添加数据，这样也减少各个方面的压力</p><p>Logstash连接数据库需要jdbc的支持，所以，第一步还是安装扩展</p><h3 id="安装mysql-connector-java"><a href="#安装mysql-connector-java" class="headerlink" title="安装mysql-connector-java"></a>安装mysql-connector-java</h3><p>yum直接安装既可以，安装完成后，通过<code>rmp -ql</code> 找到 <strong>/usr/share/java/mysql-connector-java-5.1.17.jar</strong> 的位置，这里后面会用到</p><h3 id="配置Logstash的配置文件"><a href="#配置Logstash的配置文件" class="headerlink" title="配置Logstash的配置文件"></a>配置Logstash的配置文件</h3><p>在input里面，书写多个 对象， Logstash会从上而下执行，而不是覆盖，所以，如果你想一次添加多个表的数据到elastic，可以多写几个jdbc的对象，每个对象访问不同的库和表</p><p><a href="https://www.elastic.co/guide/en/logstash/current/plugins-inputs-jdbc.html" target="_blank" rel="noopener">https://www.elastic.co/guide/en/logstash/current/plugins-inputs-jdbc.html</a></p><p>上面是elastic官方的 jdbc 插件的使用说明，下面我就上一下自己的配置，并简单的附一下说明</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br></pre></td><td class="code"><pre><span class="line">input &#123;</span><br><span class="line">    jdbc &#123;</span><br><span class="line">        jdbc_connection_string =&gt; &quot;jdbc:mysql://localhost:3306/test&quot;     // jdbc的数据库连接</span><br><span class="line">        jdbc_user =&gt; &quot;*****&quot;            // 数据库用户名</span><br><span class="line">        jdbc_password =&gt; &quot;****&quot;         // 数据库密码</span><br><span class="line"></span><br><span class="line">        jdbc_driver_library =&gt; &quot;/usr/share/java/mysql-connector-java-5.1.17.jar&quot;     // java的mysql驱动，也就是上面我们安装的，地址替换成你服务器上的位置即可</span><br><span class="line">        jdbc_driver_class =&gt; &quot;com.mysql.jdbc.Driver&quot;     // java的mysql驱动类</span><br><span class="line"></span><br><span class="line">        codec =&gt; plain &#123;charset =&gt; &quot;UTF-8&quot;&#125;              // 编码，防乱码</span><br><span class="line">        </span><br><span class="line">        # 分页</span><br><span class="line">        jdbc_paging_enabled =&gt; true                   // 开启分页查询，这样可以减轻压力</span><br><span class="line">        jdbc_page_size =&gt; 300                         // 每次查询的数量</span><br><span class="line">        use_column_value =&gt; true                      // 是否使用列的值，因为我们开启了分页，所以这里设置为true</span><br><span class="line">        tracking_column =&gt; &quot;id&quot;                        // 跟踪的列的名称  这里是分页以及增量导入elastic的时候使用，与上面字段结合使用，logstash会将这个字段的值，存放在我们下面设置的文件里，然后每次查询的时候，会以存储的值为依据，向下查询</span><br><span class="line">        last_run_metadata_path =&gt; &quot;/data/elk/logstash-6.2.4/data/.logstash_jdbc_last_run_index&quot;</span><br><span class="line">        statement =&gt; &quot;select * from test where id &gt; :sql_last_value&quot;        // 查看的sql语句 sql_last_value是内置的变量 ，也是存放在上面文件中的值</span><br><span class="line">        type =&gt; &quot;test&quot;           // 类型，这里可以随便设置，我这里与表名相同</span><br><span class="line">    &#125;   </span><br><span class="line">    jdbc &#123;</span><br><span class="line">        jdbc_connection_string =&gt; &quot;jdbc:mysql://localhost:3306/test&quot;</span><br><span class="line">        jdbc_user =&gt; &quot;*****&quot;</span><br><span class="line">        jdbc_password =&gt; &quot;*****&quot;</span><br><span class="line"></span><br><span class="line">        jdbc_driver_library =&gt; &quot;/usr/share/java/mysql-connector-java-5.1.17.jar&quot;</span><br><span class="line">        jdbc_driver_class =&gt; &quot;com.mysql.jdbc.Driver&quot;</span><br><span class="line"></span><br><span class="line">        # 分页</span><br><span class="line">        jdbc_paging_enabled =&gt; true</span><br><span class="line">        jdbc_page_size =&gt; 300 </span><br><span class="line">        use_column_value =&gt; true</span><br><span class="line">        tracking_column =&gt; &quot;id&quot;</span><br><span class="line">        last_run_metadata_path =&gt; &quot;/data/elk/logstash-6.2.4/data/.logstash_jdbc_last_run_test1&quot;</span><br><span class="line">        statement =&gt; &quot;select * from test1 where id &gt; :sql_last_value&quot;</span><br><span class="line">        type =&gt; &quot;test1&quot;</span><br><span class="line">    &#125;</span><br><span class="line">output &#123;</span><br><span class="line">    stdout &#123;                  // 输出到屏幕终端</span><br><span class="line">        codec =&gt; rubydebug    // rubydebug格式输出</span><br><span class="line">    &#125;</span><br><span class="line">    elasticsearch &#123;             // 输出到elastic</span><br><span class="line">        &quot;hosts&quot; =&gt; &quot;127.0.0.1:9200&quot;           // elastic的地址</span><br><span class="line">        &quot;index&quot; =&gt; &quot;%&#123;type&#125;&quot;      // 类型  也就是我们上面设置的type的值，这样直接用，可以避免if 判断 但是索引就不能自定义了 有利有弊</span><br><span class="line">        # &quot;type&quot; =&gt; &quot;index&quot;</span><br><span class="line">        &quot;document_type&quot; =&gt; &quot;index&quot;   // elastic里面的type</span><br><span class="line">        &quot;document_id&quot; =&gt; &quot;%&#123;id&#125;&quot;     // elastic里面的id，这里建议使用mysql的id，避免mysql数据在elastic里面重复，同时方便查找及增删改查</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="后记"><a href="#后记" class="headerlink" title="后记"></a>后记</h1><p>个人也是刚刚接触ELK，准备打算将学习过程中的东西记录下来，也算是踩坑日记了，所以，ELK的相关东西后面应该还会有很多，Fighting！</p>]]></content>
      
      
      <categories>
          
          <category> ELK </category>
          
      </categories>
      
      
        <tags>
            
            <tag> ELK </tag>
            
            <tag> 大数据 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Sublime倒腾系列：SublimeLinter-PHP语法检验</title>
      <link href="/posts/48314/"/>
      <url>/posts/48314/</url>
      
        <content type="html"><![CDATA[<h1 id="安装"><a href="#安装" class="headerlink" title="安装"></a>安装</h1><p>通过<code>package controller</code>搜索安装<code>SublimeLinter</code>和<code>SublimeLinter-php</code>即可。</p><p>如果不清楚<code>package controller</code>的使用的话，可参考<a href="https://tyloafer.github.io/2018/04/21/sublime-sftp/">《Sublime倒腾系列：配置sftp实现文件上传下载》</a> 或 参考官方文档 <a href="https://packagecontrol.io/installation" target="_blank" rel="noopener">https://packagecontrol.io/installation</a> </p><h1 id="配置"><a href="#配置" class="headerlink" title="配置"></a>配置</h1><p><code>Preference</code> -&gt; <code>Package Setting</code> -&gt; <code>SublimeLinter</code> -&gt;<code>setting</code> 即可打开 <code>SublimeLinter</code> 的用户自定义界面，左侧是系统预设的配置，可以根据左侧的预设 在右边的用户设置中进行一下设置：</p><p>我的设置如下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">// SublimeLinter Settings - User</span><br><span class="line">&#123;</span><br><span class="line"></span><br><span class="line">    &quot;linters&quot;: &#123;</span><br><span class="line">        &quot;php&quot;: &#123;</span><br><span class="line">            &quot;executable&quot;: &quot;D:\\soft\\php72\\php.exe&quot;,     // 这里填写php执行脚本的绝对路径 mac和linux使用 / ，windows下使用\\</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;,</span><br><span class="line">    &quot;paths&quot;: &#123;</span><br><span class="line">        &quot;linux&quot;: [],</span><br><span class="line">        &quot;osx&quot;: [],</span><br><span class="line">        &quot;windows&quot;: [&quot;D:\\soft\\php72\\php.exe&quot;]  // // 这里填写环境变量的绝对地址  用到的添加上去即可</span><br><span class="line">    &#125;,</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>当然，你还可以根据自己的喜好进行配置，例如 style，显示的样式， panel显示等，这个就不多介绍了，注释写的很清晰了。</p>]]></content>
      
      
      <categories>
          
          <category> Sublime </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Sublime </tag>
            
            <tag> Package </tag>
            
            <tag> SublimeLinter </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Yii2倒腾系列：自定义错误处理</title>
      <link href="/posts/40357/"/>
      <url>/posts/40357/</url>
      
        <content type="html"><![CDATA[<h1 id="起因"><a href="#起因" class="headerlink" title="起因"></a>起因</h1><p>Yii2框架，在dev环境下时，错误提示是很友好的，但是，如果我们的代码在线上或者在预发布环境上，有时我们不需要将错误显示的那么明显，当然这时我们可以设置环境为prod，这样就不会有错误提示了，但是一旦出了错误，对于开发人员的排查也就比较耗时耗力了，这时，如果程序出错了，便能给开发人员发送一个邮件，告诉开发人员用户的请求地址，请求参数，错误文件，错误的行数，这样也就可以让开发人员在第一时间解决bug，而展示给用户的仅仅是一条我们定义的错误提示，这样是不是会更好呢？</p><a id="more"></a><h2 id="errorHandler组件设置"><a href="#errorHandler组件设置" class="headerlink" title="errorHandler组件设置"></a>errorHandler组件设置</h2><p>Yii2为我们提供了errorHandler组件，我们只需要设置一下当出现错误的时候，应该路由到的控制器即可，在main.php或main-local.php中的components中添加</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">&apos;errorHandler&apos; =&gt; [</span><br><span class="line">    &apos;errorAction&apos; =&gt; &apos;site/error&apos;,</span><br><span class="line">],</span><br></pre></td></tr></table></figure><p>其次，开启errorHandler 这个组件，需要，关闭debug，同时环境切换的dev下，即在index.php中，将<em>YII_DEBUG</em>和<em>YII_ENV</em> 定义如下</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">defined(&apos;YII_DEBUG&apos;) or define(&apos;YII_DEBUG&apos;, false);</span><br><span class="line">defined(&apos;YII_ENV&apos;) or define(&apos;YII_ENV&apos;, &apos;dev&apos;);</span><br></pre></td></tr></table></figure><p>最后，假如我们将错误处理交给SiteController下actionError() （site/error）这个方法处理，请保证SiteController或者SiteController的父类控制器里面没有下面的内容</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">public function actions()</span><br><span class="line">&#123;</span><br><span class="line">    return [</span><br><span class="line">        &apos;error&apos; =&gt; [</span><br><span class="line">            &apos;class&apos; =&gt; &apos;yii\web\ErrorAction&apos;,</span><br><span class="line">        ],</span><br><span class="line">    ];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>上面的 <em>actions</em> 方法会将<em>actionError()</em>这个方法重新指向 <em>yii\web\ErrorAction</em> 。</p><h1 id="将错误信息用邮件发给开发人员"><a href="#将错误信息用邮件发给开发人员" class="headerlink" title="将错误信息用邮件发给开发人员"></a>将错误信息用邮件发给开发人员</h1><p>Yii2框架本身的错误提示页面比较友好，所以我便将页面内容拿过来，并做了一点修改。</p><ol><li><p>首先新建一个error对应view模板页面（views/site/error.php），将Yii2本身的错误异常处理页面模板exception.php拷贝过来并修改，相信各位 这点简单的操作 肯定不是什么问题的。</p></li><li><p>将actionError()修改如下</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line">public function actionError()</span><br><span class="line">&#123;</span><br><span class="line">       http_response_code(200);</span><br><span class="line">       $exception = Yii::$app-&gt;errorHandler-&gt;exception;</span><br><span class="line">       $statusCode = Yii::$app-&gt;response-&gt;statusCode;</span><br><span class="line">       // 过滤404</span><br><span class="line">       // 此时在 file_put_contents的时候，由于jquery.map.js不存在而报404的错误</span><br><span class="line">       if ($statusCode != 404) &#123;</span><br><span class="line">           $exception_key = Yii::$app-&gt;params[&apos;ExceptionMailList&apos;];</span><br><span class="line">           $request_url = $_SERVER[&apos;REQUEST_SCHEME&apos;] . &quot;://&quot; . $_SERVER[&apos;HTTP_HOST&apos;] . $_SERVER[&apos;REQUEST_URI&apos;];</span><br><span class="line">           $params = json_encode(Yii::$app-&gt;request-&gt;post());</span><br><span class="line">           $content = $this-&gt;renderPartial(&apos;exception&apos;, [&apos;exception&apos; =&gt; $exception,</span><br><span class="line">               &apos;handler&apos; =&gt; Yii::$app-&gt;errorHandler,</span><br><span class="line">               &apos;request_url&apos; =&gt; $request_url,</span><br><span class="line">               &apos;params&apos;    =&gt;  $params</span><br><span class="line">           ]);</span><br><span class="line">           foreach (Yii::$app-&gt;params[&apos;ExceptionNotifyList&apos;] as $email) &#123;</span><br><span class="line">               Email::begin()-&gt;setType(&apos;exception&apos;)</span><br><span class="line">                   -&gt;setEmail($email)</span><br><span class="line">                   -&gt;setUsername(&apos;lixiaoyu&apos;)</span><br><span class="line">                   -&gt;setValue(&apos;content&apos;, $content)</span><br><span class="line">                   -&gt;send();</span><br><span class="line">           &#125;</span><br><span class="line">       &#125;</span><br><span class="line"></span><br><span class="line">       return  FunctionHelper::errorJson(&quot;An internal server error occurred&quot;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>上面代码仅仅是渲染异常页面，然后获取渲染后的页面，并作为邮件内容发送给设置的开发人员的邮箱，这样，便能在第一时间收到异常信息并处理了。</p></li></ol>]]></content>
      
      
      <categories>
          
          <category> Yii2 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> PHP </tag>
            
            <tag> Yii2 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Hexo中引入Mermaid流程图</title>
      <link href="/posts/7790/"/>
      <url>/posts/7790/</url>
      
        <content type="html"><![CDATA[<h1 id="起因"><a href="#起因" class="headerlink" title="起因"></a>起因</h1><p>流程图是个很清晰的展示自己思路的很好的工具，我在我的电脑上用Typora写的时候，自身带了mermaid流程图，但是上传到github上就无法解析了，Google若干后依旧没有效果，但是去Hexo官网逛逛的时候，无意中发现Hexo带有mermaid的插件，所以，对于不了解的技术，还是要多看多读官方文档 [!哀伤脸] 。</p><p>下面的内容摘自github并根据我自己的主题 <em>NEXT</em> 做了点修改， 下面的内容也是以 <em>NEXT</em> 主题为例，各位也可以直接看原版内容<a href="https://github.com/webappdevelp/hexo-filter-mermaid-diagrams" target="_blank" rel="noopener">https://github.com/webappdevelp/hexo-filter-mermaid-diagrams</a></p><a id="more"></a><h1 id="安装插件"><a href="#安装插件" class="headerlink" title="安装插件"></a>安装插件</h1><ol><li><p>yarn 安装</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">yarn add hexo-filter-mermaid-diagrams</span><br></pre></td></tr></table></figure></li><li><p>npm 安装</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">npm install hexo-filter-mermaid-diagrams</span><br></pre></td></tr></table></figure></li></ol><h1 id="编辑配置文件"><a href="#编辑配置文件" class="headerlink" title="编辑配置文件"></a>编辑配置文件</h1><p>配置文件<em>_config.yml</em>，应该分别在根目录下和themes/next/下分别有一个，我们这里编辑的是根目录下的配置文件</p><p>在 <em>_config.yml</em>  的最后加上以下内容</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"># mermaid chart</span><br><span class="line">mermaid: ## mermaid url https://github.com/knsv/mermaid</span><br><span class="line">  enable: true  # default true</span><br><span class="line">  version: &quot;7.1.2&quot; # default v7.1.2</span><br><span class="line">  options:  # find more api options from https://github.com/knsv/mermaid/blob/master/src/mermaidAPI.js</span><br><span class="line">    #startOnload: true  // default true</span><br></pre></td></tr></table></figure><h1 id="引入相关的js文件"><a href="#引入相关的js文件" class="headerlink" title="引入相关的js文件"></a>引入相关的js文件</h1><p>找到主题里面的页脚文件，也即  <code>themes/next/layout/_partials/footer.swig</code> ，在文件最后加上以下内容</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">&#123;% if (theme.mermaid.enable)  %&#125;</span><br><span class="line">  &lt;script src=&apos;https://unpkg.com/mermaid@&#123;&#123; theme.mermaid.version &#125;&#125;/dist/mermaid.min.js&apos;&gt;&lt;/script&gt;</span><br><span class="line">  &lt;script&gt;</span><br><span class="line">    if (window.mermaid) &#123;</span><br><span class="line">      mermaid.initialize(&#123;theme: &apos;forest&apos;&#125;);</span><br><span class="line">    &#125;</span><br><span class="line">  &lt;/script&gt;</span><br><span class="line">&#123;% endif %&#125;</span><br></pre></td></tr></table></figure><p>至此，重启hexo server应该就可以看到效果了。</p>]]></content>
      
      
      <categories>
          
          <category> Hexo </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Hexo </tag>
            
            <tag> Next </tag>
            
            <tag> Mermaid </tag>
            
            <tag> 流程图 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Sublime倒腾系列：配置sftp实现文件上传下载</title>
      <link href="/posts/45096/"/>
      <url>/posts/45096/</url>
      
        <content type="html"><![CDATA[<h1 id="起因"><a href="#起因" class="headerlink" title="起因"></a>起因</h1><p>作为一枚PHP程序猿，用sublime做开发总感觉自己很不入流，所以后来接触了一段时间的PHPStorm，不得不说，PHPStorm真的很强大，git、xdebug、sftp等能想到的基本都集成了，但是，对于PHPStorm，一直有两点不满意，一是自动补全，二是 界面！！！所以，也就从此开启了个人的Sublime倒腾之旅。而我对Sublime而别钟爱的地方也就是他的插件，每次玩的时候都感觉跟发现了新大陆一样，让我时刻保持着新鲜感。</p><p>下面就简单介绍一下，Sublime的插件-SFTP，标榜PHPStorm的SFTP。</p><a id="more"></a><h1 id="安装sftp"><a href="#安装sftp" class="headerlink" title="安装sftp"></a>安装sftp</h1><h2 id="安装package-controller"><a href="#安装package-controller" class="headerlink" title="安装package controller"></a>安装package controller</h2><p>官网虽然介绍的比较详细了，但是还是多废话一遍吧。</p><p>首先打开sublime，然后通过快捷键 <em>ctrl+`</em> 或者菜单的 <em>View &gt; Show Consoled</em>打开Sublime的控制台，然后输入下列代码，等待执行完成即可。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">import urllib.request,os,hashlib; h = &apos;6f4c264a24d933ce70df5dedcf1dcaee&apos; + &apos;ebe013ee18cced0ef93d5f746d80ef60&apos;; pf = &apos;Package Control.sublime-package&apos;; ipp = sublime.installed_packages_path(); urllib.request.install_opener( urllib.request.build_opener( urllib.request.ProxyHandler()) ); by = urllib.request.urlopen( &apos;http://packagecontrol.io/&apos; + pf.replace(&apos; &apos;, &apos;%20&apos;)).read(); dh = hashlib.sha256(by).hexdigest(); print(&apos;Error validating download (got %s instead of %s), please try manual install&apos; % (dh, h)) if dh != h else open(os.path.join( ipp, pf), &apos;wb&apos; ).write(by)</span><br></pre></td></tr></table></figure><h2 id="安装sftp-1"><a href="#安装sftp-1" class="headerlink" title="安装sftp"></a>安装sftp</h2><p>通过快捷键<em>ctrl_shift+p</em> ，然后在弹出的输入框中输入 <em>pci</em> , 找到 <em>Package Controller: Install Package</em> ,确定回车，然后输入<em>sftp</em>, 等待安装完成即可</p><h2 id="新建-sftp配置文件"><a href="#新建-sftp配置文件" class="headerlink" title="新建 sftp配置文件"></a>新建 sftp配置文件</h2><p>安装完成<em>sftp</em>，下一步就是配置了，将我们的目录指向远程服务器的目录，从而实现通过简单的快捷键或者自动上传更新远程文件以与本地保持同步</p><ol><li><p>在打开的文件夹的根目录新建文件<code>sftp-config.json</code></p></li><li><p>通过快捷键<em>Ctrl+shift+p</em> ,调出插件管理panel</p></li><li><p>输入<em>sftp</em>, 并找到 <em>SFTP: Brower Server</em>, 回车确定就发现sftp-config.json以被修改成如下</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">    // The tab key will cycle through the settings when first created</span><br><span class="line">    // Visit http://wbond.net/sublime_packages/sftp/settings for help</span><br><span class="line">    </span><br><span class="line">    // sftp, ftp or ftps</span><br><span class="line">    &quot;type&quot;: &quot;sftp&quot;,</span><br><span class="line"></span><br><span class="line">    &quot;sync_down_on_open&quot;: true,</span><br><span class="line">    &quot;sync_same_age&quot;: true,</span><br><span class="line">    </span><br><span class="line">    &quot;host&quot;: &quot;example.com&quot;,</span><br><span class="line">    &quot;user&quot;: &quot;username&quot;,</span><br><span class="line">    //&quot;password&quot;: &quot;password&quot;,</span><br><span class="line">    //&quot;port&quot;: &quot;22&quot;,</span><br><span class="line">    </span><br><span class="line">    &quot;remote_path&quot;: &quot;/example/path/&quot;,</span><br><span class="line">    //&quot;file_permissions&quot;: &quot;664&quot;,</span><br><span class="line">    //&quot;dir_permissions&quot;: &quot;775&quot;,</span><br><span class="line">    </span><br><span class="line">    //&quot;extra_list_connections&quot;: 0,</span><br><span class="line"></span><br><span class="line">    &quot;connect_timeout&quot;: 30,</span><br><span class="line">    //&quot;keepalive&quot;: 120,</span><br><span class="line">    //&quot;ftp_passive_mode&quot;: true,</span><br><span class="line">    //&quot;ftp_obey_passive_host&quot;: false,</span><br><span class="line">    //&quot;ssh_key_file&quot;: &quot;~/.ssh/id_rsa&quot;,</span><br><span class="line">    //&quot;sftp_flags&quot;: [&quot;-F&quot;, &quot;/path/to/ssh_config&quot;],</span><br><span class="line">    </span><br><span class="line">    //&quot;preserve_modification_times&quot;: false,</span><br><span class="line">    //&quot;remote_time_offset_in_hours&quot;: 0,</span><br><span class="line">    //&quot;remote_encoding&quot;: &quot;utf-8&quot;,</span><br><span class="line">    //&quot;remote_locale&quot;: &quot;C&quot;,</span><br><span class="line">    //&quot;allow_config_upload&quot;: false,</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>对配置文件进行修改，分别填写上自己的host user password remote_path 即可</p></li></ol><h2 id="扩展"><a href="#扩展" class="headerlink" title="扩展"></a>扩展</h2><p>通过上面的几步操作，已经可以实现将本地与远程文件实现同步了，但是，像我的服务器，关闭了用户名密码登录，仅允许密钥登录，这又该如何操作呢？</p><h3 id="生成ppk密钥"><a href="#生成ppk密钥" class="headerlink" title="生成ppk密钥"></a>生成ppk密钥</h3><p>经过我的尝试，我发现，如果通过密钥登录的话，Sublime不识别id_rsa这样格式的密钥，而仅仅识别.ppk结尾的密钥，这样我们就需要将我们的id_rsa文件转成.ppk格式</p><p>我这里是使用puttygen来进行密钥格式转换的</p><ol><li>下载好puttygen</li><li>选择puttygen菜单上的Conversions-&gt;Import Key 选择 密钥</li><li>点击面板上的 Save private key ，选择保存位置即可转换完成</li></ol><h3 id="配置sftp的密钥模式"><a href="#配置sftp的密钥模式" class="headerlink" title="配置sftp的密钥模式"></a>配置sftp的密钥模式</h3><p>密钥登录其实主要是上面配置文件中的 <em>ssh_key_file</em> 这个选项来决定的，这里要使用绝对地址，指向你的 .ppk 结尾的密钥，简单的上一下我的配置吧，各位读者应该就一目了然了</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">    // The tab key will cycle through the settings when first created</span><br><span class="line">    // Visit http://wbond.net/sublime_packages/sftp/settings for help</span><br><span class="line">    </span><br><span class="line">    // sftp, ftp or ftps</span><br><span class="line">    &quot;type&quot;: &quot;sftp&quot;,</span><br><span class="line"></span><br><span class="line">    &quot;save_before_upload&quot;: true,</span><br><span class="line">    &quot;upload_on_save&quot;: false,     // 当为true的时候，保存文件的时候会自动将你的文件上传到服务器，个人开发比较适合</span><br><span class="line">    &quot;sync_down_on_open&quot;: false,   // 当为true的时候，会自动同步远程的文件夹</span><br><span class="line">    &quot;sync_skip_deletes&quot;: false,</span><br><span class="line">    &quot;sync_same_age&quot;: true,</span><br><span class="line">    &quot;confirm_downloads&quot;: false,</span><br><span class="line">    &quot;confirm_sync&quot;: true,</span><br><span class="line">    &quot;confirm_overwrite_newer&quot;: false,</span><br><span class="line">    </span><br><span class="line">    &quot;host&quot;: &quot;xxx.xxx.xxx.xxx&quot;,</span><br><span class="line">    &quot;user&quot;: &quot;root&quot;,</span><br><span class="line">    //&quot;password&quot;: &quot;password&quot;,</span><br><span class="line">    //&quot;port&quot;: &quot;22&quot;,</span><br><span class="line">    </span><br><span class="line">    &quot;remote_path&quot;: &quot;/data/www/html/httpserver/&quot;,    // 这里是服务器的文件夹路径</span><br><span class="line">    &quot;ignore_regexes&quot;: [</span><br><span class="line">        &quot;\\.sublime-(project|workspace)&quot;, &quot;sftp-config(-alt\\d?)?\\.json&quot;,</span><br><span class="line">        &quot;sftp-settings\\.json&quot;, &quot;/venv/&quot;, &quot;\\.svn/&quot;, &quot;\\.hg/&quot;, &quot;\\.git/&quot;,</span><br><span class="line">        &quot;\\.bzr&quot;, &quot;_darcs&quot;, &quot;CVS&quot;, &quot;\\.DS_Store&quot;, &quot;Thumbs\\.db&quot;, &quot;desktop\\.ini&quot;</span><br><span class="line">    ],</span><br><span class="line">    //&quot;file_permissions&quot;: &quot;664&quot;,</span><br><span class="line">    //&quot;dir_permissions&quot;: &quot;775&quot;,</span><br><span class="line">    //&quot;extra_list_connections&quot;: 0,</span><br><span class="line"></span><br><span class="line">    &quot;connect_timeout&quot;: 30,</span><br><span class="line">    //&quot;keepalive&quot;: 120,</span><br><span class="line">    &quot;ftp_passive_mode&quot;: true,</span><br><span class="line">    &quot;ftp_obey_passive_host&quot;: false,</span><br><span class="line">    &quot;ssh_key_file&quot;: &quot;D:\\workplace\\cloudserver\\httpserver.ppk&quot;,   // windows下路径是\\， linux和Mac Os 是 /</span><br><span class="line">    // &quot;sftp_flags&quot;: [&quot;-F&quot;, &quot;/etc/ssh/ssh_config&quot;],</span><br><span class="line">    </span><br><span class="line">    //&quot;preserve_modification_times&quot;: false,</span><br><span class="line">    //&quot;remote_time_offset_in_hours&quot;: 0,</span><br><span class="line">    //&quot;remote_encoding&quot;: &quot;utf-8&quot;,</span><br><span class="line">    //&quot;remote_locale&quot;: &quot;C&quot;,</span><br><span class="line">    // &quot;allow_config_upload&quot;: false,</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> Sublime </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Sublime </tag>
            
            <tag> Sftp </tag>
            
            <tag> Package </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Session锁导致的ajax请求阻塞</title>
      <link href="/posts/17445/"/>
      <url>/posts/17445/</url>
      
        <content type="html"><![CDATA[<h1 id="起因"><a href="#起因" class="headerlink" title="起因"></a>起因</h1><p>在做项目的时候，做到登录这一块，需要同时支持扫码登录及账号密码登录，整体的思路如下</p><pre class="mermaid">graph TD    st(开始)-->op1(扫码登录界面)    st-->op2(帐密登录界面)    op1--手机端扫码并上传扫码者信息-->op3(扫码登录接口)    op3--返回web扫码者信息-->op1    op1--携带返回者信息请求-->op4(帐密登录接口)    op2--携带登录信息-->op4    op4--yes-->out1>登录成功]    op4--no-->out2>登录失败]    out1-->en(结束)    out2-->en</pre><p>后来发现，webLogin的接口每次调用都特别慢，打开debug后，发现webLogin都是在scanLogin接口结束后，才能开始处理，webLogin被阻塞了。</p><a id="more"></a><h1 id="处理"><a href="#处理" class="headerlink" title="处理"></a>处理</h1><p>排查过程比较繁琐，就直接省略了。这里的原因是，框架这里使用的是Yii2，Yii2会把在初始化的时候调用session_start()来启动session，而session是以文件形式存储的，session启动的时候会给相对应的session文件加上锁，接口处理结束时，取消锁，从而导致的第二个接口在调用的时候被挂起。</p><p>PHP中可以通过下面函数</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">session_write_close();</span><br></pre></td></tr></table></figure><p>关闭session的文件锁。</p><h1 id="扩展"><a href="#扩展" class="headerlink" title="扩展"></a>扩展</h1><h2 id="当你调用-session-start-时，都发生了什么"><a href="#当你调用-session-start-时，都发生了什么" class="headerlink" title="当你调用 session_start() 时，都发生了什么"></a>当你调用 session_start() 时，都发生了什么</h2><p>我们使用一个基本的 PHP 配置为例：当你开始一次 PHP 会话时，PHP会在 <em>session.save_path</em> 路径下创建一个普通的文件，默认路径为 <em>/var/lib/php/session</em> 。所有的 session 数据都保存在这个地方。</p><p>如果你的用户还没有一个 session cookie ，那么 PHP 将产生一个新的 ID，并设置到用户机器的 cookie 中。如果是一个已访问过的用户，那么他会将 cookie 发送给你的 web 服务器，PHP 则会解析它，并且从 <em>session.save_path</em> 路径下加载到相应的 session 数据。<br>简而言之，这就是 <em>session_start()</em> 的所做的工作。</p><h2 id="会话锁与并发"><a href="#会话锁与并发" class="headerlink" title="会话锁与并发"></a>会话锁与并发</h2><p>接下来我们举一个稍微完整一点的例子，来我们说明PHP初始化session后，各个场景下所发生的事情。</p><table><thead><tr><th>Timing</th><th>PHP Code</th><th>Linux/Server</th></tr></thead><tbody><tr><td>0ms</td><td><code>session_start();</code></td><td>创建文件锁：/var/lib/php/session/sess_$identifier</td></tr><tr><td>15ms</td><td>SQL查询，for循环，第三方API调用</td><td>持有session文件锁</td></tr><tr><td>350ms</td><td>PHP脚本执行结束</td><td>session文件锁被移除</td></tr></tbody></table><p>当你调用<strong>session_start()</strong>（或者PHP的<strong>session.auto_start</strong>被设置为true时，该方法会被自动调用），操作系统会锁住session文件。大多数文件锁的实现都是<code>flock</code>，在Linux上，它也用于<a href="https://ma.ttias.be/prevent-cronjobs-from-overlapping-in-linux/" target="_blank" rel="noopener">防止定时任务的重复执行</a>或者其它文件锁定工作。<br>在Linux机器上，一个session文件锁看起来就像这样子。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">$ fuser /var/lib/php/session/sess_cdmtgg3noi8fb6j2vqkaai9ff5</span><br><span class="line">/var/lib/php/session/sess_cdmtgg3noi8fb6j2vqkaai9ff5:  2768  2769  2770</span><br></pre></td></tr></table></figure><p><code>fuser</code>报告了3个进程的PID，这些进程要么正持有此文件锁，或者正在等待此文件锁的释放。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">$ lsof /var/lib/php/session/sess_cdmtgg3noi8fb6j2vqkaai9ff5</span><br><span class="line">COMMAND PID  USER      FD  TYPE DEVICE SIZE/OFF NODE   NAME</span><br><span class="line">php-fpm 2769 http_demo 5uW REG  253,1  0        655415 sess_cdmtgg3noi8fb6j2vqkaai9ff5</span><br></pre></td></tr></table></figure><p><code>lsof</code>可以告知你当前持有文件锁的PID以及指令。<br>该session的文件锁会保持到脚本执行结束或者被主动移除（后面会讲到）。这是一个读写锁：任何对session读取都必须等到锁被释放之后。<br>锁本身并不是问题。它保护session文件中的数据，防止多个同时写入损毁数据或者覆盖之前的数据。<br>但是当第二个并发的PHP执行想要获取同一个PHP会话的时候，就会造成问题了。</p><table><thead><tr><th>Timing</th><th>script 1</th><th>Linux/Server</th><th>script 2</th></tr></thead><tbody><tr><td>0ms</td><td><code>session_start();</code></td><td>script1锁定(<code>flock</code>)文件/var/lib/php/session/sess_$identifier</td><td><code>session_start();</code>被调用，但是被锁阻塞。PHP等待锁被移除。</td></tr><tr><td>15ms</td><td>SQL查询，for循环，第三方API调用</td><td>文件锁保持不变。</td><td>脚本仍然在等待，啥都不做。</td></tr><tr><td>350ms</td><td>script1执行结束。</td><td>script1持有的文件锁被移除。</td><td>script2仍然在等待。</td></tr><tr><td>360ms</td><td></td><td>script2得到新的文件锁。</td><td>script2现在可以执行它的SQL查询，for循环…</td></tr><tr><td>700ms</td><td></td><td>script2持有的文件锁被移除。</td><td>script2执行结束。</td></tr></tbody></table><p>解释一下上面的表格：</p><ul><li>当2个PHP文件同时想要开始一个会话时，只有一个能赢且获得锁。另一个则需要等待。</li><li>当它等待的时候，不会做任何事情：<code>session_start()</code>阻塞了之后动作的执行。</li><li>一旦第一个脚本的锁被移除，第二个脚本在获得锁的同时就可以向后继续执行了。</li></ul><p><strong>在绝大多数场景下，这都使得PHP对于同一个用户来说，表现得像是一系列同步脚本：一个执行完成后执行下一个，没有平行的请求。即使你使用AJAX调用这些PHP脚本也无济于事。</strong><br>所以，刚才两个脚本没能同时在350ms左右的时间执行完毕，第一个脚本350ms执行完毕，而第一个脚本则消耗两倍的时长执行了700ms，因为它得等第一个脚本先执行完。</p><h2 id="可选的session处理器：redis，memcache，mysql"><a href="#可选的session处理器：redis，memcache，mysql" class="headerlink" title="可选的session处理器：redis，memcache，mysql"></a>可选的session处理器：redis，memcache，mysql</h2><p>如果你在寻求一个快速的解决方案，觉得“我只需要把session保存在memcached里”，那么你会失望的。默认的memcached配置使用了与之前描述相同的、安全的逻辑：只要有一个PHP使用了sessions那它们就会阻塞。<br>如果你正在使用PHP的memcached扩展，你可以将<code>memcached.sess_locking</code>设置为“off”，来避免session锁。该配置项的默认值是“on”，与普通的session处理器一样会阻塞。<br>如果你在使用redis，那么你是幸运的，因为redis的session处理器还没有支持锁功能。用redis作为session存储后端，是没有锁的。<br>如果你在使用MySQL作为session后端存储，你会有一个自己的实现：没有一个PHP扩展实现了使用MySQL作为session存储的功能。在你的PHP代码中会有一个函数<a href="http://php.net/manual/en/function.session-set-save-handler.php" target="_blank" rel="noopener">session_set_save_handler()</a>申明了负责session数据读取和写入的类或者方法。也就是说你的代码实现决定了session是否会产生阻塞。</p><h2 id="PHP-session锁：想要解决的问题"><a href="#PHP-session锁：想要解决的问题" class="headerlink" title="PHP session锁：想要解决的问题"></a>PHP session锁：想要解决的问题</h2><p>我对于session锁行为的看法看起过于负面了，但实际上我只是提醒你注意它的行为方式。其实锁的存在也它好的一面。<br>想象以下没有“session锁”的场景，当两个脚本同时处理同一个session数据时，可能引发错误：</p><table><thead><tr><th>Timing</th><th>script 1</th><th>script 2</th></tr></thead><tbody><tr><td>0ms</td><td><code>session_start();</code>session数据被读入到$_SESSION变量中</td><td>1session数据被读入到$_SESSION变量中</td><td></td></tr><tr><td>15ms</td><td>脚本1写入session数据：<code>$_SESSION[&#39;payment_id&#39;] = 1;</code></td><td>脚本2写入session数据：<code>$_SESSION[&#39;payment_id&#39;] = 5;</code></td></tr><tr><td>350ms</td><td><code>sleep(1);</code></td><td>脚本结束，保存session数据</td></tr><tr><td>450ms</td><td>脚本结束，保存session数据</td></tr></tbody></table><blockquote><p>session中的数据值应该是多少？<br>应当是脚本1的所保存的值。因为脚本2所保存的值被脚本1最后所保存的值覆盖了。</p></blockquote><p><strong>这是一个非常尴尬，而且又很难排查的并发问题。session锁可以防止这种情况发生。</strong><br>绝大多数情况下，这是写session数据时才会碰到的问题。如果你有一个PHP脚本只是读取session数据（大多数ajax请求都是），你可以安全地对数据进行多次读取。<br>另一方面，如果你有一个长时间运行的脚本，它读取了session数据并且还会修改session数据，而另一个脚本开始执行并且读取到了旧的过时数据 — 这也可能使你的应用出错。</p><h2 id="关闭PHP的会话锁：PHP-5-x-和-PHP-7"><a href="#关闭PHP的会话锁：PHP-5-x-和-PHP-7" class="headerlink" title="关闭PHP的会话锁：PHP 5.x 和 PHP 7"></a>关闭PHP的会话锁：PHP 5.x 和 PHP 7</h2><p>PHP中有一个方法叫做<code>session_write_close()</code>。它的功能如其名：写入session数据，关闭session文件，从而解除了session锁。你在PHP代码中，可以这样使用。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">&lt;?php</span><br><span class="line">// This works in PHP 5.x and PHP 7</span><br><span class="line">session_start();</span><br><span class="line"></span><br><span class="line">$_SESSION[&apos;something&apos;] = &apos;foo&apos;;</span><br><span class="line">$_SESSION[&apos;yolo&apos;] = &apos;swag&apos;;</span><br><span class="line"></span><br><span class="line">session_write_close();</span><br><span class="line"></span><br><span class="line">// Do the rest of your PHP execution below</span><br></pre></td></tr></table></figure><p>上面的示例代码先开启了session（将session数据读到\$_SESSION中），然后写入数据再解除锁。接下来，它就再也不能写入这个session文件了。如果接下来该脚本还在继续操作$_SESSION变量，那么这些变化都不会被保存下来。<br>从PHP 7开始，在调用<code>session_start()</code>的时候你可设置额外的选项。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">&lt;?php</span><br><span class="line">session_start([</span><br><span class="line">  &apos;read_and_close&apos; =&gt; true</span><br><span class="line">]);</span><br><span class="line">?&gt;</span><br></pre></td></tr></table></figure><p>以上语法等同于：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">&lt;?php</span><br><span class="line">session_start();</span><br><span class="line"></span><br><span class="line">session_write_close();</span><br><span class="line">?&gt;</span><br></pre></td></tr></table></figure><p>它先读取了session数据，然后立刻释放了锁，这样就不会阻塞其它脚本了。</p>]]></content>
      
      
      <categories>
          
          <category> PHP </category>
          
      </categories>
      
      
        <tags>
            
            <tag> PHP </tag>
            
            <tag> Ajax </tag>
            
            <tag> SESSION </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>PHP获取环境变量</title>
      <link href="/posts/44810/"/>
      <url>/posts/44810/</url>
      
        <content type="html"><![CDATA[<h1 id="起因"><a href="#起因" class="headerlink" title="起因"></a>起因</h1><p>使用PHP的exec等函数与：Linux进行交互是很常见的方式，但是有时候发现，在终端里面通过命令行模式运行的代码可行，放到网站上去访问就出问题了，这里主要是因为在通过Nginx调起PHP-FPM的时候，会存在一些参数的配置问题下面就简单介绍一下这两种方式。</p><a id="more"></a><h1 id="解决-PHP-FPM模式"><a href="#解决-PHP-FPM模式" class="headerlink" title="解决-PHP-FPM模式"></a>解决-PHP-FPM模式</h1><ol><li><p>通过Nginx传递</p><p>如在nginx的配置里设置：<br><code>fastcgi_param  ENV_XXX  123456;</code><br>每次页面请求nginx都会将此变量传递给php，php可以通过getenv函数或$_SERVER全局变量获得。 </p></li><li><p>通过PHP-FPM配置传递</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">; Clear environment in FPM workers</span><br><span class="line">; Prevents arbitrary environment variables from reaching FPM worker processes</span><br><span class="line">; by clearing the environment in workers before env vars specified in this</span><br><span class="line">; pool configuration are added.</span><br><span class="line">; Setting to &quot;no&quot; will make all environment variables available to PHP code</span><br><span class="line">; via getenv(), _ENV and _SERVER.</span><br><span class="line">; Default Value: yes </span><br><span class="line">; clear_env = no</span><br><span class="line"></span><br><span class="line">; Pass environment variables like LD_LIBRARY_PATH. All $VARIABLEs are taken from</span><br><span class="line">; the current environment.</span><br><span class="line">; Default Value: clean env </span><br><span class="line">;env[HOSTNAME] = $HOSTNAME</span><br><span class="line">env[PATH] = /usr/local/bin:/usr/bin:/bin:/usr/local/sbin</span><br><span class="line">;env[TMP] = /tmp</span><br><span class="line">;env[TMPDIR] = /tmp</span><br><span class="line">;env[TEMP] = /tmp</span><br></pre></td></tr></table></figure><p>上面是php-fpm.conf（包括php-fpm.d/<a href="http://www.conf）里面关于环境变量的配置，在里面有一个`clear_env`的参数配置，这个默认是*yes*，而他的含义就是会把Linux上设置的环境变量给清空，这样的设置也是基于安全角度来考虑，我们此时把这个值设置为*no*即可，即" target="_blank" rel="noopener">www.conf）里面关于环境变量的配置，在里面有一个`clear_env`的参数配置，这个默认是*yes*，而他的含义就是会把Linux上设置的环境变量给清空，这样的设置也是基于安全角度来考虑，我们此时把这个值设置为*no*即可，即</a></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">clear_env = no</span><br></pre></td></tr></table></figure><p>在下面的配置中有一个<code>env[PATH]</code>的参数配置，这里也可以满足我们设置环境变量的需求</p><p>​</p><h1 id="解决-命令行模式"><a href="#解决-命令行模式" class="headerlink" title="解决-命令行模式"></a>解决-命令行模式</h1><p>命令行模式限制较少，可以通过getenv函数或$_SERVER全局变量获取对当前执行用户有效的系统环境变量，同样要注意sudo的限制</p></li></ol>]]></content>
      
      
      <categories>
          
          <category> PHP </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Linux </tag>
            
            <tag> PHP </tag>
            
            <tag> Nginx </tag>
            
            <tag> php-fpm </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>使用redis-dump对redis的数据进行导入导出</title>
      <link href="/posts/55761/"/>
      <url>/posts/55761/</url>
      
        <content type="html"><![CDATA[<h1 id="起因"><a href="#起因" class="headerlink" title="起因"></a>起因</h1><p>Redis虽然可以进行aof和rdb的备份，但是总是用起来没有MySQL对数据的管理感觉顺手，便产生了使用第三方来进行数据管理的想法以及实现。</p><a id="more"></a><h1 id="安装Ruby"><a href="#安装Ruby" class="headerlink" title="安装Ruby"></a>安装Ruby</h1><p>Redis-dump的安装依赖Ruby较高版本，yum源里面的Ruby版本较低，所以这里使用<code>rvm</code>进行安装</p><ol><li><p>安装<code>RVM</code></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">gpg --keyserver hkp://keys.gnupg.net --recv-keys 409B6B1796C275462A1703113804BB82D39DC0E3 7D2BAF1CF37B13E2069D6956105BD0E739499BDB</span><br><span class="line">\curl -sSL https://get.rvm.io | bash -s stable</span><br></pre></td></tr></table></figure></li><li><p>使用<code>RVM</code> 安装<code>Ruby</code></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">rvm install ruby</span><br></pre></td></tr></table></figure></li></ol><h1 id="安装redis-dump"><a href="#安装redis-dump" class="headerlink" title="安装redis-dump"></a>安装redis-dump</h1><p>直接使用<code>Ruby</code>的<code>gem</code>包管理直接安装即可</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">gem install redis-dump</span><br></pre></td></tr></table></figure><h1 id="使用redis-dump"><a href="#使用redis-dump" class="headerlink" title="使用redis-dump"></a>使用redis-dump</h1><ol><li><p>导出</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">redis-dump -u :password@xxx.xxx.xxx.xxx:6379 &gt; redis.json</span><br></pre></td></tr></table></figure></li><li><p>导入</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">redis-load -u :password@localhost &lt; redis.json</span><br></pre></td></tr></table></figure></li><li><p>更多</p><p>更多可参考官方使用手册</p><p><a href="http://delanotes.com/redis-dump/" target="_blank" rel="noopener">http://delanotes.com/redis-dump/</a></p></li></ol>]]></content>
      
      
      <categories>
          
          <category> Redis </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Linux </tag>
            
            <tag> Redis </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Windows上传ZIP文件到Linux下，解压乱码处理</title>
      <link href="/posts/35688/"/>
      <url>/posts/35688/</url>
      
        <content type="html"><![CDATA[<h1 id="起因"><a href="#起因" class="headerlink" title="起因"></a>起因</h1><p>作为码农，从windows上上传文件一般都会避免中文命名，都知道会有编码的问题，但是这个问题是不可逃避的。</p><p>近期，我给PM做一个产品原型的管理页面的时候，这个问题便不可避免的发生了。</p><a id="more"></a><h1 id="处理"><a href="#处理" class="headerlink" title="处理"></a>处理</h1><p>Linux下解压ZIP文件，主要依靠<code>unzip</code>这个命令，通过<code>-h</code>查看帮助后，发现<code>unzip</code>有个·<code>-O -I</code>这两个参数（ps: 如果没有，请升级到最新版本）</p><p>对于这两个参数的解释如下</p><blockquote><p>  -O CHARSET  specify a character encoding for DOS, Windows and OS/2 archives<br>  -I CHARSET  specify a character encoding for UNIX and other archives</p></blockquote><p>由上可知，我们这里使用<code>-O</code>应该就可以避免编码问题了</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">unzip -O gbk filename.zip</span><br></pre></td></tr></table></figure><h1 id="扩展问题-PHP下处理"><a href="#扩展问题-PHP下处理" class="headerlink" title="扩展问题-PHP下处理"></a>扩展问题-PHP下处理</h1><p>在Linux终端下，处理上述文件已经没有问题了，接下来肯定要考虑使用PHP来进行处理了。</p><p>php有一个ZipArchiv 解压缩类，但是我并没有找到针对编码的处理方式，所以无奈还是通过<code>exec</code>等命令来处理。<strong>注意：</strong> 如果你的php脚本是通过php-fpm来调度执行而不是php-cli直接执行的话，php-fpm的配置文件<em>php-fpm.conf</em>或<em>php-fpm.d/<a href="http://www.conf" target="_blank" rel="noopener">www.conf</a></em>里面会有环境变量的设置，这里要注意php-fpm的环境变量里面的<em>LANG</em>的值与Linux的设置的相同，不然还是会存在乱码的问题。</p>]]></content>
      
      
      <categories>
          
          <category> Debug </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Linux </tag>
            
            <tag> Debug </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Munin安装及监控-报警配置</title>
      <link href="/posts/25813/"/>
      <url>/posts/25813/</url>
      
        <content type="html"><![CDATA[<p>在完成<a href="https://tyloafer.github.io/2017/12/09/Munin监控安装及配置/">《Munin安装及监控》</a>之后，另一个功能-报警就被提上日程了，苦苦查看官方文档之后，发现也仅仅是介绍了有这个报警的功能。</p><a id="more"></a><h1 id="Command配置"><a href="#Command配置" class="headerlink" title="Command配置"></a>Command配置</h1><p>在<em>munin.conf</em> 有个配置是 <em>contact.anotheruser.command</em>， 而本篇文章的报警也是基于这个命令实现的，先贴一个示例</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">contact.munin.command mail -s &quot;Munin notification&quot; test@163.com</span><br></pre></td></tr></table></figure><p>可以看出，其中anotheruser是我们在监控的时候的，自己定义的一个用户，这个后面会介绍。</p><p>这里的 <em>mail -s</em> 是调用Linux终端的 mail 命令来发送邮件， 具体配置可参见<a href="https://tyloafer.github.io/2017/12/03/mail/">《Linux下使用mail发送邮件》</a>, 当然这里的命令也可以随便写，只要能在终端执行即可，例</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">contact.munin.command /usr/sbin/php /home/test.php</span><br></pre></td></tr></table></figure><h1 id="用户配置"><a href="#用户配置" class="headerlink" title="用户配置"></a>用户配置</h1><p>接着上面埋下的一个疑问，就是command前面的user，我怎么知道应该写哪个user，先贴一下我的一个memory的配置，这个配置时<em>plugin-conf.d/</em> 下面的<em>memory</em> 的配置</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">[memory]</span><br><span class="line">    user munin</span><br><span class="line">    env.swap_warning 80% </span><br><span class="line">    env.swap_critical 90% </span><br><span class="line">    env.active_warning 80% </span><br><span class="line">    env.cached_warning 80% </span><br><span class="line">    env.active_critical 90% </span><br><span class="line">    env.cached_critical 90% </span><br><span class="line">    env.apps_warning 80% </span><br><span class="line">    env.apps_critical 90% </span><br><span class="line">    env.cache_warning 80% </span><br><span class="line">    env.cache_critical 90%</span><br></pre></td></tr></table></figure><p>其实，user是我们配置的第一行指定的，这个munin在执行的时候，如果检测memory达到告警值的时候，就去找这个配置的user，然后执行相应的command</p><h1 id="建议"><a href="#建议" class="headerlink" title="建议"></a>建议</h1><p>Munin的监控插件是使用perl和python来写的，没事可以多看看插件源码，可以对监控的设置会有一个更加清晰的认知，同时也可以尝试自己用脚本语言写一下，练练手。</p>]]></content>
      
      
      <categories>
          
          <category> Linux </category>
          
      </categories>
      
      
        <tags>
            
            <tag> munin </tag>
            
            <tag> Linux </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Linux下mail发送邮件8015错误</title>
      <link href="/posts/58415/"/>
      <url>/posts/58415/</url>
      
        <content type="html"><![CDATA[<h1 id="起因"><a href="#起因" class="headerlink" title="起因"></a>起因</h1><p>在上上篇文章<a href="https://tyloafer.github.io/2017/12/03/mail/">Linux下使用mail发送邮件</a>中介绍了如何在linux下通过mail发送邮件，然而在后来我使用的过程中，却发现报错了</p><blockquote><p>Error initializing NSS: Unknown error -8015.</p></blockquote><a id="more"></a><h1 id="分析"><a href="#分析" class="headerlink" title="分析"></a>分析</h1><p>出现这个原因，主要是因为我监控系统需要用到，但监系统的执行用户和属组肯定不是root，但是我安装及配置的时候是使用root，同时，我在使用root用户发送邮件的时候却并没有这个错误。此上，基本确定应该是文件权限的问题了。</p><p>查看配置的时候，发现使用smtps发送的时候需要配置证书，也即下面一段</p><blockquote><p>set nss-config-dir=/etc/mail/.certs    # SSL证书保存位置，稍后个人制作</p></blockquote><h1 id="解决办法"><a href="#解决办法" class="headerlink" title="解决办法"></a>解决办法</h1><p>赋予其他用户 nss-config-dir下面文件的写的权限即可，如果感觉不安全，给予其他用户 你使用的 证书 写的权限即可</p><blockquote><p>chmod +r /etc/mail/.certs -R</p></blockquote>]]></content>
      
      
      <categories>
          
          <category> Linux </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Linux </tag>
            
            <tag> mail </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>PHP如何读取大文件</title>
      <link href="/posts/63198/"/>
      <url>/posts/63198/</url>
      
        <content type="html"><![CDATA[<h1 id="起因"><a href="#起因" class="headerlink" title="起因"></a>起因</h1><p>这是偶然间看到的一篇文章，感觉收获颇丰，故转载。转载自<a href="https://www.luyuqiang.com/how-php-read-a-large-file" target="_blank" rel="noopener">芦雨强的网络日志</a></p><h1 id="干货分割线"><a href="#干货分割线" class="headerlink" title="干货分割线"></a>干货分割线</h1><p>作为一个PHP开发者，我们经常需要关注内存管理。PHP引擎在我们运行脚本之后做了很好的清理工作，短周期执行的web服务器模型意味着即使是烂代码也不会长时间影响。</p><a id="more"></a><p>我们很少需要走出舒适的边界–比如我们尝试在一个小的VPS上为创建一个大项目运行Composer，或者当我们在小服务器上读取一个大文件。</p><p>这是后续将在本教程中呈现的问题。</p><p>教程代码可以在<a href="https://github.com/sitepoint-editors/sitepoint-performant-reading-of-big-files-in-php" target="_blank" rel="noopener">github</a>找到</p><h1 id="衡量成功"><a href="#衡量成功" class="headerlink" title="衡量成功"></a>衡量成功</h1><p>确定我们完善代码的唯一方式是把烂代码和修正过的代码进行比较。换句话说，我们不知道它是否是解决办法，除非我们知道它帮了多少。</p><p>有两个我们需要关心的指标。第一个是CPU的使用。我们想要过程快或者慢？第二个是内存的使用。脚本运行使用了多少内存？这些通常是成反比的-意味着我们可以在看CPU的使用时候，不看内存的使用，反之亦然。</p><p>在一个异步程序模型中（比如多进程或者多线程的PHP应用），CPU和内存使用都需要谨慎考虑的。在传统PHP架构中，当它们中的哪个达到服务器极限的时候通常就会有问题。</p><p>在PHP中测量CPU使用不切实际。如果你关注，可以考虑在Ubuntu或者MacOs中使用top命令。Windows可以考虑安装一个linux子系统，你就可以在Ubuntu上使用top。</p><p>这个教程的目的是测量内存使用。我们将看到「传统」脚本中内存的使用情况，之后将会优化并且测量，最后我希望你可以做一个学习后的选择。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">//php.net文档中格式化字节的方法</span><br><span class="line">memory_get_peak_usage();</span><br><span class="line"></span><br><span class="line">function formatBytes($bytes, $precision = 2) &#123;</span><br><span class="line">    $units = array(&apos;b&apos;, &apos;kb&apos;, &apos;mb&apos;, &apos;gb&apos;, &apos;tb&apos;);</span><br><span class="line"></span><br><span class="line">    $bytes = max($bytes, 0);</span><br><span class="line">    $pow = floor(($bytes ? log($bytes) : 0) / log(1024));</span><br><span class="line">    $pow = min($pow, count($units) - 1);</span><br><span class="line"></span><br><span class="line">    $bytes /= (1 &lt;&lt; (10 * $pow));</span><br><span class="line"></span><br><span class="line">    return round($bytes, $precision) . &apos; &apos; . $units[$pow];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>我们将会在脚本的最后使用这个函数，因此可以在第一时间看到哪个脚本使用了更多的内存。</p><h1 id="选项"><a href="#选项" class="headerlink" title="选项"></a>选项</h1><p>我们可以采取很多高效读取文件方法。但是有两种常用的场景。我们可以先读取后处理数据，然后输出处理后的数据或者执行其他操作。我们可能也想要转换一个数据流而不用获取数据。</p><p>对于第一种情况，我们读取一个文件，然后每一万行创建一个独立的队列进程。我们需要至少把一万行放到在内存中，然后把他们发送到队列管理器。</p><p>对于第二种情况，我们压缩一个特别大的API响应。我们不在乎它说什么，但我们需要确保它是以压缩形式备份的。</p><p>两种情况下，我们都需要读取大文件，只不过一个关注数据一个不关注。让我们探索这些选项吧。。。</p><h1 id="一行一行读文件"><a href="#一行一行读文件" class="headerlink" title="一行一行读文件"></a>一行一行读文件</h1><p>有很多处理文件的函数。让我们使用一个简单明了的文件读取：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">// from memory.php</span><br><span class="line"></span><br><span class="line">function formatBytes($bytes, $precision = 2) &#123;</span><br><span class="line">    $units = array(&apos;b&apos;, &apos;kb&apos;, &apos;mb&apos;, &apos;gb&apos;, &apos;tb&apos;);</span><br><span class="line"></span><br><span class="line">    $bytes = max($bytes, 0);</span><br><span class="line">    $pow = floor(($bytes ? log($bytes) : 0) / log(1024));</span><br><span class="line">    $pow = min($pow, count($units) - 1);</span><br><span class="line"></span><br><span class="line">    $bytes /= (1 &lt;&lt; (10 * $pow));</span><br><span class="line"></span><br><span class="line">    return round($bytes, $precision) . &apos; &apos; . $units[$pow];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">print formatBytes(memory_get_peak_usage());</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">// from reading-files-line-by-line-1.php</span><br><span class="line"></span><br><span class="line">function readTheFile($path) &#123;</span><br><span class="line">    $lines = [];</span><br><span class="line">    $handle = fopen($path, &apos;r&apos;);</span><br><span class="line"></span><br><span class="line">    while(!feof($handle)) &#123;</span><br><span class="line">        $lines[] = trim(fgets($handle));</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    fclose($handle);</span><br><span class="line">    return $lines;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">readTheFile(&apos;shakespeare.txt&apos;);</span><br><span class="line"></span><br><span class="line">require &apos;memory.php&apos;;</span><br></pre></td></tr></table></figure><p>我们正在读取一个包含莎士比亚全集的文本文件。文本文件大约5.5MB，消耗了12.8MB的内存。现在，让我们使用生成器来读取每一行：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">// from reading-files-line-by-line-2.php</span><br><span class="line"></span><br><span class="line">function readTheFile($path) &#123;</span><br><span class="line">    $handle = fopen($path, &apos;r&apos;);</span><br><span class="line"></span><br><span class="line">    while(!feof($handle)) &#123;</span><br><span class="line">        yield trim(fgets($handle));</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    fclose($handle);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">readTheFile(&apos;shakespeare.txt&apos;);</span><br><span class="line"></span><br><span class="line">require &apos;memory.php&apos;;</span><br></pre></td></tr></table></figure><p>这个文本文件同样大小，但是消耗了393KB的内存。这也说明不了什么，除非我们使用读取的数据做一些事。假设我们把文档以每两个空行分成小片段。就像：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">// from reading-files-line-by-line-3.php</span><br><span class="line"></span><br><span class="line">$iterator = readTheFile(&apos;shakespeare.txt&apos;);</span><br><span class="line"></span><br><span class="line">$buffer = &apos;&apos;;</span><br><span class="line"></span><br><span class="line">foreach ($iterator as $iteration) &#123;</span><br><span class="line">    preg_match(&apos;/\n&#123;3&#125;/&apos;, $buffer, $matches);</span><br><span class="line"></span><br><span class="line">    if (count($matches)) &#123;</span><br><span class="line">        print &apos;.&apos;;</span><br><span class="line">        $buffer = &apos;&apos;;</span><br><span class="line">    &#125; else &#123;</span><br><span class="line">        $buffer .= $iteration . PHP_EOL;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">require &apos;memory.php&apos;;</span><br></pre></td></tr></table></figure><p>猜一下我们现在用了多少内存？尽管我们把文档分割成了1216个片段，我们却只用了458KB的内存，意外吗？鉴于生成器的性质，我们内存消耗最大的是需要在循环中存储最大文本块的内存。在这种情况下，最大的块是101,985个字符。</p><p>我已经写了<a href="https://www.sitepoint.com/memory-performance-boosts-with-generators-and-nikiciter/" target="_blank" rel="noopener">使用生成器的性能提升</a>和<a href="https://github.com/nikic/iter" target="_blank" rel="noopener">Nikita Popov的生成器库</a>，所以你想要了解更多就去看吧。</p><p>生成器也有其他用法，但对读取大文件有很明显的性能提升。如果我们需要去处理数据，生成器也是最好的方式。</p><h1 id="文件间的管道输送"><a href="#文件间的管道输送" class="headerlink" title="文件间的管道输送"></a>文件间的管道输送</h1><p>在某些情况下，我们不需要处理数据，而是把一个文件的数据传递到另一个文件。这通常被叫做管道输送（大概因为我们只看到了两头，没看到管道内。。。当然它不是透明的）。我们可以通过使用流方法获取它们。写了个从一个文件传递到另一个的脚本，方便我们可以测量内存使用：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">// from piping-files-1.php</span><br><span class="line"></span><br><span class="line">file_put_contents(</span><br><span class="line">    &apos;piping-files-1.txt&apos;, file_get_contents(&apos;shakespeare.txt&apos;)</span><br><span class="line">);</span><br><span class="line"></span><br><span class="line">require &apos;memory.php&apos;;</span><br></pre></td></tr></table></figure><p>不出意外地，这个脚本使用比文件的拷贝更多的内存。这是因为它不得不读取、把文本内容放到内存中，然后写入到一个新文件。对于小文件还好。但是当我们处理一个大文件，就不妙了。。。</p><p>让我们使用流的方式从一个文件传递到另一个（或者叫管道输送）</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">// from piping-files-2.php</span><br><span class="line"></span><br><span class="line">$handle1 = fopen(&apos;shakespeare.txt&apos;, &apos;r&apos;);</span><br><span class="line">$handle2 = fopen(&apos;piping-files-2.txt&apos;, &apos;w&apos;);</span><br><span class="line"></span><br><span class="line">stream_copy_to_stream($handle1, $handle2);</span><br><span class="line"></span><br><span class="line">fclose($handle1);</span><br><span class="line">fclose($handle2);</span><br><span class="line"></span><br><span class="line">require &apos;memory.php&apos;;</span><br></pre></td></tr></table></figure><p>这段代码很奇怪。我们打开两个文件的句柄，第一个使用读模式，第二使用写模式。然后我们从第一个复制到第二个。然后关闭两个文件的句柄。是不是惊喜到你了，内存只使用了393KB。</p><p>这看起来是不是很熟悉。不就是我们使用生成器的代码一行一行读取然后存储吗？这是因为第二个变量使用fgets指定每行读取多少字节（默认-1或者直到一个新行）</p><p>stream_copy_to_stream的第三个参数是完全相同的参数（具有完全相同的默认值）。stream_copy_to_stream正在读取一个流，一次一行，并将其写入另一个流。 它跳过了生成器产生值的部分，因为我们不需要使用该值。</p><p>管道输送这些文本对我们来说没用，所以让我们仔细思考一下其他可能的例子。假设我们想要从CDN输出一个图像，重定向应用的路由。代码如下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">// from piping-files-3.php</span><br><span class="line"></span><br><span class="line">file_put_contents(</span><br><span class="line">    &apos;piping-files-3.jpeg&apos;, file_get_contents(</span><br><span class="line">        &apos;https://github.com/assertchris/uploads/raw/master/rick.jpg&apos;</span><br><span class="line">    )</span><br><span class="line">);</span><br><span class="line"></span><br><span class="line">// ...or write this straight to stdout, if we don&apos;t need the memory info</span><br><span class="line"></span><br><span class="line">require &apos;memory.php&apos;;</span><br></pre></td></tr></table></figure><p>我们可以使用以上代码解决一个应用的路由问题。但我们想从CDN获取而不是把文件存储在本地文件系统中。我们可能使用更优雅的（像<a href="http://docs.guzzlephp.org/en/stable/" target="_blank" rel="noopener">Guzzle</a>）替代file_get_contents，但是效果一样。</p><p>图片的内存使用大约581KB。现在，我们试着使用流替代？</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">// from piping-files-4.php</span><br><span class="line"></span><br><span class="line">$handle1 = fopen(</span><br><span class="line">    &apos;https://github.com/assertchris/uploads/raw/master/rick.jpg&apos;, &apos;r&apos;</span><br><span class="line">);</span><br><span class="line"></span><br><span class="line">$handle2 = fopen(</span><br><span class="line">    &apos;piping-files-4.jpeg&apos;, &apos;w&apos;</span><br><span class="line">);</span><br><span class="line"></span><br><span class="line">// ...or write this straight to stdout, if we don&apos;t need the memory info</span><br><span class="line"></span><br><span class="line">stream_copy_to_stream($handle1, $handle2);</span><br><span class="line"></span><br><span class="line">fclose($handle1);</span><br><span class="line">fclose($handle2);</span><br><span class="line"></span><br><span class="line">require &apos;memory.php&apos;;</span><br></pre></td></tr></table></figure><p>内存使用会略少（400KB），但是结果却一样。如果我们需要更多的内存信息，我们可以打印到standard output。事实上，PHP为实现这个提供了简单的方法。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">$handle1 = fopen(</span><br><span class="line">    &apos;https://github.com/assertchris/uploads/raw/master/rick.jpg&apos;, &apos;r&apos;</span><br><span class="line">);</span><br><span class="line"></span><br><span class="line">$handle2 = fopen(</span><br><span class="line">    &apos;php://stdout&apos;, &apos;w&apos;</span><br><span class="line">);</span><br><span class="line"></span><br><span class="line">stream_copy_to_stream($handle1, $handle2);</span><br><span class="line"></span><br><span class="line">fclose($handle1);</span><br><span class="line">fclose($handle2);</span><br><span class="line"></span><br><span class="line">// require &apos;memory.php&apos;;</span><br></pre></td></tr></table></figure><h1 id="其他流"><a href="#其他流" class="headerlink" title="其他流"></a>其他流</h1><p>有一些其他流我们可以管道传递、读、或者写：</p><ul><li>php://stdin (只读)</li><li>php://stderr (只写, 像 php://stdout)</li><li>php://input (只读) 获取原请求体</li><li>php://output (只写) 可以写到缓冲区</li><li>php://memory 和 php://temp (读写)存储临时数据的地方。php://temp不同的是以文件存储，php://memory存储在内存</li></ul><h1 id="过滤器"><a href="#过滤器" class="headerlink" title="过滤器"></a>过滤器</h1><p>还有一个使用流的技巧叫过滤器。它们是中间步骤，提供管理流而不暴露给我们的功能。设想一下我们想要压缩莎士比亚.txt。可能会使用Zip扩展：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">// from filters-1.php</span><br><span class="line"></span><br><span class="line">$zip = new ZipArchive();</span><br><span class="line">$filename = &apos;filters-1.zip&apos;;</span><br><span class="line"></span><br><span class="line">$zip-&gt;open($filename, ZipArchive::CREATE);</span><br><span class="line">$zip-&gt;addFromString(&apos;shakespeare.txt&apos;, file_get_contents(&apos;shakespeare.txt&apos;));</span><br><span class="line">$zip-&gt;close();</span><br><span class="line"></span><br><span class="line">require &apos;memory.php&apos;;</span><br></pre></td></tr></table></figure><p>整洁的代码，但是却消耗了10.75MB。我们使用过滤器改进：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">// from filters-2.php</span><br><span class="line"></span><br><span class="line">$handle1 = fopen(</span><br><span class="line">    &apos;php://filter/zlib.deflate/resource=shakespeare.txt&apos;, &apos;r&apos;</span><br><span class="line">);</span><br><span class="line"></span><br><span class="line">$handle2 = fopen(</span><br><span class="line">    &apos;filters-2.deflated&apos;, &apos;w&apos;</span><br><span class="line">);</span><br><span class="line"></span><br><span class="line">stream_copy_to_stream($handle1, $handle2);</span><br><span class="line"></span><br><span class="line">fclose($handle1);</span><br><span class="line">fclose($handle2);</span><br><span class="line"></span><br><span class="line">require &apos;memory.php&apos;;</span><br></pre></td></tr></table></figure><p>可以看到使用php://filter/zlib.defalte的过滤器来压缩资源。我们可以把一个压缩后的数据管道传递到另一个文件。内存消耗896KB。</p><p>我知道这不是同一个格式，或者使用zip压缩更好。但是你不得不怀疑：如果你选择不同的格式可以节省掉12倍的内存，何乐而不为呢？</p><p>可以通过另一个zlib的解压缩过滤器解压文件：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">// from filters-2.php</span><br><span class="line"></span><br><span class="line">file_get_contents(</span><br><span class="line">    &apos;php://filter/zlib.inflate/resource=filters-2.deflated&apos;</span><br><span class="line">);</span><br></pre></td></tr></table></figure><p>流已经在<a href="https://www.sitepoint.com/%EF%BB%BFunderstanding-streams-in-php/" target="_blank" rel="noopener">理解PHP中的流</a> 和 <a href="https://www.sitepoint.com/using-php-streams-effectively/" target="_blank" rel="noopener">PHP流与效率</a>中大量提及。如果你想要了解更多，点开看看。</p><h1 id="自定义流"><a href="#自定义流" class="headerlink" title="自定义流"></a>自定义流</h1><p>fopen和file_get_contents有他们自己的默认设置，但是可以完全的自定义。为了方便理解，自己创建一个新的流：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line">// from creating-contexts-1.php</span><br><span class="line"></span><br><span class="line">$data = join(&apos;&amp;&apos;, [</span><br><span class="line">    &apos;twitter=assertchris&apos;,</span><br><span class="line">]);</span><br><span class="line"></span><br><span class="line">$headers = join(&apos;\r\n&apos;, [</span><br><span class="line">    &apos;Content-type: application/x-www-form-urlencoded&apos;,</span><br><span class="line">    &apos;Content-length: &apos; . strlen($data),</span><br><span class="line">]);</span><br><span class="line"></span><br><span class="line">$options = [</span><br><span class="line">    &apos;http&apos; =&gt; [</span><br><span class="line">        &apos;method&apos; =&gt; &apos;POST&apos;,</span><br><span class="line">        &apos;header&apos;=&gt; $headers,</span><br><span class="line">        &apos;content&apos; =&gt; $data,</span><br><span class="line">    ],</span><br><span class="line">];</span><br><span class="line"></span><br><span class="line">$context = stream_content_create($options);</span><br><span class="line"></span><br><span class="line">$handle = fopen(&apos;https://example.com/register&apos;, &apos;r&apos;, false, $context);</span><br><span class="line">$response = stream_get_contents($handle);</span><br><span class="line"></span><br><span class="line">fclose($handle);</span><br></pre></td></tr></table></figure><p>在这个例子中，我们尝试向API发出POST请求。API端是安全的，但是仍需要使用http上下文属性（用于http和http）。我们设置一些头并且打开API文件句柄。考虑到安全，我们以只读方式打开。</p><p>可以自定义很多东西，所以如果你想了解更多，最好查看<a href="https://php.net/function.stream-context-create" target="_blank" rel="noopener">文档</a>。</p><h1 id="自定义协议的过滤器"><a href="#自定义协议的过滤器" class="headerlink" title="自定义协议的过滤器"></a>自定义协议的过滤器</h1><p>在本文结束之前，来谈谈自定义协议。 如果你看<a href="https://php.net/manual/en/class.streamwrapper.php" target="_blank" rel="noopener">文档</a>，你可以找到一个示例类来实现：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line">Protocol &#123;</span><br><span class="line">    public resource $context;</span><br><span class="line">    public construct ( void )</span><br><span class="line">    public destruct ( void )</span><br><span class="line">    public bool dir_closedir ( void )</span><br><span class="line">    public bool dir_opendir ( string $path , int $options )</span><br><span class="line">    public string dir_readdir ( void )</span><br><span class="line">    public bool dir_rewinddir ( void )</span><br><span class="line">    public bool mkdir ( string $path , int $mode , int $options )</span><br><span class="line">    public bool rename ( string $path_from , string $path_to )</span><br><span class="line">    public bool rmdir ( string $path , int $options )</span><br><span class="line">    public resource stream_cast ( int $cast_as )</span><br><span class="line">    public void stream_close ( void )</span><br><span class="line">    public bool stream_eof ( void )</span><br><span class="line">    public bool stream_flush ( void )</span><br><span class="line">    public bool stream_lock ( int $operation )</span><br><span class="line">    public bool stream_metadata ( string $path , int $option , mixed $value )</span><br><span class="line">    public bool stream_open ( string $path , string $mode , int $options ,</span><br><span class="line">        string &amp;$opened_path )</span><br><span class="line">    public string stream_read ( int $count )</span><br><span class="line">    public bool stream_seek ( int $offset , int $whence = SEEK_SET )</span><br><span class="line">    public bool stream_set_option ( int $option , int $arg1 , int $arg2 )</span><br><span class="line">    public array stream_stat ( void )</span><br><span class="line">    public int stream_tell ( void )</span><br><span class="line">    public bool stream_truncate ( int $new_size )</span><br><span class="line">    public int stream_write ( string $data )</span><br><span class="line">    public bool unlink ( string $path )</span><br><span class="line">    public array url_stat ( string $path , int $flags )</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>我们不打算实现在教程中，因为我认为这是值得的自己完成过程。需要做很多工作，但是一旦这个工作完成，可以很容易地注册的流包装：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">if (in_array(&apos;highlight-names&apos;, stream_get_wrappers())) &#123;</span><br><span class="line">    stream_wrapper_unregister(&apos;highlight-names&apos;);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">stream_wrapper_register(&apos;highlight-names&apos;, &apos;HighlightNamesProtocol&apos;);</span><br><span class="line"></span><br><span class="line">$highlighted = file_get_contents(&apos;highlight-names://story.txt&apos;);</span><br></pre></td></tr></table></figure><p>类似地，可以自己创建一个自定义流过滤器。文档有一个过滤器类的例子：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">Filter &#123;</span><br><span class="line">    public $filtername;</span><br><span class="line">    public $params</span><br><span class="line">    public int filter ( resource $in , resource $out , int &amp;$consumed ,</span><br><span class="line">        bool $closing )</span><br><span class="line">    public void onClose ( void )</span><br><span class="line">    public bool onCreate ( void )</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>很容易注册：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">$handle = fopen(&apos;story.txt&apos;, &apos;w+&apos;);</span><br><span class="line">stream_filter_append($handle, &apos;highlight-names&apos;, STREAM_FILTER_READ);</span><br></pre></td></tr></table></figure><p>高亮名字过滤器需要去匹配新的过滤器类的过滤器名属性。也可以在php：//filter/highligh-names/resource=story.txt字符串中使用自定义过滤器。定义过滤器比定义协议要容易得多。 其中一个原因是协议需要处理目录操作，而过滤器只需处理每个数据块。</p><p>如果你有强烈的进取心，鼓励你编写协议的过滤器。如果你可以将过滤器应用于stream_copy_to_stream操作，那么即使处理大容量的大文件，你的应用程序内存也不会超阈值。 试着编写一个调整图像大小的过滤器或加密应用程序的过滤器。</p><h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><p>尽管这不是我们经常处理的问题，在读取大文件时也很容易陷入困境。在异步应用中，当我们不注意内存使用时，很容易就把整个服务搞挂。</p><p>这个教程希望给你讲解一些新想法（或者唤醒你的记忆），以便你能在读、写大文件时想得更多。当开始熟练掌握流和生成器后，停止使用像file_get_contents函数：一些莫名其妙问题就在程序中消失了。这就是意义所在！</p><h1 id="声明"><a href="#声明" class="headerlink" title="声明"></a>声明</h1><p>本文转载自<a href="https://www.luyuqiang.com/how-php-read-a-large-file" target="_blank" rel="noopener">芦雨强的网络日志</a></p>]]></content>
      
      
      <categories>
          
          <category> PHP </category>
          
      </categories>
      
      
        <tags>
            
            <tag> PHP </tag>
            
            <tag> 优化 </tag>
            
            <tag> 大文件 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>file_get_contents使用SSL连接报错</title>
      <link href="/posts/55399/"/>
      <url>/posts/55399/</url>
      
        <content type="html"><![CDATA[<h1 id="分析"><a href="#分析" class="headerlink" title="分析"></a>分析</h1><p>在使用file_get_contents的时候，有时候获取受信任的https的内容是正常的，但是遇到一些不受信任的https连接，就会报错，主要原因还是不受信任的https大部分是自制证书或者已过期等等，检测证书的时候没通过。</p><p>既然知道了原因，那不让他验证ssl不就可以了。</p><a id="more"></a><h1 id="处理"><a href="#处理" class="headerlink" title="处理"></a>处理</h1><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">string file_get_contents ( string $filename [, bool $use_include_path = false [, resource $context [, int $offset = -1 [, int $maxlen ]]]] )</span><br></pre></td></tr></table></figure><p>上述是<em>file_get_contents()</em> 函数的文档，第三参数可以设置一些头信息等，就如同使用curl一样，我们在头部添加一下信息就可以不验证ssl了</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">&quot;ssl&quot;=&gt;array(</span><br><span class="line">  &quot;verify_peer&quot;=&gt;false,</span><br><span class="line">  &quot;verify_peer_name&quot;=&gt;false,</span><br><span class="line">),</span><br></pre></td></tr></table></figure><p>完整使用用例如下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">&lt;?php</span><br><span class="line">$opts = [</span><br><span class="line">    &quot;ssl&quot; =&gt; [</span><br><span class="line">        &quot;verify_peer&quot;=&gt;false,</span><br><span class="line">        &quot;verify_peer_name&quot;=&gt;false,</span><br><span class="line">    ],</span><br><span class="line">];</span><br><span class="line">$context = stream_context_create($opts);</span><br><span class="line">$response = file_get_contents(&quot;https://tyloafer.github.io/2018/12/03/mail/&quot;, false, $context);</span><br></pre></td></tr></table></figure><h1 id="扩展"><a href="#扩展" class="headerlink" title="扩展"></a>扩展</h1><p>官方实例中有如下用法：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">&lt;?php</span><br><span class="line">// Create a stream</span><br><span class="line">$opts = array(</span><br><span class="line">  &apos;http&apos;=&gt;array(</span><br><span class="line">    &apos;method&apos;=&gt;&quot;GET&quot;,</span><br><span class="line">    &apos;header&apos;=&gt;&quot;Accept-language: en\r\n&quot; .</span><br><span class="line">              &quot;Cookie: foo=bar\r\n&quot;</span><br><span class="line">  )</span><br><span class="line">);</span><br><span class="line"></span><br><span class="line">$context = stream_context_create($opts);</span><br><span class="line"></span><br><span class="line">// Open the file using the HTTP headers set above</span><br><span class="line">$file = file_get_contents(&apos;http://www.example.com/&apos;, false, $context);</span><br></pre></td></tr></table></figure><p>也就是说 其实我们可以在第三个参数中这是header、cookie、params等信息，这样就可以跟curl一样模拟post和get请求了。用例就不详述了，各位猿们自行探索吧。</p>]]></content>
      
      
      <categories>
          
          <category> PHP </category>
          
      </categories>
      
      
        <tags>
            
            <tag> PHP </tag>
            
            <tag> Debug </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Munin安装及监控</title>
      <link href="/posts/62852/"/>
      <url>/posts/62852/</url>
      
        <content type="html"><![CDATA[<h1 id="安装munin"><a href="#安装munin" class="headerlink" title="安装munin"></a>安装munin</h1><ol><li><p>通过yum安装munin munin-node httpd</p><pre><code>yum -y install munin munin-node httpd</code></pre><a id="more"></a></li><li><p>修改配置文件/etc/munin/munin.conf </p> <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">dbdir /data/www/html/munin/databases // 数据库存放地址 </span><br><span class="line">htmldir /data/www/html/munin/html //页面存放地址</span><br><span class="line">logdir /data/www/html/munin/log // 日志存放地址 </span><br><span class="line">rundir /var/run/munin // 运行时pid存放地址 </span><br><span class="line"></span><br><span class="line"># Where to look for the HTML templates </span><br><span class="line"># </span><br><span class="line">tmpldir /etc/munin/templates </span><br><span class="line"></span><br><span class="line"># a simple host tree </span><br><span class="line">[localhost] </span><br><span class="line">    address 127.0.0.1 </span><br><span class="line">    use_node_name yes</span><br></pre></td></tr></table></figure></li><li><p>创建存放地址并修改权限<br>​      </p><pre><code>mkdir /data/www/html/munin/databases /data/www/html/munin/html /data/www/html/munin/logchown munin:munin /data/www/html/munin -R</code></pre></li></ol><ol start="3"><li><p>启动munin-node<br>​      </p><pre><code>service munin-node start</code></pre><p>查看配置中htmldir的路径下是否生成了HTML等静态文件，如没有，请执行下面命令   </p><pre><code>su munin --shell=/bin/bashmunin-cron</code></pre></li><li><p>访问静态页面的存放地址即可查看,此处没有单独配置域名，所以直接访问http://域名/munin/html/即可</p></li></ol><h1 id="利用cgi动态绘制图形"><a href="#利用cgi动态绘制图形" class="headerlink" title="利用cgi动态绘制图形"></a>利用cgi动态绘制图形</h1><pre><code>yum -y install  spawn-fcgi # 安装绘图的cgispawn-fcgi -s /var/run/munin/fastcgi-graph.sock    -u munin -g munin /var/www/cgi-bin/munin-cgi-graph # 启动进程，这里的sock的路径可自定义，后期需要在nginx中进行配置</code></pre><p>综上将fcgi安装启动完成，下面将fcgi整合到nginx中进行动态的绘制图片</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">location ^~ /munin-cgi/munin-cgi-graph/ &#123;</span><br><span class="line">    root /data/www/html</span><br><span class="line">    fastcgi_split_path_info ^(/munin-cgi/munin-cgi-graph)(.*);</span><br><span class="line">    fastcgi_param PATH_INFO $fastcgi_path_info;</span><br><span class="line">    fastcgi_pass unix:/var/run/munin/fastcgi-graph.sock;</span><br><span class="line">    include fastcgi_params;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="监控nginx"><a href="#监控nginx" class="headerlink" title="监控nginx"></a>监控nginx</h1><p>监控nginx其实是利用了nginx的<em>http_stub_status_module</em>m模块来获取nginx的请求和状态。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">my $URL = exists $ENV&#123;&apos;url&apos;&#125; ? $ENV&#123;&apos;url&apos;&#125; : &quot;http://localhost/nginx_status&quot;;                   </span><br><span class="line">my $port = exists $ENV&#123;&apos;port&apos;&#125; ? $ENV&#123;&apos;port&apos;&#125; : &quot;80&quot;;                                           </span><br><span class="line">                                                                                                </span><br><span class="line">if ( exists $ARGV[0] and $ARGV[0] eq &quot;autoconf&quot; )                                               </span><br><span class="line">&#123;</span><br><span class="line">    if ($ret)&#123;</span><br><span class="line">        print &quot;no ($ret)\n&quot;;</span><br><span class="line">        exit 0;</span><br><span class="line">    &#125;</span><br><span class="line">    my $ua = LWP::UserAgent-&gt;new(timeout =&gt; 30,</span><br><span class="line">            agent =&gt; sprintf(&quot;munin/%s (libwww-perl/%s)&quot;,    $Munin::Common::Defaults::MUNIN_VERSION, $LWP::VERSION));     </span><br><span class="line">    my $response = $ua-&gt;request(HTTP::Request-&gt;new(&apos;GET&apos;,$URL));</span><br><span class="line">    unless ($response-&gt;is_success and $response-&gt;content =~ /server/im)</span><br><span class="line">    &#123;</span><br><span class="line">        print &quot;no (no nginx status on $URL)\n&quot;;</span><br><span class="line">        exit 0;</span><br><span class="line">    &#125;</span><br><span class="line">    else</span><br><span class="line">    &#123;</span><br><span class="line">        print &quot;yes\n&quot;;</span><br><span class="line">        exit 0;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>这是nginx_request模块的源码，通过上面可以看出，其实这个程序是去请求里面的url，从而获得nginx的一些状态<br>接下来我们看一下官方nginx的配置<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">server &#123;</span><br><span class="line">      listen 80;</span><br><span class="line">      server_name localhost;</span><br><span class="line">      location /nginx_status &#123;</span><br><span class="line">              stub_status on;</span><br><span class="line">              access_log   off;</span><br><span class="line">              allow 127.0.0.1;</span><br><span class="line">              deny all;</span><br><span class="line">      &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>综上，整体思路可以理清：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">graph LR</span><br><span class="line">munin发起请求--&gt;nginx获取请求</span><br><span class="line">nginx获取请求--&gt;nginx解析请求,启动stu_status模块</span><br></pre></td></tr></table></figure><p>所以，只要将官方的nginx配置加入到nginx.conf中即可，但是，在此我遇到了一个问题，通过curl访问这<em>个<a href="https://localhost/nginx_status" target="_blank" rel="noopener">https://localhost/nginx_status</a></em> 返回的是</p><pre><code>curl: (7) Failed connect to localhost:80; Connection refused</code></pre><p>但是访问127.0.0.1却是可以的，我的配置如下</p><p><strong>nginx.conf</strong><br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">server &#123;</span><br><span class="line">      listen 80;</span><br><span class="line">      server_name 127.0.0.1;</span><br><span class="line">      location /nginx_status &#123;</span><br><span class="line">              stub_status on;</span><br><span class="line">              access_log   off;</span><br><span class="line">              allow 127.0.0.1;</span><br><span class="line">              deny all;</span><br><span class="line">      &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p><strong>nginx_request</strong><br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">my $URL = exists $ENV&#123;&apos;url&apos;&#125; ? $ENV&#123;&apos;url&apos;&#125; : &quot;http://127.0.0.1/nginx_status&quot;;                   </span><br><span class="line">my $port = exists $ENV&#123;&apos;port&apos;&#125; ? $ENV&#123;&apos;port&apos;&#125; : &quot;80&quot;;                                           </span><br><span class="line">                                                                                                </span><br><span class="line">if ( exists $ARGV[0] and $ARGV[0] eq &quot;autoconf&quot; )                                               </span><br><span class="line">&#123;</span><br><span class="line">    if ($ret)&#123;</span><br><span class="line">        print &quot;no ($ret)\n&quot;;</span><br><span class="line">        exit 0;</span><br><span class="line">    &#125;</span><br><span class="line">    my $ua = LWP::UserAgent-&gt;new(timeout =&gt; 30,</span><br><span class="line">            agent =&gt; sprintf(&quot;munin/%s (libwww-perl/%s)&quot;, $Munin::Common::Defaults::MUNIN_VERSION, $LWP::VERSION));     </span><br><span class="line">    my $response = $ua-&gt;request(HTTP::Request-&gt;new(&apos;GET&apos;,$URL));</span><br><span class="line">    unless ($response-&gt;is_success and $response-&gt;content =~ /server/im)</span><br><span class="line">    &#123;</span><br><span class="line">        print &quot;no (no nginx status on $URL)\n&quot;;</span><br><span class="line">        exit 0;</span><br><span class="line">    &#125;</span><br><span class="line">    else</span><br><span class="line">    &#123;</span><br><span class="line">        print &quot;yes\n&quot;;</span><br><span class="line">        exit 0;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>检查模块是否正常<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">munin-node-configure |grep nginx</span><br><span class="line">nginx_request | yes |  </span><br><span class="line">nginx_status | yes |</span><br></pre></td></tr></table></figure></p><h1 id="监控Redis"><a href="#监控Redis" class="headerlink" title="监控Redis"></a>监控Redis</h1><ol><li><p>首先下载munin redis的第三方插件</p><pre><code>git clone https://github.com/bpineau/redis-munin</code></pre></li><li><p>将git下载的redis-munin中的<em>redis_</em>更名，更改为redis_<em>IP</em>_<em>PORT</em>, eg. <em>redis_127.0.0.1_6379</em></p></li><li><p>加载redis插件</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ln -sf /path/to/redis_*IP*_*PORT* /etc/munin/plugins/</span><br></pre></td></tr></table></figure></li><li><p>在/etc/munin/conf.d中添加redis，创建munin的redis配置文件</p><pre><code>[redis_*]   user root     //在这里要root用户   env.host 127.0.0.1   env.port 6379</code></pre></li><li><p>测试redis插件</p><pre><code>munin-run redis</code></pre></li><li><p>重启munin</p><pre><code>service munin-node restart</code></pre><p>​     </p><h1 id="监控php-fpm"><a href="#监控php-fpm" class="headerlink" title="监控php-fpm"></a>监控php-fpm</h1></li><li><p>首先开启php-fpm的状态</p><blockquote><p>vim /etc/php-fpm.d/<a href="http://www.conf" target="_blank" rel="noopener">www.conf</a></p><p>pm.status_path = /status     //把前面注释去掉 </p><p>kill -USR2 <code>cat /run/php-fpm/php-fpm.pid</code>  // 平滑重启php-fpm，线上建议此用法</p></blockquote></li><li><p>修改nginx配置</p><blockquote><p>在上面监控nginx的server下的location下面添加一个location配置</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">&gt; location ~ ^/(status|ping)$ &#123;</span><br><span class="line">&gt; include fastcgi_params;</span><br><span class="line">&gt; fastcgi_pass 127.0.0.1:9000;</span><br><span class="line">&gt; fastcgi_param SCRIPT_FILENAME $fastcgi_script_name;  </span><br><span class="line">&gt; allow 127.0.0.1;</span><br><span class="line">&gt; deny all;</span><br><span class="line">&gt; &#125;</span><br><span class="line">&gt;</span><br></pre></td></tr></table></figure></blockquote></li><li><p>重启nginx</p></li><li><p>通过curl访问，检测配置是否正确</p><pre><code>curl -v http://127.0.0.1/status</code></pre></li><li><p>下载munin-phpfpm的插件</p><pre><code>git clone https://github.com/tjstein/php5-fpm-munin-plugins</code></pre></li><li><p>建立phpfpm相关插件的软链</p><pre><code>ln -s /etc/munin/thirdPlugins/php5-fpm-munin-plugins/phpfpm_* /etc/munin/plugins/</code></pre></li><li><p>编辑phpfpm的配置文件</p><blockquote><p>vim /et/munin/conf.d/phpfpm</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">&gt; [phpfpm*]</span><br><span class="line">&gt; env.url http://127.0.01/status</span><br><span class="line">&gt; env.ports 80</span><br><span class="line">&gt;</span><br></pre></td></tr></table></figure></blockquote></li><li><p>测试phpfpm插件</p><blockquote><p>munin-run phpfpm_connections<br>munin-run phpfpm_memory</p></blockquote></li></ol><h1 id="监控MySQL"><a href="#监控MySQL" class="headerlink" title="监控MySQL"></a>监控MySQL</h1><p>munin本身自带的MySQL监控信息太少，所以我们这里选择第三方的munin MySQL插件</p><ol><li><p>安装第三方MySQL插件所需的依赖</p><pre><code>yum -y install yum install perl-Cache-Cache perl-IPC-ShareLite perl-DBD-MySQL perl-Module-Pluggable</code></pre></li><li><p>下载源码包</p><pre><code>git clone https://github.com/kjellm/munin-mysql</code></pre></li><li><p>编辑下载下来的源码包里面的<em>Makefile</em></p><blockquote><p>修改第四行的代码 <em>PLUGIN_DIR:=/usr/local/share/munin/plugins</em></p><pre><code>PLUGIN_DIR:=/usr/share/munin/plugins</code></pre><p>修改第四十五行的代码 <em>$(MUNIN_NODE) restart</em></p><pre><code>service munin-node restart</code></pre><p>​</p></blockquote></li><li><p>编辑<em>mysql.conf</em></p><blockquote><p>注释第十一行<em>env.mysqlconnection DBI:mysql:mysql</em>并删除第九行<em>env.mysqlconnection DBI:mysql:mysql;host=localhost;port=3306</em>的注释</p><p>按照mysql的配置分别填写host port user password</p></blockquote></li><li><p>在当前路径下执行编译脚本<br>​      </p><pre><code>make install</code></pre></li><li><p>检测MySQL插件是否正常安装</p><pre><code>munin-run mysql</code></pre></li></ol><h1 id="重新生成HTML文件"><a href="#重新生成HTML文件" class="headerlink" title="重新生成HTML文件"></a>重新生成HTML文件</h1><p>综上所有步骤完成后，重启<em>munin-node</em>发现页面上还是没有MySQL，redis，phpfpm的相关内容，这时需要通过<strong>munin-cron</strong>脚本来重新生成HTML文件</p><blockquote><p>su - munin –shell=/bin/bash<br>munin-cron</p></blockquote><h1 id="Nginx添加认证模块及禁用缓存"><a href="#Nginx添加认证模块及禁用缓存" class="headerlink" title="Nginx添加认证模块及禁用缓存"></a>Nginx添加认证模块及禁用缓存</h1><p>我们在浏览时发现，很多地方HTML会被浏览器缓存，导致很多时候需要强制刷新才能看到最新的图片，这是我们需要在nginx中禁止缓存来处理</p><p>我们利用Nginx的<em>ngx_http_auth_basic_module</em>来做用户验证以保证信息的安全</p><p>上面我们为了动态的生成图片，在nginx中做了解析，<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">location ^~ /munin-cgi/munin-cgi-graph/ &#123;</span><br><span class="line">    root /data/www/html</span><br><span class="line">    fastcgi_split_path_info ^(/munin-cgi/munin-cgi-graph)(.*);</span><br><span class="line">    fastcgi_param PATH_INFO $fastcgi_path_info;</span><br><span class="line">    fastcgi_pass unix:/var/run/munin/fastcgi-graph.sock;</span><br><span class="line">    include fastcgi_params;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>在做权限认证的时候，我们首先需要生成一个用户名和密码，以供nginx使用<br>​<br>        printf “munin:$(openssl passwd -crypt 123456)\n” &gt;&gt; /etc/munin/httppwd</p><p>在这段代码的上面添加权限认证及进行缓存，通知修改一下这段解析禁止缓存<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">#munin 下面的文件不缓存</span><br><span class="line">location ~ /munin/html &#123;</span><br><span class="line">    root /data/www/html;</span><br><span class="line">    expires -1;</span><br><span class="line">    add_header Cache-Control no-store;</span><br><span class="line">    index index.html;</span><br><span class="line">    auth_basic &quot;User Auth&quot;;</span><br><span class="line">    auth_basic_user_file /etc/munin/httppwd;</span><br><span class="line">    autoindex on;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line">#munin 监控动态画图</span><br><span class="line">location ^~ /munin-cgi/munin-cgi-graph/ &#123;</span><br><span class="line">    root /data/www/html;</span><br><span class="line">    add_header Cache-Control no-store;</span><br><span class="line">    fastcgi_split_path_info ^(/munin-cgi/munin-cgi-graph)(.*);</span><br><span class="line">    fastcgi_param PATH_INFO $fastcgi_path_info;</span><br><span class="line">    fastcgi_pass unix:/var/run/munin/fastcgi-graph.sock;</span><br><span class="line">    include fastcgi_params;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>]]></content>
      
      
      <categories>
          
          <category> Linux </category>
          
      </categories>
      
      
        <tags>
            
            <tag> munin </tag>
            
            <tag> Linux </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Linux下使用mail发送邮件</title>
      <link href="/posts/47206/"/>
      <url>/posts/47206/</url>
      
        <content type="html"><![CDATA[<p>近期在做监控的时候，需要通过命令行来发送邮件。普通邮件通过25端口发送，简单配置一下即可，但是我们的邮件服务器并不支持普通的smtp邮件发送，仅仅支持smtps发送邮件，这就需要证书验证了，我们在这里通过自制证书并忽略验证来通过smtps发送邮件</p><a id="more"></a><h1 id="mailx"><a href="#mailx" class="headerlink" title="mailx"></a>mailx</h1><h2 id="安装mailx"><a href="#安装mailx" class="headerlink" title="安装mailx"></a>安装mailx</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">yum -y install mailx</span><br></pre></td></tr></table></figure><h2 id="配置mailx（smtps-465端口）"><a href="#配置mailx（smtps-465端口）" class="headerlink" title="配置mailx（smtps - 465端口）"></a>配置mailx（smtps - 465端口）</h2><p>编辑/etc/mail.rc，并添加上以下内容</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">set from=username@hostname.com         # 这里是发件人的邮箱地址</span><br><span class="line">set smtp=smtps://smtp_hostname:465   # 这里设置发件服务器的ssl地址,例：smtps://smtp.163.com:465</span><br><span class="line">set nss-config-dir=/etc/mail/.certs    # SSL证书保存位置，稍后个人制作</span><br><span class="line">set ssl-verify=ignore                  # 表示不对ssl的证书进行验证</span><br><span class="line">set smtp-auth-user=username@hostname.com  # 邮箱验证用户名，一般同邮箱地址</span><br><span class="line">set smtp-auth-password=password        # 邮箱验证密码</span><br><span class="line">set smtp-auth=login                    # 认证方式</span><br></pre></td></tr></table></figure><h2 id="配置mailx（smtp-25端口）"><a href="#配置mailx（smtp-25端口）" class="headerlink" title="配置mailx（smtp - 25端口）"></a>配置mailx（smtp - 25端口）</h2><p>smtp的发送方式相对于smtps的发送方式的配置要简单需要，因为不需要ssl验证，所以也就不需要自制证书，配置完下面部分后即可使用</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">set from=username@hostname.com         # 这里是发件人的邮箱地址</span><br><span class="line">set smtp=smtp_hostname                # 这里设置发件服务器的ssl地址,例：smtp.163.com</span><br><span class="line">set smtp-auth-user=username@hostname.com  # 邮箱验证用户名，一般同邮箱地址</span><br><span class="line">set smtp-auth-password=password        # 邮箱验证密码</span><br><span class="line">set smtp-auth=login                    # 认证方式</span><br></pre></td></tr></table></figure><h1 id="证书制作"><a href="#证书制作" class="headerlink" title="证书制作"></a>证书制作</h1><p>首先创建一个目录保存证书，然后创建证书和密钥的数据库</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">$ mkdir .certs</span><br><span class="line">$ certutil -N -d .certs</span><br></pre></td></tr></table></figure><p>然后从邮箱服务器获取证书，并导入到本地数据库（将hostname修改成对应的邮箱主机）</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">$ echo -n | openssl s_client -connect smtp_hostname:465 | sed -ne &apos;/-BEGIN CERTIFICATE-/,/-END CERTIFICATE-/p&apos; &gt; .certs/hostname.crt</span><br><span class="line">$ certutil -A -n &quot;Google Internet Authority&quot; -t &quot;C,,&quot; -d .certs -i .certs/hostname.crt</span><br></pre></td></tr></table></figure><h1 id="发送邮件"><a href="#发送邮件" class="headerlink" title="发送邮件"></a>发送邮件</h1><p>执行一下命令即可发送邮件</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">$ mail -s &quot;test&quot; keven518@163.com </span><br><span class="line">this is test email</span><br><span class="line">crtl+d</span><br></pre></td></tr></table></figure><p>crtl+d结束输入 或者执行 <code>man mailx</code>查看帮助文档</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ Error in certificate: Peer&apos;s certificate issuer is not recognized.</span><br></pre></td></tr></table></figure><p>上述错误直接无视即可</p>]]></content>
      
      
      <categories>
          
          <category> Linux </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Linux </tag>
            
            <tag> mail </tag>
            
        </tags>
      
    </entry>
    
    
  
  
</search>
