<?xml version="1.0" encoding="utf-8"?>
<search> 
  
  
    
    <entry>
      <title>Go值拷贝的一些思考</title>
      <link href="/posts/50287/"/>
      <url>/posts/50287/</url>
      
        <content type="html"><![CDATA[<blockquote><p><a href="文档地址：https://golang.org/ref/spec#Calls">In a function call, the function value and arguments are evaluated in the usual order. After they are evaluated, the parameters of the call are passed by value to the function and the called function begins execution.</a></p></blockquote><p>官方文档已经明确说明：Go里边函数传参只有值传递一种方式: 值传递<br>那么为什么会引发Go的值拷贝的讨论？<br><a id="more"></a></p><h2 id="现象"><a href="#现象" class="headerlink" title="现象"></a>现象</h2><p>用下面的代码做一下展示<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">package main</span><br><span class="line"></span><br><span class="line">import (</span><br><span class="line">&quot;fmt&quot;</span><br><span class="line">)</span><br><span class="line"></span><br><span class="line">func main() &#123;</span><br><span class="line">arr := [5]int&#123;0, 1, 2, 3, 4&#125;</span><br><span class="line">s := arr[1:]</span><br><span class="line">changeSlice(s)</span><br><span class="line">fmt.Println(s)</span><br><span class="line">fmt.Println(arr)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">func changeSlice(arr []int) &#123;</span><br><span class="line">for i := range arr &#123;</span><br><span class="line">arr[i] = 10</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>输出结果</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">[10 10 10 10]</span><br><span class="line">[0 10 10 10 10]</span><br></pre></td></tr></table></figure><p>如果Go是值拷贝的，那么我修改了函数 <code>changeSlice</code> 里面的<code>slice s</code> 的值，为什么main函数里面的<code>slice</code>和 <code>array</code>也被修改了</p><h2 id="原因"><a href="#原因" class="headerlink" title="原因"></a>原因</h2><p><img src="https://github-1253518569.cos.ap-shanghai.myqcloud.com/address.jpg" alt></p><p>以上图为例，a 是初始变量，b 是引用变量(Go中并不存在)，p 是指针变量<br>变量a被拷贝后，地址发生了变化，地址上存储的是原先地址存储的值 10<br>变量p被拷贝后，地址发生了变化，地址上存储的还是原先地址存储的值 ）0X001, 然后按照这个地址去查找，找到的是 0X001 上面存储的值</p><p>所以，当你去修改拷贝后的*p的值，其实修改的还是0X001地址上的值，而不是 拷贝后a的值</p><p><img src="https://github-1253518569.cos.ap-shanghai.myqcloud.com/slice-array.jpg" alt></p><p>那么我们接下来看slice，slice在实现的时候，其实是对array的映射，也就是说slice存对应的是原array的地址，就类似于p与a的关系，那么整个slice拷贝后，拷贝后的slice中存储的还是array的地址，去修改拷贝后的slice，其实跟修改slice，和原array是一样的</p><h2 id="试验"><a href="#试验" class="headerlink" title="试验"></a>试验</h2><p>我们用下面一个例子，实现以下我们上面的想法<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">package main</span><br><span class="line"></span><br><span class="line">import (</span><br><span class="line">&quot;fmt&quot;</span><br><span class="line">)</span><br><span class="line"></span><br><span class="line">func main() &#123;</span><br><span class="line">var a *int</span><br><span class="line">b := 10</span><br><span class="line">a = &amp;b</span><br><span class="line">change(a)</span><br><span class="line">fmt.Println(a, b)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">func change(a *int) &#123;</span><br><span class="line">*a = 30</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>打印结果<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">0xc000096000 30</span><br></pre></td></tr></table></figure></p><p>符合猜想</p><h2 id="More"><a href="#More" class="headerlink" title="More"></a>More</h2><p>这里的东西，其实用dlv调试会看的很方便，有兴趣可以动一下手</p><h2 id="结论"><a href="#结论" class="headerlink" title="结论"></a>结论</h2><p>Go的拷贝都是值拷贝，只是slice中存储的是原array的地址，所以在拷贝的时候，其实是把地址拷贝的新的slice，那么此时修改slice的时候，还是根据slice中存储的地址，找到要修改的内容</p>]]></content>
      
      
      <categories>
          
          <category> Go </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Go </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Go的调试工具:gdb vs dlv</title>
      <link href="/posts/8063/"/>
      <url>/posts/8063/</url>
      
        <content type="html"><![CDATA[<p>GoLand编辑器虽然很强大，但是在展示内存及堆栈信息这一块还是比较的弱，有可能是我的姿势不对，所以，开始切入了gdb调试，但是gdb踩到了坑，并没有解决，也就引发了gdb与dlv的对比了</p><a id="more"></a><h2 id="gdb"><a href="#gdb" class="headerlink" title="gdb"></a>gdb</h2><h3 id="安装"><a href="#安装" class="headerlink" title="安装"></a>安装</h3><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">yum install ncures-devel</span><br><span class="line">wget http://ftp.gnu.org/gnu/gdb/gdb-8.2.tar.gz</span><br><span class="line">tar zxf gdb-8.2.tar.gz</span><br><span class="line">cd gdb-8.2</span><br><span class="line">make &amp;&amp; make install</span><br></pre></td></tr></table></figure><h3 id="进入调试"><a href="#进入调试" class="headerlink" title="进入调试"></a>进入调试</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">go build -gcflags &apos;-N -l&apos; main.go</span><br><span class="line">gdb main</span><br></pre></td></tr></table></figure><h3 id="使用"><a href="#使用" class="headerlink" title="使用"></a>使用</h3><ol><li><p>启动调试程序（<code>gdb</code>）</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">[lday@alex GoDbg]$ gdb ./GoDbg</span><br></pre></td></tr></table></figure></li><li><p>在main函数上设置断点（<code>b</code>）</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">(gdb) b main.main</span><br><span class="line">Breakpoint 1 at 0x401000: file /home/lday/Works/Go_Works/GoLocalWorks/src/GoWorks/GoDbg/main.go, line 9.</span><br></pre></td></tr></table></figure></li><li><p>带参数启动程序（<code>r</code>）</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">(gdb) r arg1 arg2</span><br><span class="line">Starting program: /home/lday/Works/Go_Works/GoLocalWorks/src/GoWorks/GoDbg/GoDbg arg1 arg2</span><br><span class="line">[New LWP 8412]</span><br><span class="line">[New LWP 8413]</span><br><span class="line">[New LWP 8414]</span><br><span class="line">[New LWP 8415]</span><br><span class="line"></span><br><span class="line">Breakpoint 1, main.main () at /home/lday/Works/Go_Works/GoLocalWorks/src/GoWorks/GoDbg/main.go:9</span><br><span class="line">9    func main() &#123;</span><br></pre></td></tr></table></figure></li><li><p>在文件dbgTest.go上通过行号设置断点（<code>b</code>）</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">(gdb) b dbgTest.go:16</span><br><span class="line">Breakpoint 3 at 0x457960: file /home/lday/Works/Go_Works/GoLocalWorks/src/GoWorks/GoDbg/mylib/dbgTest.go, line 16.</span><br></pre></td></tr></table></figure></li><li><p>查看断点设置情况（<code>info b</code>）</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">(gdb) info b</span><br><span class="line">Num     Type           Disp Enb Address            What</span><br><span class="line">1       breakpoint     keep y   0x0000000000401000 in main.main </span><br><span class="line">                                                   at /home/lday/Works/Go_Works/GoLocalWorks/src/GoWorks/GoDbg/main.go:9</span><br><span class="line">    breakpoint already hit 1 time</span><br><span class="line">2       breakpoint     keep y   0x0000000000401000 in main.main </span><br><span class="line">                                                   at /home/lday/Works/Go_Works/GoLocalWorks/src/GoWorks/GoDbg/main.go:9</span><br><span class="line">    breakpoint already hit 1 time</span><br><span class="line">3       breakpoint     keep y   0x0000000000457960 in GoWorks/GoDbg/mylib.DBGTestRun </span><br><span class="line">                                                   at /home/lday/Works/Go_Works/GoLocalWorks/src/GoWorks/GoDbg/mylib/dbgTest.go:16</span><br></pre></td></tr></table></figure></li><li><p>禁用断点（<code>dis n</code>）</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">(gdb) dis 1   </span><br><span class="line">(gdb) info b</span><br><span class="line">Num     Type           Disp Enb Address            What</span><br><span class="line">1       breakpoint     keep n   0x0000000000401000 in main.main </span><br><span class="line">                                                   at /home/lday/Works/Go_Works/GoLocalWorks/src/GoWorks/GoDbg/main.go:9</span><br><span class="line">    breakpoint already hit 1 time</span><br><span class="line">2       breakpoint     keep y   0x0000000000401000 in main.main </span><br><span class="line">                                                   at /home/lday/Works/Go_Works/GoLocalWorks/src/GoWorks/GoDbg/main.go:9</span><br><span class="line">    breakpoint already hit 1 time</span><br><span class="line">3       breakpoint     keep y   0x0000000000457960 in GoWorks/GoDbg/mylib.DBGTestRun </span><br><span class="line">                                                   at /home/lday/Works/Go_Works/GoLocalWorks/src/GoWorks/GoDbg/mylib/dbgTest.go:16</span><br></pre></td></tr></table></figure></li><li><p>删除断点（<code>del n</code>）</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">(gdb) del 1</span><br><span class="line">(gdb) info b</span><br><span class="line">Num     Type           Disp Enb Address            What</span><br><span class="line">2       breakpoint     keep y   0x0000000000401000 in main.main </span><br><span class="line">                                                   at /home/lday/Works/Go_Works/GoLocalWorks/src/GoWorks/GoDbg/main.go:9</span><br><span class="line">    breakpoint already hit 1 time</span><br><span class="line">3       breakpoint     keep y   0x0000000000457960 in GoWorks/GoDbg/mylib.DBGTestRun </span><br><span class="line">                                                   at /home/lday/Works/Go_Works/GoLocalWorks/src/GoWorks/GoDbg/mylib/dbgTest.go:16</span><br></pre></td></tr></table></figure></li><li><p>断点后继续执行（<code>c</code>）</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">(gdb) c</span><br><span class="line">Continuing.</span><br><span class="line">Golang dbg test...</span><br><span class="line">argc:3</span><br><span class="line">argv:[/home/lday/Works/Go_Works/GoLocalWorks/src/GoWorks/GoDbg/GoDbg arg1 arg2]</span><br><span class="line"></span><br><span class="line">Breakpoint 3, GoWorks/GoDbg/mylib.DBGTestRun (var1=1, var2=&quot;golang dbg test&quot;)</span><br><span class="line">    at /home/lday/Works/Go_Works/GoLocalWorks/src/GoWorks/GoDbg/mylib/dbgTest.go:16</span><br><span class="line">16    func DBGTestRun(var1 int, var2 string, var3 []int, var4 MyStruct) &#123;</span><br><span class="line">(gdb)</span><br></pre></td></tr></table></figure></li><li><p>显示代码（<code>l</code>）</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">(gdb) l</span><br><span class="line">11        B string</span><br><span class="line">12        C map[int]string</span><br><span class="line">13        D []string</span><br><span class="line">14    &#125;</span><br><span class="line">15    </span><br><span class="line">16    func DBGTestRun(var1 int, var2 string, var3 []int, var4 MyStruct) &#123;</span><br><span class="line">17        fmt.Println(&quot;DBGTestRun Begin!\n&quot;)</span><br><span class="line">18        waiter := &amp;sync.WaitGroup&#123;&#125;</span><br><span class="line">19    </span><br><span class="line">20        waiter.Add(1)</span><br></pre></td></tr></table></figure></li><li><p>单步执行（<code>n</code>）</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">(gdb) n</span><br><span class="line">DBGTestRun Begin!</span><br><span class="line"></span><br><span class="line">18        waiter := &amp;sync.WaitGroup&#123;&#125;</span><br></pre></td></tr></table></figure></li><li><p>打印变量信息（<code>print/p</code>）<br>在进入DBGTestRun的地方设置断点(<code>b dbgTest.go:16</code>)，进入该函数后，通过p命令显示对应变量：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">(gdb) l 17</span><br><span class="line">12        C map[int]string</span><br><span class="line">13        D []string</span><br><span class="line">14    &#125;</span><br><span class="line">15    </span><br><span class="line">16    func DBGTestRun(var1 int, var2 string, var3 []int, var4 MyStruct) &#123;</span><br><span class="line">17        fmt.Println(&quot;DBGTestRun Begin!\n&quot;)</span><br><span class="line">18        waiter := &amp;sync.WaitGroup&#123;&#125;</span><br><span class="line">19    </span><br><span class="line">20        waiter.Add(1)</span><br><span class="line">21        go RunFunc1(var1, waiter)</span><br><span class="line">(gdb) p var1 </span><br><span class="line">$3 = 1</span><br><span class="line">(gdb) p var2</span><br><span class="line">$4 = &quot;golang dbg test&quot;</span><br><span class="line">(gdb) p var3</span><br><span class="line">No symbol &quot;var3&quot; in current context.</span><br></pre></td></tr></table></figure><p><strong>从上面的输出我们可以看到一个很奇怪的事情，虽然DBGTestRun有4个参数传入，但是，似乎var3和var4 gdb无法识别，在后续对dlv的实验操作中，我们发现，dlv能够识别var3， var4.</strong></p></li><li><p>查看调用栈（<code>bt</code>），切换调用栈（<code>f n</code>），显示当前栈变量信息</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line">(gdb) bt</span><br><span class="line">#0  GoWorks/GoDbg/mylib.DBGTestRun (var1=1, var2=&quot;golang dbg test&quot;)</span><br><span class="line">    at /home/lday/Works/Go_Works/GoLocalWorks/src/GoWorks/GoDbg/mylib/dbgTest.go:17</span><br><span class="line">#1  0x00000000004018c2 in main.main () at /home/lday/Works/Go_Works/GoLocalWorks/src/GoWorks/GoDbg/main.go:27</span><br><span class="line">(gdb) f 1</span><br><span class="line">#1  0x00000000004018c2 in main.main () at /home/lday/Works/Go_Works/GoLocalWorks/src/GoWorks/GoDbg/main.go:27</span><br><span class="line">27        mylib.DBGTestRun(var1, var2, var3, var4)</span><br><span class="line">(gdb) l</span><br><span class="line">22        var4.A = 1</span><br><span class="line">23        var4.B = &quot;golang dbg my struct field B&quot;</span><br><span class="line">24        var4.C = map[int]string&#123;1: &quot;value1&quot;, 2: &quot;value2&quot;, 3: &quot;value3&quot;&#125;</span><br><span class="line">25        var4.D = []string&#123;&quot;D1&quot;, &quot;D2&quot;, &quot;D3&quot;&#125;</span><br><span class="line">26    </span><br><span class="line">27        mylib.DBGTestRun(var1, var2, var3, var4)</span><br><span class="line">28        fmt.Println(&quot;Golang dbg test over&quot;)</span><br><span class="line">29    &#125;</span><br><span class="line">(gdb) print var1 </span><br><span class="line">$5 = 1</span><br><span class="line">(gdb) print var2</span><br><span class="line">$6 = &quot;golang dbg test&quot;</span><br><span class="line">(gdb) print var3</span><br><span class="line">$7 =  []int = &#123;1, 2, 3&#125;</span><br><span class="line"></span><br><span class="line">(gdb) print var4</span><br><span class="line">$8 = &#123;A = 1, B = &quot;golang dbg my struct field B&quot;, C = map[int]string = &#123;[1] = &quot;value1&quot;, [2] = &quot;value2&quot;, [3] = &quot;value3&quot;&#125;, </span><br><span class="line">D =  []string = &#123;&quot;D1&quot;, &quot;D2&quot;, &quot;D3&quot;&#125;&#125;</span><br></pre></td></tr></table></figure></li></ol><h2 id="dlv-推荐"><a href="#dlv-推荐" class="headerlink" title="dlv(推荐)"></a>dlv(推荐)</h2><h3 id="安装-1"><a href="#安装-1" class="headerlink" title="安装"></a>安装</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">go get -u github.com/go-delve/delve/cmd/dlv</span><br></pre></td></tr></table></figure><h3 id="进入调试-1"><a href="#进入调试-1" class="headerlink" title="进入调试"></a>进入调试</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">dlv debug main.go</span><br></pre></td></tr></table></figure><h3 id="使用-1"><a href="#使用-1" class="headerlink" title="使用"></a>使用</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line">args ------------------------ Print function arguments.</span><br><span class="line">break (alias: b) ------------ Sets a breakpoint.</span><br><span class="line">breakpoints (alias: bp) ----- Print out info for active breakpoints.</span><br><span class="line">call ------------------------ Resumes process, injecting a function call (EXPERIMENTAL!!!)</span><br><span class="line">clear ----------------------- Deletes breakpoint.</span><br><span class="line">clearall -------------------- Deletes multiple breakpoints.</span><br><span class="line">condition (alias: cond) ----- Set breakpoint condition.</span><br><span class="line">config ---------------------- Changes configuration parameters.</span><br><span class="line">continue (alias: c) --------- Run until breakpoint or program termination.</span><br><span class="line">deferred -------------------- Executes command in the context of a deferred call.</span><br><span class="line">disassemble (alias: disass) - Disassembler.</span><br><span class="line">down ------------------------ Move the current frame down.</span><br><span class="line">edit (alias: ed) ------------ Open where you are in $DELVE_EDITOR or $EDITOR</span><br><span class="line">exit (alias: quit | q) ------ Exit the debugger.</span><br><span class="line">frame ----------------------- Set the current frame, or execute command on a different frame.</span><br><span class="line">funcs ----------------------- Print list of functions.</span><br><span class="line">goroutine ------------------- Shows or changes current goroutine</span><br><span class="line">goroutines ------------------ List program goroutines.</span><br><span class="line">help (alias: h) ------------- Prints the help message.</span><br><span class="line">libraries ------------------- List loaded dynamic libraries</span><br><span class="line">list (alias: ls | l) -------- Show source code.</span><br><span class="line">locals ---------------------- Print local variables.</span><br><span class="line">next (alias: n) ------------- Step over to next source line.</span><br><span class="line">on -------------------------- Executes a command when a breakpoint is hit.</span><br><span class="line">print (alias: p) ------------ Evaluate an expression.</span><br><span class="line">regs ------------------------ Print contents of CPU registers.</span><br><span class="line">restart (alias: r) ---------- Restart process.</span><br><span class="line">set ------------------------- Changes the value of a variable.</span><br><span class="line">source ---------------------- Executes a file containing a list of delve commands</span><br><span class="line">sources --------------------- Print list of source files.</span><br><span class="line">stack (alias: bt) ----------- Print stack trace.</span><br><span class="line">step (alias: s) ------------- Single step through program.</span><br><span class="line">step-instruction (alias: si)  Single step a single cpu instruction.</span><br><span class="line">stepout --------------------- Step out of the current function.</span><br><span class="line">thread (alias: tr) ---------- Switch to the specified thread.</span><br><span class="line">threads --------------------- Print out info for every traced thread.</span><br><span class="line">trace (alias: t) ------------ Set tracepoint.</span><br><span class="line">types ----------------------- Print list of types</span><br><span class="line">up -------------------------- Move the current frame up.</span><br><span class="line">vars ------------------------ Print package variables.</span><br><span class="line">whatis ---------------------- Prints type of an expression.</span><br></pre></td></tr></table></figure><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><ol><li><p>dlv对goroutine的支持更好，我使用gdb的没有找到goroutine的调试方法，可能姿势不对</p></li><li><p>gdb对于局部引用变量无法调试，dlv不会</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">  i := <span class="number">10</span></span><br><span class="line">  j := &amp;i</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>如上代码，gdb 使用 <code>p j</code> 打印变量j的时候报错，dlv却可以</p></li></ol><h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><p><a href="http://lday.me/2017/02/27/0005_gdb-vs-dlv/" target="_blank" rel="noopener">《Golang程序调试工具介绍(gdb vs dlv)》</a></p>]]></content>
      
      
      <categories>
          
          <category> Go </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Go </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Golang常见错误之goroutine使用变量问题</title>
      <link href="/posts/22138/"/>
      <url>/posts/22138/</url>
      
        <content type="html"><![CDATA[<p><a href="https://www.jb51.net/article/128539.htm" target="_blank" rel="noopener">https://www.jb51.net/article/128539.htm</a><br>针对这篇文章引发的一些实验<br><a id="more"></a></p><p>在看这篇文章的时候，总感觉用文章中的例子说明值拷贝和指针拷贝是有问题的，而且go官方说，他们的拷贝只有值拷贝一种，那么为什么使用指针类型和非指针类型，会出现不同的现象，在追踪的过程了就发现了下面的奇葩实例</p><h2 id="试验代码"><a href="#试验代码" class="headerlink" title="试验代码"></a>试验代码</h2><pre><code>package mainimport (    &quot;fmt&quot;    &quot;time&quot;)type fieldNoPointer struct {    name string}func (p fieldNoPointer) Print() {    fmt.Println(p.name)}type fieldPointer struct {    name string}func (p *fieldPointer) Print() {    fmt.Println(p.name)}func main() {    printDataWithPointerUseFieldPointerWithFunc()    printDataWithPointerUseFieldPointerWithNoFunc()    printDataWithNoPointerUseFieldPointerWithFunc()    printDataWithNoPointerUseFieldPointerWithNoFunc()    printDataWithPointerUseFieldNoPointerWithFunc()    printDataWithPointerUseFieldNoPointerWithNoFunc()    printDataWithNoPointerUseFieldNoPointerWithFunc()    printDataWithNoPointerUseFieldNoPointerWithNoFunc()    time.Sleep(1)}func printDataWithPointerUseFieldPointerWithFunc()  {    fmt.Println(&quot;print by get printDataWithPointerUseFieldPointerWithFunc&quot;)    data := []*fieldPointer{{"one"},{"two"},{"three"}}    for _,v := range data {        go func() {            v.Print()        }()    }    time.Sleep(time.Second)}func printDataWithPointerUseFieldPointerWithNoFunc()  {    fmt.Println(&quot;print by get printDataWithPointerUseFieldPointerWithNoFunc&quot;)    data := []*fieldPointer{{"one"},{"two"},{"three"}}    for _,v := range data {        go v.Print()    }    time.Sleep(time.Second)}func printDataWithNoPointerUseFieldPointerWithFunc()  {    fmt.Println(&quot;print by get printDataWithNoPointerUseFieldPointerWithFunc&quot;)    data := []fieldPointer{{"one"},{"two"},{"three"}}    for _,v := range data {        go func() {            v.Print()        }()    }    time.Sleep(time.Second)}func printDataWithNoPointerUseFieldPointerWithNoFunc()  {    fmt.Println(&quot;print by get printDataWithNoPointerUseFieldPointerWithNoFunc&quot;)    data := []fieldPointer{{"one"},{"two"},{"three"}}    for _,v := range data {        go v.Print()    }    time.Sleep(time.Second)}func printDataWithPointerUseFieldNoPointerWithFunc()  {    fmt.Println(&quot;print by get printDataWithPointerUseFieldNoPointerWithFunc&quot;)    data := []*fieldNoPointer{{"one"},{"two"},{"three"}}    for _,v := range data {        go func() {            v.Print()        }()    }    time.Sleep(time.Second)}func printDataWithPointerUseFieldNoPointerWithNoFunc()  {    fmt.Println(&quot;print by get printDataWithPointerUseFieldNoPointerWithNoFunc&quot;)    data := []*fieldNoPointer{{"one"},{"two"},{"three"}}    for _,v := range data {        go v.Print()    }    time.Sleep(time.Second)}func printDataWithNoPointerUseFieldNoPointerWithFunc()  {    fmt.Println(&quot;print by get printDataWithNoPointerUseFieldNoPointerWithFunc&quot;)    data := []fieldNoPointer{{"one"},{"two"},{"three"}}    for _,v := range data {        go func() {            v.Print()        }()    }    time.Sleep(time.Second)}func printDataWithNoPointerUseFieldNoPointerWithNoFunc()  {    fmt.Println(&quot;print by get printDataWithNoPointerUseFieldNoPointerWithNoFunc&quot;)    data := []fieldNoPointer{{"one"},{"two"},{"three"}}    for _,v := range data {        go v.Print()    }    time.Sleep(time.Second)}</code></pre><h2 id="实验结果"><a href="#实验结果" class="headerlink" title="实验结果"></a>实验结果</h2><pre><code>print by get printDataWithPointerUseFieldPointerWithFuncthreethreethreeprint by get printDataWithPointerUseFieldPointerWithNoFunconetwothreeprint by get printDataWithNoPointerUseFieldPointerWithFuncthreethreethreeprint by get printDataWithNoPointerUseFieldPointerWithNoFuncthreethreethreeprint by get printDataWithPointerUseFieldNoPointerWithFuncthreethreethreeprint by get printDataWithPointerUseFieldNoPointerWithNoFuncthreeonetwoprint by get printDataWithNoPointerUseFieldNoPointerWithFuncthreethreethreeprint by get printDataWithNoPointerUseFieldNoPointerWithNoFuncthreeonetwo</code></pre><p>在这里，我以 我以 <code>struct的func是否指针类型</code> <code>struc的数据是否是指针类型</code> 以及 <code>goroutine 是否使用匿名函数</code> 为例作为测试的，上面的测试例子都是无意中发现的</p><p>图表</p><table><thead><tr><th></th><th>Goroutine func 且 struct数据是指针类型</th><th>Goroutine且 struct数据是指针类型</th><th>Goroutine func 且 struct数据不是指针类型</th><th>Goroutine且 struct数据不是指针类型</th></tr></thead><tbody><tr><td>Struct func指针类型</td><td>异常</td><td>正常</td><td>异常</td><td>异常</td></tr><tr><td>Struct func非指针类型</td><td>异常</td><td>异常</td><td>异常</td><td>正常</td></tr></tbody></table><h2 id="结论"><a href="#结论" class="headerlink" title="结论"></a>结论</h2><p>在goroutine里面使用变量的时候，需要传递，上面案例中不传递变量直接使用的方法都是错误的</p>]]></content>
      
      
      <categories>
          
          <category> Go </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Go </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>头条面经-PHP/Golang</title>
      <link href="/posts/55859/"/>
      <url>/posts/55859/</url>
      
        <content type="html"><![CDATA[<p>好像这里必须要写点什么，以下是今日头条杭州研发岗位（PHP/Golang）的面试记录</p><a id="more"></a><h1 id="一面（约1h）"><a href="#一面（约1h）" class="headerlink" title="一面（约1h）"></a>一面（约1h）</h1><ol><li>在面对未知的流量暴增，可以预先怎么处理</li><li>如何限流，限流算法，对于ddos攻击怎么处理</li><li>PHP数组的底层实现</li><li>分布式事务</li><li>RPC相对于传统的API调用的优点</li><li>服务调度中心的感知与动态上下线</li><li>MySQL的索引，为什么是B+而不是平衡二叉树</li><li>索引查找在Linux的磁盘上是怎么操作的</li><li>聚簇索引相对于B+索引的优点</li><li>如何分析SQL执行慢的原因</li><li>Redis连接时的connect与pconnect的区别</li><li>Redis有哪些结构时间复杂度较高</li><li>Redis hash的实现</li><li>算法题： 在1个10G大小的文件中，存储的都是int型的数据，如何在内存使用小于8M的情况下进行排序</li><li>设计题： 以微博为例，有1个亿的用户，同时用户之间有关注和粉丝，用户的关注和取关操作比较频繁，如何设计架构和API接口</li></ol><h1 id="二面（约1-5h）"><a href="#二面（约1-5h）" class="headerlink" title="二面（约1.5h）"></a>二面（约1.5h）</h1><p>二面主要以自己的项目为切入点，进一步考察你对项目中知识点的把握程度，我这里是以一个 自己撸的小项目 <a href="https://github.com/tyloafer/ProcessManager" target="_blank" rel="noopener">进程管理工具</a> 为项目背景</p><ol><li>守护进程是什么，怎么实现</li><li>PHP是否适合做守护进程，为什么（内存管理这一块）</li><li>PHP的垃圾回收机制</li><li>进程间通信方式</li><li>共享内存是怎么实现的</li><li>怎么查看Linux服务器的负载，及判断哪些操作引起的负载过高</li><li>MySQL的IO过高怎么优化，分库分表及分区</li><li>MySQL的索引结构，myisam的索引结构， innodb的索引结构，innodb为什么必须要有主键索引</li><li>添加索引，为什么可以减少io操作（磁盘页）</li><li>nginx的负载均衡算法</li><li>算法题： 忘了</li><li>算法题：查找一个字符串中最长的无重复字串</li></ol><p>上面是我基本还记得的一些题目，考察的力度相对比较深，所以，请选择一个自己比较熟悉的项目，因为面试官是会剖析到底层的</p><h1 id="三面（约0-6h）"><a href="#三面（约0-6h）" class="headerlink" title="三面（约0.6h）"></a>三面（约0.6h）</h1><p>三面与二面的内容差不多，没有更深的问题，但是，需要注重细节，同时三面面试官有时间会放烟雾弹，坚定自己的立场就好</p><ol><li>面试题： 在一个横向和纵向都是递增的有界二维坐标轴中，如何快速判断某个数是否存在于这个二维坐标中</li></ol><h1 id="Hr面（约0-5h）"><a href="#Hr面（约0-5h）" class="headerlink" title="Hr面（约0.5h）"></a>Hr面（约0.5h）</h1><p>hr小姐姐：你有什么心仪的公司吗</p><p>我： 大厂，类似于BAT这种</p><p>hr小姐姐：为什么呢？</p><p>我： 我感觉 阿里的架构不错，微博鸟哥待过，技术架构肯定吊吊的。。。</p><p>hr小姐姐：你跟我在北京面的其他候选人都不太一样啊，他们都不屑于去这些公司，感觉想进就进，他们比较倾向于滴滴，头条这些年轻，发展比较快速的公司</p><p>我：卒。。。（毕竟我毕业才一年半啊-_-，校招还因为自己不在意，完美错过了所有大厂的招聘）</p><h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><p>头条面试，算法是必考项，但是面试官都是让我给出思路，也没写多少行代码</p><p>涉猎范围一般，基本就是Redis MySQL ，Nginx比较少，可能配置简单吧</p><p>深度较深，很少人会去关注PHP的垃圾回收，何为垃圾，线程安全，array的HashTable实现这些内容, Redis Hash表等</p>]]></content>
      
      
      <categories>
          
          <category> 面经 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 面经 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Linux终端科学上网</title>
      <link href="/posts/31170/"/>
      <url>/posts/31170/</url>
      
        <content type="html"><![CDATA[<p>对于经常在服务商使用git 和 composer 的我来说，实在受不了那几k的网速，但是毕竟使用较少，而且，还可以使用国内镜像源，但是近期要使用Google API，这个就有点头疼了。所以，废话不多话，直接上步骤，没什么技术含量。</p><a id="more"></a><h1 id="Proxychains4版本"><a href="#Proxychains4版本" class="headerlink" title="Proxychains4版本"></a>Proxychains4版本</h1><h2 id="安装配置shadowsocks"><a href="#安装配置shadowsocks" class="headerlink" title="安装配置shadowsocks"></a>安装配置shadowsocks</h2><h3 id="安装"><a href="#安装" class="headerlink" title="安装"></a>安装</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">pip install shadowsocks</span><br></pre></td></tr></table></figure><h3 id="配置"><a href="#配置" class="headerlink" title="配置"></a>配置</h3><p>编辑配置文件 <code>/etc/sslocal.json</code>，配置文件可以放在任意位置，启动的时候 指定对应位置即可</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">    &quot;server&quot;:&quot;xxx.xxx.xxx.xxx&quot;, // ss 服务器ip</span><br><span class="line">    &quot;server_port&quot;:xxx,  // ss 端口</span><br><span class="line">    &quot;local_address&quot;: &quot;127.0.0.1&quot;, // 本机代理</span><br><span class="line">    &quot;local_port&quot;:1080, // 本机代理端口</span><br><span class="line">    &quot;password&quot;:&quot;*******&quot;, // ss 密码</span><br><span class="line">    &quot;timeout&quot;:300,</span><br><span class="line">    &quot;method&quot;:&quot;rc4-md5&quot; // ss 加密方式</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>配置时请把后面的注释去掉</p><h3 id="使用"><a href="#使用" class="headerlink" title="使用"></a>使用</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">启动：sslocal -c /etc/sslocal.json -d start</span><br><span class="line"></span><br><span class="line">停止：sslocal -c /etc/sslocal.json -d stop</span><br><span class="line"></span><br><span class="line">重启：sslocal -c /etc/sslocal.json -d restart</span><br></pre></td></tr></table></figure><h2 id="安装配置-Proxychains4"><a href="#安装配置-Proxychains4" class="headerlink" title="安装配置 Proxychains4"></a>安装配置 Proxychains4</h2><p>项目地址： <a href="https://github.com/rofl0r/proxychains-ng" target="_blank" rel="noopener">https://github.com/rofl0r/proxychains-ng</a></p><p>编译安装即可</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">git clone https://github.com/rofl0r/proxychains-ng.git</span><br><span class="line">cd proxychains-ng</span><br><span class="line">./configure</span><br><span class="line">make &amp;&amp; make install</span><br><span class="line">cp ./src/proxychains.conf /etc/proxychains.conf</span><br></pre></td></tr></table></figure><p>修改 <code>/etc/proxychains.conf</code> 将 <strong>socks4 127.0.0.1 9095</strong> 改成 <strong>socks5 127.0.0.1 1080</strong> </p><p>这里<strong>127.0.0.1</strong> 与 shadowsock配置文件中 <strong>local_address</strong> 对应 <strong>1080</strong> 与 <strong>local_port</strong> 对应即可</p><p>至此，安装完成，只要在使用的命令前 加上 <code>proxychains4</code> 即可实现科学上网</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">proxychains4 wget https://www.google.com</span><br></pre></td></tr></table></figure><h1 id="HTTP-PROXY-推荐"><a href="#HTTP-PROXY-推荐" class="headerlink" title="HTTP_PROXY(推荐)"></a>HTTP_PROXY(推荐)</h1><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">http:</span><br><span class="line">export http_proxy=http://proxyAddress:port</span><br><span class="line">export http_proxy=socks5://127.0.0.1:1087</span><br><span class="line"></span><br><span class="line">https:</span><br><span class="line">export https_proxy=https://proxyAddress:port</span><br><span class="line">export https_proxy=socks5://127.0.0.1:1087</span><br><span class="line"></span><br><span class="line">http &amp;&amp; https</span><br><span class="line">export all_proxy=http://proxyAddress:port</span><br><span class="line">export all_proxy=socks5://127.0.0.1:1087</span><br></pre></td></tr></table></figure><p>如果http代理需要验证的话</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">http_proxy=http://userName:password@proxyAddress:port</span><br></pre></td></tr></table></figure><p>其他代理方式相同</p>]]></content>
      
      
      <categories>
          
          <category> ShadowSock </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 科学上网 </tag>
            
            <tag> ShadowSock </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>SeLinux引发的问题小记</title>
      <link href="/posts/15998/"/>
      <url>/posts/15998/</url>
      
        <content type="html"><![CDATA[<p>以前自己在部署服务器的时候，忘了遇到了什么坑，导致后来习惯性把新服务器上的 <strong>SeLinux</strong> 服务直接关闭，今天处理了一台不是我部署的服务器，又踩了两个坑，这里做一下记录，后面有时间还是要好好了解一下这块。</p><h1 id="FastCGI-sent-in-stderr-“Primary-script-unknown”-while-reading-response-header-from-upstream"><a href="#FastCGI-sent-in-stderr-“Primary-script-unknown”-while-reading-response-header-from-upstream" class="headerlink" title="FastCGI sent in stderr: “Primary script unknown” while reading response header from upstream"></a>FastCGI sent in stderr: “Primary script unknown” while reading response header from upstream</h1><blockquote><p> 这个问题一般是 <strong>SCRIPT_FILENAME</strong>   这个变量没有设置好，但是打印出来其实是正确的，也就是证明nginx的配置时没有问题的，可以考虑是 <strong>SeLinux</strong> 的原因</p></blockquote><p>处理： chcon -R -t httpd_sys_content_t /path/to/webroot</p><h1 id="chmod-777-后依旧-failed-to-open-stream-Permission-denied"><a href="#chmod-777-后依旧-failed-to-open-stream-Permission-denied" class="headerlink" title="chmod 777 后依旧 failed to open stream: Permission denied"></a>chmod 777 后依旧 failed to open stream: Permission denied</h1><p>处理： </p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">setenforce Permissive</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> Linux </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Linux </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>深入理解PHP系列之线程安全</title>
      <link href="/posts/56229/"/>
      <url>/posts/56229/</url>
      
        <content type="html"><![CDATA[<p>进程: 进程拥有自己独立的堆和栈，既不共享堆，亦不共享栈，进程由操作系统调度。</p><p>线程: 线程拥有自己独立的栈和共享的堆，共享堆，不共享栈，线程亦由操作系统调度(标准线程是的)。</p><p>根据前面三篇文章《<a href="https://tyloafer.github.io/posts/30726/">浅析堆栈和内存溢出</a>》 《<a href="https://tyloafer.github.io/posts/17570/">深入PHP系列之PHP数组底层的实现</a>》《<a href="https://tyloafer.github.io/posts/47934/">深入PHP系列-变量分离与引用</a>》可以得知，PHP的变量是由zval结构体构成的，数组则是hash表和链表构成的，这些，都是程序员进行分配销毁的内存，也即堆内存。由此可得，在不同的线程中，PHP其实是共享变量的，如果线程1修改了变量a， 则线程2使用变量a的时候，就是线程1修改后的结果，所谓线程安全也就是，如何保障，各个线程之间可以安全的使用公共的资源，不受影响且不影响其他线程。因此，PHP实现了一个线程安全资源管理器（Thread Safe Resource Manager, TSRM），用于解决这个问题，实现线程之间安全的操作公共资源。</p><a id="more"></a><h1 id="核心思想"><a href="#核心思想" class="headerlink" title="核心思想"></a>核心思想</h1><p><img src="https://github-1253518569.cos.ap-shanghai.myqcloud.com/thread_1.png" alt="thread_1"></p><p>如图，如果三个线程的内存地址不同，那么在 Thread1 里面操作的是Thread1对应的内存地址，就不会影响 Thread2 和 Thread3 对应的内存地址的值。</p><p>TSRM的核心思想就是为不同的线程分配独立的内存空间，如果一个资源会被多线程使用，那么首先需要预先向TSRM注册资源，然后TSRM为这个资源分配一个唯一的编号，并把这种资源的大小、初始化函数等保存到一个<code>tsrm_resource_type</code>结构中，各线程只能通过TSRM分配的那个编号访问这个资源；然后当线程拿着这个编号获取资源时TSRM如果发现是第一次请求，则会根据注册时的资源大小分配一块内存，然后调用初始化函数进行初始化，并把这块资源保存下来供这个线程后续使用。</p><h1 id="基本实现"><a href="#基本实现" class="headerlink" title="基本实现"></a>基本实现</h1><p><img src="https://github-1253518569.cos.ap-shanghai.myqcloud.com/thread_safe.png" alt="线程安全结构"></p><p>TSRM的整体结构主要如上图所示，现从左向右开始梳理</p><h2 id="tsrm-tls-table"><a href="#tsrm-tls-table" class="headerlink" title="tsrm_tls_table"></a>tsrm_tls_table</h2><p>左侧第一个结构是 <code>tsrm_tls_table</code>, tsrm_tls_table 是一个数组，数组每个索引对应的值是一个地址，也就是为线程申请内存地址。那么如何确定线程在 tsrm_tls_table  的哪个索引下面呢，在PHP的数组的实现中，通过hash散列取模来确定索引，这里也是一样，只是简化了，直接通过线程id % tsrm_tls_table_size 来确定索引。</p><p>我们以上图为例， tsrm_tls_table_size 为 2， 如果新的一个线程， 线程id（后面用 thread_id来替代）， 3 % 2 = 1， 所以 我们在 tsrm_tls_table[1] 下面去寻找这个线程内存地址。进而，这里就会引发一个问题， 5 % 2 = 1，那是不是就冲突了?</p><h2 id="tsrm-tls-entry"><a href="#tsrm-tls-entry" class="headerlink" title="tsrm_tls_entry"></a>tsrm_tls_entry</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">struct _tsrm_tls_entry &#123;</span><br><span class="line">    void **storage; //资源数组</span><br><span class="line">    int count; //拥有的资源数:storage数组大小</span><br><span class="line">    THREAD_T thread_id; //所属线程id</span><br><span class="line">    tsrm_tls_entry *next;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>按照上面的情况来考虑，肯定会存在冲突的情况，除非这个数组特别大，但是那样内存耗费就得不偿失了。</p><p>所以，<code>tsrm_tls_entry</code> 的结构体 有一个这样的 属性 <code>tsrm_tls_entry *next;</code>，这样就可以把各个冲突的 <code>tsrm_tls_entry</code> 串成链表来解决冲突了，这也是hash冲突时，常用的解决方法。</p><h3 id="tsrm-resource-type"><a href="#tsrm-resource-type" class="headerlink" title="tsrm_resource_type"></a>tsrm_resource_type</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">typedef struct &#123;</span><br><span class="line">    size_t size; //资源的大小</span><br><span class="line">    ts_allocate_ctor ctor; //初始化函数</span><br><span class="line">    ts_allocate_dtor dtor;</span><br><span class="line">    int done;</span><br><span class="line">&#125; tsrm_resource_type;</span><br></pre></td></tr></table></figure><p><code>tsrm_resource_type</code> 这个结构体好像在上图中并没有体现出来具体是干什么的，接下来，先看一下，TSRM的初始化过程，应该就能知道这个结构体的作用了</p><p><strong>初始化</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">TSRM_API int tsrm_startup(int expected_threads, int expected_resources, int debug_level, char *debug_filename)</span><br><span class="line">&#123;</span><br><span class="line">    pthread_key_create( &amp;tls_key, 0 );</span><br><span class="line"></span><br><span class="line">    //分配tsrm_tls_table</span><br><span class="line">    tsrm_tls_table_size = expected_threads;</span><br><span class="line">    tsrm_tls_table = (tsrm_tls_entry **) calloc(tsrm_tls_table_size, sizeof(tsrm_tls_entry *));</span><br><span class="line">    ...</span><br><span class="line">    //初始化资源的递增id，注册资源时就是用的这个值</span><br><span class="line">    id_count=0;</span><br><span class="line"></span><br><span class="line">    //分配资源类型数组：resource_types_table</span><br><span class="line">    resource_types_table_size = expected_resources;</span><br><span class="line">    resource_types_table = (tsrm_resource_type *) calloc(resource_types_table_size, sizeof(tsrm_resource_type));</span><br><span class="line">    ...</span><br><span class="line">    //创建锁</span><br><span class="line">    tsmm_mutex = tsrm_mutex_alloc();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>注册资源</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">#ifdef ZTS</span><br><span class="line">ZEND_API int executor_globals_id;</span><br><span class="line">#endif</span><br><span class="line"></span><br><span class="line">int zend_startup(zend_utility_functions *utility_functions, char **extensions)</span><br><span class="line">&#123;</span><br><span class="line">    ...</span><br><span class="line">#ifdef ZTS</span><br><span class="line">    ts_allocate_id(&amp;executor_globals_id, sizeof(zend_executor_globals), (ts_allocate_ctor) executor_globals_ctor, (ts_allocate_dtor) executor_globals_dtor);</span><br><span class="line">    </span><br><span class="line">    executor_globals = ts_resource(executor_globals_id);</span><br><span class="line">    ...</span><br><span class="line">#endif</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line">TSRM_API ts_rsrc_id ts_allocate_id(ts_rsrc_id *rsrc_id, size_t size, ts_allocate_ctor ctor, ts_allocate_dtor dtor)</span><br><span class="line">&#123;</span><br><span class="line">    //加锁，保证各线程串行调用此函数</span><br><span class="line">    tsrm_mutex_lock(tsmm_mutex);</span><br><span class="line"></span><br><span class="line">    //分配id，即id_count当前值，然后把id_count加1</span><br><span class="line">    *rsrc_id = TSRM_SHUFFLE_RSRC_ID(id_count++);</span><br><span class="line"></span><br><span class="line">    //检查resource_types_table数组当前大小是否已满</span><br><span class="line">    if (resource_types_table_size &lt; id_count) &#123;</span><br><span class="line">        //需要对resource_types_table扩容</span><br><span class="line">        resource_types_table = (tsrm_resource_type *) realloc(resource_types_table, sizeof(tsrm_resource_type)*id_count);</span><br><span class="line">        ...</span><br><span class="line">        //把数组大小修改新的大小</span><br><span class="line">        resource_types_table_size = id_count;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    //将新注册的资源插入resource_types_table数组，下标就是分配的资源id</span><br><span class="line">    resource_types_table[TSRM_UNSHUFFLE_RSRC_ID(*rsrc_id)].size = size;</span><br><span class="line">    resource_types_table[TSRM_UNSHUFFLE_RSRC_ID(*rsrc_id)].ctor = ctor;</span><br><span class="line">    resource_types_table[TSRM_UNSHUFFLE_RSRC_ID(*rsrc_id)].dtor = dtor;</span><br><span class="line">    resource_types_table[TSRM_UNSHUFFLE_RSRC_ID(*rsrc_id)].done = 0;</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>根据上面的初始化和注册资源流程可以看出， <code>tsrm_tls_entry</code>  结构是 <code>resource_types_table</code> 的基本组成单位，<code>resource_types_table</code> 就是线程的资源聚集地， 在注册资源的时候，tsrm会给资源分配一个id，然后线程再去使用这个资源的时候，首先根据tread_id找到 分配的线程内存地址，然后再根据 资源id，找到资源在线程内存地址里面的地址</p><h1 id="流程优化"><a href="#流程优化" class="headerlink" title="流程优化"></a>流程优化</h1><p>梳理一下，线程里面查找一个资源可以分为三步</p><ol><li>获取当前线程的thread_id</li><li>根据thread_id获取tsrm_tls_entry，这个过程需要对tsrm_tls_table加锁，遍历链表</li><li>根据资源id，获取tsrm_tls_entry里面的对应的资源</li></ol><p>线程对资源的操作是频繁的，每次都要进行上面三步操作是很费时的，而且第二步还需要加锁，这个将严重的影响性能。</p><p>TSRM通过线程私有数据（Thread-Specific Data, TSD）优化了这个问题，TSD是由POSIX数据库维护的，使用同一名称为不同线程保存数据的一种存储形式，即各线程根据同名的key可以获取到不同的变量地址。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">// 创建名为key的TSD</span><br><span class="line">int pthread_key_create(pthread_key_t* keyp, void (*destructor)(void*) );</span><br><span class="line">// 销毁名为key的TSD</span><br><span class="line">int pthread_key_delete(pthread_key_t* key);</span><br><span class="line">// 根据key设置TSD</span><br><span class="line">int pthread_setspecific(pthread_key_t key, const void* value);</span><br><span class="line">// 根据key获取</span><br><span class="line">int pthread_setspecific(pthread_key_t key, const void* value);</span><br></pre></td></tr></table></figure><p>如此，便可以将上面三步优化为下面两步</p><ol><li>根据资源id获取资源的地址</li><li>根据资源地址，获取资源内容</li></ol>]]></content>
      
      
      <categories>
          
          <category> PHP </category>
          
      </categories>
      
      
        <tags>
            
            <tag> PHP </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>浅析堆栈和内存溢出</title>
      <link href="/posts/30726/"/>
      <url>/posts/30726/</url>
      
        <content type="html"><![CDATA[<p>对于一个PHPer来说，PHP已经帮我们处理好了GC，线程安全等内存相关的操作，完全不需要我们去考虑，让我们更加注重于代码的实现。再加上大学原本就是混的嗨皮，学的心塞，也对这些概念没什么了解，但是近期在看PHP的源码的时候，感慨还是逃不掉这些概念。</p><a id="more"></a><h1 id="内存分布"><a href="#内存分布" class="headerlink" title="内存分布"></a>内存分布</h1><p>一个C语言的内存布局：</p><ol><li>栈区（stack）: 由编译器自动分配释放 ，存放函数的参数值，局部变量的值等。其操作方式类似于数据结构中的栈。</li><li>堆区（heap） : 一般由程序员分配释放， 若程序员不释放，程序结束时可能由OS回收 。注意它与数据结构中的堆是两回事，分配方式倒是类似于链表。</li><li>全局区（静态区）（static）: 全局变量和静态变量的存储是放在一块的，初始化的全局变量和静态变量在一块区域， 未初始化的全局变量和未初始化的静态变量在相邻的另一块区域。 - 程序结束后由系统释放。</li><li>文字常量区 : 常量字符串就是放在这里的。 程序结束后由系统释放</li><li>程序代码区 : 存放函数体的二进制代码。</li></ol><p>内存分布如下图所示</p><p><img src="https://github-1253518569.cos.ap-shanghai.myqcloud.com/1609713-eaa6e0729938352f.webp" alt="img"></p><p>上图是网上搜索堆栈很常见的一个图，在这个图里面，栈区和堆区就是对应内存分配中的栈区和堆区，其余的可参照下面对应</p><p>可读写取 =&gt; 全局区</p><p>文字常量区 =&gt; 只读区</p><p>程序代码去 =&gt; 只读区</p><h1 id="例子"><a href="#例子" class="headerlink" title="例子"></a>例子</h1><p>下面，我们结合网上非常经典的一个例子来分析</p><p><img src="https://github-1253518569.cos.ap-shanghai.myqcloud.com/1470646448_1244.PNG" alt="https://github-1253518569.cos.ap-shanghai.myqcloud.com/1470646448_1244.PNG"></p><ul><li>int a = 0 : 这里是写在main函数外面的全局变量，属于初始化过的全局变量，所以应该存在在 <code>全局区</code></li><li>char *p1 : 这里同上，区别是没有经过初始化，所以属于未初始化的全局变量，所以应该也存在 <code>全局区</code></li><li>int b : 这一行是在main函数里面，也没有声明全局变量，属于局部变量，所以应该是存放在 <code>栈区</code> 上面</li><li>char s[] = “abc” : 同上，s 变量是 局部变量，也就是存放在 <code>栈区</code> 上面，分配的内存里面存储的就是 “abc”</li><li>char *p2 : 同 <code>int b</code> 分析可得，存放在 <code>栈区</code> 上面</li><li>char *p3 :  同上分析可得， p3 是存放在 <code>栈区</code> 上面，p3所在的内存就存储了它所指向的地址，也就是说并不是存储的”123456”，这时候 “123456” 就可以看成一个常量字符串，应该是存放在 <code>文字常量区</code></li><li>static int c = 0 : 初始化的静态变量应该存放在 <code>全局区</code></li><li>p1 = (char * )malloc(10) : p1 这个变量肯定是被压入 <code>栈内</code> 的，其值也就是申请的内存的首地址， 那 malloc 分配的地址呢， 这个地址是由程序员分配的，所以是存放在 <code>堆区</code> 上的一块内存</li><li>p2 = (char *) malloc(20) : 同上分析</li><li>strcpy(p1, “123456”) : 对于编译器的优化，个人并不清楚，所以可依据图中的注释 </li></ul><h1 id="内存泄漏"><a href="#内存泄漏" class="headerlink" title="内存泄漏"></a>内存泄漏</h1><p>在上面的内存分布中会发现，除了<code>堆区</code>以外，其他区的内存区会在程序结束时，由系统释放，所以内 <strong>内存泄漏</strong>是指由于疏忽或错误造成程序未能释放已经不再使用的<a href="https://zh.wikipedia.org/wiki/%E5%86%85%E5%AD%98" target="_blank" rel="noopener">内存</a>。内存泄漏并非指内存在物理上的消失，而是应用程序分配某段内存后，由于设计错误，导致在释放该段内存之前就失去了对该段内存的控制，从而造成了内存的浪费。</p><p>所以，在C语言中，内存的释放是由 <strong>free()</strong> 来处理完成的，</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">void free(void *ptr)  </span><br><span class="line">&#123; </span><br><span class="line">    struct mem_control_block *free; </span><br><span class="line">    free = ptr - sizeof(struct mem_control_block); </span><br><span class="line">    free-&gt;is_available = 1; </span><br><span class="line">    return; </span><br><span class="line">&#125;</span><br><span class="line">struct mem_control_block &#123; </span><br><span class="line">int is_available;    //这是一个标记？ </span><br><span class="line">int size;            //这是实际空间的大小 </span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>上面是 <strong>free()</strong>， 其实是把对应内存块设置为可用，同时把指针再向前偏移 <strong>内存块控制头</strong> 的长度，也就是实际分配的内存块首地址，所以，这里引出一个问题，如果我们给 <strong>free()</strong> 的不是<strong>malloc()</strong> 返回给我们的地址，这时候去释放内存是不时会存在问题 ，所以，综上，内存泄漏可以总结出两种原因</p><ol><li>malloc 之后 没有 free</li><li>free 是 给的地址不是 malloc 返回给我们的首地址</li></ol>]]></content>
      
      
      <categories>
          
          <category> 内存 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 内存 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>深入PHP系列之PHP数组底层的实现</title>
      <link href="/posts/17570/"/>
      <url>/posts/17570/</url>
      
        <content type="html"><![CDATA[<p>数组是PHP中非常强大、灵活的一种数据类型，它的底层实现为散列表(HashTable，也称作：哈希表)，除了我们熟悉的PHP用户空间的Array类型之外，内核中也随处用到散列表，比如函数、类、常量、已include文件的索引表、全局符号表等都用的HashTable存储。</p><p>散列表是根据关键码值(Key value)而直接进行访问的数据结构，它的key - value之间存在一个映射函数，可以根据key通过映射函数直接索引到对应的value值，它不以关键字的比较为基本操作，采用直接寻址技术（就是说，它是直接通过key映射到内存地址上去的），从而加快查找速度，在理想情况下，无须任何比较就可以找到待查关键字，查找的期望时间为O(1)。</p><a id="more"></a><h1 id="数组结构"><a href="#数组结构" class="headerlink" title="数组结构"></a>数组结构</h1><h2 id="Array-结构体（zend-type-h）"><a href="#Array-结构体（zend-type-h）" class="headerlink" title="Array 结构体（zend_type.h）"></a>Array 结构体（<strong>zend_type.h</strong>）</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">struct _zend_array &#123;</span><br><span class="line">    zend_refcounted_h gc;</span><br><span class="line">    union &#123;</span><br><span class="line">        struct &#123;</span><br><span class="line">            ZEND_ENDIAN_LOHI_4(</span><br><span class="line">                zend_uchar    flags,</span><br><span class="line">                zend_uchar    _unused,</span><br><span class="line">                zend_uchar    nIteratorsCount,</span><br><span class="line">                zend_uchar    _unused2)</span><br><span class="line">        &#125; v;</span><br><span class="line">        uint32_t flags;</span><br><span class="line">    &#125; u;</span><br><span class="line">    uint32_t          nTableMask; // 哈希值计算掩码 等于 -nTableSize</span><br><span class="line">    Bucket           *arData;  // 存储元素数组，指向第一个bucket</span><br><span class="line">    uint32_t          nNumUsed; // 已用的bucket数量</span><br><span class="line">    uint32_t          nNumOfElements; // 哈希表中全部元素数</span><br><span class="line">    uint32_t          nTableSize;  // 哈希表的总大小</span><br><span class="line">    uint32_t          nInternalPointer;</span><br><span class="line">    zend_long         nNextFreeElement; // 下一个可用的数值索引， 例 arr[] = 1; 这里就是1</span><br><span class="line">    dtor_func_t       pDestructor;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>这个了结构体里面 在第2行 引入了 <strong>zend_refcounted_h</strong> 结构体，这个是垃圾回收时用到的</p><p>在第14行的时候 引入了 <strong>Bucket</strong> 结构体，我们继续看一下 <strong>Bucket</strong> 结构体</p><h2 id="Bucket结构体-（zend-type-h）"><a href="#Bucket结构体-（zend-type-h）" class="headerlink" title="Bucket结构体 （zend_type.h）"></a>Bucket结构体 （zend_type.h）</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">typedef struct _Bucket &#123;</span><br><span class="line">zval              val;</span><br><span class="line">zend_ulong        h;                /* hash value (or numeric index)   */</span><br><span class="line">zend_string      *key;              /* string key or NULL for numerics */</span><br><span class="line">&#125; Bucket;</span><br></pre></td></tr></table></figure><p>在第2行的时候，引入了 zval 结构体，</p><h2 id="zval结构体（zend-type-h）"><a href="#zval结构体（zend-type-h）" class="headerlink" title="zval结构体（zend_type.h）"></a>zval结构体（zend_type.h）</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line">struct _zval_struct &#123;</span><br><span class="line">    zend_value        value;            /* value */</span><br><span class="line">    union &#123;</span><br><span class="line">        struct &#123;</span><br><span class="line">            ZEND_ENDIAN_LOHI_3(</span><br><span class="line">                zend_uchar    type,         /* active type */</span><br><span class="line">                zend_uchar    type_flags,</span><br><span class="line">                union &#123;</span><br><span class="line">                    uint16_t  call_info;    /* call info for EX(This) */</span><br><span class="line">                    uint16_t  extra;        /* not further specified */</span><br><span class="line">                &#125; u)</span><br><span class="line">        &#125; v;</span><br><span class="line">        uint32_t type_info;</span><br><span class="line">    &#125; u1;</span><br><span class="line">    union &#123;</span><br><span class="line">        uint32_t     next;                 /* hash collision chain */</span><br><span class="line">        uint32_t     cache_slot;           /* cache slot (for RECV_INIT) */</span><br><span class="line">        uint32_t     opline_num;           /* opline number (for FAST_CALL) */</span><br><span class="line">        uint32_t     lineno;               /* line number (for ast nodes) */</span><br><span class="line">        uint32_t     num_args;             /* arguments number for EX(This) */</span><br><span class="line">        uint32_t     fe_pos;               /* foreach position */</span><br><span class="line">        uint32_t     fe_iter_idx;          /* foreach iterator index */</span><br><span class="line">        uint32_t     access_flags;         /* class constant access flags */</span><br><span class="line">        uint32_t     property_guard;       /* single property guard */</span><br><span class="line">        uint32_t     constant_flags;       /* constant flags */</span><br><span class="line">        uint32_t     extra;                /* not further specified */</span><br><span class="line">    &#125; u2;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h2 id="字段解释"><a href="#字段解释" class="headerlink" title="字段解释"></a>字段解释</h2><p>首先从 array结构体开始说起</p><ul><li>nTableMask : 哈希值计算掩码， 数组的索引计算出来的long 与这个值进行位运算，从而计算出这个数据应该存放在索引表的位置</li><li>arData: 数组中的值都存放在这里，这个也是数组hash表的实现的地方</li><li>nNumUsed: 使用的bucket的总数</li><li>nNumOfElements: hash表中的有效数据，在PHP中，删除数组中的一个元素，并不会直接将这个元素从hash表里面删除，而是在bucket里面的zval结构体里面修改为 <code>IS_UNDEF</code>， 在 <code>ht-&gt;nNumUsed &gt; ht-&gt;nNumOfElements + (ht-&gt;nNumOfElements &gt;&gt; 5)</code> 的时候进行整理</li><li>nTableSize: 分配的hash表的大小</li><li>nNextFreeElement: 下一个可用的hash数值索引</li><li>pDestructor: 一个回调函数，当覆盖/删除一个key或者释放zend_array时，用于释放Bucket中的val。</li></ul><p>Bucket</p><ul><li>val：存储的zval数据。</li><li>h：当元素保存在整形下标时，下标保存在该字段，并且本身充当hash值，对其取模得到哈希表的槽位。</li><li>key：当保存的key是字符串时，保存在该字段，通过某个哈希算法生成hash值保存到h字段，对h取模得到哈希表的槽位。</li></ul><h1 id="hash表"><a href="#hash表" class="headerlink" title="hash表"></a>hash表</h1><h2 id="hash表图示"><a href="#hash表图示" class="headerlink" title="hash表图示"></a>hash表图示</h2><p>首先在这里展示一下，数组的hash表大致的实现图示，然后结合插入操作来具体分析</p><p><img src="https://github-1253518569.cos.ap-shanghai.myqcloud.com/php-hash-table.png" alt="hash表图示"></p><h2 id="hash表实现（zend-hash-c）"><a href="#hash表实现（zend-hash-c）" class="headerlink" title="hash表实现（zend_hash.c）"></a>hash表实现（zend_hash.c）</h2><p>这里首要分析了 数组的插入操作，插入的时候，是如何创建使用hash表的索引及选择bucket的位置的，插入操作主要通过 <code>_zend_hash_add_or_update_i</code> 实现的，如下：</p><p>首先先将一些可能会用用到的常量和函数先在这里声明一下，后面查看源码的时候会用到</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line">#define Z_NEXT(zval)                (zval).u2.next</span><br><span class="line">#define Z_NEXT_P(zval_p)            Z_NEXT(*(zval_p))</span><br><span class="line"></span><br><span class="line">#define HT_HASH_EX(data, idx) \</span><br><span class="line">    ((uint32_t*)(data))[(int32_t)(idx)]</span><br><span class="line">#define HT_HASH(ht, idx) \</span><br><span class="line">    HT_HASH_EX((ht)-&gt;arData, idx)</span><br><span class="line"># define HT_IDX_TO_HASH(idx) \</span><br><span class="line">    ((idx) * sizeof(Bucket))</span><br><span class="line"></span><br><span class="line">#define HT_FLAGS(ht) (ht)-&gt;u.flags</span><br><span class="line"></span><br><span class="line">#define HT_IS_PACKED(ht) \</span><br><span class="line">    ((HT_FLAGS(ht) &amp; HASH_FLAG_PACKED) != 0)</span><br><span class="line"></span><br><span class="line">#define HASH_UPDATE (1&lt;&lt;0)</span><br><span class="line">#define HASH_ADD(1&lt;&lt;1)</span><br><span class="line">#define HASH_UPDATE_INDIRECT(1&lt;&lt;2)</span><br><span class="line">#define HASH_ADD_NEW(1&lt;&lt;3)</span><br><span class="line">#define HASH_ADD_NEXT(1&lt;&lt;4)</span><br><span class="line"></span><br><span class="line">#define HASH_FLAG_CONSISTENCY      ((1&lt;&lt;0) | (1&lt;&lt;1))</span><br><span class="line">#define HASH_FLAG_PACKED           (1&lt;&lt;2)</span><br><span class="line">#define HASH_FLAG_INITIALIZED      (1&lt;&lt;3)</span><br><span class="line">#define HASH_FLAG_STATIC_KEYS      (1&lt;&lt;4) /* long and interned strings */</span><br><span class="line">#define HASH_FLAG_HAS_EMPTY_IND    (1&lt;&lt;5)</span><br><span class="line">#define HASH_FLAG_ALLOW_COW_VIOLATION (1&lt;&lt;6)</span><br></pre></td></tr></table></figure><p>源码如下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br></pre></td><td class="code"><pre><span class="line">static zend_always_inline zval *_zend_hash_add_or_update_i(HashTable *ht, zend_string *key, zval *pData, uint32_t flag)</span><br><span class="line">&#123;</span><br><span class="line">zend_ulong h;</span><br><span class="line">uint32_t nIndex;</span><br><span class="line">uint32_t idx;</span><br><span class="line">Bucket *p, *arData;</span><br><span class="line"></span><br><span class="line">IS_CONSISTENT(ht);</span><br><span class="line">HT_ASSERT_RC1(ht);</span><br><span class="line">// 检查hashtable是否初始化</span><br><span class="line">if (UNEXPECTED(!(HT_FLAGS(ht) &amp; HASH_FLAG_INITIALIZED))) &#123;</span><br><span class="line">    // 如果数组还没有分配ardata内存， 这时需要分配内存，包括中间映射表和元素数组</span><br><span class="line">zend_hash_real_init_mixed(ht);</span><br><span class="line">if (!ZSTR_IS_INTERNED(key)) &#123;</span><br><span class="line">zend_string_addref(key);</span><br><span class="line">HT_FLAGS(ht) &amp;= ~HASH_FLAG_STATIC_KEYS;</span><br><span class="line">zend_string_hash_val(key);</span><br><span class="line">&#125;</span><br><span class="line">goto add_to_hash;</span><br><span class="line">&#125; else if (HT_FLAGS(ht) &amp; HASH_FLAG_PACKED) &#123;</span><br><span class="line">    // 这里将packed array转换成等效的hash array</span><br><span class="line">zend_hash_packed_to_hash(ht);</span><br><span class="line">if (!ZSTR_IS_INTERNED(key)) &#123;</span><br><span class="line">zend_string_addref(key);</span><br><span class="line">HT_FLAGS(ht) &amp;= ~HASH_FLAG_STATIC_KEYS;</span><br><span class="line">zend_string_hash_val(key);</span><br><span class="line">&#125;</span><br><span class="line">&#125; else if ((flag &amp; HASH_ADD_NEW) == 0) &#123;</span><br><span class="line">p = zend_hash_find_bucket(ht, key, 0);</span><br><span class="line"></span><br><span class="line">if (p) &#123;</span><br><span class="line">zval *data;</span><br><span class="line">// key已经存在的情况，且标志位 是HASH_ADD</span><br><span class="line">if (flag &amp; HASH_ADD) &#123;</span><br><span class="line">if (!(flag &amp; HASH_UPDATE_INDIRECT)) &#123;</span><br><span class="line">return NULL;</span><br><span class="line">&#125;</span><br><span class="line">// 新更新的值不与原先相同，继续执行</span><br><span class="line">ZEND_ASSERT(&amp;p-&gt;val != pData);</span><br><span class="line">data = &amp;p-&gt;val;</span><br><span class="line">// IS_INDIRECT是间接zval，不明白什么意思，继续学习</span><br><span class="line">if (Z_TYPE_P(data) == IS_INDIRECT) &#123;</span><br><span class="line">data = Z_INDIRECT_P(data);</span><br><span class="line">if (Z_TYPE_P(data) != IS_UNDEF) &#123;</span><br><span class="line">return NULL;</span><br><span class="line">&#125;</span><br><span class="line">&#125; else &#123;</span><br><span class="line">return NULL;</span><br><span class="line">&#125;</span><br><span class="line">&#125; else &#123;</span><br><span class="line">ZEND_ASSERT(&amp;p-&gt;val != pData);</span><br><span class="line">data = &amp;p-&gt;val;</span><br><span class="line">if ((flag &amp; HASH_UPDATE_INDIRECT) &amp;&amp; Z_TYPE_P(data) == IS_INDIRECT) &#123;</span><br><span class="line">data = Z_INDIRECT_P(data);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">// 释放掉原来的data</span><br><span class="line">if (ht-&gt;pDestructor) &#123;</span><br><span class="line">ht-&gt;pDestructor(data);</span><br><span class="line">&#125;</span><br><span class="line">// 将新的pData值复制给原来的data</span><br><span class="line">ZVAL_COPY_VALUE(data, pData);</span><br><span class="line">return data;</span><br><span class="line">&#125;</span><br><span class="line">if (!ZSTR_IS_INTERNED(key)) &#123;</span><br><span class="line">zend_string_addref(key);</span><br><span class="line">HT_FLAGS(ht) &amp;= ~HASH_FLAG_STATIC_KEYS;</span><br><span class="line">&#125;</span><br><span class="line">&#125; else if (!ZSTR_IS_INTERNED(key)) &#123;</span><br><span class="line">zend_string_addref(key);</span><br><span class="line">HT_FLAGS(ht) &amp;= ~HASH_FLAG_STATIC_KEYS;</span><br><span class="line">zend_string_hash_val(key);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">// 如果hash表满了，对hash表进行扩容</span><br><span class="line">ZEND_HASH_IF_FULL_DO_RESIZE(ht);/* If the Hash table is full, resize it */</span><br><span class="line"></span><br><span class="line">// 添加hash表</span><br><span class="line">add_to_hash:</span><br><span class="line">    // ardata数组的顺序索引</span><br><span class="line">idx = ht-&gt;nNumUsed++;</span><br><span class="line">ht-&gt;nNumOfElements++;</span><br><span class="line">arData = ht-&gt;arData;</span><br><span class="line">// arData的指针偏移到 idx</span><br><span class="line">p = arData + idx;</span><br><span class="line">// 设置 hash表里面的bucket结构体的 key和 h</span><br><span class="line">p-&gt;key = key;</span><br><span class="line">p-&gt;h = h = ZSTR_H(key);</span><br><span class="line">// 与tablemask进行计算得出hash索引</span><br><span class="line">nIndex = h | ht-&gt;nTableMask;</span><br><span class="line">Z_NEXT(p-&gt;val) = HT_HASH_EX(arData, nIndex);</span><br><span class="line">// 新的元素放到当前hash冲突链表的头部</span><br><span class="line">HT_HASH_EX(arData, nIndex) = HT_IDX_TO_HASH(idx);</span><br><span class="line">ZVAL_COPY_VALUE(&amp;p-&gt;val, pData);</span><br><span class="line"></span><br><span class="line">return &amp;p-&gt;val;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>从上面的<code>api _zend_hash_add_or_update_i</code>可以看出，其实更新操作很简单的，验证key是否存在，key存在的情况下如果值相等的话不做任何的操作，值不相同做更新操作。<br>这里比较重要的是hash表的新增，这里会涉及hash索引以及hash冲突链表。</p><p><code>nIndex = h | ht-&gt;nTableMask;</code> </p><p>这里由于 <strong>nTableMask</strong> 是 <strong>-TableSize</strong>， 所以 <strong>nIndex</strong> 的计算结果范围，也就落到了-2^0 - -2^(tableSize-1)范围里从而将整个 <strong>arData</strong> 分成上图所示的左右两部分，左边是索引表，右边是元素数组，每次新增数据（非更新）的时候，首先把这个数据，顺序的插入到<strong>arData</strong> 右侧的元素数组里面，这样做的目的是为了保证数组的顺序性，在foreach的时候，只需要顺序遍历 <strong>arData</strong> 右侧的数组即可，但是这里有一个问题就是 查找怎么办， 所以就引入了<strong>arData</strong> 左侧的索引表，计算出key的hash索引，然后再指向 刚刚插入的<strong>arData</strong>右侧元素数组的地址</p><p>既然使用了hash表，就避免不了hash冲突的问题</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Z_NEXT(p-&gt;val) = HT_HASH_EX(arData, nIndex);</span><br><span class="line">HT_HASH_EX(arData, nIndex) = HT_IDX_TO_HASH(idx);</span><br></pre></td></tr></table></figure><p>结合上面可能用到的一些定义，这行就可以翻译成</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">p-&gt;val.u2.next = *arData[nIndex]</span><br><span class="line">*arData[nIndex] = arData[idx]</span><br></pre></td></tr></table></figure><p>索引bucket指向新插入的元素，新插入的元素里阿米你的zval结构体里面的next指针再指向原先 索引bucket指向的位置，这样就把新插入的元素放在了冲突链表的头位置了</p><h1 id="扩展-遍历"><a href="#扩展-遍历" class="headerlink" title="扩展-遍历"></a>扩展-遍历</h1><p>根据上面的插入思路，可以很清晰的看到，数组在内存中是个有序的数组，hash表实现了位置的索引，zval的u2结构体帮助实现了 hash冲突的链表解决方案</p><p>如果此时去遍历数组，就只需要顺序遍历<code>arData</code>的右侧元素数据即可，还是有序的</p>]]></content>
      
      
      <categories>
          
          <category> PHP </category>
          
      </categories>
      
      
        <tags>
            
            <tag> PHP </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>深入PHP系列之PHP排序sort函数实现</title>
      <link href="/posts/30174/"/>
      <url>/posts/30174/</url>
      
        <content type="html"><![CDATA[<p>PHP的数组是个很强大的存在，而且使用PHP的数组的时候，只要你能想到，基本都已实现，所以也让我慢慢忘记了排序算法的存在。近期，有个人问我，PHP的sort函数是怎么实现的，尴尬，在重温了一遍算法之后，根据我大学依稀存在的C语言基础，尝试阅读了一下PHP的sort函数实现的源码，以下是以PHP7.3源码为例，个人技术水平有限，仅供参考</p><a id="more"></a><h1 id="sort"><a href="#sort" class="headerlink" title="sort"></a>sort</h1><blockquote><p>bool <strong>sort</strong>    ( array <code>&amp;$array</code>   [, int <code>$sort_flags</code> = SORT_REGULAR  ] )</p></blockquote><p>首先我们在 <code>php_srray.h</code> 中可以看到array 中 相关 排序函数的定义</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">PHP_FUNCTION(ksort);</span><br><span class="line">PHP_FUNCTION(krsort);</span><br><span class="line">PHP_FUNCTION(natsort);</span><br><span class="line">PHP_FUNCTION(natcasesort);</span><br><span class="line">PHP_FUNCTION(asort);</span><br><span class="line">PHP_FUNCTION(arsort);</span><br><span class="line">PHP_FUNCTION(sort);</span><br><span class="line">PHP_FUNCTION(rsort);</span><br><span class="line">PHP_FUNCTION(usort);</span><br><span class="line">....</span><br></pre></td></tr></table></figure><p>然后进入<code>array.c</code> 找到 <code>PHP_FUNCTION(sort)</code> 的实现</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">PHP_FUNCTION(sort)</span><br><span class="line">&#123;</span><br><span class="line">    zval *array;</span><br><span class="line">    zend_long sort_type = PHP_SORT_REGULAR;</span><br><span class="line">    compare_func_t cmp;</span><br><span class="line"></span><br><span class="line">    ZEND_PARSE_PARAMETERS_START(1, 2)</span><br><span class="line">        Z_PARAM_ARRAY_EX(array, 0, 1)</span><br><span class="line">        Z_PARAM_OPTIONAL</span><br><span class="line">        Z_PARAM_LONG(sort_type)</span><br><span class="line">    ZEND_PARSE_PARAMETERS_END_EX(RETURN_FALSE);</span><br><span class="line"></span><br><span class="line">    cmp = php_get_data_compare_func(sort_type, 0);</span><br><span class="line"></span><br><span class="line">    if (zend_hash_sort(Z_ARRVAL_P(array), cmp, 1) == FAILURE) &#123;</span><br><span class="line">        RETURN_FALSE;</span><br><span class="line">    &#125;</span><br><span class="line">    RETURN_TRUE;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ol><li><code>ZEND_PARSE_PARAMETERS_START</code>  <code>ZEND_PARSE_PARAMETERS_END_EX</code> ，在 <code>zend_api.h</code> 中有定义及实现， 主要是进行参数的校验转换等操作</li><li><code>php_get_data_compare_func</code> 设置比较函数， 也就是根据 sort_flag 来决定</li><li><code>zend_hash_sort</code> 这里开始了正式的排序</li></ol><h1 id="zend-hash-sort"><a href="#zend-hash-sort" class="headerlink" title="zend_hash_sort"></a>zend_hash_sort</h1><p>这个定义在 <code>zend_hash.h</code> 中</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">#define zend_hash_sort(ht, compare_func, renumber) \</span><br><span class="line">    zend_hash_sort_ex(ht, zend_sort, compare_func, renumber)</span><br></pre></td></tr></table></figure><p>这里将 <code>zend_hash_sort</code>  的方法转到了 <code>zend_hash_sort_ex</code> 的方法，接下来继续查看 <code>zend_hash_sort_ex</code> 即可</p><h1 id="zend-hash-sort-ex"><a href="#zend-hash-sort-ex" class="headerlink" title="zend_hash_sort_ex"></a>zend_hash_sort_ex</h1><p>这个定义在 <code>zend_hash.h</code> 中，在<code>zend_hash.c</code> 中实现</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br></pre></td><td class="code"><pre><span class="line">ZEND_API int ZEND_FASTCALL zend_hash_sort_ex(HashTable *ht, sort_func_t sort, compare_func_t compar, zend_bool renumber)</span><br><span class="line">&#123;</span><br><span class="line">    Bucket *p;</span><br><span class="line">    uint32_t i, j;</span><br><span class="line"></span><br><span class="line">    IS_CONSISTENT(ht);</span><br><span class="line">    HT_ASSERT_RC1(ht);</span><br><span class="line"></span><br><span class="line">    if (!(ht-&gt;nNumOfElements&gt;1) &amp;&amp; !(renumber &amp;&amp; ht-&gt;nNumOfElements&gt;0)) &#123; /* Doesn&apos;t require sorting */</span><br><span class="line">        return SUCCESS;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    if (HT_IS_WITHOUT_HOLES(ht)) &#123;</span><br><span class="line">        i = ht-&gt;nNumUsed;</span><br><span class="line">    &#125; else &#123;</span><br><span class="line">        for (j = 0, i = 0; j &lt; ht-&gt;nNumUsed; j++) &#123;</span><br><span class="line">            p = ht-&gt;arData + j;</span><br><span class="line">            if (UNEXPECTED(Z_TYPE(p-&gt;val) == IS_UNDEF)) continue;</span><br><span class="line">            if (i != j) &#123;</span><br><span class="line">                ht-&gt;arData[i] = *p;</span><br><span class="line">            &#125;</span><br><span class="line">            i++;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    sort((void *)ht-&gt;arData, i, sizeof(Bucket), compar,</span><br><span class="line">            (swap_func_t)(renumber? zend_hash_bucket_renum_swap :</span><br><span class="line">                ((HT_FLAGS(ht) &amp; HASH_FLAG_PACKED) ? zend_hash_bucket_packed_swap : zend_hash_bucket_swap)));</span><br><span class="line"></span><br><span class="line">    ht-&gt;nNumUsed = i;</span><br><span class="line">    ht-&gt;nInternalPointer = 0;</span><br><span class="line"></span><br><span class="line">    if (renumber) &#123;</span><br><span class="line">        for (j = 0; j &lt; i; j++) &#123;</span><br><span class="line">            p = ht-&gt;arData + j;</span><br><span class="line">            p-&gt;h = j;</span><br><span class="line">            if (p-&gt;key) &#123;</span><br><span class="line">                zend_string_release(p-&gt;key);</span><br><span class="line">                p-&gt;key = NULL;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        ht-&gt;nNextFreeElement = i;</span><br><span class="line">    &#125;</span><br><span class="line">    if (HT_FLAGS(ht) &amp; HASH_FLAG_PACKED) &#123;</span><br><span class="line">        if (!renumber) &#123;</span><br><span class="line">            zend_hash_packed_to_hash(ht);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; else &#123;</span><br><span class="line">        if (renumber) &#123;</span><br><span class="line">            void *new_data, *old_data = HT_GET_DATA_ADDR(ht);</span><br><span class="line">            Bucket *old_buckets = ht-&gt;arData;</span><br><span class="line"></span><br><span class="line">            new_data = pemalloc(HT_SIZE_EX(ht-&gt;nTableSize, HT_MIN_MASK), (GC_FLAGS(ht) &amp; IS_ARRAY_PERSISTENT));</span><br><span class="line">            HT_FLAGS(ht) |= HASH_FLAG_PACKED | HASH_FLAG_STATIC_KEYS;</span><br><span class="line">            ht-&gt;nTableMask = HT_MIN_MASK;</span><br><span class="line">            HT_SET_DATA_ADDR(ht, new_data);</span><br><span class="line">            memcpy(ht-&gt;arData, old_buckets, sizeof(Bucket) * ht-&gt;nNumUsed);</span><br><span class="line">            pefree(old_data, GC_FLAGS(ht) &amp; IS_ARRAY_PERSISTENT);</span><br><span class="line">            HT_HASH_RESET_PACKED(ht);</span><br><span class="line">        &#125; else &#123;</span><br><span class="line">            zend_hash_rehash(ht);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    return SUCCESS;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ol><li>第13行开始，判断这个hash表是否有空洞， 如果有的话，遍历整个hash表并填补空洞</li><li>使用sort方法来进行 这个hash表的排序， 这里的sort其实是个指针，由<code>zend_hash_sort_ex</code> 的第二个参数 <strong>sort_func_t sort</strong> 传递过来，根据上一部分 <code>zend_hash_sort</code> 的实现代码，可以看出，这里的sort，其实是指向了 <strong>zend_sort</strong> 这个方法</li><li>30行以后就是排序完成后的操作了，不是主要，就不多废话了</li></ol><h1 id="zend-sort"><a href="#zend-sort" class="headerlink" title="zend_sort"></a>zend_sort</h1><p>这个在<code>zend_sort.h</code>中定义，在 <code>zend_sort.c</code> 中实现</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br></pre></td><td class="code"><pre><span class="line">ZEND_API void zend_sort(void *base, size_t nmemb, size_t siz, compare_func_t cmp, swap_func_t swp)</span><br><span class="line">&#123;</span><br><span class="line">while (1) &#123;</span><br><span class="line">if (nmemb &lt;= 16) &#123;</span><br><span class="line">zend_insert_sort(base, nmemb, siz, cmp, swp);</span><br><span class="line">return;</span><br><span class="line">&#125; else &#123;</span><br><span class="line">char *i, *j;</span><br><span class="line">char *start = (char *)base;</span><br><span class="line">char *end = start + (nmemb * siz);</span><br><span class="line">size_t offset = (nmemb &gt;&gt; Z_L(1));</span><br><span class="line">char *pivot = start + (offset * siz);</span><br><span class="line"></span><br><span class="line">if ((nmemb &gt;&gt; Z_L(10))) &#123;</span><br><span class="line">size_t delta = (offset &gt;&gt; Z_L(1)) * siz;</span><br><span class="line">zend_sort_5(start, start + delta, pivot, pivot + delta, end - siz, cmp, swp);</span><br><span class="line">&#125; else &#123;</span><br><span class="line">zend_sort_3(start, pivot, end - siz, cmp, swp);</span><br><span class="line">&#125;</span><br><span class="line">swp(start + siz, pivot);</span><br><span class="line">pivot = start + siz;</span><br><span class="line">i = pivot + siz;</span><br><span class="line">j = end - siz;</span><br><span class="line">while (1) &#123;</span><br><span class="line">while (cmp(pivot, i) &gt; 0) &#123;</span><br><span class="line">i += siz;</span><br><span class="line">if (UNEXPECTED(i == j)) &#123;</span><br><span class="line">goto done;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">j -= siz;</span><br><span class="line">if (UNEXPECTED(j == i)) &#123;</span><br><span class="line">goto done;</span><br><span class="line">&#125;</span><br><span class="line">while (cmp(j, pivot) &gt; 0) &#123;</span><br><span class="line">j -= siz;</span><br><span class="line">if (UNEXPECTED(j == i)) &#123;</span><br><span class="line">goto done;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">swp(i, j);</span><br><span class="line">i += siz;</span><br><span class="line">if (UNEXPECTED(i == j)) &#123;</span><br><span class="line">goto done;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">done:</span><br><span class="line">swp(pivot, i - siz);</span><br><span class="line">if ((i - siz) - start &lt; end - i) &#123;</span><br><span class="line">zend_sort(start, (i - start)/siz - 1, siz, cmp, swp);</span><br><span class="line">base = i;</span><br><span class="line">nmemb = (end - i)/siz;</span><br><span class="line">&#125; else &#123;</span><br><span class="line">zend_sort(i, (end - i)/siz, siz, cmp, swp);</span><br><span class="line">nmemb = (i - start)/siz - 1;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ol><li>4-7行进行了判断， 如果元素总数 &lt;= 16 ，则进行插入排序，这是很正常的，因为插入排序在最好的情况下时O(n) 级的算法，而数据量小的情况下，数据有序的可能性就越高，也就符合了最好的情况</li><li>后面就是 如果元素总数  &gt; 16， 则开始了另外一种排序，首先确定了头元素和尾元素，并让元素总数右移一位作为基准， 这里涉及一个函数 <code>Z_L</code> ，后面做补充解释</li><li>继续判断 <code>nmemb &gt;&gt; Z_L(10)</code> 如果 元素总数 右移 10位，依然大于 0的话，选取的偏移数 再向右偏移 1位 作为 delta， 然后  <code>zend_sort_5(start, start + delta, pivot, pivot + delta, end - siz, cmp, swp);</code> 进行交换，否则 执行 <code>zend_sort_3(start, pivot, end - siz, cmp, swp);</code> 执行排序</li><li>下面就是标准的快速排序的操作思路了，只是一般我们会使用递归来处理，但是递归会消耗空间，所以 PHP源码里面选择了非递归的方式</li></ol><h1 id="Z-L"><a href="#Z-L" class="headerlink" title="Z_L"></a>Z_L</h1><p>这里在 <code>zend_long.h</code> 中有定义</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"># define Z_L(i) INT64_C(i)</span><br></pre></td></tr></table></figure><p>然后继续看 <code>INT64_C</code> </p><h1 id="INI64-C"><a href="#INI64-C" class="headerlink" title="INI64_C"></a>INI64_C</h1><p>这个在 <code>php_stdint.h</code> 中有定义</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">#ifndef INT64_C</span><br><span class="line"># if SIZEOF_INT &gt;= 8</span><br><span class="line">#  define INT64_C(c) c</span><br><span class="line"># elif SIZEOF_LONG &gt;= 8</span><br><span class="line">#  define INT64_C(c) c ## L</span><br><span class="line"># elif SIZEOF_LONG_LONG &gt;= 8</span><br><span class="line">#  define INT64_C(c) c ## LL</span><br><span class="line"># endif</span><br><span class="line">#endif</span><br></pre></td></tr></table></figure><h1 id="zend-sort-3"><a href="#zend-sort-3" class="headerlink" title="zend_sort_3"></a>zend_sort_3</h1><p>这个函数也是在 <code>zend_sort.c</code>中实现的，主要就是判断，然后交换</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">static inline void zend_sort_3(void *a, void *b, void *c, compare_func_t cmp, swap_func_t swp) /* &#123;&#123;&#123; */ &#123;</span><br><span class="line">if (!(cmp(a, b) &gt; 0)) &#123;</span><br><span class="line">if (!(cmp(b, c) &gt; 0)) &#123;</span><br><span class="line">return;</span><br><span class="line">&#125;</span><br><span class="line">swp(b, c);</span><br><span class="line">if (cmp(a, b) &gt; 0) &#123;</span><br><span class="line">swp(a, b);</span><br><span class="line">&#125;</span><br><span class="line">return;</span><br><span class="line">&#125;</span><br><span class="line">if (!(cmp(c, b) &gt; 0)) &#123;</span><br><span class="line">swp(a, c);</span><br><span class="line">return;</span><br><span class="line">&#125;</span><br><span class="line">swp(a, b);</span><br><span class="line">if (cmp(b, c) &gt; 0) &#123;</span><br><span class="line">swp(b, c);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><p>综上分析，php的sort函数在元素数 较小(16个及以下)的时候，使用插入排序，否则使用非递归的快速排序来进行排序。</p>]]></content>
      
      
      <categories>
          
          <category> PHP </category>
          
      </categories>
      
      
        <tags>
            
            <tag> PHP </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>深入PHP系列-变量分离与引用</title>
      <link href="/posts/47934/"/>
      <url>/posts/47934/</url>
      
        <content type="html"><![CDATA[<p>近期在看鸟哥的博客的时候，发现自己对PHP内核方面还真是一窍不通，就以PHP变量来说，一直都知道PHP变量是写时复制，但是真的去分析这个变量的refcount和is_ref的时候，又是一脸懵逼，学习道路漫漫，戒骄戒躁。</p><a id="more"></a><p>PHP7和PHP5的zval结构具有不同，这里分开来理解</p><h1 id="PHP5"><a href="#PHP5" class="headerlink" title="PHP5"></a>PHP5</h1><h2 id="zval结构"><a href="#zval结构" class="headerlink" title="zval结构"></a>zval结构</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">struct _zval_struct &#123;</span><br><span class="line">        /* Variable information */</span><br><span class="line">        zvalue_value value;             /* value */</span><br><span class="line">        zend_uint refcount;</span><br><span class="line">        zend_uchar type;        /* active type */</span><br><span class="line">        zend_uchar is_ref;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>一个变量在创建的时候创建了一个结构体，这个结构体里面的</p><ul><li><strong>value</strong> 代表的这个变量的值，</li></ul><ul><li><strong>refcount</strong>用于标识此zval被多少个变量引用，当值为0的时候会被销毁</li><li><strong>is_ref</strong>标识是不是用户使用 &amp; 的强制引用</li></ul><h3 id="赋值"><a href="#赋值" class="headerlink" title="赋值"></a>赋值</h3><p>我们以下面的代码为例</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">&lt;?php</span><br><span class="line">   $val = &apos;tyloafer&apos;;</span><br><span class="line">   $ref = $val;</span><br></pre></td></tr></table></figure><p>首先 第一行代码创建了一个变量，并申请了8个字节大小的内存，（这里暂不考虑结构体的其他占用）</p><p>第二行又创建了一个变量，与第一个变量 $val 相同，则此时是否应该占用16个字节呢</p><p>实际情况并不是这样的，这也就是 结构体中的 <strong>refcount</strong> 和 <strong>is_ref</strong> 的作用</p><p>我们使用 <code>xdebug_debug_zval</code> 调试一下变量</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">$val = &apos;tyloafer&apos;</span><br><span class="line">$val : val: (refcount=1, is_ref=0)=&apos;tyloafer&apos;</span><br><span class="line"></span><br><span class="line">$ref = $val</span><br><span class="line">$val : val: (refcount=2, is_ref=0)=&apos;tyloafer&apos;</span><br><span class="line">$ref : ref: (refcount=2, is_ref=0)=&apos;tyloafer&apos;</span><br></pre></td></tr></table></figure><p>这里并没有新申请一块内存，复制结构体，而是将原有的refcount 进行了 +1 操作，那如果此时对变量进行unset操作，其实就是对refcount 进行 -1 操作了</p><h3 id="引用赋值"><a href="#引用赋值" class="headerlink" title="引用赋值"></a>引用赋值</h3><p>在PHP里面，还有一种赋值方式，即引用赋值，我们以下面代码为例</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">&lt;?php</span><br><span class="line">   $val = &apos;tyloafer&apos;;</span><br><span class="line">   $ref = &amp;$val;</span><br></pre></td></tr></table></figure><p>调试变量结果</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">$val = &apos;tyloafer&apos;</span><br><span class="line">$val : val: (refcount=1, is_ref=0)=&apos;tyloafer&apos;</span><br><span class="line"></span><br><span class="line">$ref = &amp;$val</span><br><span class="line">$val : val: (refcount=2, is_ref=1)=&apos;tyloafer&apos;</span><br><span class="line">$ref : ref: (refcount=2, is_ref=1)=&apos;tyloafer&apos;</span><br></pre></td></tr></table></figure><p>这里不仅 <strong>refcount</strong> 进行了 +1 操作， <strong>is_ref</strong> 也进行了 +1 操作，因为我们这里使用了 <strong>&amp;</strong> 操作 </p><p>针对于 赋值 操作，val 和 ref 两个变量均是指向同一个 zval 结构体，当我们对 ref 进行修改的时候，这时候两个变量的值就会不一样</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">&lt;?php</span><br><span class="line">   $val = &apos;tyloafer&apos;;</span><br><span class="line">   $ref = $val;</span><br><span class="line">   $ref = 1;</span><br></pre></td></tr></table></figure><p>从而可以推断，当执行到 <code>$ref = 1</code> 的时候， ref 和 val 两个变量指向的就不是同一个 zval 结构体了，此时 debug 结果如下</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">$val = &apos;tyloafer&apos;</span><br><span class="line">$val : val: (refcount=1, is_ref=0)=&apos;tyloafer&apos;</span><br><span class="line"></span><br><span class="line">$ref = $val</span><br><span class="line">$val : val: (refcount=1, is_ref=0)=&apos;tyloafer&apos;</span><br><span class="line">$ref : ref: (refcount=1, is_ref=0)=1</span><br></pre></td></tr></table></figure><p>这个过程就被称作 写时复制 (Copy On Write)</p><h2 id="写时复制-Copy-On-Write"><a href="#写时复制-Copy-On-Write" class="headerlink" title="写时复制(Copy On Write)"></a>写时复制(Copy On Write)</h2><p>PHP在修改一个变量以前，会首先查看这个变量的refcount，如果refcount大于1，PHP就会执行一个分离的例程。这个机制就是所谓的copy on write(写时复制)。</p><p>其中赋值函数如下</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br></pre></td><td class="code"><pre><span class="line">static inline zval* zend_assign_to_variable(zval **variable_ptr_ptr, zval *value TSRMLS_DC)</span><br><span class="line">&#123;</span><br><span class="line">zval *variable_ptr = *variable_ptr_ptr;</span><br><span class="line">zval garbage;</span><br><span class="line"></span><br><span class="line">if (Z_TYPE_P(variable_ptr) == IS_OBJECT &amp;&amp;</span><br><span class="line">    UNEXPECTED(Z_OBJ_HANDLER_P(variable_ptr, set) != NULL)) &#123;</span><br><span class="line">Z_OBJ_HANDLER_P(variable_ptr, set)(variable_ptr_ptr, value TSRMLS_CC);</span><br><span class="line">return variable_ptr;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"> if (EXPECTED(!PZVAL_IS_REF(variable_ptr))) &#123;  // 非引用赋值逻辑</span><br><span class="line">if (Z_REFCOUNT_P(variable_ptr)==1) &#123;</span><br><span class="line">if (UNEXPECTED(variable_ptr == value)) &#123;</span><br><span class="line">return variable_ptr;</span><br><span class="line">&#125; else if (EXPECTED(!PZVAL_IS_REF(value))) &#123;</span><br><span class="line">Z_ADDREF_P(value);</span><br><span class="line">*variable_ptr_ptr = value;</span><br><span class="line">ZEND_ASSERT(variable_ptr != &amp;EG(uninitialized_zval));</span><br><span class="line">GC_REMOVE_ZVAL_FROM_BUFFER(variable_ptr);</span><br><span class="line">zval_dtor(variable_ptr);</span><br><span class="line">efree(variable_ptr);</span><br><span class="line">return value;</span><br><span class="line">&#125; else &#123;</span><br><span class="line">goto copy_value;</span><br><span class="line">&#125;</span><br><span class="line">&#125; else &#123; /* we need to split */  // 这里是引用的相关赋值逻辑</span><br><span class="line">Z_DELREF_P(variable_ptr);</span><br><span class="line">GC_ZVAL_CHECK_POSSIBLE_ROOT(variable_ptr);</span><br><span class="line">if (PZVAL_IS_REF(value)) &#123;</span><br><span class="line">ALLOC_ZVAL(variable_ptr);</span><br><span class="line">*variable_ptr_ptr = variable_ptr;</span><br><span class="line">INIT_PZVAL_COPY(variable_ptr, value);</span><br><span class="line">zval_copy_ctor(variable_ptr);</span><br><span class="line">return variable_ptr;</span><br><span class="line">&#125; else &#123;</span><br><span class="line">*variable_ptr_ptr = value;</span><br><span class="line">Z_ADDREF_P(value);</span><br><span class="line">return value;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"> &#125; else &#123;</span><br><span class="line">if (EXPECTED(variable_ptr != value)) &#123;</span><br><span class="line">copy_value:</span><br><span class="line">if (EXPECTED(Z_TYPE_P(variable_ptr) &lt;= IS_BOOL)) &#123;</span><br><span class="line">/* nothing to destroy */</span><br><span class="line">ZVAL_COPY_VALUE(variable_ptr, value);</span><br><span class="line">zendi_zval_copy_ctor(*variable_ptr);</span><br><span class="line">&#125; else &#123;</span><br><span class="line">ZVAL_COPY_VALUE(&amp;garbage, variable_ptr);</span><br><span class="line">ZVAL_COPY_VALUE(variable_ptr, value);</span><br><span class="line">zendi_zval_copy_ctor(*variable_ptr);</span><br><span class="line">_zval_dtor_func(&amp;garbage ZEND_FILE_LINE_CC);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">return variable_ptr;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这里的<code>EXPECTED(var)</code> 就相当于 <code>val == 1</code></p><p>我们根据这个特性，做一下 下面的代码的分析</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">&lt;?php</span><br><span class="line">    $val = &apos;tyloafer&apos;;</span><br><span class="line">    $ref = &amp;$val;</span><br><span class="line">    $copy = $val;</span><br><span class="line">    $copy = &apos;1111&apos;;</span><br></pre></td></tr></table></figure><p>首先代码执行到第一行 <code>$val = &#39;tyloafer&#39;;</code> ， 这时候 PHP会创建一个zval结构体，此时他的值应该是 </p><blockquote><p> refcount = 1, is_ref = 0</p></blockquote><p>执行到第二行的时候，根据上面结果可以知道 </p><blockquote><p>$val : val: (refcount=2, is_ref=1)=’tyloafer’<br>$ref : ref: (refcount=2, is_ref=1)=’tyloafer’</p></blockquote><p>接下来执行第三行，此时val 的 refcount = 2， is_ref = 1， 满足了<strong>写时复制</strong>的条件， 但是这里是使用val 的变量，赋值给新的变量，是否会 触发 <strong>COW</strong> 呢，其实是会触发的，我们照此思路处理下去的话</p><p>如果这个脚本就 <code>$copy = $val;</code> 一行的话， 这两个变量 val copy 是会共用一个 结构体的，但是此时 val 结构满足了 分离的条件，所以 这两个变量就需要进行分离，也就是 copy 不能共用 val 的结构体 分离出去，但是原先的 val 和 ref 没有修改， 所以不会触发分离的条件，所以 此时的结果就是</p><blockquote><p>$val : val: (refcount=2, is_ref=1)=’tyloafer’<br>$ref : ref: (refcount=2, is_ref=1)=’tyloafer’<br>$copy : copy: (refcount=1, is_ref=0)=’tyloafer’</p></blockquote><p>最后一步， <code>$copy = 111;</code>  ，此时的copy 已经分离出来了，是个独立的结构体，也不满足分离条件，直接修改 结构体里面的 value即可</p><blockquote><p>$copy : copy: (refcount=1, is_ref=0)=’1111’<br>$val : val: (refcount=2, is_ref=1)=’tyloafer’</p></blockquote><h3 id="经典性能问题"><a href="#经典性能问题" class="headerlink" title="经典性能问题"></a>经典性能问题</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line">&lt;?php</span><br><span class="line"></span><br><span class="line">$array = range(1, 100000);</span><br><span class="line">function dummy($array) &#123;&#125;</span><br><span class="line"></span><br><span class="line">function test(&amp;$arr)</span><br><span class="line">&#123;</span><br><span class="line">    dummy($arr);</span><br><span class="line">&#125;</span><br><span class="line">function test1($arr)</span><br><span class="line">&#123;</span><br><span class="line">    dummy($arr);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">$array = range(1, 100000);</span><br><span class="line">$start = microtime(true);</span><br><span class="line">$i     = 0;</span><br><span class="line">while ($i++ &lt; 100) &#123;</span><br><span class="line">    test1($array);</span><br><span class="line">&#125;</span><br><span class="line">printf(&quot;Used %s s\n&quot;, microtime(true) - $start);</span><br><span class="line"></span><br><span class="line">$start = microtime(true);</span><br><span class="line">$i     = 0;</span><br><span class="line">while ($i++ &lt; 100) &#123;</span><br><span class="line">    test($array);</span><br><span class="line">&#125;</span><br><span class="line">printf(&quot;Used %s s\n&quot;, microtime(true) - $start);</span><br></pre></td></tr></table></figure><p>鸟哥的博客里，针对这个写个一个比较简单的例子，但是我感觉用的最多的场景还是 函数套函数 的场景，所以自己修改了一下 案例</p><p>输出结果：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">引用传值共消耗： 1.7663018703461 s</span><br><span class="line">传值共消耗： 0.00076103210449219 s</span><br></pre></td></tr></table></figure><p>根据 <code>zend_assign_to_variable</code> 的函数逻辑及上面的分析，就可以看出来是因为复发了 分离 的操作，所以会 拷贝 $i 次数组，这个问题在PHP7的时候已经做了修改。</p><h1 id="PHP7"><a href="#PHP7" class="headerlink" title="PHP7"></a>PHP7</h1><h2 id="zval结构-1"><a href="#zval结构-1" class="headerlink" title="zval结构"></a>zval结构</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line">struct _zval_struct &#123;</span><br><span class="line">     union &#123;</span><br><span class="line">          zend_long         lval;             /* long value */</span><br><span class="line">          double            dval;             /* double value */</span><br><span class="line">          zend_refcounted  *counted;</span><br><span class="line">          zend_string      *str;</span><br><span class="line">          zend_array       *arr;</span><br><span class="line">          zend_object      *obj;</span><br><span class="line">          zend_resource    *res;</span><br><span class="line">          zend_reference   *ref;</span><br><span class="line">          zend_ast_ref     *ast;</span><br><span class="line">          zval             *zv;</span><br><span class="line">          void             *ptr;</span><br><span class="line">          zend_class_entry *ce;</span><br><span class="line">          zend_function    *func;</span><br><span class="line">          struct &#123;</span><br><span class="line">               uint32_t w1;</span><br><span class="line">               uint32_t w2;</span><br><span class="line">          &#125; ww;</span><br><span class="line">     &#125; value;</span><br><span class="line">    union &#123;</span><br><span class="line">        struct &#123;</span><br><span class="line">            ZEND_ENDIAN_LOHI_4(</span><br><span class="line">                zend_uchar    type,         /* active type */</span><br><span class="line">                zend_uchar    type_flags,</span><br><span class="line">                zend_uchar    const_flags,</span><br><span class="line">                zend_uchar    reserved)     /* call info for EX(This) */</span><br><span class="line">        &#125; v;</span><br><span class="line">        uint32_t type_info;</span><br><span class="line">    &#125; u1;</span><br><span class="line">    union &#123;</span><br><span class="line">        uint32_t     var_flags;</span><br><span class="line">        uint32_t     next;                 /* hash collision chain */</span><br><span class="line">        uint32_t     cache_slot;           /* literal cache slot */</span><br><span class="line">        uint32_t     lineno;               /* line number (for ast nodes) */</span><br><span class="line">        uint32_t     num_args;             /* arguments number for EX(This) */</span><br><span class="line">        uint32_t     fe_pos;               /* foreach position */</span><br><span class="line">        uint32_t     fe_iter_idx;          /* foreach iterator index */</span><br><span class="line">    &#125; u2;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>而引用计数部分保存在 <code>zend_refcounted_h</code> 的结构体中</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">typedef struct _zend_refcounted_h &#123;</span><br><span class="line">    uint32_t         refcount;          /* reference counter 32-bit */</span><br><span class="line">    union &#123;</span><br><span class="line">        struct &#123;</span><br><span class="line">            ZEND_ENDIAN_LOHI_3(</span><br><span class="line">                zend_uchar    type,</span><br><span class="line">                zend_uchar    flags,    /* used for strings &amp; objects */</span><br><span class="line">                uint16_t      gc_info)  /* keeps GC root number (or 0) and color */</span><br><span class="line">        &#125; v;</span><br><span class="line">        uint32_t type_info;</span><br><span class="line">    &#125; u;</span><br><span class="line">&#125; zend_refcounted_h;</span><br></pre></td></tr></table></figure><p>也即如图所示</p><p><img src="https://github-1253518569.cos.ap-shanghai.myqcloud.com/zval1.png" alt="https://github-1253518569.cos.ap-shanghai.myqcloud.com/zval1.png"></p><h2 id="写时改变-Change-On-Write"><a href="#写时改变-Change-On-Write" class="headerlink" title="写时改变(Change On Write)"></a>写时改变(Change On Write)</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">&lt;?php</span><br><span class="line">$val = &quot;laruence&quot;;</span><br><span class="line">$ref = &amp;$val;</span><br><span class="line">$copy = $val;</span><br></pre></td></tr></table></figure><p>以上面代码为例</p><p>当代码执行到第二行 <code>$ref = &amp;$val;</code> 的时候， 生成一个 IS_REFERNCE 类型，然后因为此时有俩个变量引用它所以zend_reference这个结构的引用计数zval.value.ref-&gt;gc.refcount为2.</p><p>当代码执行到 <code>$copy = $val;</code> 的时候， 发现 <code>$val</code> 是一个引用， 于是，直接让 <code>$copy</code> 指向的是zval.value.ref-&gt;val, 也就是字符串值为laruence的zval, 然后把zval的引用计数+1, 也就是zval.value.ref-&gt;val.value.str.gc.refcount为2. 并没有产生复制.</p><p>xdebug结果</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">$val = &apos;laruence&apos;</span><br><span class="line">$val : val: (refcount=0, is_ref=0)=&apos;laruence&apos;</span><br><span class="line">$ref = &amp;$val</span><br><span class="line">$val : val: (refcount=2, is_ref=1)=&apos;laruence&apos;</span><br><span class="line">$ref : ref: (refcount=2, is_ref=1)=&apos;laruence&apos;</span><br><span class="line">$copy = $val</span><br><span class="line">$val : val: (refcount=2, is_ref=1)=&apos;laruence&apos;</span><br><span class="line">$ref : ref: (refcount=2, is_ref=1)=&apos;laruence&apos;</span><br><span class="line">$copy : copy: (refcount=0, is_ref=0)=&apos;laruence&apos;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> PHP </category>
          
      </categories>
      
      
        <tags>
            
            <tag> PHP </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>PHP实现基于Swoole的MySQL连接池</title>
      <link href="/posts/55187/"/>
      <url>/posts/55187/</url>
      
        <content type="html"><![CDATA[<p>对于共享资源，有一个很著名的设计模式：资源池（Resource Pool）。该模式正是为了解决资源的频繁分配﹑释放所造成的问题。数据库连接池的基本思想就是为数据库连接建立一个“池”子，在使用的时候，从“池子”中获取资源，用完后将连接放回“池子”，减少了数据库连接建立与释放造成的损耗。</p><a id="more"></a><p>而对于PHP而言，每一个请求过来都是由php-fpm调起来一个cgi来处理，处理完后就会被释放，所以并没办法在代码中实现连接池的，但是由运行方式，我们可以自然而然的推想，既然php-fpm是常驻内存的，那我们将数据库连接交给php-fpm托管，也就实现了理论上的数据库连接池，而这种实现方式也就是MySQL的<strong>pconnect</strong>的实现方式，而且经测试，效果并没有显著的提升。那么，接下来便可以考虑基于<strong>Swoole</strong>的常驻内存的特性来帮忙实现了</p><h1 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h1><ol><li>首先基于Swoole的channel实现一个<strong>内存队列</strong> <strong>quene</strong>，（也可以通过php的共享内存实现，这里不讨论这种方式），用于存放MySQL连接的线程id，<strong>thread_id</strong></li><li>建立一定数量的MySQL连接存放在数组中，然后将 <strong>thread_id</strong>（mysqli::$thread_id）推进<strong>内存队列</strong> <strong>quene</strong>,</li><li>每个请求过来的时候，从<strong>quene</strong>中 pop 出一个 <strong>thread_id</strong>， 根据<strong>thread_id</strong>找到对应数组中对应的数据库连接</li><li>请求结束后，将<strong>thread_id</strong>再push进<strong>quene</strong></li></ol><h1 id="代码实现"><a href="#代码实现" class="headerlink" title="代码实现"></a>代码实现</h1><h2 id="数据库连接管理者"><a href="#数据库连接管理者" class="headerlink" title="数据库连接管理者"></a>数据库连接管理者</h2><blockquote><p>这个类是用来管理连接的，增加和删除以及获取链接使用</p></blockquote><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br></pre></td><td class="code"><pre><span class="line">class MysqlConnections &#123;</span><br><span class="line">    private $config = [</span><br><span class="line">        &apos;host&apos; =&gt; &apos;127.0.0.1&apos;,</span><br><span class="line">        &apos;username&apos; =&gt; &apos;root&apos;,</span><br><span class="line">        &apos;password&apos; =&gt; &apos;ifind@13579&apos;,</span><br><span class="line">        &apos;dbname&apos; =&gt; &apos;test&apos;,</span><br><span class="line">        &apos;charset&apos; =&gt; &apos;utf8&apos;,</span><br><span class="line">    ];</span><br><span class="line">    private $connectionsNum = 0;</span><br><span class="line"></span><br><span class="line">    private $connections = [];</span><br><span class="line">    function __construct($config = []) &#123;</span><br><span class="line">        $this-&gt;config = array_merge($this-&gt;config, $config);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    /**</span><br><span class="line">     * 增加一个mysql连接到连接池</span><br><span class="line">     */</span><br><span class="line">    public function addConnection()</span><br><span class="line">    &#123;</span><br><span class="line">        $mysql = new Mysqli($this-&gt;config[&apos;host&apos;], $this-&gt;config[&apos;username&apos;], $this-&gt;config[&apos;password&apos;], $this-&gt;config[&apos;dbname&apos;]);</span><br><span class="line">        $this-&gt;connections[$mysql-&gt;thread_id] = $mysql;</span><br><span class="line">        echo &apos;add &apos; . $mysql-&gt;thread_id . &apos; into pool &apos; . PHP_EOL;</span><br><span class="line">        $this-&gt;connectionsNum ++;</span><br><span class="line">        return $mysql-&gt;thread_id;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public function getConnection($id = 0)</span><br><span class="line">    &#123;</span><br><span class="line">        if ($id == 0) &#123;</span><br><span class="line">            $id = $this-&gt;addConnection();</span><br><span class="line">        &#125;</span><br><span class="line">        return $this-&gt;connections[$id];</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public function releaseConnection($id)</span><br><span class="line">    &#123;</span><br><span class="line">        $this-&gt;connectionsNum--;</span><br><span class="line">        unset($this-&gt;connections[$id]);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public function __get($name)</span><br><span class="line">    &#123;</span><br><span class="line">        if ($name == &apos;connectionsNum&apos;) &#123;</span><br><span class="line">            return $this-&gt;connectionsNum;</span><br><span class="line">        &#125; else &#123;</span><br><span class="line">            return null;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="内存队列"><a href="#内存队列" class="headerlink" title="内存队列"></a>内存队列</h2><blockquote><p>这里是以数据库连接属性的thread_id 组成的内存队列</p></blockquote><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><span class="line">class Quene &#123;</span><br><span class="line">    private $length; // 队长</span><br><span class="line">    private $size;</span><br><span class="line"></span><br><span class="line">    private $chan;</span><br><span class="line">    /**</span><br><span class="line">     * 构造函数</span><br><span class="line">     */</span><br><span class="line">    public function __construct($size = 64 * 1024) </span><br><span class="line">    &#123;</span><br><span class="line">        $this-&gt;chan = new \Swoole\Channel($size);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    /**</span><br><span class="line">     * 入队操作</span><br><span class="line">     * @param  [type] $id [description]</span><br><span class="line">     * @return [type]     [description]</span><br><span class="line">     */</span><br><span class="line">    public function push($id)</span><br><span class="line">    &#123;</span><br><span class="line">        $this-&gt;length ++;</span><br><span class="line">        $this-&gt;chan-&gt;push($id);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    /**</span><br><span class="line">     * 出队操作</span><br><span class="line">     * @return [type] [description]</span><br><span class="line">     */</span><br><span class="line">    public function pop()</span><br><span class="line">    &#123;</span><br><span class="line">        $this-&gt;length --;</span><br><span class="line">        $id = $this-&gt;chanpop();</span><br><span class="line">        return $id;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public function __get($name)</span><br><span class="line">    &#123;</span><br><span class="line">        if ($name == &apos;length&apos;) &#123;</span><br><span class="line">            return $this-&gt;length;</span><br><span class="line">        &#125; else &#123;</span><br><span class="line">            return null;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="数据库连接池"><a href="#数据库连接池" class="headerlink" title="数据库连接池"></a>数据库连接池</h2><blockquote><p>结合上面的连接管理者和队列，实现对连接的分发和归还</p></blockquote><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br></pre></td><td class="code"><pre><span class="line">class DbPool &#123;</span><br><span class="line">    private $max; // 最大的mysql连接数</span><br><span class="line">    private $min = 0; // 建立最小的mysql连接数</span><br><span class="line">    private $connections;</span><br><span class="line">    private $quene;</span><br><span class="line"></span><br><span class="line">    public function __construct($max, $min = 0)</span><br><span class="line">    &#123;</span><br><span class="line">        if (!empty($max)) &#123;</span><br><span class="line">            $this-&gt;max = $max;</span><br><span class="line">        &#125; else &#123;</span><br><span class="line">            throw new Exception(&apos;please set max connnections&apos;, &apos;-1&apos;);</span><br><span class="line">        &#125;</span><br><span class="line">        $this-&gt;min = $min;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public function setConnection(MysqlConnections $connections)</span><br><span class="line">    &#123;</span><br><span class="line">        $this-&gt;connections = $connections;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public function setQuene(Quene $quene)</span><br><span class="line">    &#123;</span><br><span class="line">        $this-&gt;quene = $quene;</span><br><span class="line">        $this-&gt;initQuene();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public function initQuene($min = 0, $max = 0)</span><br><span class="line">    &#123;</span><br><span class="line">        for ($i = 0; $i &lt; $this-&gt;min; $i++) &#123;</span><br><span class="line">            $this-&gt;quene-&gt;push($this-&gt;connections-&gt;addConnection());</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public function obtain()</span><br><span class="line">    &#123;</span><br><span class="line">        if ($this-&gt;connections-&gt;connectionsNum &gt;= $this-&gt;max) &#123;</span><br><span class="line">            // 超出链接最大限制，等待mysql链接释放</span><br><span class="line">            $id = !$this-&gt;quene-&gt;pop();</span><br><span class="line">            while (!$id) &#123;</span><br><span class="line">                usleep(200000);</span><br><span class="line">                $id = $this-&gt;quene-&gt;pop();</span><br><span class="line">            &#125;</span><br><span class="line">            return $this-&gt;connections-&gt;getConnection($id);</span><br><span class="line">        &#125; else &#123;</span><br><span class="line">            $id = $this-&gt;quene-&gt;pop();</span><br><span class="line">            return $this-&gt;connections-&gt;getConnection($id);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public function restitute(Mysqli $db)</span><br><span class="line">    &#123;</span><br><span class="line">        echo &apos;restitute thread_id : &apos; . $db-&gt;thread_id . PHP_EOL;</span><br><span class="line">        $this-&gt;quene-&gt;push($db-&gt;thread_id);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="Swoole-Http-Server"><a href="#Swoole-Http-Server" class="headerlink" title="Swoole Http Server"></a>Swoole Http Server</h2><blockquote><p>基于swoole开启一个http server，获取相应的数据库连接，并相应</p></blockquote><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">class SwooleServer</span><br><span class="line">&#123;</span><br><span class="line">    private $config = [</span><br><span class="line">        &apos;Connections&apos; =&gt; [</span><br><span class="line">            &apos;min&apos; =&gt; 5,</span><br><span class="line">            &apos;max&apos; =&gt; 10,</span><br><span class="line">        ],</span><br><span class="line">        &apos;Db&apos; =&gt; [</span><br><span class="line">            &apos;host&apos; =&gt; &apos;127.0.0.1&apos;,</span><br><span class="line">            &apos;username&apos; =&gt; &apos;test&apos;,</span><br><span class="line">            &apos;password&apos; =&gt; &apos;123456&apos;,</span><br><span class="line">            &apos;dbname&apos; =&gt; &apos;test&apos;,</span><br><span class="line">            &apos;charset&apos; =&gt; &apos;utf8&apos;,</span><br><span class="line">        ],</span><br><span class="line">        &apos;Swoole&apos; =&gt; [</span><br><span class="line">            &apos;enable_static_handler&apos; =&gt; true,</span><br><span class="line">            &apos;document_root&apos; =&gt; &quot;/home/lixy/basic/web/&quot;,</span><br><span class="line">            &apos;worker_num&apos; =&gt; 5,</span><br><span class="line">            &apos;task_worker_num&apos; =&gt; 5,</span><br><span class="line">            &apos;log_level&apos; =&gt; 3,</span><br><span class="line">        ],</span><br><span class="line">        &apos;Channel&apos; =&gt; [</span><br><span class="line">            &apos;size&apos; =&gt; 256 * 1024,</span><br><span class="line">        ],</span><br><span class="line">    ];</span><br><span class="line">    private $db_pool;   // mysql链接内存队列</span><br><span class="line">    public function __construct()</span><br><span class="line">    &#123;</span><br><span class="line">        $this-&gt;swoole = new \Swoole\Http\Server(&apos;0.0.0.0&apos;, 9502);</span><br><span class="line">        $this-&gt;swoole-&gt;set($this-&gt;config[&apos;Swoole&apos;]);</span><br><span class="line">        $this-&gt;swoole-&gt;on(&apos;task&apos;, [$this, &apos;task&apos;]);</span><br><span class="line">        $this-&gt;swoole-&gt;on(&apos;finish&apos;, [$this, &apos;finish&apos;]);</span><br><span class="line">        $this-&gt;swoole-&gt;on(&apos;request&apos;, [$this, &apos;request&apos;]);</span><br><span class="line">        $this-&gt;getDbPool();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public function getDbPool()</span><br><span class="line">    &#123;</span><br><span class="line">        $connections = new MysqlConnections($this-&gt;config[&apos;Db&apos;]);</span><br><span class="line">        $quene = new Quene();</span><br><span class="line">        $this-&gt;db_pool = new DbPool($this-&gt;config[&apos;Connections&apos;][&apos;max&apos;], $this-&gt;config[&apos;Connections&apos;][&apos;min&apos;]);</span><br><span class="line">        $this-&gt;db_pool-&gt;setConnection($connections);</span><br><span class="line">        $this-&gt;db_pool-&gt;setQuene($quene);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public function __call($name, $args)</span><br><span class="line">    &#123;</span><br><span class="line">        return call_user_func_array([$this-&gt;swoole, $name], $args);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    /**</span><br><span class="line">     * onrequest事件</span><br><span class="line">     * @param  [type] $request  请求对象</span><br><span class="line">     * @param  [type] $response 相应对象</span><br><span class="line">     * @return [type]</span><br><span class="line">     */</span><br><span class="line">    public function request($request, $response)</span><br><span class="line">    &#123;</span><br><span class="line">        $db = $this-&gt;db_pool-&gt;obtain();</span><br><span class="line">        echo &apos;get thread id : &apos; . $db-&gt;thread_id . PHP_EOL;</span><br><span class="line">        $sql = &apos;select * from test&apos;;</span><br><span class="line">        $result = $db-&gt;query($sql);</span><br><span class="line">        $this-&gt;db_pool-&gt;restitute($db);</span><br><span class="line">        $response-&gt;end(&apos;hello, response from swoole server&apos;);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public function task($serv, $task_id, $from_id, $data)</span><br><span class="line">    &#123;</span><br><span class="line">        echo $task_id;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public function finish($serv, $task_id, $data)</span><br><span class="line">    &#123;</span><br><span class="line">        echo $task_id;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">$swoole_index = new SwooleServer();</span><br><span class="line">$swoole_index-&gt;start();</span><br></pre></td></tr></table></figure><h1 id="测试"><a href="#测试" class="headerlink" title="测试"></a>测试</h1><blockquote><p>ab -n 10 -c 5 <a href="http://127.0.0.1:9502/" target="_blank" rel="noopener">http://127.0.0.1:9502/</a></p></blockquote><p>结果</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line">add 6879 into pool </span><br><span class="line">add 6880 into pool </span><br><span class="line">add 6881 into pool </span><br><span class="line">add 6882 into pool </span><br><span class="line">add 6883 into pool </span><br><span class="line"></span><br><span class="line">get thread id : 6879</span><br><span class="line">restitute thread_id : 6879</span><br><span class="line">get thread id : 6880</span><br><span class="line">get thread id : 6881</span><br><span class="line">restitute thread_id : 6880</span><br><span class="line">get thread id : 6882</span><br><span class="line">restitute thread_id : 6881</span><br><span class="line">restitute thread_id : 6882</span><br><span class="line">get thread id : 6883</span><br><span class="line">get thread id : 6879</span><br><span class="line">restitute thread_id : 6879</span><br><span class="line">get thread id : 6881</span><br><span class="line">get thread id : 6880</span><br><span class="line">restitute thread_id : 6881</span><br><span class="line">restitute thread_id : 6880</span><br><span class="line">restitute thread_id : 6883</span><br><span class="line">get thread id : 6882</span><br><span class="line">get thread id : 6879</span><br><span class="line">restitute thread_id : 6882</span><br><span class="line">restitute thread_id : 6879</span><br><span class="line">get thread id : 6881</span><br><span class="line">restitute thread_id : 6881</span><br></pre></td></tr></table></figure><p>完美符合预期</p>]]></content>
      
      
      <categories>
          
          <category> PHP </category>
          
      </categories>
      
      
        <tags>
            
            <tag> PHP </tag>
            
            <tag> Swoole </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>MyISAM与InnoDB性能测试对比</title>
      <link href="/posts/51443/"/>
      <url>/posts/51443/</url>
      
        <content type="html"><![CDATA[<p>MyISAM与InnoDB的优缺点在此就不再多说了，网上可以搜出一堆，而这种文章的最后一般都是推荐，读的多的使用MyISAM，写与更新多的推荐InnoDB，但是，了解过两种存储引擎之后，就会产生一种疑惑，InnoDB采用的是聚簇索引，无论是索引还是数据都是存放在内存中的，MyISAM引擎使用B+Tree作为索引结构，叶节点的data域存放的是数据记录的地址，找到了之后还要到硬盘上去获取数据，这样肯定会造成时间损耗的，所以，还是准备用实验数据来解决疑惑</p><a id="more"></a><p>我的MySQL的版本是 5.7.22， 服务器是1G1核</p><h1 id="单进程写"><a href="#单进程写" class="headerlink" title="单进程写"></a>单进程写</h1><blockquote><p>commit = 0 表示 my.cnf 中 <strong>innodb_flush_log_at_trx_commit</strong> 的属性值为0</p><p>no index  表示除主键索引为无其他索引 这里有四个索引</p><p>index 表示只有主键索引</p></blockquote><table><thead><tr><th>数据（w）</th><th>MyISAM (index)</th><th>MyISAM  (no index)</th><th>InnoDB (commit=0) (index)</th><th>InnoDB (commit=0) (no index)</th></tr></thead><tbody><tr><td>1</td><td>6.39</td><td>3.90</td><td>4.99</td><td>4.89</td></tr><tr><td>5</td><td>26.89</td><td>22.73</td><td>29.80</td><td>22.33</td></tr><tr><td>10</td><td>49.55</td><td>34.96</td><td>53.40</td><td>33.21</td></tr><tr><td>50</td><td>189.20</td><td>139.93</td><td>260.78</td><td>200.74</td></tr></tbody></table><p>综上可以看出，单进程一条一条的插入的时间，MyISAM的性能略占优势，但是并不太明显， 而无索引比有索引的又略占优势，这也是因为插入的时候同时还要注意维护索引树导致的，所以，索引虽好，可不要太贪了。</p><table><thead><tr><th>数据（w）</th><th>MyISAM (index)</th><th>MyISAM  (no index)</th><th>InnoDB (commit=0) (index)</th><th>InnoDB (commit=0) (no index)</th></tr></thead><tbody><tr><td>1</td><td>9.70</td><td>4.91</td><td>60.9</td><td>49.8</td></tr><tr><td>5</td><td>32.01</td><td>18.33</td><td>306.55</td><td>243.17</td></tr></tbody></table><p>还有10w和50w的数据就不再比较了，因为性能差距太明显了，那这里就有一个问题了， <strong>innodb_flush_log_at_trx_commit</strong>  这个参数是什么意思，为什么会有那么大的影响</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">innodb_flush_log_at_trx_commit=0 （延迟写、实时刷）：log_buffer --每隔1秒--&gt; log_file --实时--&gt; disk</span><br><span class="line">innodb_flush_log_at_trx_commit=1 （实时写、实时刷）：log_buffer --实时--&gt; log_file --实时--&gt; disk</span><br><span class="line">innodb_flush_log_at_trx_commit=2 （实时写、延迟刷）：log_buffer --实时--&gt; log_file --每隔1秒 --&gt; disk</span><br></pre></td></tr></table></figure><p>所以，这里其实是刷日志到硬盘导致的性能下降，这里还是需要注意的，性能影响还是很大的</p><h1 id="多进程写"><a href="#多进程写" class="headerlink" title="多进程写"></a>多进程写</h1><p>这里以每个进程写1w条数据为例</p><table><thead><tr><th>进程数</th><th>MyISAM(s/进程)</th><th>InnoDB(s/进程)</th></tr></thead><tbody><tr><td>20</td><td>90.00</td><td>29.66</td></tr><tr><td>50</td><td>255.89</td><td>74.52</td></tr><tr><td>100</td><td>545.385</td><td>201.94</td></tr></tbody></table><p>上面充分可以展示出来<strong>InnoDB</strong> 引擎在多进程下的优势</p><h1 id="单进程读"><a href="#单进程读" class="headerlink" title="单进程读"></a>单进程读</h1><table><thead><tr><th>总次数(w)</th><th>MyISAM(总时间 s)</th><th>InnoDB(总时间 s)</th></tr></thead><tbody><tr><td>1</td><td>67.14</td><td>77.15</td></tr><tr><td>5</td><td>110.58</td><td>104.21</td></tr><tr><td>10</td><td>136.02</td><td>146.26</td></tr></tbody></table><h1 id="多进程读"><a href="#多进程读" class="headerlink" title="多进程读"></a>多进程读</h1><p>这里以每个进程读5k条数据为例</p><table><thead><tr><th>进程数</th><th>MyISAM(s/进程)</th><th>InnoDB(s/进程)</th></tr></thead><tbody><tr><td>20</td><td>140.89</td><td>140.37</td></tr><tr><td>50</td><td>366.32</td><td>308.76</td></tr><tr><td>100</td><td>766.37</td><td>615.50</td></tr></tbody></table><p>可以看出，在单进程的读中，MyISAM战友微弱的优势，但这种微弱的优势在多进程中也荡然无存了</p><p>再考虑<strong>InnoDB</strong> 支持 <strong>事务</strong>， <strong>外键</strong>， <strong>崩溃恢复</strong> 一系列高级特性，还有什么犹豫的吗？</p>]]></content>
      
      
      <categories>
          
          <category> MySQL </category>
          
      </categories>
      
      
        <tags>
            
            <tag> MySQL </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Nginx倒腾笔记（七）：Nginx限制访问频率</title>
      <link href="/posts/34870/"/>
      <url>/posts/34870/</url>
      
        <content type="html"><![CDATA[<p>面对而已的DDOS攻击是一种很让人头疼的问题，其中CC攻击是DDOS的一种，也是一种常见的网站攻击方法，通过有限的IP不断的去请求对方服务器，造成对方服务器资源耗尽直至宕机。</p><p>而通过Nginx的<strong>HttpLimitReqModul</strong>和<strong>HttpLimitZoneModule</strong> 来限制同一IP在同一时间段内的访问次数来降低CC攻击带来的危害</p><a id="more"></a><p>下面是一种简单的频率限制在nginx里面的配置</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">http &#123;</span><br><span class="line">    limit_req_zone $binary_remote_addr zone=one:10m rate=1r/s;</span><br><span class="line"></span><br><span class="line">    ...</span><br><span class="line"></span><br><span class="line">    server &#123;</span><br><span class="line"></span><br><span class="line">        ...</span><br><span class="line"></span><br><span class="line">        location /search/ &#123;</span><br><span class="line">            limit_req zone=one burst=5;</span><br><span class="line">        &#125;</span><br></pre></td></tr></table></figure><h1 id="limit-req-zone"><a href="#limit-req-zone" class="headerlink" title="limit_req_zone"></a>limit_req_zone</h1><p>limit_req_zone的使用规则是 </p><p><strong>limit_req_zone</strong> <em>key</em> zone=<em>name</em>:<em>size</em> rate=<em>rate</em></p><p><code>limit_req_zone $binary_remote_addr zone=one:10m rate=1r/s;</code></p><p>这一段是定义了一个名为<em>one</em> 的zone空间，空间大小为10m， 以$binary_remote_addr 为key,限制平均每秒的请求为1个，1M能存储16000个状态，rate的值必须为整数</p><h1 id="limit-req"><a href="#limit-req" class="headerlink" title="limit_req"></a>limit_req</h1><p>limit_req的使用规则是</p><p><strong>limit_req</strong> zone=<em>name</em> [burst=<em>number</em>] [nodelay];</p><p><code>limit_req zone=one burst=5;</code></p><p>zone: zone是指使用我们上面定义的zone，这个很好理解</p><p>burst: burst其实是一个桶的概念，以我们的设置为例，我们设置的是1request/s，如果一次性来了3个request，nginx会在第一秒处理一个请求，另外两个请求放到这个<strong>burst</strong>桶里，然后下一秒先处理桶里的请求，后面来的请求继续放进桶里，如果桶满了，这时候的请求就会返回503了</p><p>nodelay: 如果不希望在请求受限的情况下延迟过多的请求，可以使用这个参数，同时配合burst，他会在第一秒的时候，处理限制的请求数和burst里面的请求数</p>]]></content>
      
      
      <categories>
          
          <category> Nginx </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Nginx </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>HTTP协议：HTTP1.0、HTTP1.1、HTTP2.0对比</title>
      <link href="/posts/43499/"/>
      <url>/posts/43499/</url>
      
        <content type="html"><![CDATA[<p>早在HTTP建立之初，主要就是为了将超文本标记语言(HTML)文档从Web服务器传送到客户端的浏览器。也是说对于前端来说，我们所写的HTML页面将要放在我们的web服务器上，用户端通过浏览器访问url地址来获取网页的显示内容，但是到了WEB2.0以来，我们的页面变得复杂，不仅仅单纯的是一些简单的文字和图片，同时我们的HTML页面有了CSS，Javascript，来丰富我们的页面展示，当ajax的出现，我们又多了一种向服务器端获取数据的方法，这些其实都是基于HTTP协议的。同样到了移动互联网时代，我们页面可以跑在手机端浏览器里面，但是和PC相比，手机端的网络情况更加复杂，这使得我们开始了不得不对HTTP进行深入理解并不断优化过程中。</p><a id="more"></a><p>#对比</p><table><thead><tr><th></th><th>HTTP1.0</th><th>HTTP1.1</th><th>HTTP2.0</th></tr></thead><tbody><tr><td>Host头</td><td>✗</td><td>✔</td><td>✔</td></tr><tr><td>Range头</td><td>✗</td><td>✔</td><td>✔</td></tr><tr><td>长连接</td><td>✗</td><td>✔</td><td>✔</td></tr><tr><td>request method</td><td>GET  HEAD POST</td><td>以上+ OPTIONS  PUT  DELETE TRACE CONNECT</td><td>以上全部</td></tr><tr><td>cache</td><td>Expire  Last-Modefied  Pragma</td><td>以上+ETag   Cache-Control</td><td>以上全部</td></tr><tr><td>header压缩</td><td>✗</td><td>✗</td><td>✔</td></tr><tr><td>多路复用</td><td>✗</td><td>✗</td><td>✔</td></tr><tr><td>服务器推送</td><td>✗</td><td>✗</td><td>✔</td></tr></tbody></table><h1 id="解析"><a href="#解析" class="headerlink" title="解析"></a>解析</h1><p>我们这里主要选取了几个点来进行分析</p><h2 id="Range"><a href="#Range" class="headerlink" title="Range"></a>Range</h2><p>这里的<strong>Range</strong> 和 <strong>Content-Range</strong> 是针对于HTTP1.0的宽带浪费现象而提出来的一个解决方案。</p><p>在这里，我们接触的最多的便是断点续传了， 我们在请求下载某一个较大文件的时候，秉着耐心终于等到了99%了，但是这时候却突然断网了，如果再让你等待几十分钟去等待他重新下载完成，我们估计都要爆发了，而如果客户端，知道本地已经下了99%，只去请求服务端剩余的部分，这样不仅节约了用户的时间，还解决了服务器传输多余的重复数据而导致的宽带浪费</p><h2 id="长连接"><a href="#长连接" class="headerlink" title="长连接"></a>长连接</h2><p>一个web页面上面可能包含几十个图片文件或js、css文件，在HTTP1.0的时代，规定了浏览器与服务器只能保持短暂的连接，浏览器的每个请求都要与服务器建立一个新的TCP连接，TCP的连接需要三次握手，https还需要校验证书，那么问题就暴漏出来了，这几十次图片、js、css文件其实是在同一个web页面里面的，如果我们去除多余的几十次三次握手，那么访问速度就会提升上来，HTTP1.1使用了<strong>长连接</strong>来解决这个问题，我们可以配置后台服务器的长连接的时间，超时无内容传输才会断开连接，从而，在一定时间内的浏览器的请求可以使用同一个TCP连接或者几个TCP连接，减少了握手带来的时间损耗</p><h2 id="多路复用"><a href="#多路复用" class="headerlink" title="多路复用"></a>多路复用</h2><p>既然上面解析了长连接，这里就把多路复用提上来吧。HTTP2.0使用了多路复用的技术，做到同一个连接并发处理多个请求，而且并发请求的数量比HTTP1.1大了好几个数量级。</p><p>以chrome为例，每个页面，浏览器最多允许建立6个TCP连接，发起请求-&gt;服务端处理-&gt;响应请求 这样算是完成了一个浏览器请求。但是如果一个页面同时发起几百个请求，其中前几个请求又比较耗时，则会把这6个TCP连接全部占用，同时阻塞了后面的请求，这样整体请求都会慢下来了。</p><p>HTTP2采用多路复用是指，在同一个域名下，开启一个TCP的connection，每个请求以stream的方式传输，每个stream有唯一标识，connection一旦建立，后续的请求都可以复用这个connection并且可以同时发送，server端可以根据stream的唯一标识来相应对应的请求。这样上面请求阻塞的问题就可以得到解决。</p><p>##服务器推送</p><p>意思是说，当我们对支持HTTP2.0的web server请求数据的时候，服务器会顺便把一些客户端需要的资源一起推送到客户端，免得客户端再次创建连接发送请求到服务器端获取。这种方式非常合适加载静态资源。</p><h2 id="header压缩"><a href="#header压缩" class="headerlink" title="header压缩"></a>header压缩</h2><p>我们在传输文本等静态资源的时候，一般会开启压缩，gzip等，这样会减少宽带的占用，对于一些较大的文本文件，压缩后会减少的特别明显，相应也会感觉提升了很多。而header头信息的传输却一直使用字符串来传输，HTTP2.0使用HPACK算法对header的数据进行压缩，这样数据体积小了，在网络上传输就会更快。</p><h1 id="对比"><a href="#对比" class="headerlink" title="对比"></a>对比</h1><p><a href="https://http2.akamai.com/demo" target="_blank" rel="noopener">https://http2.akamai.com/demo</a> 是Akamai公司建立的一个官方演示，我们可以很明显的看出HTTP2.0对HTTP1.1上的性能提升</p><p><img src="https://github-1253518569.cos.ap-shanghai.myqcloud.com/http_beyond_http1.png" alt="http速度对比图"></p><h1 id="全站启用HTTP2"><a href="#全站启用HTTP2" class="headerlink" title="全站启用HTTP2"></a>全站启用HTTP2</h1><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">server &#123;</span><br><span class="line">    listen 83 http2;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在你的nginx配置文件的 <code>listen</code> 后面加上 <code>http2</code> 就可以启用HTTP2.0了，请放心使用，HTTP2.0已经兼容了HTTP1.1，如果你的浏览器不支持HTTP2.0的话，服务器使用HTTP1.1的协议进行传输</p>]]></content>
      
      
      <categories>
          
          <category> HTTP </category>
          
      </categories>
      
      
        <tags>
            
            <tag> HTTP </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>PHP实现断点续传</title>
      <link href="/posts/13685/"/>
      <url>/posts/13685/</url>
      
        <content type="html"><![CDATA[<p>断点续传指的是在上传/下载时，将任务（一个文件或压缩包）人为的划分为几个部分，每一个部分采用一个线程进行上传/下载，如果碰到网络故障，可以从已经上传/下载的部分开始继续上传/下载未完成的部分，而没有必要从头开始上传/下载。可以节省时间，提高速度。</p><a id="more"></a><h1 id="实现原理"><a href="#实现原理" class="headerlink" title="实现原理"></a>实现原理</h1><p>HTTP1.1 协议（RFC2616）开始支持获取文件的部分内容，这为并行下载以及断点续传提供了技术支持。它通过在 Header 里两个参数实现的，客户端发请求时对应的是 Range ，服务器端响应时对应的是 Content-Range。</p><p><strong>Range</strong></p><p>用于请求头中，指定第一个字节的位置和最后一个字节的位置，一般格式：</p><blockquote><p>Range:(unit=first byte pos)-[last byte pos]</p></blockquote><p>Range 头部的格式有以下几种情况：</p><blockquote><p>Range: bytes=0-499 表示第 0-499 字节范围的内容<br>Range: bytes=500-999 表示第 500-999 字节范围的内容<br>Range: bytes=-500 表示最后 500 字节的内容<br>Range: bytes=500- 表示从第 500 字节开始到文件结束部分的内容<br>Range: bytes=0-0,-1 表示第一个和最后一个字节<br>Range: bytes=500-600,601-999 同时指定几个范围</p></blockquote><p><strong>Content-Range</strong></p><p>用于响应头中，在发出带 Range 的请求后，服务器会在 Content-Range 头部返回当前接受的范围和文件总大小。一般格式：</p><blockquote><p>Content-Range: bytes (unit first byte pos) - [last byte pos]/[entity legth]</p></blockquote><p>例如：</p><blockquote><p>Content-Range: bytes 0-499/22400</p></blockquote><p>0－499 是指当前发送的数据的范围，而 22400 则是文件的总大小。</p><p>而在响应完成后，返回的响应头内容也不同：</p><blockquote><p>HTTP/1.1 200 Ok（不使用断点续传方式）<br>HTTP/1.1 206 Partial Content（使用断点续传方式）</p></blockquote><h1 id="增强校验"><a href="#增强校验" class="headerlink" title="增强校验"></a>增强校验</h1><p>在实际场景中，会出现一种情况，即在终端发起续传请求时，URL 对应的文件内容在服务器端已经发生变化，此时续传的数据肯定是错误的。如何解决这个问题了？显然此时需要有一个标识文件唯一性的方法。</p><p>在 RFC2616 中也有相应的定义，比如实现 Last-Modified 来标识文件的最后修改时间，这样即可判断出续传文件时是否已经发生过改动。同时 FC2616 中还定义有一个 ETag 的头，可以使用 ETag 头来放置文件的唯一标识。</p><h2 id="Last-Modified"><a href="#Last-Modified" class="headerlink" title="Last-Modified"></a>Last-Modified</h2><p>If-Modified-Since，和 Last-Modified 一样都是用于记录页面最后修改时间的 HTTP 头信息，只是 Last-Modified 是由服务器往客户端发送的 HTTP 头，而 If-Modified-Since 则是由客户端往服务器发送的头，可以看到，再次请求本地存在的 cache 页面时，客户端会通过 If-Modified-Since 头将先前服务器端发过来的 Last-Modified 最后修改时间戳发送回去，这是为了让服务器端进行验证，通过这个时间戳判断客户端的页面是否是最新的，如果不是最新的，则返回新的内容，如果是最新的，则返回 304 告诉客户端其本地 cache 的页面是最新的，于是客户端就可以直接从本地加载页面了，这样在网络上传输的数据就会大大减少，同时也减轻了服务器的负担。</p><h2 id="Etag"><a href="#Etag" class="headerlink" title="Etag"></a>Etag</h2><p>Etag（Entity Tags）主要为了解决 Last-Modified 无法解决的一些问题。</p><ol><li>一些文件也许会周期性的更改，但是内容并不改变（仅改变修改时间），这时候我们并不希望客户端认为这个文件被修改了，而重新 GET。</li><li>某些文件修改非常频繁，例如：在秒以下的时间内进行修改（1s 内修改了 N 次），If-Modified-Since 能检查到的粒度是 s 级的，这种修改无法判断（或者说 UNIX 记录 MTIME 只能精确到秒）。</li><li>某些服务器不能精确的得到文件的最后修改时间。</li></ol><p>为此，HTTP/1.1 引入了 Etag。Etag 仅仅是一个和文件相关的标记，可以是一个版本标记，例如：v1.0.0；或者说 “627-4d648041f6b80” 这么一串看起来很神秘的编码。但是 HTTP/1.1 标准并没有规定 Etag 的内容是什么或者说要怎么实现，唯一规定的是 Etag 需要放在 “” 内。</p><h2 id="If-Range"><a href="#If-Range" class="headerlink" title="If-Range"></a>If-Range</h2><p>用于判断实体是否发生改变，如果实体未改变，服务器发送客户端丢失的部分，否则发送整个实体。一般格式：</p><blockquote><p>If-Range: Etag | HTTP-Date</p></blockquote><p>也就是说，If-Range 可以使用 Etag 或者 Last-Modified 返回的值。当没有 ETage 却有 Last-modified 时，可以把 Last-modified 作为 If-Range 字段的值。</p><p>例如：</p><blockquote><p>If-Range: “627-4d648041f6b80”<br>If-Range: Fri, 22 Feb 2013 03:45:02 GMT</p></blockquote><p>If-Range 必须与 Range 配套使用。如果请求报文中没有 Range，那么 If-Range 就会被忽略。如果服务器不支持 If-Range，那么 Range 也会被忽略。</p><p>如果请求报文中的 Etag 与服务器目标内容的 Etag 相等，即没有发生变化，那么应答报文的状态码为 206。如果服务器目标内容发生了变化，那么应答报文的状态码为 200。</p><p>用于校验的其他 HTTP 头信息：If-Match/If-None-Match、If-Modified-Since/If-Unmodified-Since。</p><h2 id="工作原理"><a href="#工作原理" class="headerlink" title="工作原理"></a>工作原理</h2><p>Etag 由服务器端生成，客户端通过 If-Range 条件判断请求来验证资源是否修改。请求一个文件的流程如下：</p><p>第一次请求：</p><ol><li>客户端发起 HTTP GET 请求一个文件。</li><li>服务器处理请求，返回文件内容以及相应的 Header，其中包括 Etag（例如：627-4d648041f6b80）（假设服务器支持 Etag 生成并已开启了 Etag）状态码为 200。</li></ol><p>第二次请求（断点续传）：</p><ol><li>客户端发起 HTTP GET 请求一个文件，同时发送 If-Range（该头的内容就是第一次请求时服务器返回的 Etag：627-4d648041f6b80）。</li><li>服务器判断接收到的 Etag 和计算出来的 Etag 是否匹配，如果匹配，返回range返回的内容，响应的状态码为 206；否则，状态码为 200。</li></ol><h1 id="PHP实现"><a href="#PHP实现" class="headerlink" title="PHP实现"></a>PHP实现</h1><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line">$filename = &apos;1.txt&apos;;</span><br><span class="line">$file = fopen($filename, &apos;r&apos;);</span><br><span class="line">$output = fopen(&apos;php://stdout&apos;, &apos;w&apos;);</span><br><span class="line">$size = filesize($filename);</span><br><span class="line"></span><br><span class="line">if (isset($_SERVER[&apos;HTTP_RANGE&apos;])) &#123;</span><br><span class="line">    // 断点续传，获取续传的开头和结尾</span><br><span class="line">    $range = str_replace(&apos;bytes=&apos;, &apos;&apos;, $_SERVER[&apos;HTTP_RANGE&apos;]);</span><br><span class="line">    list($start, $end) = explode(&apos;-&apos;, $range);</span><br><span class="line">    $start = empty($start) ? 0 : $start;</span><br><span class="line">    $end = empty($end) ? ($size - 1) : $end;</span><br><span class="line">    $length = $end - $start + 1;</span><br><span class="line">    if ($length &gt;= 0) &#123;</span><br><span class="line">        // 返回断点续传code及相关头信息</span><br><span class="line">        header(&apos;HTTP/1.1 206 Partial Content&apos;);</span><br><span class="line">        header(&apos;Accept-Ranges: bytes&apos;);</span><br><span class="line">        header(&apos;Last-Modified: &apos;.gmdate(&apos;D, d M Y 01:01:01&apos;, filemtime($filename)).&apos; GMT&apos;);</span><br><span class="line">        header(&apos;Etags: &apos; . fileinode($filename));</span><br><span class="line">        header(&apos;Content-Length:&apos; . $length);</span><br><span class="line">        header(&apos;Content-Range: bytes &apos; . $length . &apos;/&apos; . $size);</span><br><span class="line">        // 偏移文件指针读取固定长度返回</span><br><span class="line">        fseek($file, $start);</span><br><span class="line">        echo fread($file, $length);</span><br><span class="line">    &#125;</span><br><span class="line">&#125; else &#123;</span><br><span class="line">    // 非断点续传</span><br><span class="line">    header(&apos;cache-control:public&apos;);</span><br><span class="line">    header(&apos;content-type:application/octet-stream&apos;);</span><br><span class="line">    header(&apos;Content-Length: &apos; . $size);</span><br><span class="line">    header(&apos;Etags: &apos; . fileinode($filename));</span><br><span class="line">    header(&apos;Last-Modified: &apos;.gmdate(&apos;D, d M Y 01:01:01&apos;, filemtime($filename)).&apos; GMT&apos;);</span><br><span class="line">    header(&apos;content-disposition:attachment; filename=&apos; . $filename);</span><br><span class="line">    echo fread($file, $size);</span><br><span class="line">&#125;</span><br><span class="line">fclose($file);</span><br><span class="line">fclose($output);</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> PHP </category>
          
          <category> HTTP </category>
          
      </categories>
      
      
        <tags>
            
            <tag> PHP </tag>
            
            <tag> HTTP </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>免费SSL证书制作-Lets Encrypt</title>
      <link href="/posts/28158/"/>
      <url>/posts/28158/</url>
      
        <content type="html"><![CDATA[<p>腾讯云一年的免费SSL证书到期了，在老大的推荐下看了一下<code>Let&#39;s Encrypt</code> 家的免费证书，虽然只有三个月，但是支持免费续期，而且支持通配符证书，这倒是很大的福利了</p><a id="more"></a><p>首先声明，我的系统是<code>CentOS7</code> ，系统不一致，可自行Google其他或直接官网教程<a href="https://certbot.eff.org/lets-encrypt/centosrhel7-nginx" target="_blank" rel="noopener">https://certbot.eff.org/lets-encrypt/centosrhel7-nginx</a></p><h1 id="下载certbot"><a href="#下载certbot" class="headerlink" title="下载certbot"></a>下载certbot</h1><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">$ wget https://dl.eff.org/certbot-auto</span><br><span class="line">$ chmod +x certbot-auto</span><br></pre></td></tr></table></figure><h1 id="制作通配符证书"><a href="#制作通配符证书" class="headerlink" title="制作通配符证书"></a>制作通配符证书</h1><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ ./certbot-auto certonly  -d &quot;*.example.com&quot; -d &quot;example.com&quot;  --manual --preferred-challenges dns-01  --server https://acme-v02.api.letsencrypt.org/directory</span><br></pre></td></tr></table></figure><p>这里会自动运行yum安装必要的包，然后会提示如下</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">Please choose an account</span><br><span class="line">- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -</span><br><span class="line">1: dev_test@2016-04-18T23:21:19Z (911e)</span><br><span class="line">2: ip-10-164-131-233.ap-southeast-1.compute.internal@2016-06-13T11:02:16Z (5c1b)</span><br><span class="line">- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -</span><br><span class="line">Select the appropriate number [1-2] then [enter] (press &apos;c&apos; to cancel): 1</span><br><span class="line">Obtaining a new certificate</span><br><span class="line">Performing the following challenges:</span><br><span class="line">dns-01 challenge for example.com</span><br><span class="line">dns-01 challenge for example.com</span><br><span class="line"></span><br><span class="line">- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -</span><br><span class="line">NOTE: The IP of this machine will be publicly logged as having requested this</span><br><span class="line">certificate. If you&apos;re running certbot in manual mode on a machine that is not</span><br><span class="line">your server, please ensure you&apos;re okay with that.</span><br><span class="line"></span><br><span class="line">Are you OK with your IP being logged?</span><br><span class="line">- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -</span><br><span class="line">(Y)es/(N)o: Y</span><br></pre></td></tr></table></figure><p>注意这里</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">Please deploy a DNS TXT record under the name</span><br><span class="line">_acme-challenge.example.com with the following value:</span><br><span class="line"></span><br><span class="line">e35fqmCZcB8L56ID4801hlA3aLx3viXtZo1yA3WVSmg</span><br><span class="line"></span><br><span class="line">Before continuing, verify the record is deployed.</span><br><span class="line">- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -</span><br><span class="line">Press Enter to Continue</span><br></pre></td></tr></table></figure><p>需要在后台域名解析之后再按Enter</p><p>制作完成后，将制作后的证书拿过用即可</p><p>配置如下</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">ssl_certificate cert/fullchain1.pem;</span><br><span class="line">ssl_certificate_key cert/privkey1.pem;</span><br><span class="line">ssl_trusted_certificate cert/chain1.pem;</span><br></pre></td></tr></table></figure><p>重启后就能看到HTTPS的安全绿色小球了</p><h1 id="续期"><a href="#续期" class="headerlink" title="续期"></a>续期</h1><p>上面提到了，这个证书有效期只有三个月，所以需要定时重新生成新的证书，然后完成后重启nginx</p><p>完整命令：<code>certbot-auto renew [--cert-name CERTNAME] [options]</code><br>可选参数：</p><ul><li><code>--cert-name CERTNAME</code>：指定要更新的证书。Certbot 用这个名称来管理证书文件。名称不影响证书内容。可以用 <code>certbot certificates</code> 命令查看证书名。</li><li><code>--dry-run</code>：用于测试，只获取测试证书，不保存至磁盘。只有 certonly 和 renew 两个子命令可以用这个参数。仍然会会改写 Apache 或 Nginx 服务器的配置文件并重启服务器。仍然会调用 <code>--pre-hook</code> 和 <code>--post-hook</code> 命令（只要定义过）。只是不再调用 <code>--deploy-hook</code> 命令。</li><li><code>--force-renewal, --renew-by-default</code>：强制更新域名的证书，即使离过期时间还远得很。</li><li><code>--allow-subset-of-names</code>：在域名所有权认证时，即使认证失败，也产生证书。在更新多个域名时有效，因为有可能部分域名不再指向当前主机。注意：不能和参数 <code>--csr</code> 同时使用。</li><li><code>-q, --quiet</code>：静默执行。</li><li><code>--debug-challenges</code>：调试模式，提交至 CA 前需要用户确认。</li><li><code>--preferred-challenges</code>：验证域名所有权的方式，”dns” 或 “tls-sni-01,http,dns” 等。每个服务器插件支持有限种类的方式。</li><li><code>--pre-hook PRE_HOOK</code>：在获取证书前要执行的 shell 命令。比如暂时关闭服务器软件以防止可能的冲突。只有在自动获取/更新证书时才会执行。如果更新多个证书时，只执行第一个命令。</li><li><code>--post-hook POST_HOOK</code>：在获取证书后要执行的 shell 命令。比如<strong>部署新证书，或重启服务器软件。</strong>如果更新多个证书时，只执行第一个命令。</li><li><code>--deploy-hook DEPLOY_HOOK</code>：每个有效的认证都会触发一次的 shell 命令。对这个命令，shell 变量 <code>$RENEWED_LINEAGE</code> 表示包含域名证书和私钥的配置目录，比如 <code>/etc/letsencrypt/live/example.com</code>。<code>$RENEWED_DOMAINS</code> 表示空格分隔的刚更新的域名列表，比如 <code>example.com www.example.com</code>。</li><li><code>--disable-hook-validation</code>：验证 <code>--pre-hook/--post-hook/--deploy-hook</code> 的 shell 命令是否有效，提前发现错误。</li><li><code>--no-directory-hooks</code>：更新证书时不执行 hook 目录中的命令。</li></ul><p>写个脚本加入到定时任务里面即可</p>]]></content>
      
      
      <categories>
          
          <category> SSL </category>
          
      </categories>
      
      
        <tags>
            
            <tag> SSL </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>PHP性能分析工具xhgui+tideways实践</title>
      <link href="/posts/7748/"/>
      <url>/posts/7748/</url>
      
        <content type="html"><![CDATA[<p>自从线上接口报内存溢出的问题后，就一直想搭建一个性能分析的平台，但后来一直没有时间，知道后来出现了接口调用时间过长，才将这个任务提上议程。</p><p>我同事先前所在的部门使用了<code>xhprof</code>  + <code>xhgui</code> 的处理方式，但是研究后发现 <code>xhprof</code> 只支持到php5.6，无奈放弃了，同时，虽然 <code>tideways</code> 自己也提供了UI，但是炫酷的都是要收费的，综合考虑后，选用了 <code>tideways</code> + <code>xhgui</code>  的解决方案</p><a id="more"></a><h1 id="安装Tideways"><a href="#安装Tideways" class="headerlink" title="安装Tideways"></a>安装Tideways</h1><h2 id="安装PHP及扩展"><a href="#安装PHP及扩展" class="headerlink" title="安装PHP及扩展"></a>安装PHP及扩展</h2><p>在<code>https://webtatic.com/</code> 有每个版本的php的源，这里就简单过一下</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">yum install epel-release</span><br><span class="line">rpm -Uvh https://mirror.webtatic.com/yum/el7/webtatic-release.rpm</span><br><span class="line">yum install php72w* --skip-broken</span><br></pre></td></tr></table></figure><h2 id="安装Tideways-1"><a href="#安装Tideways-1" class="headerlink" title="安装Tideways"></a>安装Tideways</h2><p>我这里存放源码的目录是 <code>/data/local/</code> 下，目录是不会产生任何影响的，phpize编译完扩展后会自动拷贝到php的modules对应的目录的， 拷贝命令请去除注释</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">git clone https://github.com/tideways/php-xhprof-extension.git   // 克隆下git文件</span><br><span class="line">cd php-xhprof-extension </span><br><span class="line">phpize  // 生成configure文件</span><br><span class="line">./configure</span><br><span class="line">make &amp;&amp; make install  // 安装</span><br><span class="line"></span><br><span class="line">// 开启php扩展</span><br><span class="line">echo &apos;</span><br><span class="line">; enable tideways_xhprof</span><br><span class="line">extension=tideways_xhprof.so</span><br><span class="line">tideways.auto_prepend_library=0&apos; &gt; /etc/php.d/tideways_xhprof.ini</span><br><span class="line"></span><br><span class="line">// 重启php-fpm</span><br><span class="line">service php-fpm restart</span><br></pre></td></tr></table></figure><h1 id="安装xhgui"><a href="#安装xhgui" class="headerlink" title="安装xhgui"></a>安装xhgui</h1><p>这个项目放到一个web可访问的路径，这个最终是通过浏览器展示的</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">git clone https://github.com/laynefyc/xhgui-branch.git // 汉化版</span><br><span class="line">// git clone https://github.com/perftools/xhgui.git  // 原版</span><br><span class="line">mv xhgui-branch xhgui</span><br><span class="line">cd xhgui</span><br><span class="line">chmod 777 cache // 把cache目录给与代码可读写的权限</span><br><span class="line">php install.php  // 安装xhgui</span><br></pre></td></tr></table></figure><h1 id="安装MongoDB"><a href="#安装MongoDB" class="headerlink" title="安装MongoDB"></a>安装MongoDB</h1><h2 id="安装MongoDB-1"><a href="#安装MongoDB-1" class="headerlink" title="安装MongoDB"></a>安装MongoDB</h2><p>创建 <code>/etc/yum.repos.d/mongo.repo</code> 文件， 内容如下</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">[mongodb-org-4.0]</span><br><span class="line">name=MongoDB Repository</span><br><span class="line">baseurl=https://repo.mongodb.org/yum/redhat/$releasever/mongodb-org/4.0/x86_64/</span><br><span class="line">gpgcheck=1</span><br><span class="line">enabled=1</span><br><span class="line">gpgkey=https://www.mongodb.org/static/pgp/server-4.0.asc</span><br></pre></td></tr></table></figure><p>使用yum安装</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">yum install -y mongodb-org</span><br></pre></td></tr></table></figure><p>启动</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">service mongod start</span><br></pre></td></tr></table></figure><h2 id="添加索引"><a href="#添加索引" class="headerlink" title="添加索引"></a>添加索引</h2><p>tideways会将结果集存放在MongoDB中，当然是可以选择的，权衡一下，我们这里使用MongoDB</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">mongo</span><br><span class="line">&gt; use xhprof</span><br><span class="line">&gt; db.results.ensureIndex( &#123; &apos;meta.SERVER.REQUEST_TIME&apos; : -1 &#125; )</span><br><span class="line">&gt; db.results.ensureIndex( &#123; &apos;profile.main().wt&apos; : -1 &#125; )</span><br><span class="line">&gt; db.results.ensureIndex( &#123; &apos;profile.main().mu&apos; : -1 &#125; )</span><br><span class="line">&gt; db.results.ensureIndex( &#123; &apos;profile.main().cpu&apos; : -1 &#125; )</span><br><span class="line">&gt; db.results.ensureIndex( &#123; &apos;meta.url&apos; : 1 &#125; )</span><br><span class="line">&gt; db.results.ensureIndex( &#123; &apos;meta.simple_url&apos; : 1 &#125; )</span><br></pre></td></tr></table></figure><h1 id="整合Tideways和Xhgui到项目"><a href="#整合Tideways和Xhgui到项目" class="headerlink" title="整合Tideways和Xhgui到项目"></a>整合Tideways和Xhgui到项目</h1><h2 id="整合代码"><a href="#整合代码" class="headerlink" title="整合代码"></a>整合代码</h2><p>汉化版xhgui的作者是建议如下使用</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">server &#123;</span><br><span class="line">  listen 80;</span><br><span class="line">  server_name site.localhost;</span><br><span class="line">  root /Users/markstory/Sites/awesome-thing/app/webroot/;  // 汉化xhgui作者的目录，仅拷贝</span><br><span class="line">  fastcgi_param PHP_VALUE &quot;auto_prepend_file=/Users/markstory/Sites/xhgui/external/header.php&quot;; // 汉化xhgui作者的目录，仅拷贝</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这里是你的需要做性能监控的web服务的nginx的配置</p><p>但是，我在这样使用的时候，php-fpm在我调用的接口的时候就会自动挂掉，然后看了一下文件 <code>xhgui/external/header.php</code> ， 在这个里面，作者注册了<code>register_shutdown_function</code> 函数，我使用的框架是Yii2，其次，里面还会做判断各种扩展及存储方案，这个对于我已经确定了方案的用户来说，这种判断是没用的，相对还要消耗性能，所以这里根据header.php的逻辑，直接写入代码</p><p>在beforeAction中加入 </p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line">private function startXhprof()</span><br><span class="line">&#123;</span><br><span class="line">    $dir = &apos;/data/www/html/xhgui&apos;;</span><br><span class="line">    // Use the callbacks defined in the configuration file</span><br><span class="line">    // to determine whether or not XHgui should enable profiling.</span><br><span class="line">    //</span><br><span class="line">    // Only load the config class so we don&apos;t pollute the host application&apos;s</span><br><span class="line">    // autoloaders.</span><br><span class="line">    require_once $dir . &apos;/src/Xhgui/Config.php&apos;;</span><br><span class="line">    \Xhgui_Config::load($dir . &apos;/config/config.default.php&apos;);</span><br><span class="line">    if (file_exists($dir . &apos;/config/config.php&apos;)) &#123;</span><br><span class="line">        \Xhgui_Config::load($dir . &apos;/config/config.php&apos;);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    $filterPath = \Xhgui_Config::read(&apos;profiler.filter_path&apos;);</span><br><span class="line">    if(is_array($filterPath)&amp;&amp;in_array($_SERVER[&apos;DOCUMENT_ROOT&apos;],$filterPath))&#123;</span><br><span class="line">        return;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    if (!isset($_SERVER[&apos;REQUEST_TIME_FLOAT&apos;])) &#123;</span><br><span class="line">        $_SERVER[&apos;REQUEST_TIME_FLOAT&apos;] = microtime(true);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    tideways_xhprof_enable(TIDEWAYS_XHPROF_FLAGS_MEMORY | TIDEWAYS_XHPROF_FLAGS_MEMORY_MU | TIDEWAYS_XHPROF_FLAGS_MEMORY_PMU | TIDEWAYS_XHPROF_FLAGS_CPU);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">public function beforeAction($action)</span><br><span class="line">&#123;</span><br><span class="line">  $this-&gt;startXhprof();</span><br><span class="line">  return parent::beforeAction($action);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在 <code>afterAction</code> 中获取分析数据并存入MongoDB</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br></pre></td><td class="code"><pre><span class="line">private function stopXhprof()</span><br><span class="line">&#123;</span><br><span class="line">    $data[&apos;profile&apos;] = tideways_xhprof_disable();</span><br><span class="line">    </span><br><span class="line">    // ignore_user_abort(true) allows your PHP script to continue executing, even if the user has terminated their request.</span><br><span class="line">    // Further Reading: http://blog.preinheimer.com/index.php?/archives/248-When-does-a-user-abort.html</span><br><span class="line">    // flush() asks PHP to send any data remaining in the output buffers. This is normally done when the script completes, but</span><br><span class="line">    // since we&apos;re delaying that a bit by dealing with the xhprof stuff, we&apos;ll do it now to avoid making the user wait.</span><br><span class="line">    ignore_user_abort(true);</span><br><span class="line">    flush();</span><br><span class="line">    </span><br><span class="line">    if (!defined(&apos;XHGUI_ROOT_DIR&apos;)) &#123;</span><br><span class="line">        require &apos;/data/www/html/xhgui/src/bootstrap.php&apos;;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    $uri = array_key_exists(&apos;REQUEST_URI&apos;, $_SERVER)</span><br><span class="line">        ? $_SERVER[&apos;REQUEST_URI&apos;]</span><br><span class="line">        : null;</span><br><span class="line">    if (empty($uri) &amp;&amp; isset($_SERVER[&apos;argv&apos;])) &#123;</span><br><span class="line">        $cmd = basename($_SERVER[&apos;argv&apos;][0]);</span><br><span class="line">        $uri = $cmd . &apos; &apos; . implode(&apos; &apos;, array_slice($_SERVER[&apos;argv&apos;], 1));</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    $time = array_key_exists(&apos;REQUEST_TIME&apos;, $_SERVER)</span><br><span class="line">        ? $_SERVER[&apos;REQUEST_TIME&apos;]</span><br><span class="line">        : time();</span><br><span class="line">    $requestTimeFloat = explode(&apos;.&apos;, $_SERVER[&apos;REQUEST_TIME_FLOAT&apos;]);</span><br><span class="line">    if (!isset($requestTimeFloat[1])) &#123;</span><br><span class="line">        $requestTimeFloat[1] = 0;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    $requestTs = new \MongoDate($time);</span><br><span class="line">    $requestTsMicro = new \MongoDate($requestTimeFloat[0], $requestTimeFloat[1]);</span><br><span class="line"></span><br><span class="line">    $data[&apos;meta&apos;] = array(</span><br><span class="line">        &apos;url&apos; =&gt; $uri,</span><br><span class="line">        &apos;SERVER&apos; =&gt; $_SERVER,</span><br><span class="line">        &apos;get&apos; =&gt; $_GET,</span><br><span class="line">        &apos;env&apos; =&gt; $_ENV,</span><br><span class="line">        &apos;simple_url&apos; =&gt; \Xhgui_Util::simpleUrl($uri),</span><br><span class="line">        &apos;request_ts&apos; =&gt; $requestTs,</span><br><span class="line">        &apos;request_ts_micro&apos; =&gt; $requestTsMicro,</span><br><span class="line">        &apos;request_date&apos; =&gt; date(&apos;Y-m-d&apos;, $time),</span><br><span class="line">    );</span><br><span class="line"></span><br><span class="line">    try &#123;</span><br><span class="line">        $config = \Xhgui_Config::all();</span><br><span class="line">        $config += array(&apos;db.options&apos; =&gt; array());</span><br><span class="line">        $saver = \Xhgui_Saver::factory($config);</span><br><span class="line">        $saver-&gt;save($data);</span><br><span class="line">    &#125; catch (\Exception $e) &#123;</span><br><span class="line">        error_log(&apos;xhgui - &apos; . $e-&gt;getMessage());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">public function afterAction($action, $result)</span><br><span class="line">&#123;</span><br><span class="line">    $this-&gt;stopXhprof();</span><br><span class="line">    return parent::afterAction($action, $result);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="整理nginx"><a href="#整理nginx" class="headerlink" title="整理nginx"></a>整理nginx</h2><p>我们需要添加一个server，指向<code>xhgui/webroot/</code> 目录，用于展示</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">server &#123;</span><br><span class="line">    listen       80;</span><br><span class="line">    server_name  xx.xxx.com;</span><br><span class="line">    root  /data/www/html/xhgui/webroot;   //指向自身的目录</span><br><span class="line"></span><br><span class="line">    location / &#123;</span><br><span class="line">        index  index.php;</span><br><span class="line">        if (!-e $request_filename) &#123;</span><br><span class="line">            rewrite . /index.php last;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"># 下面这段可根据自身配置的php解析进行相应的修改</span><br><span class="line">    location ~ \.php$ &#123;</span><br><span class="line">        fastcgi_pass   127.0.0.1:9000;</span><br><span class="line">        fastcgi_index  index.php;</span><br><span class="line">        fastcgi_param SCRIPT_FILENAME $document_root$fastcgi_script_name;</span><br><span class="line">        include        fastcgi_params;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>到此为止，访问配置的域名就可以看到性能分析平台了</p><h1 id="异常"><a href="#异常" class="headerlink" title="异常"></a>异常</h1><p>有可能你会遇到如下的问题</p><p><img src="http://github-1253518569.cossh.myqcloud.com/mongo-exception.png" alt="mongo异常"></p><p>修改 <code>/path/to/xhgui/src/Xhgui/Profiles.php</code> 的<strong>aggregate</strong> 的传参，约172行</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line">137         $results = $this-&gt;_collection-&gt;aggregate(array(</span><br><span class="line">138             array(&apos;$match&apos; =&gt; $match),</span><br><span class="line">139             array(</span><br><span class="line">140                 &apos;$project&apos; =&gt; array(</span><br><span class="line">141                     &apos;date&apos; =&gt; $col,</span><br><span class="line">142                     &apos;profile.main()&apos; =&gt; 1</span><br><span class="line">143                 )</span><br><span class="line">144             ),</span><br><span class="line">145             array(</span><br><span class="line">146                 &apos;$group&apos; =&gt; array(</span><br><span class="line">147                     &apos;_id&apos; =&gt; &apos;$date&apos;,</span><br><span class="line">148                     &apos;row_count&apos; =&gt; array(&apos;$sum&apos; =&gt; 1),</span><br><span class="line">149                     &apos;wall_times&apos; =&gt; array(&apos;$push&apos; =&gt; &apos;$profile.main().wt&apos;),</span><br><span class="line">150                     &apos;cpu_times&apos; =&gt; array(&apos;$push&apos; =&gt; &apos;$profile.main().cpu&apos;),</span><br><span class="line">151                     &apos;mu_times&apos; =&gt; array(&apos;$push&apos; =&gt; &apos;$profile.main().mu&apos;),</span><br><span class="line">152                     &apos;pmu_times&apos; =&gt; array(&apos;$push&apos; =&gt; &apos;$profile.main().pmu&apos;),</span><br><span class="line">153                 )</span><br><span class="line">154             ),</span><br><span class="line">155             array(</span><br><span class="line">156                 &apos;$project&apos; =&gt; array(</span><br><span class="line">157                     &apos;date&apos; =&gt; &apos;$date&apos;,</span><br><span class="line">158                     &apos;row_count&apos; =&gt; &apos;$row_count&apos;,</span><br><span class="line">159                     &apos;raw_index&apos; =&gt; array(</span><br><span class="line">160                         &apos;$multiply&apos; =&gt; array(</span><br><span class="line">161                             &apos;$row_count&apos;,</span><br><span class="line">162                             $percentile / 100</span><br><span class="line">163                         )</span><br><span class="line">164                     ),</span><br><span class="line">165                     &apos;wall_times&apos; =&gt; &apos;$wall_times&apos;,</span><br><span class="line">166                     &apos;cpu_times&apos; =&gt; &apos;$cpu_times&apos;,</span><br><span class="line">167                     &apos;mu_times&apos; =&gt; &apos;$mu_times&apos;,</span><br><span class="line">168                     &apos;pmu_times&apos; =&gt; &apos;$pmu_times&apos;,</span><br><span class="line">169                 )</span><br><span class="line">170             ),</span><br><span class="line">171             array(&apos;$sort&apos; =&gt; array(&apos;_id&apos; =&gt; 1)),</span><br><span class="line">172         )</span><br><span class="line">173,array(&apos;cursor&apos; =&gt; array(&apos;batchSize&apos; =&gt; 0)));</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> PHP </category>
          
      </categories>
      
      
        <tags>
            
            <tag> PHP </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>git merge和git merge --no-ff的区别</title>
      <link href="/posts/132/"/>
      <url>/posts/132/</url>
      
        <content type="html"><![CDATA[<p>在很多介绍GItFlow工作流的文章里面，都会推荐在合并分支的时候加上<code>--no-ff</code>参数， 而我们在合并的时候，有时git也会提示 使用了 <strong>fast-forward</strong>， 这里我将介绍一下<code>merge</code>的三种状态及 <code>git merge</code> 和 <code>git merge --no-ff</code> 的区别</p><a id="more"></a><p>Git merge的时候，有几种合并方式可以选择</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">--ff</span><br><span class="line">When the merge resolves as a fast-forward, only update the branch pointer, without creating a merge commit. This is the default behavior.</span><br><span class="line"></span><br><span class="line">--no-ff</span><br><span class="line">Create a merge commit even when the merge resolves as a fast-forward. This is the default behaviour when merging an annotated (and possibly signed) tag.</span><br><span class="line"></span><br><span class="line">--squash</span><br><span class="line">--no-squash</span><br><span class="line">Produce the working tree and index state as if a real merge happened (except for the merge information), but do not actually make a commit, move the HEAD, or record $GIT_DIR/MERGE_HEAD (to cause the next git commit command to create a merge commit). This allows you to create a single commit on top of the current branch whose effect is the same as merging another branch (or more in case of an octopus).</span><br><span class="line"></span><br><span class="line">With --no-squash perform the merge and commit the result. This option can be used to override --squash.</span><br></pre></td></tr></table></figure><p>而我们平常什么都不加的时候，则使用默认的 <code>--ff</code> ， 即 <strong>fast-forward</strong> 方式</p><p>看过官方注释后，我们用一张图来简单描画一下相应的行为</p><p><img src="https://github-1253518569.cos.ap-shanghai.myqcloud.com/2018-09-18_200521.png" alt="merge"></p><ol><li><p>fast-forward</p><p><strong>Git 合并两个分支时，如果顺着一个分支走下去可以到达另一个分支的话，那么 Git 在合并两者时，只会简单地把指针右移，叫做“快进”（fast-forward）不过这种情况如果删除分支，则会丢失merge分支信息。</strong></p></li><li><p>–squash</p><p><strong>把一些不必要commit进行压缩，比如说，你的feature在开发的时候写的commit很乱，那么我们合并的时候不希望把这些历史commit带过来，于是使用–squash进行合并，此时文件已经同合并后一样了，但不移动HEAD，不提交。需要进行一次额外的commit来“总结”一下，然后完成最终的合并。</strong></p></li><li><p>–no-ff</p><p><strong>关闭fast-forward模式，在提交的时候，会创建一个merge的commit信息，然后合并的和master分支</strong></p></li></ol><p>merge的不同行为，向后看，其实最终都会将代码合并到master分支，而区别仅仅只是分支上的简洁清晰的问题，然后，向前看，也就是我们使用<code>reset</code> 的时候，就会发现，不同的行为就带来了不同的影响</p><p><img src="https://github-1253518569.cos.ap-shanghai.myqcloud.com/2018-09-18_201744.png" alt="https://github-1253518569.cos.ap-shanghai.myqcloud.com/2018-09-18_201744.png"></p><p>上图是使用 <code>merge --no-ff</code>的时候的效果，此时<code>git reset HEAD^ --hard</code> 的时候，整个分支会回退到  <strong>dev2-commit-2</strong></p><p><img src="https://github-1253518569.cos.ap-shanghai.myqcloud.com/2018-09-18_201755.png" alt=" dev3-commit-1"></p><p>上图是使用 <strong>fast-forward</strong> 模式的时候，即 <code>git merge</code> ，这时候 <code>git reset HEAD^ --hard</code>，整个分支会回退到 <strong>dev1-commit-3</strong></p><p>通常我们把 master 作为主分支，上面存放的都是比较稳定的代码，提交频率也很低，而 develop 是用来开发特性的，上面会存在许多零碎的提交，快进式合并会把 develop 的提交历史混入到 master 中，搅乱 master 的提交历史。所以如果你根本不在意提交历史，也不爱管 master 干不干净，那么 –no-ff 其实没什么用。不过，如果某一次 master 出现了问题，你需要回退到上个版本的时候，比如上例，你就会发现退一个版本到了 commint-3，而不是想要的 commit-2，因为 feature 的历史合并进了 master 里。这也就是很多人都会推荐 –no-ff 的原因了吧。</p>]]></content>
      
      
      <categories>
          
          <category> GIT </category>
          
      </categories>
      
      
        <tags>
            
            <tag> GIT </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>php的垃圾回收机制</title>
      <link href="/posts/13507/"/>
      <url>/posts/13507/</url>
      
        <content type="html"><![CDATA[<p>每个php变量存在一个叫”zval”的变量容器中。一个zval变量容器，除了包含变量的类型和值，还包括两个字节的额外信息。第一个是”is_ref”，是个bool值，用来标识这个变量是否是属于引用集合(reference set)。通过这个字节，php引擎才能把普通变量和引用变量区分开来，由于php允许用户通过使用&amp;来使用自定义引用，zval变量容器中还有一个内部引用计数机制，来优化内存使用。第二个额外字节是”refcount”，用以表示指向这个zval变量容器的变量(也称符号即symbol)个数。所有的符号存在一个符号表中，其中每个符号都有作用域(scope)，那些主脚本(比如：通过浏览器请求的的脚本)和每个函数或者方法也都有作用域。 </p><a id="more"></a><p>PHP是一种弱类型的脚本语言，弱类型不表示PHP变量没有类型的区别，PHP变量有8种原始类型：<br>四种标量类型：</p><ul><li>boolean（布尔值）</li><li>integer（整型）</li><li>float（浮点型）</li><li>string （字符串）</li></ul><p>两种复合类型：</p><ul><li>array（数组）</li><li>object（对象）</li></ul><p>两种特殊类型：</p><ul><li>resource（资源）</li><li>NULL</li></ul><hr><p>在引擎内部，变量都是用一个结构体来表示的。这个结构体可以在{PHPSRC}/Zend/zend.h中找到：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">struct _zval_struct &#123;  </span><br><span class="line">     /* Variable information */  </span><br><span class="line">     zvalue_value value;     /* value */  </span><br><span class="line">     zend_uint refcount__gc;  //代表一个计数器，表示有多少个变量名指向这个zval容器</span><br><span class="line">     zend_uchar type;    /* active type */  </span><br><span class="line">     zend_uchar is_ref__gc;  //此字段是一个布尔值，用来标识变量是否是一个引用，通过这个字段，PHP引擎可以区分一般变量和引用变量</span><br><span class="line"> &#125;;</span><br></pre></td></tr></table></figure><h2 id="copy-on-write（写时复制技术）"><a href="#copy-on-write（写时复制技术）" class="headerlink" title="copy on write（写时复制技术）"></a>copy on write（写时复制技术）</h2><blockquote><p>父进程fork子进程之后，子进程的地址空间还是简单的指向父进程的地址空间，只有当子进程需要写地址空间中的内容的时候，才会单独分离一份给子进程，这样就算子进程马上调用exec函数也没有关系，因为根本就不需要从父进程的地址空间中拷贝内容，这样就节省了内存同时又提高了速度。</p><p>这个逻辑可以叙述为：对一个一般变量a（isref=0）进行一般的赋值操作，如果a所指向的zval的计数refcount大于1，那么需要为a重新分配一个新的zval，并且把之前的zval的计数refcount减少1。</p></blockquote><h2 id="PHP5-3版本中对于新的GC算法（Concurrent-Cycle-Collection-in-Reference-Counted-Systems）"><a href="#PHP5-3版本中对于新的GC算法（Concurrent-Cycle-Collection-in-Reference-Counted-Systems）" class="headerlink" title="PHP5.3版本中对于新的GC算法（Concurrent Cycle Collection in Reference Counted Systems）"></a>PHP5.3版本中对于新的GC算法（Concurrent Cycle Collection in Reference Counted Systems）</h2><p>几个基本准则：</p><ol><li>如果一个zval的refcount增加，那么此zval还在使用，不属于垃圾</li><li>如果一个zval的refcount减少到0，那么zval可以被释放掉，不属于垃圾</li><li>如果一个zval的refcount减少之后大于0，那么此zval还不能被释放，此zval可能成为一个垃圾。</li></ol><p>新的GC算法目的就是防止循环引用的变量引起内存泄露问题。在PHP中GC算法，当节点缓冲区满了之后，垃圾分析算法就会启动，并且会释放掉发现的垃圾，从而回收内存。</p><p>现在，如果我们试一下，将数组的引用赋值给数组中的一个元素，有意思的事情发生了：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">&lt;?php</span><br><span class="line">$a = array(&quot;one&quot;);</span><br><span class="line">$a[] = &amp;$a;</span><br><span class="line">?&gt;</span><br></pre></td></tr></table></figure><p>这样$a数组就有两个元素，一个索引为0，值为字符one，另一个索引为1，为$a自身的引用，内部存储如下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">a: (refcount=2, is_ref=1)=array (</span><br><span class="line">   0 =&gt; (refcount=1, is_ref=0)=&apos;one&apos;,</span><br><span class="line">   1 =&gt; (refcount=2, is_ref=1)=...</span><br><span class="line">)</span><br></pre></td></tr></table></figure><p>“…”表示1指向a自身，是一个环形引用（循环引用）：<br><img src="https://github-1253518569.cos.ap-shanghai.myqcloud.com/242899734-5ab22a29174e9_articlex.png" alt="图片描述"></p><p>这个时候我们对$a进行unset，那么$a会从符号表中删除，同时$a指向的zval的refcount减少1。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">&lt;?php</span><br><span class="line">$a = array(&apos;one&apos;);</span><br><span class="line">$a[] = &amp;$a;</span><br><span class="line">unset($a);</span><br><span class="line">?&gt;</span><br></pre></td></tr></table></figure><p>那么问题产生了，$a已经不再符号表中了，用户无法再访问此变量，但是$a之前指向的zval的refcount变为1而不是0，因此不能被回收，这样产生了内存泄露：<br><img src="https://github-1253518569.cos.ap-shanghai.myqcloud.com/1915931556-5ab22afde99e3_articlex.png" alt="图片描述"></p><p>这样zval就成为一个垃圾了，新的GC要做的工作就是清理这种垃圾。</p><blockquote><p>在PHP编程中程序员不需要手动处理内存资源分配与释放，意味着PHP本身实现了垃圾回收处理机制。</p></blockquote><h2 id="PHP5-2中的垃圾回收算法—Reference-Counting"><a href="#PHP5-2中的垃圾回收算法—Reference-Counting" class="headerlink" title="PHP5.2中的垃圾回收算法—Reference Counting"></a>PHP5.2中的垃圾回收算法—Reference Counting</h2><blockquote><p>这个算法叫做“引用计数”，其思想非常直观和简洁：为每个内存对象分配一个计数器，当一个内存对象建立时计数器初始化为1（因此此时总是有一个变量引用此对象），以后每有一个新变量引用此内存对象，则计数器加1，而每当减少一个引用此内存对象的变量则计数器减1，当垃圾回收机制运作时，将所有计数器为0的内存对象销毁并回收其占用的内存。而php中内存对象就是zval，而计数器就是refcount__gc。</p></blockquote>]]></content>
      
      
      <categories>
          
          <category> PHP </category>
          
      </categories>
      
      
        <tags>
            
            <tag> PHP </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Nginx倒腾笔记（六）：SSL_do_handshake() failed</title>
      <link href="/posts/34556/"/>
      <url>/posts/34556/</url>
      
        <content type="html"><![CDATA[<p>前几天在倒腾镜像站的时候，在代理ipv4的站点是ok的，但是代理ipv6的https站点的时候，发现一直返回502，也就是说明，nginx代理了，但是代理的时候，下游服务器没有给你正确的响应</p><a id="more"></a><p>首先看一下原始配置</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">location / &#123;</span><br><span class="line">        proxy_cache my_cache;</span><br><span class="line">        proxy_set_header Accept-Encoding &quot;none&quot;;</span><br><span class="line">        proxy_pass https://m.cn.nytimes.com/;</span><br><span class="line">        sub_filter &apos;https://m.cn.nytimes.com&apos; &apos;https://www.xxx.com/&apos;;</span><br><span class="line">        sub_filter &apos;d1f1eryiqyjs0r.cloudfront.net&apos; &apos;www.xxx.com/d1f1eryiqyjs0r&apos;;</span><br><span class="line">        sub_filter_once  off;</span><br><span class="line">&#125;</span><br><span class="line">location ~ /d1f1eryiqyjs0r/(.*)$ &#123;</span><br><span class="line">        proxy_cache my_cache;</span><br><span class="line">        proxy_set_header referer &quot;https://cn.nytimes.com&quot;;</span><br><span class="line">        proxy_pass https://d1f1eryiqyjs0r.cloudfront.net/$1;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>思路很简单，就是通过proxy_pass来代理到目标站点，获取内容后，将不能国内访问的内容的域名替换成自己的域名，后面加上不同的后缀来标识，然后再通过我们的服务器代理内容里面的超链，理论上出了繁琐外，没有什么技术难度，然而返回了502，这就有点不够意思了。</p><p>查看error.log后发现</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">2018/09/01 07:55:24 [error] 485#485: *6372 SSL_do_handshake() failed (SSL: error:14077410:SSL routines:SSL23_GET_SERVER_HELLO:sslv3 alert handshake failure) while SSL handshaking to upstream, client: 122.224.106.25, server: www.xxx.com, request: &quot;GET / HTTP/1.1&quot;, upstream: &quot;https://52.85.131.45:443/&quot;, host: &quot;www.xxx.com&quot;</span><br></pre></td></tr></table></figure><p>SSL的问题，代理的时候加一下SSL处理</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">location / &#123;</span><br><span class="line">        proxy_ssl_server_name on;</span><br><span class="line">        proxy_ssl_protocols TLSv1 TLSv1.1 TLSv1.2;</span><br><span class="line">        proxy_cache my_cache;</span><br><span class="line">        proxy_set_header Accept-Encoding &quot;none&quot;;</span><br><span class="line">        proxy_pass https://m.cn.nytimes.com/;</span><br><span class="line">        sub_filter &apos;https://m.cn.nytimes.com&apos; &apos;https://www.xxx.com/&apos;;</span><br><span class="line">        sub_filter &apos;d1f1eryiqyjs0r.cloudfront.net&apos; &apos;www.xxx.com/d1f1eryiqyjs0r&apos;;</span><br><span class="line">        sub_filter_once  off;</span><br><span class="line">&#125;</span><br><span class="line">location ~ /d1f1eryiqyjs0r/(.*)$ &#123;</span><br><span class="line">proxy_ssl_server_name on;</span><br><span class="line">        proxy_ssl_protocols TLSv1 TLSv1.1 TLSv1.2;</span><br><span class="line">        proxy_cache my_cache;</span><br><span class="line">        proxy_set_header referer &quot;https://cn.nytimes.com&quot;;</span><br><span class="line">        proxy_pass https://d1f1eryiqyjs0r.cloudfront.net/$1;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>综上，再次打开已经OK了。</p>]]></content>
      
      
      <categories>
          
          <category> Nginx </category>
          
      </categories>
      
      
        <tags>
            
            <tag> PHP </tag>
            
            <tag> Nginx </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>php配置xdebug实现内网本地调试远程服务器</title>
      <link href="/posts/15205/"/>
      <url>/posts/15205/</url>
      
        <content type="html"><![CDATA[<p>对于一般的项目来说，<code>print_r() echo file_put_contents() exit</code> 这些函数调试就足够了，但是如果你调试的环境还有其他人，那就略胃疼了</p><p>服务器环境：centos7 php7.0</p><p>本地环境：windows php7.2（压缩包）</p><p>本地环境是公司内网，所以中间会借助xshell做一次tcp的转发</p><a id="more"></a><h1 id="服务器配置"><a href="#服务器配置" class="headerlink" title="服务器配置"></a>服务器配置</h1><h2 id="安装xdebug"><a href="#安装xdebug" class="headerlink" title="安装xdebug"></a>安装xdebug</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">yum install php70w* --skip-broken</span><br><span class="line">yum install php70w-pecl-xdebug</span><br></pre></td></tr></table></figure><h2 id="配置xdebug"><a href="#配置xdebug" class="headerlink" title="配置xdebug"></a>配置xdebug</h2><p>修改xdebug的配置文件 <code>/etc/php.d/xdebug.ini</code></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">; Enable xdebug extension module</span><br><span class="line">zend_extension=/usr/lib64/php/modules/xdebug.so</span><br><span class="line">xdebug.idekey = &quot;PHPSTORM&quot;</span><br><span class="line">; 因为DBGp调试代理是可以做调试分发的，所以，定义一个IDEKEY，目的是让调试器知道，是不是发给自己的请求</span><br><span class="line"></span><br><span class="line">xdebug.remote_enable = 1</span><br><span class="line">; 设置为1的时候，会先参数链接到remote_host和remote_port指定的调试器端口，如果连接不上，就继续执行，类似设置&gt;了0</span><br><span class="line"></span><br><span class="line">xdebug.remote_mode = &quot;req&quot;</span><br><span class="line">xdebug.remote_handler = &quot;dbgp&quot;</span><br><span class="line">; 也就是调试走哪种协议，有老的PHP3协议，也有GDB协议，DBGP是当前的默认协议，也是当前主流支持的协议</span><br><span class="line"></span><br><span class="line">xdebug.remote_connect_back = 0</span><br><span class="line">; 如果为1，xdebug会通过$_SERVER[‘REMOTE_ADDR’]变量，向发起HTTP请求的客户端发起链接，和remote_host功能类似&gt;，但是优先级比remote_host高，所以，设置了这个选项就会忽略remote_host，由于我的运行时服务器不能主动链接IDE所&gt;在PC，所以不能开启自动回连模式(内网访问外网的网页，也不能开启)</span><br><span class="line"></span><br><span class="line">xdebug.remote_host = &quot;127.0.0.1&quot;</span><br><span class="line">; 默认是主机，如果服务器可以直接你的本地电脑，可以直接填写本机ip，我这里使用xshell做tcp转发</span><br><span class="line"></span><br><span class="line">xdebug.remote_port = 9909</span><br><span class="line">; 默认端口是9000，由于担心服务器端口冲突，我修改为9909，建议你没有端口冲突时不修改</span><br><span class="line"></span><br><span class="line">xdebug.remote_autostart = 0</span><br><span class="line">; 这个为1，会忽略COOKIE或者POST/GET中带的XDEBUG_SESSION参数，不管有没有，都会启动调试，所以，还是设置为0比较好，默认0</span><br></pre></td></tr></table></figure><p>重启php-fpm</p><h1 id="Xshell-TCP转发"><a href="#Xshell-TCP转发" class="headerlink" title="Xshell TCP转发"></a>Xshell TCP转发</h1><p>首先连上你需要配置的服务器或者找到目标服务器的会话设置，然后右键找到<code>属性</code> ，然后找到<code>连接 -&gt; ssh -&gt; 隧道 -&gt; 添加</code>，按如图所示添加，上面配置目标服务器，下面配置本机</p><p><img src="http://github-1253518569.cossh.myqcloud.com/xshell-1.png" alt="配置属性"></p><p><img src="http://github-1253518569.cossh.myqcloud.com/xshell-2.png" alt="配置属性"></p><p><img src="http://github-1253518569.cossh.myqcloud.com/xshell-3.png" alt="tcp转发配置"></p><p>配置完成后分别查看一下 目标服务器的9909 是否被监听</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">netstat -ano | grep 9909</span><br></pre></td></tr></table></figure><h1 id="Sublime配置"><a href="#Sublime配置" class="headerlink" title="Sublime配置"></a>Sublime配置</h1><h2 id="Xdebug配置"><a href="#Xdebug配置" class="headerlink" title="Xdebug配置"></a>Xdebug配置</h2><p>首先通过 <code>package controller</code>安装 <code>xdebug client</code></p><p>然后通过菜单栏的 <code>tool -&gt; Xdebug-&gt; Settings-default</code>， 可以找到xdebug的默认配置（简单摘取）</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">    &quot;path_mapping&quot;: &#123;</span><br><span class="line"></span><br><span class="line">    &#125;,</span><br><span class="line"></span><br><span class="line">    // Determine which URL to launch in the default web browser</span><br><span class="line">    // when starting/stopping a session.</span><br><span class="line">    &quot;url&quot;: &quot;&quot;,</span><br><span class="line">    &quot;ide_key&quot;: &quot;sublime.xdebug&quot;,</span><br><span class="line">    &quot;host&quot;: &quot;&quot;,</span><br><span class="line"></span><br><span class="line">    // Which port number Sublime Text should listen</span><br><span class="line">    // to connect with debugger engine.</span><br><span class="line">    &quot;port&quot;: 9000,</span><br><span class="line"></span><br><span class="line">.</span><br><span class="line">.</span><br><span class="line">.</span><br><span class="line">.</span><br><span class="line">    &quot;python_path&quot; : &quot;&quot;,</span><br><span class="line"></span><br><span class="line">    // Show detailed log information about communication</span><br><span class="line">    // between debugger engine and Sublime Text.</span><br><span class="line">    // Log can be found at Packages/User/Xdebug.log</span><br><span class="line">    &quot;debug&quot;: false</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>参考系统的配置及解释，用户可以自行定义 <code>tool -&gt; Xdebug-&gt; Settings-User</code> ，但是用户一般不是只有一个项目，所以个人还是建议针对于每个 project 进行设置，可以通过菜单栏 <code>Project -&gt; Edit Project</code>， 当然，你需要先创建一个project，这都是小事了。</p><p>附上个人project配置</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">&quot;folders&quot;:</span><br><span class="line">[</span><br><span class="line">&#123;</span><br><span class="line">&quot;path&quot;: &quot;.&quot;</span><br><span class="line">&#125;</span><br><span class="line">],</span><br><span class="line">&quot;settings&quot;: &#123;</span><br><span class="line">&quot;xdebug&quot;: &#123;</span><br><span class="line">&quot;path_mapping&quot;: &#123;</span><br><span class="line">    &quot;/data/www/html/httpserver&quot; : &quot;D:/workplace/cloudserver&quot;</span><br><span class="line">&#125;,</span><br><span class="line">&quot;url&quot;: &quot;http://121.xx.xx.xxx/httpserver/&quot;,</span><br><span class="line">&quot;ide_key&quot;: &quot;PHPSTORM&quot;,</span><br><span class="line">&quot;host&quot;: &quot;0.0.0.0&quot;,</span><br><span class="line">&quot;port&quot;: 9050,</span><br><span class="line">&quot;close_on_stop&quot;: true,</span><br><span class="line">&quot;debug_layout&quot; : &#123;</span><br><span class="line">    &quot;cols&quot;: [0.0, 0.5, 1.0],</span><br><span class="line">    &quot;rows&quot;: [0.0, 0.7, 1.0],</span><br><span class="line">    &quot;cells&quot;: [[0, 0, 2, 1], [0, 1, 1, 2], [1, 1, 2, 2]]</span><br><span class="line">&#125;,</span><br><span class="line">&quot;python_path&quot; : &quot;C:\\Program Files\\Python35\\python.exe&quot;,</span><br><span class="line">&quot;debug&quot;: true</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="SFTP配置"><a href="#SFTP配置" class="headerlink" title="SFTP配置"></a>SFTP配置</h2><p>sftp配置就不多废话了，参考另一篇博客<a href="https://tyloafer.github.io/posts/45096/">Sublime倒腾系列：配置sftp实现文件上传下载</a></p><h1 id="PHPStrom配置"><a href="#PHPStrom配置" class="headerlink" title="PHPStrom配置"></a>PHPStrom配置</h1><h2 id="SFTP配置-1"><a href="#SFTP配置-1" class="headerlink" title="SFTP配置"></a>SFTP配置</h2><p><code>Tools-&gt;Deployment-&gt;Configuration</code>，在弹出的对话框里一次填入用户名，密码，</p><p><img src="http://github-1253518569.cossh.myqcloud.com/phpstrome-1.png" alt="phpstrom sft配置"></p><p>然后右边旁边一个标签页 <code>Mappings</code></p><p><img src="http://github-1253518569.cossh.myqcloud.com/phpstrome-29.png" alt="phpstrom-mapping"></p><p>配置完成后，通过 <code>Tools—&gt;Deployment—&gt;Browse Remote Host</code> 看一下右侧是否会列出远程文件，显示绿色表名是对应上了</p><h2 id="Server配置"><a href="#Server配置" class="headerlink" title="Server配置"></a>Server配置</h2><p>通过 <code>File -&gt; Settings -&gt; Languages &amp; Frameworks -&gt; PHP -&gt; Servers</code>   新建一个Server,输入服务器的IP和端口，最关键的是，将本地工程文件夹和服务器上的文件夹对应起来，方便调试的时候找到源码：</p><p><img src="http://github-1253518569.cossh.myqcloud.com/phpstrome-3.png" alt="phpstrome server配置"></p><h2 id="配置Debug"><a href="#配置Debug" class="headerlink" title="配置Debug"></a>配置Debug</h2><p>通过<code>Run -&gt; Edit Configurations -&gt; PHP Remote Debug</code>，创建一个新的配置，Servers就选择刚才配置的，Ide Key设置为php.ini里面xdebug.idekey设置的， 这里就是 <strong>PHPSTROME</strong></p><p><img src="http://github-1253518569.cossh.myqcloud.com/phpstrom-4.png" alt="phpstrom remote debug"></p><h2 id="调试（全部配置结束后测试）"><a href="#调试（全部配置结束后测试）" class="headerlink" title="调试（全部配置结束后测试）"></a>调试（全部配置结束后测试）</h2><p><img src="http://github-1253518569.cossh.myqcloud.com/phpstrom-5.png" alt="调试"></p><h1 id="Postman配置"><a href="#Postman配置" class="headerlink" title="Postman配置"></a>Postman配置</h1><p>Postman 地址： <a href="https://chrome.google.com/webstore/detail/postman/agkicnjkbankpckaomnhfjglafjcegkk?hl=zh-CN" target="_blank" rel="noopener">谷歌商店</a></p><p>Postman Interceptor 地址： <a href="https://chrome.google.com/webstore/detail/postman-interceptor/aicmkgpgakddgnaphhhpliifpcfhicfo?hl=zh-CN" target="_blank" rel="noopener">谷歌商店</a></p><p>安装完成后，打开<strong>Postman</strong>， 在右上角开启 <strong>Postman Interceptor</strong> 即可设置cookie 进行请求了</p><p><img src="http://github-1253518569.cossh.myqcloud.com/postman-1.png" alt="postman"></p><p>这时候，只要在模拟请求的时候设置一下cookie，在 <strong>phpstrom</strong> 或 <strong>sublime</strong> 设置一下断点就ok了</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Cookie:XDEBUG_SESSION=PHPSTORM</span><br></pre></td></tr></table></figure><p><img src="http://github-1253518569.cossh.myqcloud.com/postman-2.png" alt="postman cookie设置"></p>]]></content>
      
      
      <categories>
          
          <category> PHP </category>
          
      </categories>
      
      
        <tags>
            
            <tag> PHP </tag>
            
            <tag> Xdebug </tag>
            
            <tag> Sublime </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Linux权限控制-ACL</title>
      <link href="/posts/45399/"/>
      <url>/posts/45399/</url>
      
        <content type="html"><![CDATA[<p>在Linux进行权限管理接触最多的应该就是 <code>chmod</code> <code>chown</code> ，但是用的时间长了就会发现很多弊端，很明显的就是root用户用的越来越多， 777权限的文件越来越多，部分原因是开发者过懒导致的，但是简单的<code>chmod</code> <code>chown</code> 会误杀很多用户也是一部分原因。那么接下来就介绍一下更为聪明和牛逼的权限控制—-ACL</p><a id="more"></a><p><strong>访问控制表</strong>（Access Control List，ACL），又称<strong>存取控制串列</strong>，是使用以<a href="https://zh.wikipedia.org/wiki/%E5%AD%98%E5%8F%96%E6%8E%A7%E5%88%B6%E7%9F%A9%E9%99%A3" target="_blank" rel="noopener">访问控制矩阵</a>为基础的访问控制方法，每一个对象对应一个串列主体<br>。访问控制表描述每一个对象各自的访问控制，并记录可对此对象进行访问的所有主体对对象的权限。</p><ul><li><p>Linux文件系统ACL功能</p><p>主要的目的是在提供传统的 owner,group,others 的 read,write,execute 权限之外的细部权限设置。ACL 可以针对单一使用者，单一文件或目录来进行 r,w,x 的权限规范，对于需要特殊权限的使用状况非常有帮助。</p><p>简而言之，ACL功能是为了加强Linux系统文件权限管理。</p></li></ul><h1 id="开启-ACL-权限"><a href="#开启-ACL-权限" class="headerlink" title="开启 ACL 权限"></a>开启 ACL 权限</h1><p>对于CentOS6，系统安装时的分区支持acl,额外的文件系统挂载时需添加acl选项。</p><blockquote><p>mount -o remount, acl [mount point]</p></blockquote><p>对于CentOS7，默认支持acl功能。</p><h1 id="查看和设置文件-ACL-权限"><a href="#查看和设置文件-ACL-权限" class="headerlink" title="查看和设置文件 ACL 权限"></a>查看和设置文件 ACL 权限</h1><p>设置 ACL 权限用<code>setfacl -m [u|g]:[用户名|组名]:权限 文件名</code>命令。<br>查看 ACL 权限用<code>getfacl 文件名</code></p><table><thead><tr><th>选项</th><th>说明</th><th>使用</th></tr></thead><tbody><tr><td>m</td><td>设置 ACL 权限</td><td>setfacl -m [u\</td><td>g]:[用户名 \</td><td>组名]: 权限 文件名</td></tr><tr><td>x</td><td>删除指定 ACL 权限</td><td>setfacl -x [u\</td><td>g]:[用户名 \</td><td>组名] 文件名</td></tr><tr><td>b</td><td>删除全部 ACL 权限</td><td>setfacl -b 文件名</td></tr><tr><td>d</td><td>设定默认 ACL 权限 (子文件继承目录 ACL 权限)</td><td>setfacl -m d:[u\</td><td>g]:[用户名 \</td><td>组名]: 权限 文件名</td></tr><tr><td>k</td><td>删除默认 ACL 权限 (子文件继承目录 ACL 权限)</td><td>setfacl -m</td></tr><tr><td>R</td><td>递归设置 ACL 权限 (容易给文件 x 权限)</td><td>setfacl -m [u\</td><td>g]:[用户名 \</td><td>组名]: 权限 -R 目录名</td></tr></tbody></table><p>eg:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"># 1. 创建权限为drwxrwx---, 用户和用户组为root的dir目录</span><br><span class="line">[root@localhost ~]# mkdir ~ahao/dir </span><br><span class="line">[root@localhost ~]# chmod 770 ~ahao/dir</span><br><span class="line">[root@localhost ~]# ll ~ahao</span><br><span class="line">总用量 0</span><br><span class="line">drwxrwx---. 2 root root 6 11月  4 22:32 dir</span><br><span class="line"></span><br><span class="line"># 2. 操作1: ahao用户尝试进入dir目录失败, 权限不足</span><br><span class="line">[ahao@localhost ~]$ cd dir</span><br><span class="line">-bash: cd: dir: 权限不够</span><br><span class="line"></span><br><span class="line"># 3. root用户设置ACL权限, 给ahao用户赋予rx权限</span><br><span class="line">[root@localhost ~]# setfacl -m u:ahao:rx ~ahao/dir</span><br><span class="line">[ahao@localhost ~]$ ll</span><br><span class="line">总用量 0</span><br><span class="line">drwxrwx---+ 2 root root 6 11月  4 22:32 dir</span><br><span class="line"></span><br><span class="line"># 4. 操作2: ahao用户尝试进入dir目录成功, dir的+权限位代表ACL权限</span><br><span class="line">[ahao@localhost ~]$ cd dir</span><br><span class="line">[ahao@localhost dir]$ # 成功进入dir目录 </span><br><span class="line"></span><br><span class="line"># 5. 操作3: 查看ACL权限</span><br><span class="line">[ahao@localhost dir]$ getfacl ~ahao/dir/ </span><br><span class="line">getfacl: Removing leading &apos;/&apos; from absolute path names</span><br><span class="line"># file: home/ahao/dir/</span><br><span class="line"># owner: root</span><br><span class="line"># group: root</span><br><span class="line">user::rwx</span><br><span class="line">user:ahao:r-x # ACL权限</span><br><span class="line">group::rwx</span><br><span class="line">mask::rwx</span><br><span class="line">other::---</span><br></pre></td></tr></table></figure><h1 id="mask-掩码"><a href="#mask-掩码" class="headerlink" title="mask 掩码"></a>mask 掩码</h1><p>上面的例子在使用<code>getfacl dir</code>之后, 可以看到有一项是<code>mask</code>。<br>这个和默认权限<code>umask</code>差不多, 也是一个权限掩码, 表示所能赋予的权限最大值。<br>这里的<code>mask</code>和<code>ACL权限</code>进行<code>&amp;与</code>运算, 得到的才是真正的<code>ACL权限</code>。<br>用人话讲, 就是</p><blockquote><p>你考一百分是因为实力只有一百分<br>我考一百分是因为总分只有一百分</p></blockquote><p><code>mask</code>限制了权限的最高值。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"># 1. 修改ACL权限mask为r-x</span><br><span class="line">[root@localhost ~]# setfacl -m m:rx ~ahao/tmp/av </span><br><span class="line">[root@localhost ~]# getfacl ~ahao/tmp/av</span><br><span class="line">getfacl: Removing leading &apos;/&apos; from absolute path names</span><br><span class="line"># file: home/ahao/tmp/av</span><br><span class="line"># owner: root</span><br><span class="line"># group: root</span><br><span class="line">user::rwx</span><br><span class="line">group::r-x</span><br><span class="line">mask::r-x # 修改ACL权限mask为r-x</span><br><span class="line">other::---</span><br><span class="line"></span><br><span class="line"># 2. 为用户ahao添加ACL权限rwx</span><br><span class="line">[root@localhost ~]# setfacl -m u:ahao:rwx ~ahao/tmp/av/ </span><br><span class="line">[root@localhost ~]# getfacl ~ahao/tmp/av</span><br><span class="line">getfacl: Removing leading &apos;/&apos; from absolute path names</span><br><span class="line"># file: home/ahao/tmp/av</span><br><span class="line"># owner: root</span><br><span class="line"># group: root</span><br><span class="line">user::rwx</span><br><span class="line">user:ahao:rwx</span><br><span class="line">group::r-x</span><br><span class="line">mask::rwx # 注意, 这里的mask掩码会改变, 因为赋予的ACL权限大于mask</span><br><span class="line">other::---</span><br><span class="line"></span><br><span class="line"># 3. 修改ACL权限mask为r-x</span><br><span class="line">[root@localhost ~]# setfacl -m m:rx ~ahao/tmp/av</span><br><span class="line">[root@localhost ~]# getfacl ~ahao/tmp/av</span><br><span class="line">getfacl: Removing leading &apos;/&apos; from absolute path names</span><br><span class="line"># file: home/ahao/tmp/av</span><br><span class="line"># owner: root</span><br><span class="line"># group: root</span><br><span class="line">user::rwx</span><br><span class="line">user:ahao:rwx#effective:r-x # 这里会提示真实的ACL权限为r-x</span><br><span class="line">group::r-x</span><br><span class="line">mask::r-x # 这里mask不会再改变</span><br><span class="line">other::---</span><br></pre></td></tr></table></figure><ol><li><code>mask</code> 会限制 <code>ACL</code> 权限的最大值。</li><li>赋予<code>ACL</code> 权限大于 <code>mask</code> 的时候, 会将 <code>mask</code> <strong>撑大</strong>。</li></ol>]]></content>
      
      
      <categories>
          
          <category> Linux </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Linux </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Nginx倒腾笔记（六）：Nginx tcp/udp转发</title>
      <link href="/posts/27510/"/>
      <url>/posts/27510/</url>
      
        <content type="html"><![CDATA[<p>前两天给部门做了个数据库的主备用于数据分析，但是后来运维不建议直连备份服务器的3306端口，然后就很尴尬了，然后他们就从程序开始入手，脚本处理binlog，导入导出and so on，从我个人角度来说，我是不喜欢这种方式极度曲线救国的方式的，然后我就没事测试了一下Nginx到tcp转发，当然也只能做个人的小实验了。</p><a id="more"></a><h1 id="配置Nginx"><a href="#配置Nginx" class="headerlink" title="配置Nginx"></a>配置Nginx</h1><p>Nginx的stream模块不仅支持TCP转发，也支持UDP，同时还可以通过socket转发，也是很强大的了。</p><p>配置文件配置如下</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">stream &#123;</span><br><span class="line">server &#123;</span><br><span class="line">listen 1008;</span><br><span class="line"># listen 1008 udp; 通过后面添加udp，可以进行udp的转发</span><br><span class="line">proxy_pass 127.0.0.1:3306;</span><br><span class="line"># proxy_pass unix:/var/lib/mysql/mysql.sock; 将数据转发给socket处理</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="测试"><a href="#测试" class="headerlink" title="测试"></a>测试</h1><p>我们通过<code>1008</code> 端口进行连接数据库尝试一下</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">➜  httpserver master ✗ mysql -uxxxx -pxxxxx -P1008 </span><br><span class="line">mysql: [Warning] Using a password on the command line interface can be insecure.</span><br><span class="line">Reading table information for completion of table and column names</span><br><span class="line">You can turn off this feature to get a quicker startup with -A</span><br><span class="line"></span><br><span class="line">Welcome to the MySQL monitor.  Commands end with ; or \g.</span><br><span class="line">Your MySQL connection id is 5399</span><br><span class="line">Server version: 5.7.22-log MySQL Community Server (GPL)</span><br><span class="line"></span><br><span class="line">Copyright (c) 2000, 2018, Oracle and/or its affiliates. All rights reserved.</span><br><span class="line"></span><br><span class="line">Oracle is a registered trademark of Oracle Corporation and/or its</span><br><span class="line">affiliates. Other names may be trademarks of their respective</span><br><span class="line">owners.</span><br><span class="line"></span><br><span class="line">Type &apos;help;&apos; or &apos;\h&apos; for help. Type &apos;\c&apos; to clear the current input statement.</span><br><span class="line"></span><br><span class="line">mysql&gt; quit</span><br></pre></td></tr></table></figure><p>尝试ok</p><h1 id="进阶"><a href="#进阶" class="headerlink" title="进阶"></a>进阶</h1><p>既然nginx可以进行tcp和udp的转发，那我是否可以代理shadowsock呢？</p><p>配置如下</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">stream &#123;</span><br><span class="line">    server &#123;</span><br><span class="line">        listen 80;</span><br><span class="line">        listen 80 udp;</span><br><span class="line">        proxy_pass 127.0.0.1:xxxx;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>最终，并没有尝试成功，后期有时间找朋友一起抓下包分析一下，暂时就先倒腾到这了</p>]]></content>
      
      
      <categories>
          
          <category> Nginx </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Nginx </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Nginx倒腾笔记（五）：Nginx制作镜像站</title>
      <link href="/posts/42698/"/>
      <url>/posts/42698/</url>
      
        <content type="html"><![CDATA[<p>最开始接触镜像站还是当初在实验室的时候，当时还是一枚小菜鸟，不懂科学上网，然后在学姐的带领下，知道了镜像站的存在，现在虽然已经用不上镜像站了，但是还是想倒腾一下，而Nginx的反向代理正好也可以实现这个功能</p><a id="more"></a><h1 id="代理实现镜像站"><a href="#代理实现镜像站" class="headerlink" title="代理实现镜像站"></a>代理实现镜像站</h1><p>其实，nginx的 <em>proxy_pass</em> 模块就可以实现，配置如下</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">location / &#123;</span><br><span class="line">    proxy_pass https://www.google.com/;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这样，将所有网站的请求都代理到谷歌，然后等待谷歌返回给我们，我们再展示就ok了，效果如下</p><p><img src="http://github-1253518569.cossh.myqcloud.com/mirror-google.png" alt="mirror-google"></p><h1 id="进阶-小偷站"><a href="#进阶-小偷站" class="headerlink" title="进阶-小偷站"></a>进阶-小偷站</h1><p>对于镜像站的实现原理其实是这样的</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">graph TD</span><br><span class="line">st(开始)--&gt;op1(用户)</span><br><span class="line">    op1--数据--&gt;op2(我的服务器)</span><br><span class="line">    op2--用户的信息--&gt;op3(google服务器)</span><br><span class="line">    op3--谷歌返回数据--&gt;op2</span><br><span class="line">    op2--谷歌返回的数据--&gt;op1</span><br></pre></td></tr></table></figure><p>那么，既然数据是从我的服务器上经过的，我能不能将数据修改一下，伪装成我自己的站呢，连数据库都省的装了，答案当然是可以的</p><p>我们这里可以借助Nginx自带的模块 <em>ngx_http_sub_module</em> ，但是这个有点弱，也可以选用 github上的第三方模块  <a href="https://github.com/yaoweibin/ngx_http_substitutions_filter_module" target="_blank" rel="noopener"><em>ngx_http_substitutions_filter_module</em></a>  来处理，安装过程就不赘述了</p><p>配置如下</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">location / &#123;</span><br><span class="line">    proxy_pass https://www.baidu.com/;</span><br><span class="line">    proxy_set_header Accept-Encoding &quot;none&quot;;  # 防止gzip导致的替换失败</span><br><span class="line">    subs_filter_types text/plain text/css text/xml; #替换html、css、xml内容</span><br><span class="line">    subs_filter &apos;百度一下&apos; &apos;tyloafer&apos; g;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>效果如下</p><p><img src="http://github-1253518569.cossh.myqcloud.com/baidu_sub_filter.png" alt="百度替换结果"></p>]]></content>
      
      
      <categories>
          
          <category> Nginx </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Nginx </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>使用binlog还原MySQL中的误操作</title>
      <link href="/posts/39337/"/>
      <url>/posts/39337/</url>
      
        <content type="html"><![CDATA[<p>在操作数据库的时候，总会有些时候那么的手贱，导致数据丢失，如果是测试环境还好，但是要是正式环境，那就删库跑路吧。其实，如果你打开的bin-log，这些操作还是可以被还原的。</p><a id="more"></a><h1 id="开启bin-log"><a href="#开启bin-log" class="headerlink" title="开启bin-log"></a>开启bin-log</h1><p>bin-log是MySQL的主从复制中开启的一个选项，在 <code>/etc/my.cnf</code> 中有两个配置如下</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"># Remove leading # to turn on a very important data integrity option: logging</span><br><span class="line"># changes to the binary log between backups.</span><br><span class="line"># log_bin</span><br><span class="line"></span><br><span class="line"># These are commonly set, remove the # and set as required.</span><br><span class="line"># basedir = .....</span><br><span class="line">#datadir = .....</span><br><span class="line"># port = .....</span><br><span class="line"># server_id = .....</span><br><span class="line"># socket = .....</span><br></pre></td></tr></table></figure><p>其中 我们需要关注的 <code>log_bin</code>  <code>server_id</code> 这两个，配置到你需要的地方即可，<code>server_id</code> 可以随意，主从不要冲突即可，个人配置如下</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">log_bin=/data/logs/mysql/mysql-bin.log   # binlog日志文件</span><br><span class="line">server_id=1</span><br></pre></td></tr></table></figure><p>重启一下MySQL，然后进入数据库，查看一下bin-log的状态</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">mysql&gt; show variables like &apos;log_bin%&apos;;</span><br><span class="line">+---------------------------------+-----------------------------+</span><br><span class="line">| Variable_name                   | Value                       |</span><br><span class="line">+---------------------------------+-----------------------------+</span><br><span class="line">| log_bin                         | ON                          |</span><br><span class="line">| log_bin_basename                | /data/mysql/mysql-bin       |</span><br><span class="line">| log_bin_index                   | /data/mysql/mysql-bin.index |</span><br><span class="line">| log_bin_trust_function_creators | OFF                         |</span><br><span class="line">| log_bin_use_v1_row_events       | OFF                         |</span><br><span class="line">+---------------------------------+-----------------------------+</span><br></pre></td></tr></table></figure><p>其中 <code>log_bin</code> 的值为<code>On</code> 即表明已经开启了 <code>log_bin</code> </p><h1 id="开始手贱吧"><a href="#开始手贱吧" class="headerlink" title="开始手贱吧"></a>开始手贱吧</h1><h2 id="制作点假数据"><a href="#制作点假数据" class="headerlink" title="制作点假数据"></a>制作点假数据</h2><p>我们开始创建点假数据，用于我们的测试</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">mysql&gt; create database test;</span><br><span class="line">mysql&gt; use test;</span><br><span class="line">mysql&gt; create table binlog_test (id int unsigned not null);</span><br><span class="line">mysql&gt; insert into binlog_test values (1), (2), (3), (4), (5);</span><br></pre></td></tr></table></figure><p>先来5条数据，然后我们备份一下这个表，备份之前，先介绍一下<code>--master-data</code>这个参数</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">--master-data[=#]   This causes the binary log position and filename to be</span><br><span class="line">                    appended to the output. If equal to 1, will print it as a</span><br><span class="line">                    CHANGE MASTER command; if equal to 2, that command will</span><br><span class="line">                    be prefixed with a comment symbol. </span><br><span class="line">                    这个参数会在导出的文件中加入此时bin-log的偏移文件和偏移量，</span><br><span class="line">                    如果这个值是1的，会打印出这条命令，如果等于2的话，这条命令</span><br><span class="line">                    将被注释掉</span><br></pre></td></tr></table></figure><p>我们在备份的时候，需要加上这条参数，并将其设置为2，以方便我们查找我们丢失的那部分数据</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">mysqldump -uroot -p --master-data=2 test &gt; test.sql</span><br></pre></td></tr></table></figure><p>备份完成了，我们再加点假数据，最后看一下这些数据会不会还在</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">mysql&gt; insert into binlog_test values (6), (7), (8), (9), (10);</span><br></pre></td></tr></table></figure><h2 id="手贱吧"><a href="#手贱吧" class="headerlink" title="手贱吧"></a>手贱吧</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">mysql&gt; delete from binlog_test;</span><br><span class="line">mysql&gt; drop table binlog_test;</span><br></pre></td></tr></table></figure><p>这样的话，binlog_test表的数据应该全部都没有了。</p><h1 id="开始正文了-恢复数据"><a href="#开始正文了-恢复数据" class="headerlink" title="开始正文了-恢复数据"></a>开始正文了-恢复数据</h1><ol><li><p>先查看一下 备份的偏移</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">λ  /data/mysql  more test.sql </span><br><span class="line">-- MySQL dump 10.13  Distrib 5.7.18, for Linux (x86_64)</span><br><span class="line">--</span><br><span class="line">-- Host: localhost    Database: test</span><br><span class="line">-- ------------------------------------------------------</span><br><span class="line">-- Server version5.7.18-log</span><br><span class="line"></span><br><span class="line">/*!40101 SET @OLD_CHARACTER_SET_CLIENT=@@CHARACTER_SET_CLIENT */;</span><br><span class="line">/*!40101 SET @OLD_CHARACTER_SET_RESULTS=@@CHARACTER_SET_RESULTS */;</span><br><span class="line">/*!40101 SET @OLD_COLLATION_CONNECTION=@@COLLATION_CONNECTION */;</span><br><span class="line">/*!40101 SET NAMES utf8 */;</span><br><span class="line">/*!40103 SET @OLD_TIME_ZONE=@@TIME_ZONE */;</span><br><span class="line">/*!40103 SET TIME_ZONE=&apos;+00:00&apos; */;</span><br><span class="line">/*!40014 SET @OLD_UNIQUE_CHECKS=@@UNIQUE_CHECKS, UNIQUE_CHECKS=0 */;</span><br><span class="line">/*!40014 SET @OLD_FOREIGN_KEY_CHECKS=@@FOREIGN_KEY_CHECKS, FOREIGN_KEY_CHECKS=0 */;</span><br><span class="line">/*!40101 SET @OLD_SQL_MODE=@@SQL_MODE, SQL_MODE=&apos;NO_AUTO_VALUE_ON_ZERO&apos; */;</span><br><span class="line">/*!40111 SET @OLD_SQL_NOTES=@@SQL_NOTES, SQL_NOTES=0 */;</span><br><span class="line"></span><br><span class="line">--</span><br><span class="line">-- Position to start replication or point-in-time recovery from</span><br><span class="line">--</span><br><span class="line"></span><br><span class="line">-- CHANGE MASTER TO MASTER_LOG_FILE=&apos;mysql-bin.000002&apos;, MASTER_LOG_POS=627;</span><br></pre></td></tr></table></figure><p>从备份的sql文件可以看到，我们备份的偏移文件是 <em>mysql-bin.000002</em> ，偏移量是 <em>627</em></p></li><li><p>查看手贱命令的偏移</p><p>我们这时候应该就是查找一下 我们执行的delete操作的偏移</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">λ  /data/mysql  mysqlbinlog --base64-output=decode-rows mysql-bin.000002 | grep Delete -8</span><br><span class="line"># at 974</span><br><span class="line">#180717 16:37:59 server id 1  end_log_pos 1046 CRC32 0x19b80686 Querythread_id=6exec_time=0error_code=0</span><br><span class="line">SET TIMESTAMP=1531816679/*!*/;</span><br><span class="line">BEGIN</span><br><span class="line">/*!*/;</span><br><span class="line"># at 1046</span><br><span class="line">#180717 16:37:59 server id 1  end_log_pos 1100 CRC32 0x2daa51e1 Table_map: `test`.`binlog_test` mapped to number 514</span><br><span class="line"># at 1100</span><br><span class="line">#180717 16:37:59 server id 1  end_log_pos 1185 CRC32 0x05ebafa5 Delete_rows: table id 514 flags: STMT_END_F</span><br><span class="line"># at 1185</span><br><span class="line">#180717 16:37:59 server id 1  end_log_pos 1216 CRC32 0x56c7fe9e Xid = 80</span><br><span class="line">COMMIT/*!*/;</span><br><span class="line"># at 1216</span><br><span class="line">#180717 16:44:14 server id 1  end_log_pos 1281 CRC32 0xa285c84c Anonymous_GTIDlast_committed=4sequence_number=5</span><br><span class="line">SET @@SESSION.GTID_NEXT= &apos;ANONYMOUS&apos;/*!*/;</span><br><span class="line"># at 1281</span><br><span class="line">#180717 16:44:14 server id 1  end_log_pos 1405 CRC32 0x4474e0a7 Querythread_id=10exec_time=0error_code=0</span><br></pre></td></tr></table></figure><p>我们可以看到，在第10行的时候进行了删除操作，在第8行进行了表的map映射查找，那我们这时候，将结束的偏移就可以定位到 <em>mysql-bin.000002</em> 的 <em>1100</em> position</p></li><li><p>生成备份到手贱这段时间的数据</p><p>由于，我们仅仅对test库进行处理，所以我们可以在使用<code>mysqbinlog</code> 处理的时候指定<code>test</code> 库即可，主要用到了以下几个参数，可参考</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">λ  /data/mysql  mysqlbinlog --help | grep position -8</span><br><span class="line"> -j, --start-position=# </span><br><span class="line">                      Start reading the binlog at position N. Applies to the</span><br><span class="line">                      first binlog passed on the command line.</span><br><span class="line"> --stop-position=#   Stop reading the binlog at position N. Applies to the</span><br><span class="line">                      last binlog passed on the command line.</span><br><span class="line"> -d, --database=name List entries for just this database (local log only).</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">mysqlbinlog --start-position=627 --stop-position=1100 --database=test  mysql-bin.000002 &gt; binlog_test_drop.sql</span><br></pre></td></tr></table></figure><p>这样，我们需要的原始备份文件，和中间缺失的时间段的备份文件就都生成好了，下一步就可以恢复了</p></li><li><p>恢复</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">mysql -uroot -p test &lt; test.sql</span><br><span class="line"> mysql -uroot -p test &lt; binlog_test_drop.sql</span><br></pre></td></tr></table></figure></li><li><p>查看一下吧</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">mysql&gt; select * from binlog_test;</span><br><span class="line">+----+</span><br><span class="line">| id |</span><br><span class="line">+----+</span><br><span class="line">|  1 |</span><br><span class="line">|  2 |</span><br><span class="line">|  3 |</span><br><span class="line">|  4 |</span><br><span class="line">|  5 |</span><br><span class="line">|  6 |</span><br><span class="line">|  7 |</span><br><span class="line">|  8 |</span><br><span class="line">|  9 |</span><br><span class="line">| 10 |</span><br><span class="line">+----+</span><br></pre></td></tr></table></figure><p>至此，基本大功告成了，当然bin-log不仅仅是用来恢复数据的，上文也讲过了，MySQL的主从就是要依靠他来完成的，下一篇文章<a href="http://tyloafer.github.io/posts/42030/">《MySQL主从配置》</a>将会简单的介绍一下</p></li></ol>]]></content>
      
      
      <categories>
          
          <category> DataBase </category>
          
      </categories>
      
      
        <tags>
            
            <tag> MySQL </tag>
            
            <tag> DataBase </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>MySQL主从配置</title>
      <link href="/posts/42030/"/>
      <url>/posts/42030/</url>
      
        <content type="html"><![CDATA[<p><strong>MySQL主从复制原理：</strong>master服务器将数据的改变记录二进制日志，当master上的数据发生改变时，则将其改变写入二进制日志中，salve服务器会在一定时间间隔内对master二进制日志进行探测其是否发生改变，如果发生改变，则开始一个I/OThread请求master二进制事件，同时主节点为每个I/O线程启动一个dump线程，用于向其发送二进制事件，并保存至从节点本地的中继日志中，从节点将启动SQL线程从中继日志中读取二进制日志，在本地重放，使得其数据和主节点的保持一致，最后I/OThread和SQLThread将进入睡眠状态，等待下一次被唤醒。</p><p>接下来将会记录一下具体实现</p><a id="more"></a><h1 id="Master设置"><a href="#Master设置" class="headerlink" title="Master设置"></a>Master设置</h1><ol><li><p>开启mysql的bin-log，主备是基于二进制日志的</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"># master</span><br><span class="line">log-bin=/var/lib/mysql/mysql-bin</span><br><span class="line">server-id=1</span><br></pre></td></tr></table></figure><p>配置里面的<em>server-id</em> 是可以随意设置的，但是要保证在集群中的唯一性，</p></li><li><p>重启mysql，让设置生效</p></li><li><p>创建一个备份账号</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">GRANT REPLICATION SLAVE ON *.* to &apos;username&apos;@&apos;ip&apos; identified by &apos;password&apos;;</span><br></pre></td></tr></table></figure></li><li><p>导出master的数据，并且记录导出时的bin-log偏移</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">mysqldump -uroot -p --master-data=2  --all-databases &gt; all_databases.sql</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">➜  /data/www/html  ✗ more httpserver.sql</span><br><span class="line">--</span><br><span class="line">-- Position to start replication or point-in-time recovery from</span><br><span class="line">--</span><br><span class="line"></span><br><span class="line">-- CHANGE MASTER TO MASTER_LOG_FILE=&apos;mysql-bin.000001&apos;, MASTER_LOG_POS=750663;</span><br></pre></td></tr></table></figure><p>命令中的 <em>–master-data=2</em> 是为了将 <em>CHANGE MASTER TO MASTER_LOG_FILE=’mysql-bin.000001’, MASTER_LOG_POS=750663;</em>  进行注释，这里记录的 log_file和 log_pos 将会在备份服务器的设置上使用</p></li></ol><h1 id="Slave设置"><a href="#Slave设置" class="headerlink" title="Slave设置"></a>Slave设置</h1><ol><li><p>首先设置server-id，在 <code>my.cnf</code> 中加入</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"># replicate</span><br><span class="line">log-bin=/var/lib/mysql/mysql-bin   // 可以不开启</span><br><span class="line">server-id=2    // 这个值不可与master相同</span><br><span class="line">replicate-do-db = db1,db2///   // 选择需要同步的数据库，不写则全部同步</span><br></pre></td></tr></table></figure></li><li><p>重启mysql</p></li><li><p>导入数据</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">mysql -uroot -p &lt; all_databases.sql</span><br></pre></td></tr></table></figure></li><li><p>设置master信息</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">mysql root@localhost:(none)&gt;  change master to master_host=&apos;ip&apos;,master_user=&apos;user&apos;,master_password=&apos;password&apos;, master_log_file=&apos;mysql-bin.000001&apos;,master_log_pos=750663;</span><br></pre></td></tr></table></figure><p>这天命令中的 <em>master_log_file=’mysql-bin.000001’,master_log_pos=750663;</em>  便是上面sql文件中注释的内容</p></li><li><p>开启同步</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">mysql root@localhost:(none)&gt;  start slave</span><br></pre></td></tr></table></figure></li><li><p>查看slave状态</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">mysql root@localhost:(none)&gt; show slave status\G</span><br><span class="line"></span><br><span class="line">   *************************** 1. row ***************************</span><br><span class="line"></span><br><span class="line">              Slave_IO_State: Waiting for master to send event</span><br><span class="line">              Master_Host: ip  //主服务器地址</span><br><span class="line">              Master_User: user   //授权帐户名，尽量避免使用root</span><br><span class="line">              Master_Port: 3306    //数据库端口，部分版本没有此行</span><br><span class="line">              Connect_Retry: 60</span><br><span class="line">              Master_Log_File: mysql-bin.000004</span><br><span class="line">              Read_Master_Log_Pos: 600     //#同步读取二进制日志的位置，大于等于Exec_Master_Log_Pos</span><br><span class="line">              Relay_Log_File: ddte-relay-bin.000003</span><br><span class="line">              Relay_Log_Pos: 251</span><br><span class="line">              Relay_Master_Log_File: mysql-bin.000004</span><br><span class="line">              Slave_IO_Running: Yes    //此状态必须YES</span><br><span class="line">              Slave_SQL_Running: Yes     //此状态必须YES</span><br></pre></td></tr></table></figure></li></ol>]]></content>
      
      
      <categories>
          
          <category> DataBase </category>
          
      </categories>
      
      
        <tags>
            
            <tag> MySQL </tag>
            
            <tag> DataBase </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Nginx倒腾笔记（四）：rewrite使用介绍</title>
      <link href="/posts/25652/"/>
      <url>/posts/25652/</url>
      
        <content type="html"><![CDATA[<h2 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h2><table><thead><tr><th>key</th><th>value</th></tr></thead><tbody><tr><td>语法:</td><td><code>rewrite regex replacement [flag];</code></td></tr><tr><td>默认值:</td><td>—</td></tr><tr><td>上下文:</td><td><code>server</code>, <code>location</code>, <code>if</code></td></tr></tbody></table><a id="more"></a><h2 id="flag"><a href="#flag" class="headerlink" title="flag"></a>flag</h2><ul><li><code>last</code>       # 停止执行当前这一轮的<code>ngx_http_rewrite_module</code>指令集，然后查找匹配改变后URI的新location；</li><li><code>break</code>      # 停止执行当前这一轮的<code>ngx_http_rewrite_module</code>指令集；</li><li><code>redirect</code>         # 在replacement字符串未以“<code>http://</code>”或“<code>https://</code>”开头时，使用返回状态码为302的临时重定向；</li><li><code>permanent</code>        # 返回状态码为301的永久重定向。</li></ul><h2 id="例"><a href="#例" class="headerlink" title="例"></a>例</h2><p>针对于<code>last</code> 和 <code>break</code> 举例</p><ol><li><p>先测试last</p><p>nginx配置</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">location ~ /rewrite/last &#123;</span><br><span class="line">    rewrite .* /rewrite/break.html last;</span><br><span class="line">&#125;   </span><br><span class="line"></span><br><span class="line">location ~ /rewrite/break &#123;</span><br><span class="line">retorn 200 &apos;break&apos;;</span><br><span class="line">    rewrite .* /last.html break;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>GET <a href="http://test.tyloafer.cn/rewrite/last" target="_blank" rel="noopener">http://test.tyloafer.cn/rewrite/last</a></p><p>结果： break</p></blockquote><p>上面结果表明，当我们第一次请求匹配到 <code>/rewrite/last</code> 的时候，我们此时应该把uri 重写成了 <code>http://test.tyloafer.cn/rewrite/break.html</code>, 然后拿着这个uri后找 nginx解析，从而匹配到了 第二个location</p><p>即， 当我们使用 <code>last</code> 的时候，nginx会拿着解析后的uri再次进行解析</p></li><li><p>再测试last</p><p>nginx配置</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">location ~ /rewrite/last &#123;</span><br><span class="line">return 200 'last';</span><br><span class="line">    rewrite .* /rewrite/break.html last;</span><br><span class="line">&#125;   </span><br><span class="line"></span><br><span class="line">location ~ /rewrite/break &#123;</span><br><span class="line">    rewrite .* /last.html break;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>last.html</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">this is last.html</span><br></pre></td></tr></table></figure><blockquote><p>GET <a href="http://test.tyloafer.cn/rewrite/break" target="_blank" rel="noopener">http://test.tyloafer.cn/rewrite/break</a></p><p>结果： this is last.html</p></blockquote><p>上面结果表明，当我们第一次请求匹配到 <code>/rewrite/break的时候，我们此时应该把uri 重写成了</code><a href="http://test.tyloafer.cn/rewrite/blast.html`" target="_blank" rel="noopener">http://test.tyloafer.cn/rewrite/blast.html`</a>, 然后拿着这个uri后， 直接去找相应的文件了</p><p>即， 当我们使用 <code>break</code> 的时候，nginx会拿着解析后的uri不在解析，就随他去吧</p></li></ol>]]></content>
      
      
      <categories>
          
          <category> Nginx </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Nginx </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>在Vultr（centos7）上安装shadowsock及Google BBR实现全速翻墙</title>
      <link href="/posts/1/"/>
      <url>/posts/1/</url>
      
        <content type="html"><![CDATA[<p>对于程序猿来说，百度就是一个坑的存在，找一个问题，前面几页都是抄袭、雷同的问题，还有若干的百度经验，但是，对于近期的墙是越来越厚了，各种ss账号都失效了，无奈开始自己动手搭梯子吧。通过网上各种对比后，最后选了了<a href="https://www.vultr.com/?ref=7290537" target="_blank" rel="noopener"> Vultr</a> , 安装Google BBR后基本可以满速翻墙，而且，最强大的是，可以更换IP，现在最便宜的套餐 2.5$每月，500G的流量，也是足够了</p><blockquote><p><a href="https://www.vultr.com/?ref=7540935" target="_blank" rel="noopener">Vultr官网注册地址</a></p></blockquote><a id="more"></a><p>下面开始介绍安装配置过程，当然不仅局限于 Vultr的服务器，CentOS7的都可以参考。</p><h1 id="安装pip"><a href="#安装pip" class="headerlink" title="安装pip"></a>安装pip</h1><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">yum install python python-pip</span><br><span class="line">pip install --upgrade pip</span><br></pre></td></tr></table></figure><h1 id="安装配置shadowsock"><a href="#安装配置shadowsock" class="headerlink" title="安装配置shadowsock"></a>安装配置shadowsock</h1><h2 id="安装shadowsock"><a href="#安装shadowsock" class="headerlink" title="安装shadowsock"></a>安装shadowsock</h2><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">pip install shadowsocks</span><br></pre></td></tr></table></figure><p>这样就安装完成了shadowsock</p><h2 id="配置shadowsock"><a href="#配置shadowsock" class="headerlink" title="配置shadowsock"></a>配置shadowsock</h2><p>首先要创建配置文件，然后shadowsock用这个配置文件启动即可</p><p>个人习惯将配置文件放在 <code>/etc</code> 目录下</p><p>所以，这里首先创建文件 <code>/etc/shadowsocks.json</code> ，并添加一下内容</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">      &quot;server&quot;:&quot;0.0.0.0&quot;,</span><br><span class="line">      &quot;server_port&quot;:2082,</span><br><span class="line">      &quot;local_port&quot;:1080,</span><br><span class="line">      &quot;password&quot;:&quot;yourpass&quot;,</span><br><span class="line">      &quot;timeout&quot;:600,</span><br><span class="line">      &quot;method&quot;:&quot;rc4-md5&quot;</span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure><p>如果想要创建多用户的， 可以使用下面的配置文件格式</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">#### 多用户版本</span><br><span class="line">&#123;</span><br><span class="line">    &quot;server&quot;:&quot;0.0.0.0&quot;,</span><br><span class="line">    &quot;local_port&quot;:1080,</span><br><span class="line">    &quot;port_password&quot;:&#123;</span><br><span class="line">         &quot;8989&quot;:&quot;password0&quot;,</span><br><span class="line">         &quot;9001&quot;:&quot;password1&quot;,</span><br><span class="line">         &quot;9002&quot;:&quot;password2&quot;,</span><br><span class="line">         &quot;9003&quot;:&quot;password3&quot;,</span><br><span class="line">         &quot;9004&quot;:&quot;password4&quot;</span><br><span class="line">    &#125;,</span><br><span class="line">    &quot;timeout&quot;:300,</span><br><span class="line">    &quot;method&quot;:&quot;aes-256-cfb&quot;,</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>说明：</p><ul><li><code>method</code>为加密方法，可选<code>aes-128-cfb, aes-192-cfb, aes-256-cfb, bf-cfb, cast5-cfb, des-cfb, rc4-md5, chacha20, salsa20, rc4, table</code></li><li><code>server_port</code>  为服务监听端口， 这个需要在 vultr或者服务器管理界面开启</li><li><code>port_password</code> 为多用户的时候，配置的 port: pass 的json串</li></ul><h2 id="配置自启动"><a href="#配置自启动" class="headerlink" title="配置自启动"></a>配置自启动</h2><p>新建启动脚本文件<code>/etc/systemd/system/shadowsocks.service</code>，内容如下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">[Unit]</span><br><span class="line">Description=Shadowsocks</span><br><span class="line"></span><br><span class="line">[Service]</span><br><span class="line">TimeoutStartSec=0</span><br><span class="line">ExecStart=/usr/bin/ssserver -c /etc/shadowsocks.json</span><br><span class="line"></span><br><span class="line">[Install]</span><br><span class="line">WantedBy=multi-user.target</span><br></pre></td></tr></table></figure><p>执行以下命令启动 shadowsocks 服务：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">systemctl enable shadowsocks  # 启用服务</span><br><span class="line">systemctl start shadowsocks   # 启动服务</span><br><span class="line">systemctl stop shadowsocks   # 停止服务</span><br></pre></td></tr></table></figure><p>注： 如果使用多用户的模式，有可能无法使用 system 来启动，可以使用下面的命令来启动</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">/usr/bin/ssserver -c /etc/shadowsocks.json -d start # 启动</span><br><span class="line">/usr/bin/ssserver -c /etc/shadowsocks.json -d stop  # 停止</span><br></pre></td></tr></table></figure><h1 id="安装BBR加速"><a href="#安装BBR加速" class="headerlink" title="安装BBR加速"></a>安装BBR加速</h1><blockquote><p><strong>注意: </strong>需要内核4.9及以上版本，可使用<code>uname -r</code>查看。</p></blockquote><p>最简单的方法就是使用Google BBR一键安装脚本。</p><ol><li><p>获取脚本并执行(root)</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">wget --no-check-certificate https://github.com/teddysun/across/raw/master/bbr.sh</span><br><span class="line">sh ./bbr.sh</span><br></pre></td></tr></table></figure></li><li><p>查看内核版本是否 &gt; 4.9 </p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">uname -r</span><br></pre></td></tr></table></figure></li><li><p>执行 <code>sysctl net.ipv4.tcp_available_congestion_control</code> ， 查看是否返回</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">net.ipv4.tcp_available_congestion_control = reno cubic bbr</span><br></pre></td></tr></table></figure></li><li><p>执行<code>sysctl net.core.default_qdisc</code> ， 查看是否返回</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">net.core.default_qdisc = fq</span><br></pre></td></tr></table></figure></li><li><p>执行 <code>lsmod | grep bbr</code>， 返回值有tcp_bbr 即已启动</p></li></ol><p>安装完成后，脚本会提示需要重启 VPS，输入 y 并回车后重启。</p>]]></content>
      
      
      <categories>
          
          <category> ShadowSock </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 科学上网 </tag>
            
            <tag> ShadowSock </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Nginx倒腾笔记（三）：条件判断及运算符</title>
      <link href="/posts/211/"/>
      <url>/posts/211/</url>
      
        <content type="html"><![CDATA[<h2 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h2><table><thead><tr><th>key</th><th>value</th></tr></thead><tbody><tr><td>语法:</td><td><code>if (condition) { ... }</code></td></tr><tr><td>默认值:</td><td>—</td></tr><tr><td>上下文:</td><td><code>server</code>, <code>location</code></td></tr></tbody></table><a id="more"></a><h2 id="condition"><a href="#condition" class="headerlink" title="condition"></a>condition</h2><ul><li>变量名；如果变量值为空或者是以“<code>0</code>”开始的字符串，则条件为假；</li><li>使用“<code>=</code>”和“<code>!=</code>”运算符比较变量和字符串；</li><li>使用“<code>~</code>”（大小写敏感）和“<code>~*</code>”（大小写不敏感）运算符匹配变量和正则表达式。正则表达式可以包含匹配组，匹配结果后续可以使用变量<code>$1</code>..<code>$9</code>引用。如果正则表达式中包含字符“<code>}</code>”或者“<code>;</code>”，整个表达式应该被包含在单引号或双引号的引用中。</li><li>使用“<code>-f</code>”和“<code>!-f</code>”运算符检查文件是否存在；</li><li>使用“<code>-d</code>”和“<code>!-d</code>”运算符检查目录是否存在；</li><li>使用“<code>-e</code>”和“<code>!-e</code>”运算符检查文件、目录或符号链接是否存在；</li><li>使用“<code>-x</code>”和“<code>!-x</code>”运算符检查可执行文件；</li></ul><h2 id="例"><a href="#例" class="headerlink" title="例"></a>例</h2><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">if ($http_user_agent ~ MSIE) &#123;</span><br><span class="line">    return 200 'IE &gt;_&gt;';</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">if ($http_cookie ~* "id=([^;]+)(?:;|$)") &#123;</span><br><span class="line">    set $id $1;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">if ($http_refer != 'test.tyloafer.cn') &#123;</span><br><span class="line">    return 403;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">if ($vip) &#123;</span><br><span class="line">    limit_rate 10k;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">if (!-e $request_uri) &#123;</span><br><span class="line">    rewrite /(.*)$ /index.php?r=$request_uri;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="扩展（逻辑运算实现）"><a href="#扩展（逻辑运算实现）" class="headerlink" title="扩展（逻辑运算实现）"></a>扩展（逻辑运算实现）</h2><p>有时间为了实现需求，我们可能避免不了要使用逻辑运算， 但是nginx并未提供，所以，我们这时候只有通过 设置变量的值 来变相的实现逻辑运算了</p><p>需求</p><figure class="highlight nginx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="attribute">if</span> (!-e <span class="variable">$request_uri</span> &amp;&amp; !-d <span class="variable">$request_uri</span>) &#123;</span><br><span class="line">    <span class="attribute">return</span> <span class="number">404</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>实现</p><figure class="highlight nginx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="attribute">set</span> <span class="variable">$flag</span>  <span class="number">0</span>;</span><br><span class="line"><span class="attribute">if</span> (!-e <span class="variable">$request_uri</span>) &#123;</span><br><span class="line">    <span class="attribute">set</span> set <span class="variable">$flag</span> <span class="string">"<span class="variable">$&#123;flag&#125;</span>1"</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="attribute">if</span> (!-d <span class="variable">$request_uri</span>) &#123;</span><br><span class="line">    <span class="attribute">set</span> <span class="variable">$flag</span> <span class="string">"<span class="variable">$&#123;flag&#125;</span>1"</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="attribute">if</span> (<span class="variable">$flag</span> = <span class="string">'011'</span>) &#123;</span><br><span class="line">    <span class="attribute">return</span> <span class="number">404</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> Nginx </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Nginx </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Nginx倒腾笔记（二）：状态码</title>
      <link href="/posts/48459/"/>
      <url>/posts/48459/</url>
      
        <content type="html"><![CDATA[<p>这里记录了一下Nginx使用过程中常见的状态码，仅仅是做了一下解释，如果遇到下面的问题，可以到根据所代表的意义，去相应的应用程序查看 error log，以此来找出对应的解决方案</p><a id="more"></a><table><thead><tr><th>类别</th><th>状态码</th><th>状态意义</th></tr></thead><tbody><tr><td><strong>消息类(1字头)</strong></td><td></td><td></td></tr><tr><td><strong>成功类（2字头）</strong></td><td>200</td><td>成功处理请求</td></tr><tr><td><strong>重定向累（3字头）</strong></td><td>301</td><td>永久重定向</td></tr><tr><td></td><td>302</td><td>临时重定向</td></tr><tr><td></td><td>304</td><td>未修改，走缓存</td></tr><tr><td><strong>请求错误类（4字头）</strong></td><td>400</td><td>服务器不理解请求的语法。</td></tr><tr><td></td><td>401</td><td>请求要求身份验证。 对于需要登录的网页，服务器可能返回此响应。</td></tr><tr><td></td><td>403</td><td>服务器拒绝请求</td></tr><tr><td></td><td>404</td><td>没有找到资源</td></tr><tr><td></td><td>499</td><td>客户端主动断开连接</td></tr><tr><td><strong>服务器错误类（5字头）</strong></td><td>500</td><td>服务器遇到错误，无法完成请求</td></tr><tr><td></td><td>502</td><td>网关出错</td></tr><tr><td></td><td>504</td><td>服务端处理请求超时</td></tr></tbody></table>]]></content>
      
      
      <categories>
          
          <category> Nginx </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Nginx </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Nginx倒腾笔记（一）：变量</title>
      <link href="/posts/62480/"/>
      <url>/posts/62480/</url>
      
        <content type="html"><![CDATA[<p>nginx在使用过程中最基础的应该就是 变量了， 不然在rewite或location匹配的时候，有可能就无从下手了，在这里，个人整理了一下nginx的变量，并做了一下简单的测试，仅供参考</p><a id="more"></a><h1 id="内置变量"><a href="#内置变量" class="headerlink" title="内置变量"></a>内置变量</h1><h2 id="介绍"><a href="#介绍" class="headerlink" title="介绍"></a>介绍</h2><ul><li><p>$args ： 这个变量等于请求行中的参数，同\$query_string</p></li><li><p>$content_length ： 请求头中的Content-length字段。</p></li><li><p>$content_type ： 请求头中的Content-Type字段。</p></li><li><p>$document_root ： 当前请求在root指令中指定的值。</p></li><li><p>$host ： 请求主机头字段，否则为服务器名称。</p></li><li><p>$http_user_agent ： 客户端agent信息</p></li><li><p>$http_cookie ： 客户端cookie信息</p></li><li><p>$limit_rate ： 这个变量可以限制连接速率。</p></li><li><p>$request_method ： 客户端请求的动作，通常为GET或POST。</p></li><li><p>$remote_addr ： 客户端的IP地址。</p></li><li><p>$remote_port ： 客户端的端口。</p></li><li><p>$remote_user ： 已经经过Auth Basic Module验证的用户名。</p></li><li><p>$request_filename ： 当前请求的文件路径，由root或alias指令与URI请求生成。</p></li><li><p>$scheme ： HTTP方法（如http，https）。</p></li><li><p>$server_protocol ： 请求使用的协议，通常是HTTP/1.0或HTTP/1.1。</p></li><li><p>$server_addr ： 服务器地址，在完成一次系统调用后可以确定这个值。</p></li><li><p>$server_name ： 服务器名称。</p></li><li><p>$server_port ： 请求到达服务器的端口号。</p></li><li><p>$request_uri ： 包含请求参数的原始URI，不包含主机名，如：”/foo/bar.php?arg=baz”。</p></li><li><p>$uri ： 不带请求参数的当前URI，\$uri不包含主机名，如”/foo/bar.html”。</p></li><li><p>\$document_uri ： 与$uri相同。</p></li></ul><h2 id="例"><a href="#例" class="headerlink" title="例"></a>例</h2><p>我们以GET方式请求 <code>http://test.tyloafer.cn/variable?a=1&amp;b=2&amp;c=3</code> 为例</p><p>nginx配置如下</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line">location = /variable &#123;</span><br><span class="line">    add_header  Content-Type &apos;text/html; charset=utf-8&apos;;</span><br><span class="line">    return 200 &quot;</span><br><span class="line">        args = $args&lt;br /&gt;</span><br><span class="line">        binary_remote_addr = $binary_remote_addr&lt;br /&gt;</span><br><span class="line">        body_bytes_sent = $body_bytes_sent&lt;br /&gt;</span><br><span class="line">        content_length = $content_length&lt;br /&gt;</span><br><span class="line">        content_type= $content_type&lt;br /&gt;</span><br><span class="line">        document_root = $document_root&lt;br /&gt;</span><br><span class="line">        document_uri = $document_uri&lt;br /&gt;</span><br><span class="line">        host = $host&lt;br /&gt;</span><br><span class="line">        hostname   = $hostname&lt;br /&gt;</span><br><span class="line">        http_user_agent = $http_user_agent&lt;br /&gt;</span><br><span class="line">        is_args = $is_args&lt;br /&gt;</span><br><span class="line">        limit_rate  = $limit_rate&lt;br /&gt;</span><br><span class="line">        nginx_version  = $nginx_version&lt;br /&gt;</span><br><span class="line">        query_string  = $query_string&lt;br /&gt;</span><br><span class="line">        remote_addr  = $remote_addr&lt;br /&gt;</span><br><span class="line">        remote_port  = $remote_port&lt;br /&gt;</span><br><span class="line">        request_filename = $request_filename&lt;br /&gt;</span><br><span class="line">        request_body  = $request_body&lt;br /&gt;</span><br><span class="line">        request_body_file  = $request_body_file&lt;br /&gt;</span><br><span class="line">        request_completion  = $request_completion&lt;br /&gt;</span><br><span class="line">        request_method  = $request_method&lt;br /&gt;</span><br><span class="line">        request_uri  = $request_uri&lt;br /&gt;</span><br><span class="line">        scheme  = $scheme&lt;br /&gt;</span><br><span class="line">        server_addr  = $server_addr&lt;br /&gt;</span><br><span class="line">        server_name  = $server_name&lt;br /&gt;</span><br><span class="line">        server_port  = $server_port&lt;br /&gt;</span><br><span class="line">        server_protocol  = $server_protocol&lt;br /&gt;&quot;;</span><br><span class="line">    </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>GET <a href="http://test.tyloafer.cn/variable?a=1&amp;b=2&amp;c=3" target="_blank" rel="noopener">http://test.tyloafer.cn/variable?a=1&amp;b=2&amp;c=3</a></p></blockquote><p>返回</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line">args = a=1&amp;b=2&amp;c=3</span><br><span class="line">binary_remote_addr = s�i�</span><br><span class="line">body_bytes_sent = 0</span><br><span class="line">content_length = </span><br><span class="line">content_type= </span><br><span class="line">document_root = /usr/share/nginx/html</span><br><span class="line">document_uri = /variable</span><br><span class="line">host = test.tyloafer.cn</span><br><span class="line">hostname = vm_248_128_centos</span><br><span class="line">http_user_agent = Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/66.0.3359.170 Safari/537.36</span><br><span class="line">is_args = ?</span><br><span class="line">limit_rate = 0</span><br><span class="line">nginx_version = 1.12.2</span><br><span class="line">query_string = a=1&amp;b=2&amp;c=3</span><br><span class="line">remote_addr = 115.216.105.144</span><br><span class="line">remote_port = 10212</span><br><span class="line">request_filename = /usr/share/nginx/html/variable</span><br><span class="line">request_body = </span><br><span class="line">request_body_file = </span><br><span class="line">request_completion = </span><br><span class="line">request_method = GET</span><br><span class="line">request_uri = /variable?a=1&amp;b=2&amp;c=3</span><br><span class="line">scheme = http</span><br><span class="line">server_addr = 10.105.248.128</span><br><span class="line">server_name = test.tyloafer.cn</span><br><span class="line">server_port = 80</span><br><span class="line">server_protocol = HTTP/1.1</span><br></pre></td></tr></table></figure><h1 id="自定义变量"><a href="#自定义变量" class="headerlink" title="自定义变量"></a>自定义变量</h1><p>nginx配置如下</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">location ~ /self-variable &#123;</span><br><span class="line">    set $path &apos;tyloafer&apos;;</span><br><span class="line">    return 200 $path;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>GET <a href="http://test.tyloafer.cn/self-variable" target="_blank" rel="noopener">http://test.tyloafer.cn/self-variable</a></p></blockquote><p>返回</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">tyloafer</span><br></pre></td></tr></table></figure><p>注：nginx的变量赋值跟 <em>shell</em> 是一样的，一样也可以使用 <em>{}</em> ，例： ${path} </p><h1 id="自动设置的变量"><a href="#自动设置的变量" class="headerlink" title="自动设置的变量"></a>自动设置的变量</h1><p>我们在使用正则匹配的时候，会自动将匹配结果 赋值给 \$1 \$2 这样的 \${<em>num</em>} 这样类型的变量</p><p>nginx配置如下</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">location ~ /self-variable(/)(.*)$ &#123;            </span><br><span class="line">     set $path &apos;tyloafer&apos;;                      </span><br><span class="line">     return 200 &quot;path = $path , 1 = $1 , 2 = $2&quot;;</span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure><blockquote><p>GET <a href="http://test.tyloafer.cn/self-variable/haha" target="_blank" rel="noopener">http://test.tyloafer.cn/self-variable/haha</a></p></blockquote><p>返回</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">path = tyloafer , 1 = / , 2 = haha</span><br></pre></td></tr></table></figure><p>例：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">location ~ /self-variable(/)(.*)$ &#123;            </span><br><span class="line">    set $path &apos;tyloafer&apos;;</span><br><span class="line">    if ($request_uri ~ &apos;haha&apos;) &#123;</span><br><span class="line">        return 200 $1;</span><br><span class="line">    &#125; </span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure><p>这时候 在进行第一次location正则匹配是产生的\$1， 在进行第二次 <code>$request_uri ~ &#39;haha&#39;</code> 正则匹配的时候会被覆盖，所以这时候，返回的是空白的，并不是上面的 <code>/</code></p>]]></content>
      
      
      <categories>
          
          <category> Nginx </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Nginx </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>记一次被黑的经历</title>
      <link href="/posts/52665/"/>
      <url>/posts/52665/</url>
      
        <content type="html"><![CDATA[<p>某天的某时某刻，我收到了服务商的邮件，告知我出网流量过大，我次奥，我的博客站（另一个，非github）已经好久没有维护了，更何况上面也就几篇刚入门的时候写的几篇小打小闹的文章，怎么会那么火爆？</p><p>当然没有那么火爆了，登上去后发现有个程序资源基本占用100%，好吗，毫无压力的被黑了。。。</p><a id="more"></a><h1 id="处理"><a href="#处理" class="headerlink" title="处理"></a>处理</h1><p>幸好这个程序并不是什么复杂的程序，也仅仅就是一个脚本，把我的服务器当成了肉鸡，攻击别人的服务器，把这个脚本kill并删除后，服务器的load和cpu也就下来了，幸好不是什么牛逼或恶意点的病毒</p><h1 id="分析"><a href="#分析" class="headerlink" title="分析"></a>分析</h1><p>通过<code>last</code> 和 <code>lastb</code> 这两个命令，发现近期有很多尝试登陆，那么攻击手段也就明了了，肉鸡的暴力破解</p><h1 id="处理-1"><a href="#处理-1" class="headerlink" title="处理"></a>处理</h1><h1 id="修改密码并仅允许通过私钥登陆"><a href="#修改密码并仅允许通过私钥登陆" class="headerlink" title="修改密码并仅允许通过私钥登陆"></a>修改密码并仅允许通过私钥登陆</h1><p>其实，Linux服务器的密码登录并不是一个明智的选择，我们这里可以把用户名密码登录给关了，然后通过私钥登陆</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">vim /etc/ssh/sshd_config</span><br></pre></td></tr></table></figure><p>在这个文件里面有两个配置，分别按照如下设置即可</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">RSAAuthentication yes      # RSA 验证</span><br><span class="line">PubkeyAuthentication yes   # 公钥验证</span><br><span class="line">PasswordAuthentication no  # 不允许密码登录</span><br></pre></td></tr></table></figure><p>然后我们需要将自己的公钥添加到 公钥验证列表文件里面</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">cat id_rsa.pub &gt;&gt; ~/.ssh/authorized_keys</span><br></pre></td></tr></table></figure><h2 id="添加IP黑名单"><a href="#添加IP黑名单" class="headerlink" title="添加IP黑名单"></a>添加IP黑名单</h2><p>上述的攻击主要就是找很多肉鸡来宝鸡破解密码，而这些IP大部分都是黑名单里面的，所以我们时刻更新最新的IP黑名单，那么就可以再加上一层防御</p><p>Linux上黑名单可以直接添加到 <code>/etc/hosts.deny</code> 里面，这样就可以拦截了，但是我们不可能每天去更新啊，所以，我们可以写一个脚本，放在crontab里面执行一下，这样就可以继续懒下去了，这里分享一个东北大学网络中心的脚本<code>fetch_neusshbl.sh</code></p><p>直接附上代码：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#!/bin/sh</span></span><br><span class="line"><span class="comment"># Fetch NEU SSH Black list to /etc/hosts.deny</span></span><br><span class="line"><span class="comment">#</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">export</span> PATH=/bin:/sbin:/usr/bin:/usr/sbin:/usr/<span class="built_in">local</span>/bin:/usr/<span class="built_in">local</span>/sbin</span><br><span class="line"></span><br><span class="line">URL=http://antivirus.neu.edu.cn/ssh/lists/neu_sshbl_hosts.deny.gz</span><br><span class="line">HOSTSDENY=/etc/hosts.deny</span><br><span class="line">TMP_DIR=/dev/shm</span><br><span class="line">FILE=hosts.deny</span><br><span class="line"></span><br><span class="line">[ -d <span class="variable">$TMP_DIR</span> ] || TMP_DIR=/tmp</span><br><span class="line"></span><br><span class="line"><span class="built_in">cd</span> <span class="variable">$TMP_DIR</span></span><br><span class="line"></span><br><span class="line">curl --connect-timeout 60 <span class="variable">$URL</span> 2&gt; /dev/null | gzip -dc &gt; <span class="variable">$FILE</span> 2&gt; /dev/null</span><br><span class="line"></span><br><span class="line">LINES=`grep <span class="string">"^sshd:"</span> <span class="variable">$FILE</span> | wc -l`</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> [ <span class="variable">$LINES</span> -gt 10 ]</span><br><span class="line"><span class="keyword">then</span></span><br><span class="line">    sed -i <span class="string">'/^####SSH BlackList START####/,/^####SSH BlackList END####/d'</span> <span class="variable">$HOSTSDENY</span></span><br><span class="line">    <span class="built_in">echo</span> <span class="string">"####SSH BlackList START####"</span> &gt;&gt; <span class="variable">$HOSTSDENY</span></span><br><span class="line">    cat <span class="variable">$FILE</span> &gt;&gt; <span class="variable">$HOSTSDENY</span></span><br><span class="line">    <span class="built_in">echo</span> <span class="string">"####SSH BlackList END####"</span> &gt;&gt; <span class="variable">$HOSTSDENY</span></span><br><span class="line"><span class="keyword">fi</span></span><br></pre></td></tr></table></figure><p>然后将这个脚本放在<code>/etc/cron.daily/</code> 目录下面，每天执行即可</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">cp fetch_neusshbl.sh /etc/cron.daily/</span><br><span class="line">chmod +x fetch_neusshbl.sh</span><br></pre></td></tr></table></figure><h2 id="登录邮件通知"><a href="#登录邮件通知" class="headerlink" title="登录邮件通知"></a>登录邮件通知</h2><p>上面的两个步骤完成后，面对这种暴力攻击，也就安全很多了，但是返回忧则生，所以我又加了最后一道防线，如果有人登录了我的服务器，就自动给我的邮箱发送一条邮件</p><p>邮件发送的服务器配置可参考我的另一篇文章<a href="https://tyloafer.github.io/posts/47206/">《Linux下使用mail发送邮件》</a></p><p><em>本文还是着重从防御方面做了一点处理，可能相对来说，方法都比较的low，还请谅解，学海无涯，继续苦作舟吧！</em></p>]]></content>
      
      
      <categories>
          
          <category> Linux </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Linux </tag>
            
            <tag> Mail </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Redis哨兵</title>
      <link href="/posts/51207/"/>
      <url>/posts/51207/</url>
      
        <content type="html"><![CDATA[<p>Sentinel（哨兵）是Redis 的高可用性解决方案：由一个或多个Sentinel 实例 组成的Sentinel 系统可以监视任意多个主服务器，以及这些主服务器属下的所有从服务器，并在被监视的主服务器进入下线状态时，自动将下线主服务器属下的某个从服务器升级为新的主服务器。</p><a id="more"></a><p>在介绍哨兵之前，我们先看一下一些中小型的Redis的一个简单的主从架构</p><p><img src="http://github-1253518569.cossh.myqcloud.com/redis-master-slave.png" alt="http://github-1253518569.cossh.myqcloud.com/redis-master-slave.png"></p><p>我们的程序，在进程写入操作的时候，可能会直连Master，但是，如果这时候Master宕了，就会导致数据写入不进去，而等我们反应过来并处理好，说不定十几分钟甚至更长时间就过去了。但是，如果我们引入哨兵，采用下面的架构</p><p><img src="http://github-1253518569.cossh.myqcloud.com/redis-sentinal2.png" alt="http://github-1253518569.cossh.myqcloud.com/redis-sentinal2.png"></p><p>我们设置多台哨兵，我们的程序去连接哨兵，加入Master宕掉了，哨兵们去帮我们选一台Slave当新的Master，这样也就能实现快速的故障转移及处理了，毕竟线上是耽误不起每分每秒的。</p><h1 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h1><p>Redis-Sentinel是用于管理Redis集群,该系统执行以下三个任务:</p><ol><li>监控(Monitoring):Sentinel会不断地检查你的主服务器和从服务器是否运作正常</li><li>提醒(Notification):当被监控的某个Redis服务器出现问题时,Sentinel可以通过API向管理员或者其他应用程序发送通知</li><li>自动故障迁移(Automatic failover):当一个主服务器不能正常工作时,Sentinel 会开始一次自动故障迁移操作,它会将失效主</li></ol><p>服务器的其中一个从服务器升级为新的主服务器,并让失效主服务器的其他从服务器改为复制新的主服务器;当客户端试图连接失效的主服务器时,集群也会向客户端返回新主服务器的地址,使得集群可以使用新主服务器代替失效服务器</p><h1 id="搭建"><a href="#搭建" class="headerlink" title="搭建"></a>搭建</h1><p>Redis2.8和3.0已经附带了稳定版本的哨兵，通过yum安装后，在<code>redis-server</code>的同一目录下会有一个<code>redis-sentinel</code>的可执行脚本，这个就是Redis的哨兵了，后面用<code>sentinel</code>来代替哨兵这个名词，因为这是人家的正式的名字。</p><h1 id="配置"><a href="#配置" class="headerlink" title="配置"></a>配置</h1><p>在<code>/etc/</code>目录下，也就是redis.conf的同级目录下，会有一个<code>redis-sentinel.conf</code> , 这个就是 sentinel 的配置文件</p><p>我们通过下面的命令查看一下他的主要内容</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">cat sentinel-26379.conf | grep -v &quot;#&quot; | grep -v &quot;^$&quot;</span><br></pre></td></tr></table></figure><p>输出如下（# 为我的注释）：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"># 哨兵监听的端口</span><br><span class="line">port 26379</span><br><span class="line"># 工作目录</span><br><span class="line">dir /tmp</span><br><span class="line"># sentinel monitor &lt;master-name&gt; &lt;ip&gt; &lt;redis-port&gt; &lt;quorum&gt;</span><br><span class="line"># 后面的参数分别是master的名字，这个在redis的conf文件里面有设置的</span><br><span class="line"># redis的ip</span><br><span class="line"># redis监听的端口</span><br><span class="line"># quorum 是指，有几个哨兵认为master down了，才会认为这个master真正的down了，从而执行后面的灾备方案，一# 般这里设置的是总共 sentinel-num/2 + 1</span><br><span class="line">sentinel monitor mymaster 127.0.0.1 6379 2</span><br><span class="line"># 这个是指 sentinel 多少毫秒连接不上 master，就会认为它 down了</span><br><span class="line">sentinel down-after-milliseconds mymaster 30000</span><br><span class="line"></span><br><span class="line"># 表示如果master重新选出来后，其它slave节点能同时并行从新master同步缓存的台数有多少个，显然该值越大，所有slave节点完成同步切换的整体速度越快，但如果此时正好有人在访问这些slave，可能造成读取失败，影响面会更广。最保定的设置为1，只同一时间，只能有一台干这件事，这样其它slave还能继续服务，但是所有slave全部完成缓存更新同步的进程将变慢</span><br><span class="line">sentinel parallel-syncs mymaster 1</span><br><span class="line"></span><br><span class="line"># 表示多长时间后, master仍没活过来，则启动failover，从剩下的slave中选一个升级为master</span><br><span class="line">sentinel failover-timeout mymaster 180000</span><br><span class="line"></span><br><span class="line"># sentinel的日志</span><br><span class="line">logfile /var/log/redis/sentinel.log</span><br></pre></td></tr></table></figure><p>注：</p><p>我们一般以守护进程的方式开启哨兵，但是配置文件里面没有写，我们可以在配置文件的开始加上</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">daemonize yes</span><br></pre></td></tr></table></figure><h1 id="实战"><a href="#实战" class="headerlink" title="实战"></a>实战</h1><h2 id="主从配置"><a href="#主从配置" class="headerlink" title="主从配置"></a>主从配置</h2><p>了解了上面的配置后，我们可以先撘一个主从服务器</p><blockquote><p>思路如下：</p><ol><li>开启三台服务器，分别监听 6379 6380 6381 端口</li><li>将6379 设置为master， 6380和6381 分别slaveof 6379</li></ol></blockquote><p>6379.conf</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br></pre></td><td class="code"><pre><span class="line">bind 127.0.0.1</span><br><span class="line">protected-mode yes</span><br><span class="line">port 6379</span><br><span class="line">tcp-backlog 511</span><br><span class="line">timeout 0</span><br><span class="line">tcp-keepalive 300</span><br><span class="line">daemonize yes</span><br><span class="line">supervised no</span><br><span class="line">pidfile &quot;/var/run/redis_6379-6379.pid&quot;</span><br><span class="line">loglevel notice</span><br><span class="line">logfile &quot;/var/log/redis/redis-6379.log&quot;</span><br><span class="line">databases 16</span><br><span class="line">save 900 1</span><br><span class="line">save 300 10</span><br><span class="line">save 60 10000</span><br><span class="line">stop-writes-on-bgsave-error yes</span><br><span class="line">rdbcompression yes</span><br><span class="line">rdbchecksum yes</span><br><span class="line">dbfilename &quot;dump-6379.rdb&quot;</span><br><span class="line">dir &quot;/var/lib/redis&quot;</span><br><span class="line">slave-serve-stale-data yes</span><br><span class="line">slave-read-only yes</span><br><span class="line">repl-diskless-sync no</span><br><span class="line">repl-diskless-sync-delay 5</span><br><span class="line">repl-disable-tcp-nodelay no</span><br><span class="line">slave-priority 100</span><br><span class="line">appendonly yes</span><br><span class="line">appendfilename &quot;appendonly-6379.aof&quot;</span><br><span class="line">appendfsync everysec</span><br><span class="line">no-appendfsync-on-rewrite no</span><br><span class="line">auto-aof-rewrite-percentage 100</span><br><span class="line">auto-aof-rewrite-min-size 64mb</span><br><span class="line">aof-load-truncated yes</span><br><span class="line">lua-time-limit 5000</span><br><span class="line">slowlog-log-slower-than 10000</span><br><span class="line">slowlog-max-len 128</span><br><span class="line">latency-monitor-threshold 0</span><br><span class="line">notify-keyspace-events &quot;&quot;</span><br><span class="line">hash-max-ziplist-entries 512</span><br><span class="line">hash-max-ziplist-value 64</span><br><span class="line">list-max-ziplist-size -2</span><br><span class="line">list-compress-depth 0</span><br><span class="line">set-max-intset-entries 512</span><br><span class="line">zset-max-ziplist-entries 128</span><br><span class="line">zset-max-ziplist-value 64</span><br><span class="line">hll-sparse-max-bytes 3000</span><br><span class="line">activerehashing yes</span><br><span class="line">client-output-buffer-limit normal 0 0 0</span><br><span class="line">client-output-buffer-limit slave 256mb 64mb 60</span><br><span class="line">client-output-buffer-limit pubsub 32mb 8mb 60</span><br><span class="line">hz 10</span><br><span class="line">aof-rewrite-incremental-fsync yes</span><br></pre></td></tr></table></figure><p>6380的配置</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br></pre></td><td class="code"><pre><span class="line">bind 127.0.0.1</span><br><span class="line">protected-mode yes</span><br><span class="line">port 6381</span><br><span class="line">tcp-backlog 511</span><br><span class="line">timeout 0</span><br><span class="line">tcp-keepalive 300</span><br><span class="line">daemonize yes</span><br><span class="line">supervised no</span><br><span class="line">pidfile &quot;/var/run/redis_6381-6381.pid&quot;</span><br><span class="line">loglevel notice</span><br><span class="line">logfile &quot;/var/log/redis/redis-6381.log&quot;</span><br><span class="line">databases 16</span><br><span class="line">save 900 1</span><br><span class="line">save 300 10</span><br><span class="line">save 60 10000</span><br><span class="line">stop-writes-on-bgsave-error yes</span><br><span class="line">rdbcompression yes</span><br><span class="line">rdbchecksum yes</span><br><span class="line">dbfilename &quot;dump-6381.rdb&quot;</span><br><span class="line">dir &quot;/var/lib/redis&quot;</span><br><span class="line">slave-serve-stale-data yes</span><br><span class="line">slave-read-only yes</span><br><span class="line">repl-diskless-sync no</span><br><span class="line">repl-diskless-sync-delay 5</span><br><span class="line">repl-disable-tcp-nodelay no</span><br><span class="line">slave-priority 100</span><br><span class="line">appendonly yes</span><br><span class="line">appendfilename &quot;appendonly-6381.aof&quot;</span><br><span class="line">appendfsync everysec</span><br><span class="line">no-appendfsync-on-rewrite no</span><br><span class="line">auto-aof-rewrite-percentage 100</span><br><span class="line">auto-aof-rewrite-min-size 64mb</span><br><span class="line">aof-load-truncated yes</span><br><span class="line">lua-time-limit 5000</span><br><span class="line">slowlog-log-slower-than 10000</span><br><span class="line">slowlog-max-len 128</span><br><span class="line">latency-monitor-threshold 0</span><br><span class="line">notify-keyspace-events &quot;&quot;</span><br><span class="line">hash-max-ziplist-entries 512</span><br><span class="line">hash-max-ziplist-value 64</span><br><span class="line">list-max-ziplist-size -2</span><br><span class="line">list-compress-depth 0</span><br><span class="line">set-max-intset-entries 512</span><br><span class="line">zset-max-ziplist-entries 128</span><br><span class="line">zset-max-ziplist-value 64</span><br><span class="line">hll-sparse-max-bytes 3000</span><br><span class="line">activerehashing yes</span><br><span class="line">client-output-buffer-limit normal 0 0 0</span><br><span class="line">client-output-buffer-limit slave 256mb 64mb 60</span><br><span class="line">client-output-buffer-limit pubsub 32mb 8mb 60</span><br><span class="line">hz 10</span><br><span class="line">aof-rewrite-incremental-fsync yes</span><br><span class="line">slaveof 127.0.0.1 6379</span><br></pre></td></tr></table></figure><p>6381的配置与6380基本相同，只是修改一下端口和log，rdb，aof的名字而已</p><p>然后我们开启了三台redis，并且设置好了主从关系</p><blockquote><p>redis-server /path/to/6379.conf</p><p>redis-server  /path/to/6380.conf</p><p>redis-server  /path/to/6381.conf</p></blockquote><h1 id="哨兵配置"><a href="#哨兵配置" class="headerlink" title="哨兵配置"></a>哨兵配置</h1><blockquote><p>思路如下：</p><ol><li>我们一样开启三台 sentinel 分别监听 26379 26380 26381</li><li>将这三台 sentinel 全部监控我们的master 6379端口的Redis</li></ol></blockquote><p>26379.conf</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">port 26379</span><br><span class="line">dir /tmp</span><br><span class="line">sentinel monitor mymaster 127.0.0.1 6379 2</span><br><span class="line">sentinel down-after-milliseconds mymaster 30000</span><br><span class="line">sentinel parallel-syncs mymaster 1</span><br><span class="line">sentinel failover-timeout mymaster 180000</span><br><span class="line">logfile /var/log/redis/sentinel-26379.log</span><br></pre></td></tr></table></figure><p>其余两个配置，除端口和logfile外，均一样，可参考着写</p><p>然后我们开启这三台哨兵</p><blockquote><p>redis-sentinel /path/to/26379.conf</p><p>redis-sentinel  /path/to/26380.conf</p><p>redis-sentinel  /path/to/26381.conf</p></blockquote><h1 id="分析日志"><a href="#分析日志" class="headerlink" title="分析日志"></a>分析日志</h1><p>我们查看任一个哨兵的日志，启动后可以发现，日志里面输入了一下内容</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">2739:X 23 May 09:00:15.188 # Sentinel ID is 41b05827fdb8f7f8e88e74aa7070190c3c8f84f6</span><br><span class="line">2739:X 23 May 09:00:15.188 # +monitor master mymaster 127.0.0.1 6379 quorum 2</span><br><span class="line">2739:X 23 May 09:00:22.026 * +sentinel sentinel 50c453e7f9fa3acbab3f685621dabf26c02b53e3 127.0.0.1 26380 @ mymaster 127.0.0.1 6379</span><br><span class="line">2739:X 23 May 09:00:24.191 * +sentinel sentinel 3d8d577704e9c0f6ac4cde7febab25180b7d7cc5 127.0.0.1 26381 @ mymaster 127.0.0.1 6379</span><br></pre></td></tr></table></figure><p>也就是说sentinel 跟我我们配置的 找到了master ，并且找到了另外的两台 Sentinel ，这时候，我们去看 我们原先配置的 sentinel 的配置文件，应该也发生了变化</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"># Generated by CONFIG REWRITE</span><br><span class="line">sentinel known-slave mymaster 127.0.0.1 6379</span><br><span class="line">sentinel known-slave mymaster 127.0.0.1 6380</span><br><span class="line">sentinel known-sentinel mymaster 127.0.0.1 26381 3d8d577704e9c0f6ac4cde7febab25180b7d7cc5</span><br><span class="line">sentinel known-sentinel mymaster 127.0.0.1 26380 50c453e7f9fa3acbab3f685621dabf26c02b53e3</span><br></pre></td></tr></table></figure><p>这时候，Sentinel 集群监控已经开启并且开始监控了。</p><p>那么，Sentinel 是如何工作的呢，又是怎么投票选举新的master的呢，其实还是要继续依赖他锁打印的日志</p><p>我们这时候，主动下线一台，然后继续分析一下 Sentinel 的日志</p><blockquote><p>redis-cli -p 6379 shutdown</p></blockquote><p>这时候，日志又会继续打印内容</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">2739:X 23 May 09:05:02.978 # +sdown master mymaster 127.0.0.1 6379</span><br><span class="line">2739:X 23 May 09:05:03.108 # +new-epoch 1</span><br><span class="line">2739:X 23 May 09:05:03.116 # +vote-for-leader 3d8d577704e9c0f6ac4cde7febab25180b7d7cc5 1</span><br><span class="line">2739:X 23 May 09:05:04.077 # +odown master mymaster 127.0.0.1 6379 #quorum 3/2</span><br><span class="line">2739:X 23 May 09:05:04.078 # Next failover delay: I will not start a failover before Wed May 23 09:11:03 2018</span><br><span class="line">2739:X 23 May 09:05:04.208 # +config-update-from sentinel 3d8d577704e9c0f6ac4cde7febab25180b7d7cc5 127.0.0.1 26381 @ mymaster 127.0.0.1 6379</span><br><span class="line">2739:X 23 May 09:05:04.208 # +switch-master mymaster 127.0.0.1 6379 127.0.0.1 6381</span><br></pre></td></tr></table></figure><p>流程可参考：</p><ol><li>Sentinel 发现了master宕掉了</li><li>然后给另一台 slave 投票了</li><li>另外一个又发现 master 宕了，超过我们的设定了</li><li>开始协商：某个时间点之后 master还没有起，我们就另立新主吧</li><li>哎哟歪，时间到了，我们把其他的配置文件都更新一下吧，不然重启了我们的决议又失效了咋办</li><li>最后，我们欢迎新主降临</li></ol><p>我们这时候把6379再开启，又会发生什么情况了</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">2739:X 23 May 09:05:04.209 * +slave slave 127.0.0.1:6380 127.0.0.1 6380 @ mymaster 127.0.0.1 6381</span><br><span class="line">2739:X 23 May 09:05:04.209 * +slave slave 127.0.0.1:6379 127.0.0.1 6379 @ mymaster 127.0.0.1 6381</span><br></pre></td></tr></table></figure><p>其实，在上面的宕机并另立master的时候 6379 的配置已经被 Sentinel 修改了，这时候，就只有乖乖的当 slave了</p>]]></content>
      
      
      <categories>
          
          <category> Redis </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Linux </tag>
            
            <tag> Redis </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>PHP基于共享内存实现single信号量控制脚本启停</title>
      <link href="/posts/41236/"/>
      <url>/posts/41236/</url>
      
        <content type="html"><![CDATA[<p>我们在使用nginx的时候，有<code>-s reload</code>实现配置的重载，别的应用也有<code>kill -USR1</code> 实现配置的重载，但是在php的脚本在执行的时候，就只有简单粗暴的<code>kill</code> 来杀死，再启动。所以，是否可以实现 类似于 nginx的<code>-s</code>一样，给与一个信号量，来进行平滑重启或杀死？</p><a id="more"></a><h1 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h1><p>我们在写死循环的时候一般是<code>while(true)</code>, 那么只要在<code>while(true)</code>紧接着给他一个变量，然后在根据这个变量的值来判断是否需要结束不久可以实现程序的自动结束了吗？</p><p>这样的话，php程序内自定义变量肯定是不行了，我们可以借助一个文件或redis或mysql等来实现，例如，a脚本在执行开始的时候，在redis里面设置一个key a，然后每次while的时候，读取redis里面a的值，如果改变了，便执行相关的操作</p><p>这当然是可行的，但是在测试的时候，你就会发现，cpu会占用很高，所以这个就被kill了</p><h1 id="共享内存"><a href="#共享内存" class="headerlink" title="共享内存"></a>共享内存</h1><p>既然php的所有变量都是放在内存里面的，那一个php脚本a在执行的时候，设置一个变量$flag, 然后其他脚本可以访问这个变量并修改变量的值，这样的话，资源的消耗就是几乎为0了，这也就引进了一个概念：<strong>共享内存</strong></p><p>共享内存的使用主要是为了能够在同一台机器不同的进程中共享一些数据，比如在多个 php-fpm 进程中共享当前进程的使用情况。这种通信也称为进程间通信（Inter-Process Communication），简称 IPC。</p><p>PHP 内置的 <a href="http://php.net/manual/zh/book.shmop.php" target="_blank" rel="noopener">shmop 扩展</a> (Shared Memory Operations) 提供了一系列共享内存操作的函数。当然这也是基于Linux共享内存实现的，具体的就自行google吧。</p><h2 id="函数列表及简介"><a href="#函数列表及简介" class="headerlink" title="函数列表及简介"></a>函数列表及简介</h2><ol><li>int <strong>ftok</strong> ( string <code>$pathname</code> , string <code>$proj</code> )  把一个执行的文件或项目转换成一个系统上的IPC key，同一个系统上，每个文件对应的IPC key是相同的，所以也就让信号量控制成为了可能</li><li>resource <strong>shmop_open</strong> ( int <code>$key</code> , string <code>$flags</code> , int <code>$mode</code> , int <code>$size</code> ) 创建一个指定大小的内存块</li><li>string <strong>shmop_read</strong> ( resource <code>$shmid</code> , int <code>$start</code> , int <code>$count</code> ) 从一个共享内存块中读取数据 如果填充的数据比共享内存的size小的话，会自动给数据填充空白符，所以记得套trim()</li><li>int <strong>shmop_size</strong> ( resource <code>$shmid</code> ) 获取一个共享内存的大小 ，参数是 <strong>shmop_open</strong>返回的内容</li><li>int <strong>shmop_write</strong> ( resource <code>$shmid</code> , string <code>$data</code> , int <code>$offset</code> ) 向共享内存中写入数据</li><li>bool <strong>shmop_delete</strong> ( resource <code>$shmid</code> ) 删除一个共享内存块</li><li>void <strong>shmop_close</strong> ( resource <code>$shmid</code> ) 关闭一个共享内存块，并不删除</li></ol><h2 id="注意"><a href="#注意" class="headerlink" title="注意"></a>注意</h2><ol><li><p><strong>ftok()</strong> 函数的第一个<code>pathname</code> 可以使一个文件的全路径， 第二个参数，可以随意给，但必须是<strong>长度为1</strong>的字符</p></li><li><p>在使用<strong>shmop_open</strong>的时候，会注意到 第一个参数 int <code>$key</code> 有可能会一脸迷茫，这里其实是 <strong>fotk()</strong>函数的返回值， 我们前面说过 <strong>fotk()</strong> 是将文件转换成 IPC key，也就是这里的key</p></li><li><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">&quot;a&quot; for access (sets SHM_RDONLY for shmat) use this flag when you need to open an existing shared memory segment for read only</span><br><span class="line">&quot;c&quot; for create (sets IPC_CREATE) use this flag when you need to create a new shared memory segment or if a segment with the same key exists, try to open it for read and write</span><br><span class="line">&quot;w&quot; for read &amp; write access use this flag when you need to read and write to a shared memory segment, use this flag in most cases.</span><br><span class="line">&quot;n&quot; create a new memory segment (sets IPC_CREATE|IPC_EXCL) use this flag when you want to create a new shared memory segment but if one already exists with the same flag, fail. This is useful for security purposes, using this you can prevent race condition exploits.</span><br></pre></td></tr></table></figure><p>我在这里使用”n”的时候，会报错，使用“c”便不会，各位可自行测试</p></li></ol><h1 id="示例"><a href="#示例" class="headerlink" title="示例"></a>示例</h1><p>脚本a.php </p><figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&lt;?php</span></span><br><span class="line"><span class="comment">// 生成IPC key</span></span><br><span class="line">$shm_key = ftok(<span class="keyword">__FILE__</span>, <span class="string">'t'</span>);</span><br><span class="line"><span class="comment">// 信号量的话 0-9也足够了，所以这里分配1byte的大小即可，同时这样也不会产生空白符，省去了使用trim()</span></span><br><span class="line">$shm_id = shmop_open($shm_key, <span class="string">'c'</span>, <span class="number">0644</span>, <span class="number">1</span>);</span><br><span class="line">shmop_write($shm_id, <span class="number">1</span>, <span class="number">0</span>);</span><br><span class="line"><span class="keyword">while</span> (shmop_read($shm_id, <span class="number">0</span>, shmop_size($shm_id)) == <span class="number">1</span>) &#123;</span><br><span class="line">  <span class="comment">// to do</span></span><br><span class="line">&#125;</span><br><span class="line">shmop_close($shm_id);</span><br><span class="line">shmop_delete($shm_id);</span><br></pre></td></tr></table></figure><p>控制启停的脚本 single.php</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">php single.php a.php /data/</span><br></pre></td></tr></table></figure><figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&lt;?php</span></span><br><span class="line"><span class="comment">// 获取需要控制的脚本</span></span><br><span class="line">$args = $_SERVER[<span class="string">'argv'</span>];</span><br><span class="line">array_shift($args);</span><br><span class="line">$file = $args[<span class="number">1</span>] . <span class="string">'/'</span> . $args[<span class="number">0</span>];</span><br><span class="line">$shm_key = ftok(<span class="keyword">__FILE__</span>, <span class="string">'t'</span>);</span><br><span class="line"><span class="comment">// 信号量的话 0-9也足够了，所以这里分配1byte的大小即可，同时这样也不会产生空白符，省去了使用trim()</span></span><br><span class="line">$shm_id = shmop_open($shm_key, <span class="string">'c'</span>, <span class="number">0644</span>, <span class="number">1</span>);</span><br><span class="line">shmop_write($shm_id, <span class="number">0</span>, <span class="number">0</span>);</span><br><span class="line"><span class="keyword">echo</span> <span class="string">"[停止] "</span>;</span><br><span class="line"><span class="keyword">while</span> (@shmop_read($shm_id, <span class="number">0</span>, shmop_size($shm_id)) === <span class="number">0</span>) &#123;</span><br><span class="line">    <span class="keyword">echo</span> <span class="string">'.'</span>;</span><br><span class="line">&#125;</span><br><span class="line">shmop_close($shm_id);</span><br><span class="line">shmop_delete($shm_id);</span><br><span class="line"><span class="keyword">echo</span> <span class="string">"成功"</span>;</span><br></pre></td></tr></table></figure><h1 id="进阶-内存锁"><a href="#进阶-内存锁" class="headerlink" title="进阶-内存锁"></a>进阶-内存锁</h1><h2 id="函数及列表"><a href="#函数及列表" class="headerlink" title="函数及列表"></a>函数及列表</h2><p><strong>ftok</strong> 是必须要用到的</p><ol><li>resource <strong>sem_get</strong> ( int <code>$key</code> [, int <code>$max_acquire</code> = 1 [, int <code>$perm</code> = 0666 [, int <code>$auto_release</code> = 1 ]]] ) 创建一个信号资源</li><li>bool <strong>sem_acquire</strong> ( resource <code>$sem_identifier</code> [, bool <code>$nowait</code> = FALSE ] )  根据信号资源，获得一个信号使用权限</li><li>bool <strong>sem_release</strong> ( resource <code>$sem_identifier</code> ) 释放一个获取的信号使用权限</li></ol><p>上面三个是我使用到的，更多的可以参考PHP手册上的<a href="http://php.net/manual/zh/book.sem.php" target="_blank" rel="noopener">Semaphore</a>，会有更多相关的介绍，但是这里结合上面的共享内存的函数，就完全够用了。</p><h2 id="注意-1"><a href="#注意-1" class="headerlink" title="注意"></a>注意</h2><ol><li><strong>sem_get</strong> 的key也是 <strong>ftok</strong>函数产生的，所以可以与共享内存的共用一个key， 第二个参数 <code>$max_acquire</code> 设置了，这个信号资源，最多一次可以被多少个进程访问，当设置为1的时候，也就实现了锁的机制</li><li><strong>sem_acquire</strong> 是获取一个信号资源的使用权，当这个信号资源被占用，且达到最大的请求数的时候，第二个参数<code>$nowait</code> 决定了接下来的行为，如果为设置true的话，则函数直接返回 false，而如果<code>$nowait</code>设置为false的时候，则会阻塞进程，知道获取资源的使用权限</li></ol><h1 id="进阶-为脚本加上锁"><a href="#进阶-为脚本加上锁" class="headerlink" title="进阶-为脚本加上锁"></a>进阶-为脚本加上锁</h1><p>我们可以根据上面的函数，为脚本加上锁，实现一个脚本的单一执行（当然linux下的<strong>flock</strong>和php的<strong>flock()</strong>也可以实现）</p><p>脚本a.php </p><figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&lt;?php</span></span><br><span class="line"><span class="comment">// 生成IPC key</span></span><br><span class="line">$shm_key = ftok(<span class="keyword">__FILE__</span>, <span class="string">'t'</span>);</span><br><span class="line"><span class="comment">// 信号量的话 0-9也足够了，所以这里分配1byte的大小即可，同时这样也不会产生空白符，省去了使用trim()</span></span><br><span class="line">$shm_id = shmop_open($shm_key, <span class="string">'c'</span>, <span class="number">0644</span>, <span class="number">1</span>);</span><br><span class="line">shmop_write($shm_id, <span class="number">1</span>, <span class="number">0</span>);</span><br><span class="line">$sem_id = sem_get($shm_key);</span><br><span class="line"><span class="keyword">if</span> (!sem_acquire($sem_id, <span class="keyword">true</span>)) &#123;</span><br><span class="line">    <span class="comment">// 有另一个脚本正在执行，结束当前执行</span></span><br><span class="line">    <span class="keyword">echo</span> <span class="string">"another is running..."</span>;</span><br><span class="line">  <span class="keyword">exit</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">while</span> (shmop_read($shm_id, <span class="number">0</span>, shmop_size($shm_id)) == <span class="number">1</span>) &#123;</span><br><span class="line">  <span class="comment">// to do</span></span><br><span class="line">&#125;</span><br><span class="line">sem_release($sem_id);</span><br><span class="line">shmop_close($shm_id);</span><br><span class="line">shmop_delete($shm_id);</span><br></pre></td></tr></table></figure><p>控制启停的脚本 single.php</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">php single.php a.php /data/</span><br></pre></td></tr></table></figure><figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&lt;?php</span></span><br><span class="line"><span class="comment">// 获取需要控制的脚本</span></span><br><span class="line">$args = $_SERVER[<span class="string">'argv'</span>];</span><br><span class="line">array_shift($args);</span><br><span class="line">$file = $args[<span class="number">1</span>] . <span class="string">'/'</span> . $args[<span class="number">0</span>];</span><br><span class="line">$shm_key = ftok(<span class="keyword">__FILE__</span>, <span class="string">'t'</span>);</span><br><span class="line"><span class="comment">// 信号量的话 0-9也足够了，所以这里分配1byte的大小即可，同时这样也不会产生空白符，省去了使用trim()</span></span><br><span class="line">$shm_id = shmop_open($shm_key, <span class="string">'c'</span>, <span class="number">0644</span>, <span class="number">1</span>);</span><br><span class="line">shmop_write($shm_id, <span class="number">0</span>, <span class="number">0</span>);</span><br><span class="line"><span class="keyword">echo</span> <span class="string">"[停止] "</span>;</span><br><span class="line">$sem_id = sem_get($shm_key);</span><br><span class="line"><span class="comment">// 脚本在执行结束的时候，会释放信号资源，所以这里可以通过能否获得信号资源来判断脚本是否结束</span></span><br><span class="line"><span class="keyword">if</span> (!sem_acquire($sem_id, <span class="keyword">true</span>)) &#123;</span><br><span class="line">    <span class="keyword">echo</span> <span class="string">'.'</span>;</span><br><span class="line">&#125;</span><br><span class="line">sem_release($sem_id);</span><br><span class="line">shmop_close($shm_id);</span><br><span class="line">shmop_delete($shm_id);</span><br><span class="line"><span class="keyword">echo</span> <span class="string">"成功"</span>;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> PHP </category>
          
      </categories>
      
      
        <tags>
            
            <tag> PHP </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>玩玩Swoole（一）：Swoole整合Yii</title>
      <link href="/posts/13311/"/>
      <url>/posts/13311/</url>
      
        <content type="html"><![CDATA[<p>PHP是个单线程的脚本的语言，虽然可以通过<em>pcntl-fork</em>实现简单的多线程，但是这个肯定不是最优解，所以也就开始接触了Swoole，但是公司还没有相关的项目，所以也就玩玩而已</p><a id="more"></a><h1 id="入口文件"><a href="#入口文件" class="headerlink" title="入口文件"></a>入口文件</h1><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br></pre></td><td class="code"><pre><span class="line">&lt;?php</span><br><span class="line">/**</span><br><span class="line"> * @woole整合yii </span><br><span class="line"> * @authors Tyloafer (tyloafer@gmail.com)</span><br><span class="line"> * @date    2018-05-09 08:22:21</span><br><span class="line"> */</span><br><span class="line"></span><br><span class="line">class SwooleIndex</span><br><span class="line">&#123;</span><br><span class="line">private $swoole;</span><br><span class="line">private $config;</span><br><span class="line">    public function __construct()</span><br><span class="line">    &#123;</span><br><span class="line">    $option = [</span><br><span class="line">    &apos;enable_static_handler&apos; =&gt; true,</span><br><span class="line">    &apos;document_root&apos; =&gt; &quot;/home/lixy/basic/&quot;,</span><br><span class="line">    &apos;worker_num&apos; =&gt; 5,</span><br><span class="line">    &apos;log_level&apos; =&gt; 3,</span><br><span class="line">    ];</span><br><span class="line">    $this-&gt;swoole = new \Swoole\Http\Server(&apos;0.0.0.0&apos;, 9502);</span><br><span class="line">    $this-&gt;swoole-&gt;set($option);</span><br><span class="line">    $this-&gt;swoole-&gt;on(&apos;workerstart&apos;, [$this, &apos;workerStart&apos;]);</span><br><span class="line">    $this-&gt;swoole-&gt;on(&apos;request&apos;, [$this, &apos;request&apos;]);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public function __call($name, $args)</span><br><span class="line">    &#123;</span><br><span class="line">    return call_user_func_array([$this, $name], $args);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public function workerStart($server, $id)</span><br><span class="line">    &#123;</span><br><span class="line">    defined(&apos;YII_DEBUG&apos;) or define(&apos;YII_DEBUG&apos;, true);</span><br><span class="line">defined(&apos;YII_ENV&apos;) or define(&apos;YII_ENV&apos;, &apos;dev&apos;);</span><br><span class="line"></span><br><span class="line">require __DIR__ . &apos;/../vendor/autoload.php&apos;;</span><br><span class="line">require __DIR__ . &apos;/../vendor/yiisoft/yii2/Yii.php&apos;;</span><br><span class="line"></span><br><span class="line">$this-&gt;config = require __DIR__ . &apos;/../config/web.php&apos;;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public function request($request, $response)</span><br><span class="line">    &#123;</span><br><span class="line">    $this-&gt;initParams($request);</span><br><span class="line">    ob_start();</span><br><span class="line">    (new yii\web\Application($this-&gt;config))-&gt;run();</span><br><span class="line">    $content = ob_get_contents();</span><br><span class="line">    ob_clean();</span><br><span class="line">    $response-&gt;end($content);</span><br><span class="line">    &#125;</span><br><span class="line">    private function initParams($request)</span><br><span class="line">    &#123;</span><br><span class="line">    $mapping = [</span><br><span class="line">    &apos;header&apos; =&gt; [&apos;suffix&apos; =&gt; &apos;http&apos;, &apos;name&apos; =&gt; &apos;_SERVER&apos;, &apos;toupper&apos; =&gt; true, &apos;replace_slash&apos; =&gt; true],</span><br><span class="line">    &apos;server&apos; =&gt; [&apos;suffix&apos; =&gt; &apos;&apos;, &apos;name&apos; =&gt; &apos;_SERVER&apos;, &apos;toupper&apos; =&gt; true, &apos;replace_slash&apos; =&gt; false],</span><br><span class="line">    &apos;request&apos; =&gt; [&apos;suffix&apos; =&gt; &apos;&apos;, &apos;name&apos; =&gt; &apos;_REQUEST&apos;, &apos;toupper&apos; =&gt; true, &apos;replace_slash&apos; =&gt; false],</span><br><span class="line">    &apos;cookie&apos; =&gt; [&apos;suffix&apos; =&gt; &apos;&apos;, &apos;name&apos; =&gt; &apos;_COOKIE&apos;, &apos;toupper&apos; =&gt; false, &apos;replace_slash&apos; =&gt; false],</span><br><span class="line">    &apos;get&apos; =&gt; [&apos;suffix&apos; =&gt; &apos;&apos;, &apos;name&apos; =&gt; &apos;_GET&apos;, &apos;toupper&apos; =&gt; false, &apos;replace_slash&apos; =&gt; false],</span><br><span class="line">    &apos;post&apos; =&gt; [&apos;suffix&apos; =&gt; &apos;&apos;, &apos;name&apos; =&gt; &apos;_POST&apos;, &apos;toupper&apos; =&gt; false, &apos;replace_slash&apos; =&gt; false],</span><br><span class="line">    &apos;files&apos; =&gt; [&apos;suffix&apos; =&gt; &apos;&apos;, &apos;name&apos; =&gt; &apos;_FILES&apos;, &apos;toupper&apos; =&gt; false, &apos;replace_slash&apos; =&gt; false],</span><br><span class="line">    ];</span><br><span class="line"></span><br><span class="line">    // 先赋值为空，防止以前的请求对后面的请求产生影响</span><br><span class="line">    foreach ($mapping as $value) &#123;</span><br><span class="line">    $_GET = [];</span><br><span class="line">    $_POST = [];</span><br><span class="line">    $_FILES = [];</span><br><span class="line">    $_COOKIE = [];</span><br><span class="line">    $_REQUEST = [];</span><br><span class="line">    // $_SERVER = [];</span><br><span class="line">    &#125;</span><br><span class="line">    // 针对mapping里面的循环赋值</span><br><span class="line">    foreach ($mapping as $key =&gt; $value) &#123;</span><br><span class="line">    if (!empty($request-&gt;$key)) &#123;</span><br><span class="line">    foreach ($request-&gt;$key as $name =&gt; $val) &#123;</span><br><span class="line">    if (!empty($value[&apos;suffix&apos;])) &#123;</span><br><span class="line">    $name = $value[&apos;suffix&apos;] . &apos;_&apos; . $name;</span><br><span class="line">    &#125;</span><br><span class="line">    if ($value[&apos;toupper&apos;] === true) &#123;</span><br><span class="line">    $name = strtoupper($name);</span><br><span class="line">    &#125;</span><br><span class="line">    if ($value[&apos;replace_slash&apos;] === true) &#123;</span><br><span class="line">    $name = str_replace(&apos;-&apos;, &apos;_&apos;, $name);</span><br><span class="line">    &#125;</span><br><span class="line">    $&#123;strtoupper($value[&apos;name&apos;])&#125;[$name] = $val;</span><br><span class="line">    &#125;</span><br><span class="line">    &#125; else &#123;</span><br><span class="line">    $&#123;strtoupper($value[&apos;name&apos;])&#125; = [];</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    $data[strtoupper($value[&apos;name&apos;])] = $&#123;strtoupper($value[&apos;name&apos;])&#125;;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"> $_GET = $data[&apos;_GET&apos;];</span><br><span class="line">$_POST = $data[&apos;_POST&apos;];</span><br><span class="line">$_FILES = $data[&apos;_FILES&apos;];</span><br><span class="line">$_COOKIE = $data[&apos;_COOKIE&apos;];</span><br><span class="line">$_REQUEST = $data[&apos;_REQUEST&apos;];</span><br><span class="line">$_SERVER = array_merge($data[&apos;_SERVER&apos;], $_SERVER);</span><br><span class="line">    // return true;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">$swoole_index = new SwooleIndex();</span><br><span class="line">$swoole_index-&gt;start();</span><br></pre></td></tr></table></figure><p>在上面的代码里，我准备通过可变变量来对超全局变量进行赋值的，也就是</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$data[strtoupper($value[&apos;name&apos;])] = $&#123;strtoupper($value[&apos;name&apos;])&#125;;</span><br></pre></td></tr></table></figure><p>改成</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$&#123;strtoupper($value[&apos;name&apos;])&#125; = $&#123;strtoupper($value[&apos;name&apos;])&#125;;</span><br></pre></td></tr></table></figure><p>foreach里面也使用可变变量对超全局变量赋值，依然没成功，但是对非超全局变量却可以起到效果，所以暂时无解决方案。</p><h1 id="配置文件web-php"><a href="#配置文件web-php" class="headerlink" title="配置文件web.php"></a>配置文件web.php</h1><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">$config = [</span><br><span class="line">......</span><br><span class="line">    &apos;components&apos; =&gt; [</span><br><span class="line">    ......</span><br><span class="line">        // swoole task compontents</span><br><span class="line">        &apos;task&apos; =&gt; [</span><br><span class="line">            &apos;class&apos; =&gt; &apos;app\component\Task&apos;,</span><br><span class="line">        ],</span><br><span class="line">    ],</span><br><span class="line">    ......</span><br><span class="line">];</span><br></pre></td></tr></table></figure><p>原有的便不再书写了，这里加上了task的组件。</p><h1 id="任务组件Task-php"><a href="#任务组件Task-php" class="headerlink" title="任务组件Task.php"></a>任务组件Task.php</h1><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line">&lt;?php</span><br><span class="line">/**</span><br><span class="line"> * @任务处理组件 </span><br><span class="line"> * @authors Tyloafer (tyloafer@gmail.com)</span><br><span class="line"> * @date    2018-05-15 08:49:25</span><br><span class="line"> */</span><br><span class="line">namespace app\component;</span><br><span class="line"></span><br><span class="line">use yii;</span><br><span class="line">use yii\base\Component;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">class Task extends Component</span><br><span class="line">&#123;</span><br><span class="line">public function uploadFile($data)</span><br><span class="line">&#123;</span><br><span class="line">try &#123;</span><br><span class="line">file_put_contents(&apos;/home/lixy/upload/1.log&apos;, json_encode($data) . &apos;file : &apos; . file_get_contents($data[&apos;pic&apos;][&apos;tmp_name&apos;]));</span><br><span class="line">move_uploaded_file($data[&apos;pic&apos;][&apos;tmp_name&apos;], &apos;/home/lixy/upload/&apos; . $data[&apos;pic&apos;][&apos;name&apos;]);</span><br><span class="line">&#125; catch (\Exception $e) &#123;</span><br><span class="line">echo $e-&gt;getMessage();</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="结束"><a href="#结束" class="headerlink" title="结束"></a>结束</h1><p>上面就简单的实现了swoole整合Yii框架，实现多线程，任务投递等。</p>]]></content>
      
      
      <categories>
          
          <category> Swoole </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Swoole </tag>
            
            <tag> Yii </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Nginx倒腾笔记（先导）：$1等变量的使用</title>
      <link href="/posts/59969/"/>
      <url>/posts/59969/</url>
      
        <content type="html"><![CDATA[<p>这篇文章的命名也是比较晦涩，这也充分显示了我的语文功底是多么的薄弱。简单解释一下吧，我们在使用nginx里面的正则做匹配及rewrite或proxy_pass的时候，会经常使用\$1,\$2这样的变量，这边文章就是做这个解释的。</p><p>其实我是准备写一个Nginx的系列的，而这个是我近期踩到的一个坑，又想记录下来，所以就变成了先导篇。</p><a id="more"></a><p>#起因</p><p>先贴一下配置的例子吧：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">location ~ ^/lixy/(.*(?&lt;!\.php)$) &#123;</span><br><span class="line">    if ($request_uri ~ (create-group|set-avatar|change-avatar|set-group-avatar|resumable_upload|uploadFile\.php|webUpload\.php|resumable_upload_origin)) &#123;</span><br><span class="line">        access_log /data/logs/access.log file;</span><br><span class="line">    &#125;</span><br><span class="line">    proxy_pass https://tyloafer.github.io/$1;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这里的场景是，我在记录<em>request_body</em>的时候，如果是文件上传的话，就会把二进制流给记录下来，这个没必要骗的，所以，我便做了两个 <em>log_format</em> , 一个记录request_body, 另一个不记录 ，默认使用记录的</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">access_log /data/logs/access.log file;</span><br></pre></td></tr></table></figure><p>这句话，也就是指定<em>access.log</em> 的 <em>log_format</em>, 然后再讲我的请求代理到另一台 服务器上</p><p>例：xxxxx.com/lixy/2018/05/18/nginx-proxy-1 =&gt; <a href="https://tyloafer.github.io/2018/05/18/nginx-proxy-1">https://tyloafer.github.io/2018/05/18/nginx-proxy-1</a> , 我在请求的时候， location会匹配到lixy/后面的字符串并复制给$1这个变量，我在proxy_pass的时候，使用这个变量也就没什么问题了，后来发现，如果请求的接口地址包含上面的   (create-group|set-avatar|change-avatar|set-group-avatar|resumable_upload|uploadFile.php|webUpload.php|resumable_upload_origin) 这些字符的时候，还算正常，但是没有就会出问题。</p><h1 id="调试"><a href="#调试" class="headerlink" title="调试"></a>调试</h1><p>最简单的就是调试，打印参数了，这里我在nginx里面直接返回了$1,</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">location ~ ^/lixy/(.*(?&lt;!\.php)$) &#123;</span><br><span class="line">    if ($request_uri ~ (create-group|set-avatar|change-avatar|set-group-avatar|resumable_upload|uploadFi    le\.php|webUpload\.php|resumable_upload_origin)) &#123;</span><br><span class="line">        access_log /data/logs/access.log file;</span><br><span class="line">    &#125;</span><br><span class="line">    root /home/;   </span><br><span class="line">    add_header  Content-Type &apos;text/html; charset=utf-8&apos;;</span><br><span class="line">    return 200 $1;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>当请求xxxxx.com/lixy/2018/05/18/nginx-proxy-1 返回空白，</p><p>当请求xxxxx.com/lixy/2018/05/18/create-group 返回 create-group，</p><p>由此可见，在经过if的正则匹配的时候，同样会对$1进行赋值，这也就是出错的原因了，变量被重新赋值了。</p><h1 id="解决"><a href="#解决" class="headerlink" title="解决"></a>解决</h1><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">location ~ ^/lixy/(.*(?&lt;!\.php)$) &#123;</span><br><span class="line">    set $path $1;</span><br><span class="line">    if ($request_uri ~ (create-group|set-avatar|change-avatar|set-group-avatar|resumable_upload|uploadFi    le\.php|webUpload\.php|resumable_upload_origin)) &#123;</span><br><span class="line">        access_log /data/logs/access.log file;</span><br><span class="line">    &#125;</span><br><span class="line">    root /home/;   </span><br><span class="line">    proxy_pass https://tyloafer.github.io/$path;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>我们先给 location 匹配到的路由地址，赋值给$path，然后后面使用\$path就可以，\$1你们抢你们玩吧，其他的\$2 \$3 \$4 等参数，在使用的时候也需要注意。</p>]]></content>
      
      
      <categories>
          
          <category> Nginx </category>
          
      </categories>
      
      
        <tags>
            
            <tag> PHP </tag>
            
            <tag> Nginx </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Yii2倒腾系列：邮箱及多邮箱配置</title>
      <link href="/posts/35776/"/>
      <url>/posts/35776/</url>
      
        <content type="html"><![CDATA[<h1 id="起因"><a href="#起因" class="headerlink" title="起因"></a>起因</h1><p>邮件发送，在一个程序中，站着举足轻重的地位，所以，学会配置，Yii2的邮箱，也是入门的一项必要技能，但是，在业务发展过程中，有可能一不小心，邮箱被某些邮件服务上拉近黑名单了，很多这种情况就是因为，给不存在的用户发送邮件或被钓鱼了。这时候就需要设置多个邮箱，一个用于给未验证的用户发送邮件，一个给已验证的邮箱发送邮件，防止主要的邮箱被拉近黑名单。</p><a id="more"></a><h1 id="配置单个邮箱"><a href="#配置单个邮箱" class="headerlink" title="配置单个邮箱"></a>配置单个邮箱</h1><p>邮箱的配置在Yii2的文档中，写的还是比较详细的，可参考这里<a href="http://www.yii-china.com/doc/guide/tutorial_mailing.html" target="_blank" rel="noopener">http://www.yii-china.com/doc/guide/tutorial_mailing.html</a> </p><p>将mailer注册进components中即可使用，个人的配置也先贴出来</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">&apos;mailer&apos; =&gt; [</span><br><span class="line">            &apos;class&apos; =&gt; &apos;yii\swiftmailer\Mailer&apos;,         // 这里是邮件发送需调用的类</span><br><span class="line">            &apos;viewPath&apos; =&gt; &apos;@common/mail&apos;,                // 这个是邮件的模板文件，当你用compose()传入模板文件名称的时候，可以直接根据模板文件进行实例化，而不需要自己再多次重写html或txt 版本的邮件内容</span><br><span class="line">            &apos;useFileTransport&apos; =&gt; false,                 // 如果开启这个选项，会把邮件信息保存在本地文件而不是发送它们</span><br><span class="line">            &apos;transport&apos; =&gt; [                              // 这个便是发送邮箱的验证，这个下面会主要分析的</span><br><span class="line">                &apos;class&apos; =&gt; &apos;Swift_SmtpTransport&apos;,</span><br><span class="line">                &apos;host&apos; =&gt; &apos;xxxxxx&apos;,                      // 邮件服务商的host</span><br><span class="line">                &apos;username&apos; =&gt; &apos;xxxxx&apos;,</span><br><span class="line">                &apos;password&apos; =&gt; &apos;*******&apos;,</span><br><span class="line">                &apos;port&apos; =&gt; 465,                            // 端口 一般 端口是 25 ssl 465 tls 587</span><br><span class="line">                &apos;encryption&apos; =&gt; &apos;ssl&apos;,//tls or ssl</span><br><span class="line">                //&apos;timeout&apos; =&gt; 600,</span><br><span class="line">                &apos;streamOptions&apos; =&gt; [                      // 走ssl验证时的规则</span><br><span class="line">                    &apos;ssl&apos; =&gt; [</span><br><span class="line">                        &apos;allow_self_signed&apos; =&gt; true,</span><br><span class="line">                        &apos;verify_peer&apos; =&gt; false,</span><br><span class="line">                        &apos;verify_peer_name&apos; =&gt; false,</span><br><span class="line">                    ],</span><br><span class="line">                ]</span><br><span class="line">           ]</span><br><span class="line">        ],</span><br></pre></td></tr></table></figure><p>在上面的配置中国，会发现，相对于文档中 多了一个<code>transport</code>的 设置，这个就是邮箱的一些配置，我们可以通过这个配置连接我们的邮件服务器，进而收发邮件，那么，也就是说，我们修改了<code>transport</code>就是修改了我们的发件箱，我们在程序中随时更改<code>transport</code>也就可以实现我们最初的需求了，那么如何修改呢，接下来，我们一起看一下<code>Mailer</code>的实例化过程可能就清晰了。</p><h1 id="分析Mailer实例化"><a href="#分析Mailer实例化" class="headerlink" title="分析Mailer实例化"></a>分析Mailer实例化</h1><p>下面截取了一些 <em>Mailer.php</em> 的 主要实例化用到的函数</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line">/**</span><br><span class="line"> * @return array|\Swift_Mailer Swift mailer instance or array configuration.</span><br><span class="line"> */</span><br><span class="line">public function getSwiftMailer()</span><br><span class="line">&#123;</span><br><span class="line">    if (!is_object($this-&gt;_swiftMailer)) &#123;</span><br><span class="line">        $this-&gt;_swiftMailer = $this-&gt;createSwiftMailer();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    return $this-&gt;_swiftMailer;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">/**</span><br><span class="line"> * @param array|\Swift_Transport $transport</span><br><span class="line"> * @throws InvalidConfigException on invalid argument.</span><br><span class="line"> */</span><br><span class="line">public function setTransport($transport)</span><br><span class="line">&#123;</span><br><span class="line">    if (!is_array($transport) &amp;&amp; !is_object($transport)) &#123;</span><br><span class="line">        throw new InvalidConfigException(&apos;&quot;&apos; . get_class($this) . &apos;::transport&quot; should be either object or array, &quot;&apos; . gettype($transport) . &apos;&quot; given.&apos;);</span><br><span class="line">    &#125;</span><br><span class="line">    $this-&gt;_transport = $transport;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">/**</span><br><span class="line"> * @return array|\Swift_Transport</span><br><span class="line"> */</span><br><span class="line">public function getTransport()</span><br><span class="line">&#123;</span><br><span class="line">    if (!is_object($this-&gt;_transport)) &#123;</span><br><span class="line">        $this-&gt;_transport = $this-&gt;createTransport($this-&gt;_transport);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    return $this-&gt;_transport;</span><br><span class="line">&#125;</span><br><span class="line">/**</span><br><span class="line"> * Creates Swift mailer instance.</span><br><span class="line"> * @return \Swift_Mailer mailer instance.</span><br><span class="line"> */</span><br><span class="line">protected function createSwiftMailer()</span><br><span class="line">&#123;</span><br><span class="line">    return \Swift_Mailer::newInstance($this-&gt;getTransport());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>流程可以简单的如下所示</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">graph TD</span><br><span class="line">    st(开始)--&gt;op1(getSwiftMailer)</span><br><span class="line">    op1--已经实例化--&gt;out1&gt;实例化成功]</span><br><span class="line">    op1--还没实例化--&gt;op2(createSwiftMailer)</span><br><span class="line">    op2--&gt;op3(getTransport)</span><br><span class="line">    op3--返回transport对象--&gt;op2</span><br><span class="line">    op3--还未实例化--&gt;op4(createTransport)</span><br><span class="line">    op4--开始实例化--&gt;op5(setTransport)</span><br><span class="line">    op5--返回对象--&gt;op4</span><br><span class="line">    op4--返回对象--&gt;op3</span><br><span class="line">    op2--yes--&gt;en</span><br><span class="line">    out1--&gt;en(结束)</span><br></pre></td></tr></table></figure><p>从上面的分析，我们可以看出，我们要更改<code>transport</code>的话，只需要调用<code>setTransport()</code>，并将我们的配置传给他即可。</p><h1 id="配置多邮箱"><a href="#配置多邮箱" class="headerlink" title="配置多邮箱"></a>配置多邮箱</h1><p>既然，整体流程已经清晰，我们可以在params.php中添加一个数组</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line">&apos;mailer&apos; =&gt; [</span><br><span class="line">    &apos;gmail&apos; =&gt; [</span><br><span class="line">        &apos;class&apos; =&gt; &apos;Swift_SmtpTransport&apos;,</span><br><span class="line">        &apos;host&apos; =&gt; &apos;smtp.gmail.com&apos;,</span><br><span class="line">        &apos;username&apos; =&gt; &apos;xxxxxx,</span><br><span class="line">        &apos;password&apos; =&gt; &apos;*****&apos;,</span><br><span class="line">        &apos;port&apos; =&gt; 587,</span><br><span class="line">        &apos;encryption&apos; =&gt; &apos;tls&apos;,//tls or ssl</span><br><span class="line">    ],</span><br><span class="line">    &apos;163&apos; =&gt; [</span><br><span class="line">        &apos;class&apos; =&gt; &apos;Swift_SmtpTransport&apos;,</span><br><span class="line">        &apos;host&apos; =&gt; &apos;smtp.163.com&apos;,</span><br><span class="line">        &apos;username&apos; =&gt; &apos;xxxxxx&apos;,</span><br><span class="line">        &apos;password&apos; =&gt; &apos;****&apos;,</span><br><span class="line">        &apos;port&apos; =&gt; 465,</span><br><span class="line">        &apos;encryption&apos; =&gt; &apos;ssl&apos;,//tls or ssl</span><br><span class="line">        //&apos;timeout&apos; =&gt; 600,</span><br><span class="line">        &apos;streamOptions&apos; =&gt; [</span><br><span class="line">            &apos;ssl&apos; =&gt; [</span><br><span class="line">                &apos;allow_self_signed&apos; =&gt; true,</span><br><span class="line">                &apos;verify_peer&apos; =&gt; false,</span><br><span class="line">                &apos;verify_peer_name&apos; =&gt; false,</span><br><span class="line">            ],</span><br><span class="line">        ]</span><br><span class="line">   ]</span><br><span class="line">],</span><br></pre></td></tr></table></figure><p>在需要用到邮箱发送且需要更换发送邮箱的地方，先用<code>setTransport()</code>设置发件箱配置即可。例：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">$mailer =  Yii::$app-&gt;mailer;</span><br><span class="line">$mailer-&gt;setTransport(Yii::$app-&gt;params[&apos;mailer&apos;][&apos;gmail&apos;]);</span><br><span class="line">$mailer-&gt;compose(&apos;register&apos;, $data)</span><br><span class="line">       -&gt;setSubject(&apos;多邮箱测试&apos;)</span><br><span class="line">       -&gt;setFrom(&apos;xxxxxx&apos;)</span><br><span class="line">       -&gt;setTo(&apos;xxxxxx&apos;)</span><br><span class="line">       -&gt;send();</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> Yii2 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> PHP </tag>
            
            <tag> Yii2 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Elastic Stack倒腾（1）- 使用Logstash从MySQL导入数据到Elastic</title>
      <link href="/posts/41170/"/>
      <url>/posts/41170/</url>
      
        <content type="html"><![CDATA[<h1 id="序言"><a href="#序言" class="headerlink" title="序言"></a>序言</h1><p>Elastic Stack是是Elastic公司的一套开源项目，这套技术栈也被广泛的称之为ELK。包括elasicsearch，logstash，kibana。其主要功能就是对数据进行收集，格式化，索引，分析和可视化。具有搭建简单，配置容易等优点。</p><p>起初，只有elasticsearch是elastic公司的，不过在接下来的一段时间内，elastic公司先后收购了logstash和kibana，统一三者的发布版本号，完善了三者间的配合，将三者打造成了数据收集分析和展示的利器。</p><p>ElasticStack从2014年开始逐渐趋于完善稳定，不过现在（2016年05月16日）仍处在快速迭代中。</p><p><strong>对于分析日志而言，一般分为三个步骤；日志收集，日志整理存储，数据展示。对应ElasticStack中的：L(ogstash)， E(lasticsearch)，K(ibana)。</strong></p><a id="more"></a><h1 id="安装"><a href="#安装" class="headerlink" title="安装"></a>安装</h1><p>本人的所有安装均在CentOs7下进行安装的，如系统不同，请做适当修改。</p><h1 id="安装JAVA"><a href="#安装JAVA" class="headerlink" title="安装JAVA"></a>安装JAVA</h1><p>ELK的运行需要基于Java，其次运行的时候，他会去在环境变量寻找Java，所以还需要设置环境变量。</p><ol><li><p>安装Java</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">yum install java-1.7.0-openjdk</span><br></pre></td></tr></table></figure></li><li><p>查找文件安装位置</p><p>如果我们不熟悉yum安装后的文件位置，可以通过<code>rpm -ql</code>来显示安装后的文件所在位置</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">rpm -ql java-1.8.0-openjdk</span><br></pre></td></tr></table></figure></li><li><p>设置环境变量</p><p>编辑<code>~/.bashrc</code>或<code>/etc/bashrc</code>， 在里面添加 <code>JAVA_HOME</code>和 <code>JRE_HOME</code></p><figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#set java environment </span></span><br><span class="line">JAVA_HOME=/usr/lib/jvm/java<span class="number">-1.7</span><span class="number">.0</span>-openjdk<span class="number">-1.7</span><span class="number">.0</span><span class="number">.75</span>.x86_64 </span><br><span class="line">JRE_HOME=$JAVA_HOME/jre </span><br><span class="line">CLASS_PATH=.:$JAVA_HOME/lib/dt.jar:$JAVA_HOME/lib/tools.jar:$JRE_HOME/lib </span><br><span class="line">PATH=$PATH:$JAVA_HOME/bin:$JRE_HOME/bin </span><br><span class="line">export JAVA_HOME JRE_HOME CLASS_PATH PATH</span><br></pre></td></tr></table></figure></li></ol><h2 id="安装Elastic"><a href="#安装Elastic" class="headerlink" title="安装Elastic"></a>安装Elastic</h2><p>官方提供了两种安装方式，一种是压缩包的方式，这种方式比较的简单，解压后既可以使用</p><h3 id="压缩包安装"><a href="#压缩包安装" class="headerlink" title="压缩包安装"></a>压缩包安装</h3><ol><li><p>从官网下载好 tar.gz 文件 （tar.gz 和 zip文件一样 看个人习惯）</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">wget https://artifacts.elastic.co/downloads/elasticsearch/elasticsearch-6.2.4.tar.gz</span><br></pre></td></tr></table></figure></li><li><p>解压压缩文件并进入文件夹</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">tar -zxf elasticsearch-6.2.4.tar.gz</span><br><span class="line">cd elasticsearch-6.2.4</span><br></pre></td></tr></table></figure></li><li><p>运行</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">bin/elasticsearch</span><br></pre></td></tr></table></figure><p>通过上面的命令运行的时候，你会发现elasticsearch是在前台运行的，终端关闭，elasticsearch也就关闭了，我们可以加个参数 <code>-d</code> 实现以守护进程的方式运行即可</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">bin/elasticsearch -d</span><br></pre></td></tr></table></figure></li><li><p>可能会遇到的问题</p><ol><li><p><strong>can not run elasticsearch as root</strong></p><p>新建一个 用户，并切换到这个用户，然后再启动elastic</p></li><li><p><strong>max file descriptors [4096] for elasticsearch process is too low, increase to at least [65536]</strong></p><p>切换到 root 用户修改</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">vim /etc/security/limits.conf</span><br></pre></td></tr></table></figure><p>在最后面追加下面内容</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">*** hard nofile 65536</span><br><span class="line">*** soft nofile 65536</span><br></pre></td></tr></table></figure></li><li><p><strong>Error occurred during initialization of VM，Could not reserve enough space for 2097152KB object heap</strong></p><p>这里主要是内存不足，将elastic的运行内存调低即可</p><p>切换到 root 用户修改</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">vim /etc/security/limits.conf</span><br></pre></td></tr></table></figure><p>将原文件中的下面内容</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">-Xms2g</span><br><span class="line">-Xms2g</span><br></pre></td></tr></table></figure><p>修改为</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">-Xms1g</span><br><span class="line">-Xms1g</span><br></pre></td></tr></table></figure></li></ol></li></ol><h3 id="YUM安装"><a href="#YUM安装" class="headerlink" title="YUM安装"></a>YUM安装</h3><ol><li><p>下载并安装签名密钥</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">rpm --import https://artifacts.elastic.co/GPG-KEY-elasticsearch</span><br></pre></td></tr></table></figure></li><li><p>添加repo源</p><p>编辑<code>elk.repo</code></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">vim /etc/yum.repos.d/elk.repo</span><br></pre></td></tr></table></figure><p>并添加一下内容</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">[elasticsearch-6.x]</span><br><span class="line">  name=Elasticsearch repository for 6.x packages</span><br><span class="line">baseurl=https://artifacts.elastic.co/packages/6.x/yum</span><br><span class="line">gpgcheck=1</span><br><span class="line">gpgkey=https://artifacts.elastic.co/GPG-KEY-elasticsearch</span><br><span class="line">enabled=1</span><br><span class="line">autorefresh=1</span><br><span class="line">type=rpm-md</span><br></pre></td></tr></table></figure></li><li><p>使用Yum安装</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">yum install elasticsearch</span><br></pre></td></tr></table></figure></li><li><p>测试是否安装成功</p><p>运行后，通过curl访问对应的端口</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">curl -XGET http://localhost:9200</span><br></pre></td></tr></table></figure><p>如果有内容返回，恭喜你。</p><p>​</p></li></ol><h2 id="安装Logstash"><a href="#安装Logstash" class="headerlink" title="安装Logstash"></a>安装Logstash</h2><h3 id="压缩包安装-1"><a href="#压缩包安装-1" class="headerlink" title="压缩包安装"></a>压缩包安装</h3><ol><li><p>从官网下载好 tar.gz 文件 （tar.gz 和 zip文件一样 看个人习惯）</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">wget https://artifacts.elastic.co/downloads/logstash/logstash-6.2.4.tar.gz</span><br></pre></td></tr></table></figure></li><li><p>解压压缩文件并进入文件夹</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">tar -zxf logstash-6.2.4.tar.gz</span><br><span class="line">cd logstash-6.2.4</span><br></pre></td></tr></table></figure></li><li><p>运行</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">bin/logstash -f logstash.conf</span><br></pre></td></tr></table></figure></li></ol><h3 id="YUM安装-1"><a href="#YUM安装-1" class="headerlink" title="YUM安装"></a>YUM安装</h3><ol><li><p>下载并安装签名密钥</p><p>这里其实跟elastic一样，如果上面执行过，可跳过</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">rpm --import https://artifacts.elastic.co/GPG-KEY-elasticsearch</span><br></pre></td></tr></table></figure></li><li><p>添加repo源</p><p>编辑<code>elk.repo</code></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">vim /etc/yum.repos.d/elk.repo</span><br></pre></td></tr></table></figure><p>并添加一下内容</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">[logstash-6.x]</span><br><span class="line">name=Elastic repository for 6.x packages</span><br><span class="line">baseurl=https://artifacts.elastic.co/packages/6.x/yum</span><br><span class="line">gpgcheck=1</span><br><span class="line">gpgkey=https://artifacts.elastic.co/GPG-KEY-elasticsearch</span><br><span class="line">enabled=1</span><br><span class="line">autorefresh=1</span><br><span class="line">type=rpm-md</span><br></pre></td></tr></table></figure></li><li><p>使用Yum安装</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">yum install logstash</span><br></pre></td></tr></table></figure></li></ol><h2 id="安装Kiban"><a href="#安装Kiban" class="headerlink" title="安装Kiban"></a>安装Kiban</h2><h3 id="压缩包安装-2"><a href="#压缩包安装-2" class="headerlink" title="压缩包安装"></a>压缩包安装</h3><ol><li><p>从官网下载好 tar.gz 文件 （tar.gz 和 zip文件一样 看个人习惯）</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">wget https://artifacts.elastic.co/downloads/kibana/kibana-6.2.4-linux-x86_64.tar.gz</span><br></pre></td></tr></table></figure></li><li><p>解压压缩文件并进入文件夹</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">tar -zxf kibana-6.2.4-linux-x86_64.tar.gz</span><br><span class="line">cd kibana-6.2.4-linux-x86_64</span><br></pre></td></tr></table></figure></li><li><p>修改<code>config/kibana.yml</code>里面的<em>elasticsearch.url</em> 指向你的 elastic的地址</p></li><li><p>运行</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">bin/kibana</span><br></pre></td></tr></table></figure></li><li><p>在浏览器查看</p><p>打开浏览器，输入你的服务器的ip:5601， 例<a href="http://127.0.0.1:5601" target="_blank" rel="noopener">http://127.0.0.1:5601</a>, 就可以看到Kibana的页面了，当然，有可能你的服务器没有开放5601端口，这里也可以通过nginx做个代理，进行访问，这个就放在下一篇文章讲解了。</p></li></ol><h3 id="YUM安装-2"><a href="#YUM安装-2" class="headerlink" title="YUM安装"></a>YUM安装</h3><ol><li><p>下载并安装签名密钥</p><p>这里其实跟elastic一样，如果上面执行过，可跳过</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">rpm --import https://artifacts.elastic.co/GPG-KEY-elasticsearch</span><br></pre></td></tr></table></figure></li><li><p>添加repo源</p><p>编辑<code>elk.repo</code></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">vim /etc/yum.repos.d/elk.repo</span><br></pre></td></tr></table></figure><p>并添加一下内容</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">[kibana-6.x]</span><br><span class="line">name=Kibana repository for 6.x packages</span><br><span class="line">baseurl=https://artifacts.elastic.co/packages/6.x/yum</span><br><span class="line">gpgcheck=1</span><br><span class="line">gpgkey=https://artifacts.elastic.co/GPG-KEY-elasticsearch</span><br><span class="line">enabled=1</span><br><span class="line">autorefresh=1</span><br><span class="line">type=rpm-md</span><br></pre></td></tr></table></figure></li><li><p>使用Yum安装</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">yum install kibana</span><br></pre></td></tr></table></figure></li></ol><h1 id="将数据从MySQL导入到elastic"><a href="#将数据从MySQL导入到elastic" class="headerlink" title="将数据从MySQL导入到elastic"></a>将数据从MySQL导入到elastic</h1><p>我们这里安装了Logstash，所以我们这里可以通过Logstash连接数据库，获取数据后推送到elastic，由于我们数据库的数据是递增的，我们使用Logstash的时候，也可以以递增的方式向elastic添加数据，这样也减少各个方面的压力</p><p>Logstash连接数据库需要jdbc的支持，所以，第一步还是安装扩展</p><h3 id="安装mysql-connector-java"><a href="#安装mysql-connector-java" class="headerlink" title="安装mysql-connector-java"></a>安装mysql-connector-java</h3><p>yum直接安装既可以，安装完成后，通过<code>rmp -ql</code> 找到 <strong>/usr/share/java/mysql-connector-java-5.1.17.jar</strong> 的位置，这里后面会用到</p><h3 id="配置Logstash的配置文件"><a href="#配置Logstash的配置文件" class="headerlink" title="配置Logstash的配置文件"></a>配置Logstash的配置文件</h3><p>在input里面，书写多个 对象， Logstash会从上而下执行，而不是覆盖，所以，如果你想一次添加多个表的数据到elastic，可以多写几个jdbc的对象，每个对象访问不同的库和表</p><p><a href="https://www.elastic.co/guide/en/logstash/current/plugins-inputs-jdbc.html" target="_blank" rel="noopener">https://www.elastic.co/guide/en/logstash/current/plugins-inputs-jdbc.html</a></p><p>上面是elastic官方的 jdbc 插件的使用说明，下面我就上一下自己的配置，并简单的附一下说明</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br></pre></td><td class="code"><pre><span class="line">input &#123;</span><br><span class="line">    jdbc &#123;</span><br><span class="line">        jdbc_connection_string =&gt; &quot;jdbc:mysql://localhost:3306/test&quot;     // jdbc的数据库连接</span><br><span class="line">        jdbc_user =&gt; &quot;*****&quot;            // 数据库用户名</span><br><span class="line">        jdbc_password =&gt; &quot;****&quot;         // 数据库密码</span><br><span class="line"></span><br><span class="line">        jdbc_driver_library =&gt; &quot;/usr/share/java/mysql-connector-java-5.1.17.jar&quot;     // java的mysql驱动，也就是上面我们安装的，地址替换成你服务器上的位置即可</span><br><span class="line">        jdbc_driver_class =&gt; &quot;com.mysql.jdbc.Driver&quot;     // java的mysql驱动类</span><br><span class="line"></span><br><span class="line">        codec =&gt; plain &#123;charset =&gt; &quot;UTF-8&quot;&#125;              // 编码，防乱码</span><br><span class="line">        </span><br><span class="line">        # 分页</span><br><span class="line">        jdbc_paging_enabled =&gt; true                   // 开启分页查询，这样可以减轻压力</span><br><span class="line">        jdbc_page_size =&gt; 300                         // 每次查询的数量</span><br><span class="line">        use_column_value =&gt; true                      // 是否使用列的值，因为我们开启了分页，所以这里设置为true</span><br><span class="line">        tracking_column =&gt; &quot;id&quot;                        // 跟踪的列的名称  这里是分页以及增量导入elastic的时候使用，与上面字段结合使用，logstash会将这个字段的值，存放在我们下面设置的文件里，然后每次查询的时候，会以存储的值为依据，向下查询</span><br><span class="line">        last_run_metadata_path =&gt; &quot;/data/elk/logstash-6.2.4/data/.logstash_jdbc_last_run_index&quot;</span><br><span class="line">        statement =&gt; &quot;select * from test where id &gt; :sql_last_value&quot;        // 查看的sql语句 sql_last_value是内置的变量 ，也是存放在上面文件中的值</span><br><span class="line">        type =&gt; &quot;test&quot;           // 类型，这里可以随便设置，我这里与表名相同</span><br><span class="line">    &#125;   </span><br><span class="line">    jdbc &#123;</span><br><span class="line">        jdbc_connection_string =&gt; &quot;jdbc:mysql://localhost:3306/test&quot;</span><br><span class="line">        jdbc_user =&gt; &quot;*****&quot;</span><br><span class="line">        jdbc_password =&gt; &quot;*****&quot;</span><br><span class="line"></span><br><span class="line">        jdbc_driver_library =&gt; &quot;/usr/share/java/mysql-connector-java-5.1.17.jar&quot;</span><br><span class="line">        jdbc_driver_class =&gt; &quot;com.mysql.jdbc.Driver&quot;</span><br><span class="line"></span><br><span class="line">        # 分页</span><br><span class="line">        jdbc_paging_enabled =&gt; true</span><br><span class="line">        jdbc_page_size =&gt; 300 </span><br><span class="line">        use_column_value =&gt; true</span><br><span class="line">        tracking_column =&gt; &quot;id&quot;</span><br><span class="line">        last_run_metadata_path =&gt; &quot;/data/elk/logstash-6.2.4/data/.logstash_jdbc_last_run_test1&quot;</span><br><span class="line">        statement =&gt; &quot;select * from test1 where id &gt; :sql_last_value&quot;</span><br><span class="line">        type =&gt; &quot;test1&quot;</span><br><span class="line">    &#125;</span><br><span class="line">output &#123;</span><br><span class="line">    stdout &#123;                  // 输出到屏幕终端</span><br><span class="line">        codec =&gt; rubydebug    // rubydebug格式输出</span><br><span class="line">    &#125;</span><br><span class="line">    elasticsearch &#123;             // 输出到elastic</span><br><span class="line">        &quot;hosts&quot; =&gt; &quot;127.0.0.1:9200&quot;           // elastic的地址</span><br><span class="line">        &quot;index&quot; =&gt; &quot;%&#123;type&#125;&quot;      // 类型  也就是我们上面设置的type的值，这样直接用，可以避免if 判断 但是索引就不能自定义了 有利有弊</span><br><span class="line">        # &quot;type&quot; =&gt; &quot;index&quot;</span><br><span class="line">        &quot;document_type&quot; =&gt; &quot;index&quot;   // elastic里面的type</span><br><span class="line">        &quot;document_id&quot; =&gt; &quot;%&#123;id&#125;&quot;     // elastic里面的id，这里建议使用mysql的id，避免mysql数据在elastic里面重复，同时方便查找及增删改查</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="后记"><a href="#后记" class="headerlink" title="后记"></a>后记</h1><p>个人也是刚刚接触ELK，准备打算将学习过程中的东西记录下来，也算是踩坑日记了，所以，ELK的相关东西后面应该还会有很多，Fighting！</p>]]></content>
      
      
      <categories>
          
          <category> ELK </category>
          
      </categories>
      
      
        <tags>
            
            <tag> ELK </tag>
            
            <tag> 大数据 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Sublime倒腾系列：SublimeLinter-PHP语法检验</title>
      <link href="/posts/48314/"/>
      <url>/posts/48314/</url>
      
        <content type="html"><![CDATA[<h1 id="安装"><a href="#安装" class="headerlink" title="安装"></a>安装</h1><p>通过<code>package controller</code>搜索安装<code>SublimeLinter</code>和<code>SublimeLinter-php</code>即可。</p><p>如果不清楚<code>package controller</code>的使用的话，可参考<a href="https://tyloafer.github.io/2018/04/21/sublime-sftp/">《Sublime倒腾系列：配置sftp实现文件上传下载》</a> 或 参考官方文档 <a href="https://packagecontrol.io/installation" target="_blank" rel="noopener">https://packagecontrol.io/installation</a> </p><h1 id="配置"><a href="#配置" class="headerlink" title="配置"></a>配置</h1><p><code>Preference</code> -&gt; <code>Package Setting</code> -&gt; <code>SublimeLinter</code> -&gt;<code>setting</code> 即可打开 <code>SublimeLinter</code> 的用户自定义界面，左侧是系统预设的配置，可以根据左侧的预设 在右边的用户设置中进行一下设置：</p><p>我的设置如下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">// SublimeLinter Settings - User</span><br><span class="line">&#123;</span><br><span class="line"></span><br><span class="line">    &quot;linters&quot;: &#123;</span><br><span class="line">        &quot;php&quot;: &#123;</span><br><span class="line">            &quot;executable&quot;: &quot;D:\\soft\\php72\\php.exe&quot;,     // 这里填写php执行脚本的绝对路径 mac和linux使用 / ，windows下使用\\</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;,</span><br><span class="line">    &quot;paths&quot;: &#123;</span><br><span class="line">        &quot;linux&quot;: [],</span><br><span class="line">        &quot;osx&quot;: [],</span><br><span class="line">        &quot;windows&quot;: [&quot;D:\\soft\\php72\\php.exe&quot;]  // // 这里填写环境变量的绝对地址  用到的添加上去即可</span><br><span class="line">    &#125;,</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>当然，你还可以根据自己的喜好进行配置，例如 style，显示的样式， panel显示等，这个就不多介绍了，注释写的很清晰了。</p>]]></content>
      
      
      <categories>
          
          <category> Sublime </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Sublime </tag>
            
            <tag> Package </tag>
            
            <tag> SublimeLinter </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Yii2倒腾系列：自定义错误处理</title>
      <link href="/posts/40357/"/>
      <url>/posts/40357/</url>
      
        <content type="html"><![CDATA[<h1 id="起因"><a href="#起因" class="headerlink" title="起因"></a>起因</h1><p>Yii2框架，在dev环境下时，错误提示是很友好的，但是，如果我们的代码在线上或者在预发布环境上，有时我们不需要将错误显示的那么明显，当然这时我们可以设置环境为prod，这样就不会有错误提示了，但是一旦出了错误，对于开发人员的排查也就比较耗时耗力了，这时，如果程序出错了，便能给开发人员发送一个邮件，告诉开发人员用户的请求地址，请求参数，错误文件，错误的行数，这样也就可以让开发人员在第一时间解决bug，而展示给用户的仅仅是一条我们定义的错误提示，这样是不是会更好呢？</p><a id="more"></a><h2 id="errorHandler组件设置"><a href="#errorHandler组件设置" class="headerlink" title="errorHandler组件设置"></a>errorHandler组件设置</h2><p>Yii2为我们提供了errorHandler组件，我们只需要设置一下当出现错误的时候，应该路由到的控制器即可，在main.php或main-local.php中的components中添加</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">&apos;errorHandler&apos; =&gt; [</span><br><span class="line">    &apos;errorAction&apos; =&gt; &apos;site/error&apos;,</span><br><span class="line">],</span><br></pre></td></tr></table></figure><p>其次，开启errorHandler 这个组件，需要，关闭debug，同时环境切换的dev下，即在index.php中，将<em>YII_DEBUG</em>和<em>YII_ENV</em> 定义如下</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">defined(&apos;YII_DEBUG&apos;) or define(&apos;YII_DEBUG&apos;, false);</span><br><span class="line">defined(&apos;YII_ENV&apos;) or define(&apos;YII_ENV&apos;, &apos;dev&apos;);</span><br></pre></td></tr></table></figure><p>最后，假如我们将错误处理交给SiteController下actionError() （site/error）这个方法处理，请保证SiteController或者SiteController的父类控制器里面没有下面的内容</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">public function actions()</span><br><span class="line">&#123;</span><br><span class="line">    return [</span><br><span class="line">        &apos;error&apos; =&gt; [</span><br><span class="line">            &apos;class&apos; =&gt; &apos;yii\web\ErrorAction&apos;,</span><br><span class="line">        ],</span><br><span class="line">    ];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>上面的 <em>actions</em> 方法会将<em>actionError()</em>这个方法重新指向 <em>yii\web\ErrorAction</em> 。</p><h1 id="将错误信息用邮件发给开发人员"><a href="#将错误信息用邮件发给开发人员" class="headerlink" title="将错误信息用邮件发给开发人员"></a>将错误信息用邮件发给开发人员</h1><p>Yii2框架本身的错误提示页面比较友好，所以我便将页面内容拿过来，并做了一点修改。</p><ol><li><p>首先新建一个error对应view模板页面（views/site/error.php），将Yii2本身的错误异常处理页面模板exception.php拷贝过来并修改，相信各位 这点简单的操作 肯定不是什么问题的。</p></li><li><p>将actionError()修改如下</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line">public function actionError()</span><br><span class="line">&#123;</span><br><span class="line">       http_response_code(200);</span><br><span class="line">       $exception = Yii::$app-&gt;errorHandler-&gt;exception;</span><br><span class="line">       $statusCode = Yii::$app-&gt;response-&gt;statusCode;</span><br><span class="line">       // 过滤404</span><br><span class="line">       // 此时在 file_put_contents的时候，由于jquery.map.js不存在而报404的错误</span><br><span class="line">       if ($statusCode != 404) &#123;</span><br><span class="line">           $exception_key = Yii::$app-&gt;params[&apos;ExceptionMailList&apos;];</span><br><span class="line">           $request_url = $_SERVER[&apos;REQUEST_SCHEME&apos;] . &quot;://&quot; . $_SERVER[&apos;HTTP_HOST&apos;] . $_SERVER[&apos;REQUEST_URI&apos;];</span><br><span class="line">           $params = json_encode(Yii::$app-&gt;request-&gt;post());</span><br><span class="line">           $content = $this-&gt;renderPartial(&apos;exception&apos;, [&apos;exception&apos; =&gt; $exception,</span><br><span class="line">               &apos;handler&apos; =&gt; Yii::$app-&gt;errorHandler,</span><br><span class="line">               &apos;request_url&apos; =&gt; $request_url,</span><br><span class="line">               &apos;params&apos;    =&gt;  $params</span><br><span class="line">           ]);</span><br><span class="line">           foreach (Yii::$app-&gt;params[&apos;ExceptionNotifyList&apos;] as $email) &#123;</span><br><span class="line">               Email::begin()-&gt;setType(&apos;exception&apos;)</span><br><span class="line">                   -&gt;setEmail($email)</span><br><span class="line">                   -&gt;setUsername(&apos;lixiaoyu&apos;)</span><br><span class="line">                   -&gt;setValue(&apos;content&apos;, $content)</span><br><span class="line">                   -&gt;send();</span><br><span class="line">           &#125;</span><br><span class="line">       &#125;</span><br><span class="line"></span><br><span class="line">       return  FunctionHelper::errorJson(&quot;An internal server error occurred&quot;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>上面代码仅仅是渲染异常页面，然后获取渲染后的页面，并作为邮件内容发送给设置的开发人员的邮箱，这样，便能在第一时间收到异常信息并处理了。</p></li></ol>]]></content>
      
      
      <categories>
          
          <category> Yii2 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> PHP </tag>
            
            <tag> Yii2 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Hexo中引入Mermaid流程图</title>
      <link href="/posts/7790/"/>
      <url>/posts/7790/</url>
      
        <content type="html"><![CDATA[<h1 id="起因"><a href="#起因" class="headerlink" title="起因"></a>起因</h1><p>流程图是个很清晰的展示自己思路的很好的工具，我在我的电脑上用Typora写的时候，自身带了mermaid流程图，但是上传到github上就无法解析了，Google若干后依旧没有效果，但是去Hexo官网逛逛的时候，无意中发现Hexo带有mermaid的插件，所以，对于不了解的技术，还是要多看多读官方文档 [!哀伤脸] 。</p><p>下面的内容摘自github并根据我自己的主题 <em>NEXT</em> 做了点修改， 下面的内容也是以 <em>NEXT</em> 主题为例，各位也可以直接看原版内容<a href="https://github.com/webappdevelp/hexo-filter-mermaid-diagrams" target="_blank" rel="noopener">https://github.com/webappdevelp/hexo-filter-mermaid-diagrams</a></p><a id="more"></a><h1 id="安装插件"><a href="#安装插件" class="headerlink" title="安装插件"></a>安装插件</h1><ol><li><p>yarn 安装</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">yarn add hexo-filter-mermaid-diagrams</span><br></pre></td></tr></table></figure></li><li><p>npm 安装</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">npm install hexo-filter-mermaid-diagrams</span><br></pre></td></tr></table></figure></li></ol><h1 id="编辑配置文件"><a href="#编辑配置文件" class="headerlink" title="编辑配置文件"></a>编辑配置文件</h1><p>配置文件<em>_config.yml</em>，应该分别在根目录下和themes/next/下分别有一个，我们这里编辑的是根目录下的配置文件</p><p>在 <em>_config.yml</em>  的最后加上以下内容</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"># mermaid chart</span><br><span class="line">mermaid: ## mermaid url https://github.com/knsv/mermaid</span><br><span class="line">  enable: true  # default true</span><br><span class="line">  version: &quot;7.1.2&quot; # default v7.1.2</span><br><span class="line">  options:  # find more api options from https://github.com/knsv/mermaid/blob/master/src/mermaidAPI.js</span><br><span class="line">    #startOnload: true  // default true</span><br></pre></td></tr></table></figure><h1 id="引入相关的js文件"><a href="#引入相关的js文件" class="headerlink" title="引入相关的js文件"></a>引入相关的js文件</h1><p>找到主题里面的页脚文件，也即  <code>themes/next/layout/_partials/footer.swig</code> ，在文件最后加上以下内容</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">&#123;% if (theme.mermaid.enable)  %&#125;</span><br><span class="line">  &lt;script src=&apos;https://unpkg.com/mermaid@&lt;%= theme.mermaid.version %&gt;/dist/mermaid.min.js&apos;&gt;&lt;/script&gt;</span><br><span class="line">  &lt;script&gt;</span><br><span class="line">    if (window.mermaid) &#123;</span><br><span class="line">      mermaid.initialize(&#123;theme: &apos;forest&apos;&#125;);</span><br><span class="line">    &#125;</span><br><span class="line">  &lt;/script&gt;</span><br><span class="line">&#123;% endif %&#125;</span><br></pre></td></tr></table></figure><p>至此，重启hexo server应该就可以看到效果了。</p>]]></content>
      
      
      <categories>
          
          <category> Hexo </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Hexo </tag>
            
            <tag> Next </tag>
            
            <tag> Mermaid </tag>
            
            <tag> 流程图 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Sublime倒腾系列：配置sftp实现文件上传下载</title>
      <link href="/posts/45096/"/>
      <url>/posts/45096/</url>
      
        <content type="html"><![CDATA[<h1 id="起因"><a href="#起因" class="headerlink" title="起因"></a>起因</h1><p>作为一枚PHP程序猿，用sublime做开发总感觉自己很不入流，所以后来接触了一段时间的PHPStorm，不得不说，PHPStorm真的很强大，git、xdebug、sftp等能想到的基本都集成了，但是，对于PHPStorm，一直有两点不满意，一是自动补全，二是 界面！！！所以，也就从此开启了个人的Sublime倒腾之旅。而我对Sublime而别钟爱的地方也就是他的插件，每次玩的时候都感觉跟发现了新大陆一样，让我时刻保持着新鲜感。</p><p>下面就简单介绍一下，Sublime的插件-SFTP，标榜PHPStorm的SFTP。</p><a id="more"></a><h1 id="安装sftp"><a href="#安装sftp" class="headerlink" title="安装sftp"></a>安装sftp</h1><h2 id="安装package-controller"><a href="#安装package-controller" class="headerlink" title="安装package controller"></a>安装package controller</h2><p>官网虽然介绍的比较详细了，但是还是多废话一遍吧。</p><p>首先打开sublime，然后通过快捷键 <em>ctrl+`</em> 或者菜单的 <em>View &gt; Show Consoled</em>打开Sublime的控制台，然后输入下列代码，等待执行完成即可。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">import urllib.request,os,hashlib; h = &apos;6f4c264a24d933ce70df5dedcf1dcaee&apos; + &apos;ebe013ee18cced0ef93d5f746d80ef60&apos;; pf = &apos;Package Control.sublime-package&apos;; ipp = sublime.installed_packages_path(); urllib.request.install_opener( urllib.request.build_opener( urllib.request.ProxyHandler()) ); by = urllib.request.urlopen( &apos;http://packagecontrol.io/&apos; + pf.replace(&apos; &apos;, &apos;%20&apos;)).read(); dh = hashlib.sha256(by).hexdigest(); print(&apos;Error validating download (got %s instead of %s), please try manual install&apos; % (dh, h)) if dh != h else open(os.path.join( ipp, pf), &apos;wb&apos; ).write(by)</span><br></pre></td></tr></table></figure><h2 id="安装sftp-1"><a href="#安装sftp-1" class="headerlink" title="安装sftp"></a>安装sftp</h2><p>通过快捷键<em>ctrl_shift+p</em> ，然后在弹出的输入框中输入 <em>pci</em> , 找到 <em>Package Controller: Install Package</em> ,确定回车，然后输入<em>sftp</em>, 等待安装完成即可</p><h2 id="新建-sftp配置文件"><a href="#新建-sftp配置文件" class="headerlink" title="新建 sftp配置文件"></a>新建 sftp配置文件</h2><p>安装完成<em>sftp</em>，下一步就是配置了，将我们的目录指向远程服务器的目录，从而实现通过简单的快捷键或者自动上传更新远程文件以与本地保持同步</p><ol><li><p>在打开的文件夹的根目录新建文件<code>sftp-config.json</code></p></li><li><p>通过快捷键<em>Ctrl+shift+p</em> ,调出插件管理panel</p></li><li><p>输入<em>sftp</em>, 并找到 <em>SFTP: Brower Server</em>, 回车确定就发现sftp-config.json以被修改成如下</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">    // The tab key will cycle through the settings when first created</span><br><span class="line">    // Visit http://wbond.net/sublime_packages/sftp/settings for help</span><br><span class="line">    </span><br><span class="line">    // sftp, ftp or ftps</span><br><span class="line">    &quot;type&quot;: &quot;sftp&quot;,</span><br><span class="line"></span><br><span class="line">    &quot;sync_down_on_open&quot;: true,</span><br><span class="line">    &quot;sync_same_age&quot;: true,</span><br><span class="line">    </span><br><span class="line">    &quot;host&quot;: &quot;example.com&quot;,</span><br><span class="line">    &quot;user&quot;: &quot;username&quot;,</span><br><span class="line">    //&quot;password&quot;: &quot;password&quot;,</span><br><span class="line">    //&quot;port&quot;: &quot;22&quot;,</span><br><span class="line">    </span><br><span class="line">    &quot;remote_path&quot;: &quot;/example/path/&quot;,</span><br><span class="line">    //&quot;file_permissions&quot;: &quot;664&quot;,</span><br><span class="line">    //&quot;dir_permissions&quot;: &quot;775&quot;,</span><br><span class="line">    </span><br><span class="line">    //&quot;extra_list_connections&quot;: 0,</span><br><span class="line"></span><br><span class="line">    &quot;connect_timeout&quot;: 30,</span><br><span class="line">    //&quot;keepalive&quot;: 120,</span><br><span class="line">    //&quot;ftp_passive_mode&quot;: true,</span><br><span class="line">    //&quot;ftp_obey_passive_host&quot;: false,</span><br><span class="line">    //&quot;ssh_key_file&quot;: &quot;~/.ssh/id_rsa&quot;,</span><br><span class="line">    //&quot;sftp_flags&quot;: [&quot;-F&quot;, &quot;/path/to/ssh_config&quot;],</span><br><span class="line">    </span><br><span class="line">    //&quot;preserve_modification_times&quot;: false,</span><br><span class="line">    //&quot;remote_time_offset_in_hours&quot;: 0,</span><br><span class="line">    //&quot;remote_encoding&quot;: &quot;utf-8&quot;,</span><br><span class="line">    //&quot;remote_locale&quot;: &quot;C&quot;,</span><br><span class="line">    //&quot;allow_config_upload&quot;: false,</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>对配置文件进行修改，分别填写上自己的host user password remote_path 即可</p></li></ol><h2 id="扩展"><a href="#扩展" class="headerlink" title="扩展"></a>扩展</h2><p>通过上面的几步操作，已经可以实现将本地与远程文件实现同步了，但是，像我的服务器，关闭了用户名密码登录，仅允许密钥登录，这又该如何操作呢？</p><h3 id="生成ppk密钥"><a href="#生成ppk密钥" class="headerlink" title="生成ppk密钥"></a>生成ppk密钥</h3><p>经过我的尝试，我发现，如果通过密钥登录的话，Sublime不识别id_rsa这样格式的密钥，而仅仅识别.ppk结尾的密钥，这样我们就需要将我们的id_rsa文件转成.ppk格式</p><p>我这里是使用puttygen来进行密钥格式转换的</p><ol><li>下载好puttygen</li><li>选择puttygen菜单上的Conversions-&gt;Import Key 选择 密钥</li><li>点击面板上的 Save private key ，选择保存位置即可转换完成</li></ol><h3 id="配置sftp的密钥模式"><a href="#配置sftp的密钥模式" class="headerlink" title="配置sftp的密钥模式"></a>配置sftp的密钥模式</h3><p>密钥登录其实主要是上面配置文件中的 <em>ssh_key_file</em> 这个选项来决定的，这里要使用绝对地址，指向你的 .ppk 结尾的密钥，简单的上一下我的配置吧，各位读者应该就一目了然了</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">    // The tab key will cycle through the settings when first created</span><br><span class="line">    // Visit http://wbond.net/sublime_packages/sftp/settings for help</span><br><span class="line">    </span><br><span class="line">    // sftp, ftp or ftps</span><br><span class="line">    &quot;type&quot;: &quot;sftp&quot;,</span><br><span class="line"></span><br><span class="line">    &quot;save_before_upload&quot;: true,</span><br><span class="line">    &quot;upload_on_save&quot;: false,     // 当为true的时候，保存文件的时候会自动将你的文件上传到服务器，个人开发比较适合</span><br><span class="line">    &quot;sync_down_on_open&quot;: false,   // 当为true的时候，会自动同步远程的文件夹</span><br><span class="line">    &quot;sync_skip_deletes&quot;: false,</span><br><span class="line">    &quot;sync_same_age&quot;: true,</span><br><span class="line">    &quot;confirm_downloads&quot;: false,</span><br><span class="line">    &quot;confirm_sync&quot;: true,</span><br><span class="line">    &quot;confirm_overwrite_newer&quot;: false,</span><br><span class="line">    </span><br><span class="line">    &quot;host&quot;: &quot;xxx.xxx.xxx.xxx&quot;,</span><br><span class="line">    &quot;user&quot;: &quot;root&quot;,</span><br><span class="line">    //&quot;password&quot;: &quot;password&quot;,</span><br><span class="line">    //&quot;port&quot;: &quot;22&quot;,</span><br><span class="line">    </span><br><span class="line">    &quot;remote_path&quot;: &quot;/data/www/html/httpserver/&quot;,    // 这里是服务器的文件夹路径</span><br><span class="line">    &quot;ignore_regexes&quot;: [</span><br><span class="line">        &quot;\\.sublime-(project|workspace)&quot;, &quot;sftp-config(-alt\\d?)?\\.json&quot;,</span><br><span class="line">        &quot;sftp-settings\\.json&quot;, &quot;/venv/&quot;, &quot;\\.svn/&quot;, &quot;\\.hg/&quot;, &quot;\\.git/&quot;,</span><br><span class="line">        &quot;\\.bzr&quot;, &quot;_darcs&quot;, &quot;CVS&quot;, &quot;\\.DS_Store&quot;, &quot;Thumbs\\.db&quot;, &quot;desktop\\.ini&quot;</span><br><span class="line">    ],</span><br><span class="line">    //&quot;file_permissions&quot;: &quot;664&quot;,</span><br><span class="line">    //&quot;dir_permissions&quot;: &quot;775&quot;,</span><br><span class="line">    //&quot;extra_list_connections&quot;: 0,</span><br><span class="line"></span><br><span class="line">    &quot;connect_timeout&quot;: 30,</span><br><span class="line">    //&quot;keepalive&quot;: 120,</span><br><span class="line">    &quot;ftp_passive_mode&quot;: true,</span><br><span class="line">    &quot;ftp_obey_passive_host&quot;: false,</span><br><span class="line">    &quot;ssh_key_file&quot;: &quot;D:\\workplace\\cloudserver\\httpserver.ppk&quot;,   // windows下路径是\\， linux和Mac Os 是 /</span><br><span class="line">    // &quot;sftp_flags&quot;: [&quot;-F&quot;, &quot;/etc/ssh/ssh_config&quot;],</span><br><span class="line">    </span><br><span class="line">    //&quot;preserve_modification_times&quot;: false,</span><br><span class="line">    //&quot;remote_time_offset_in_hours&quot;: 0,</span><br><span class="line">    //&quot;remote_encoding&quot;: &quot;utf-8&quot;,</span><br><span class="line">    //&quot;remote_locale&quot;: &quot;C&quot;,</span><br><span class="line">    // &quot;allow_config_upload&quot;: false,</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> Sublime </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Sublime </tag>
            
            <tag> Sftp </tag>
            
            <tag> Package </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Session锁导致的ajax请求阻塞</title>
      <link href="/posts/17445/"/>
      <url>/posts/17445/</url>
      
        <content type="html"><![CDATA[<h1 id="起因"><a href="#起因" class="headerlink" title="起因"></a>起因</h1><p>在做项目的时候，做到登录这一块，需要同时支持扫码登录及账号密码登录，整体的思路如下</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">graph TD</span><br><span class="line">    st(开始)--&gt;op1(扫码登录界面)</span><br><span class="line">    st--&gt;op2(帐密登录界面)</span><br><span class="line">    op1--手机端扫码并上传扫码者信息--&gt;op3(扫码登录接口)</span><br><span class="line">    op3--返回web扫码者信息--&gt;op1</span><br><span class="line">    op1--携带返回者信息请求--&gt;op4(帐密登录接口)</span><br><span class="line">    op2--携带登录信息--&gt;op4</span><br><span class="line">    op4--yes--&gt;out1&gt;登录成功]</span><br><span class="line">    op4--no--&gt;out2&gt;登录失败]</span><br><span class="line">    out1--&gt;en(结束)</span><br><span class="line">    out2--&gt;en</span><br></pre></td></tr></table></figure><p>后来发现，webLogin的接口每次调用都特别慢，打开debug后，发现webLogin都是在scanLogin接口结束后，才能开始处理，webLogin被阻塞了。</p><a id="more"></a><h1 id="处理"><a href="#处理" class="headerlink" title="处理"></a>处理</h1><p>排查过程比较繁琐，就直接省略了。这里的原因是，框架这里使用的是Yii2，Yii2会把在初始化的时候调用session_start()来启动session，而session是以文件形式存储的，session启动的时候会给相对应的session文件加上锁，接口处理结束时，取消锁，从而导致的第二个接口在调用的时候被挂起。</p><p>PHP中可以通过下面函数</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">session_write_close();</span><br></pre></td></tr></table></figure><p>关闭session的文件锁。</p><h1 id="扩展"><a href="#扩展" class="headerlink" title="扩展"></a>扩展</h1><h2 id="当你调用-session-start-时，都发生了什么"><a href="#当你调用-session-start-时，都发生了什么" class="headerlink" title="当你调用 session_start() 时，都发生了什么"></a>当你调用 session_start() 时，都发生了什么</h2><p>我们使用一个基本的 PHP 配置为例：当你开始一次 PHP 会话时，PHP会在 <em>session.save_path</em> 路径下创建一个普通的文件，默认路径为 <em>/var/lib/php/session</em> 。所有的 session 数据都保存在这个地方。</p><p>如果你的用户还没有一个 session cookie ，那么 PHP 将产生一个新的 ID，并设置到用户机器的 cookie 中。如果是一个已访问过的用户，那么他会将 cookie 发送给你的 web 服务器，PHP 则会解析它，并且从 <em>session.save_path</em> 路径下加载到相应的 session 数据。<br>简而言之，这就是 <em>session_start()</em> 的所做的工作。</p><h2 id="会话锁与并发"><a href="#会话锁与并发" class="headerlink" title="会话锁与并发"></a>会话锁与并发</h2><p>接下来我们举一个稍微完整一点的例子，来我们说明PHP初始化session后，各个场景下所发生的事情。</p><table><thead><tr><th>Timing</th><th>PHP Code</th><th>Linux/Server</th></tr></thead><tbody><tr><td>0ms</td><td><code>session_start();</code></td><td>创建文件锁：/var/lib/php/session/sess_$identifier</td></tr><tr><td>15ms</td><td>SQL查询，for循环，第三方API调用</td><td>持有session文件锁</td></tr><tr><td>350ms</td><td>PHP脚本执行结束</td><td>session文件锁被移除</td></tr></tbody></table><p>当你调用<strong>session_start()</strong>（或者PHP的<strong>session.auto_start</strong>被设置为true时，该方法会被自动调用），操作系统会锁住session文件。大多数文件锁的实现都是<code>flock</code>，在Linux上，它也用于<a href="https://ma.ttias.be/prevent-cronjobs-from-overlapping-in-linux/" target="_blank" rel="noopener">防止定时任务的重复执行</a>或者其它文件锁定工作。<br>在Linux机器上，一个session文件锁看起来就像这样子。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">$ fuser /var/lib/php/session/sess_cdmtgg3noi8fb6j2vqkaai9ff5</span><br><span class="line">/var/lib/php/session/sess_cdmtgg3noi8fb6j2vqkaai9ff5:  2768  2769  2770</span><br></pre></td></tr></table></figure><p><code>fuser</code>报告了3个进程的PID，这些进程要么正持有此文件锁，或者正在等待此文件锁的释放。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">$ lsof /var/lib/php/session/sess_cdmtgg3noi8fb6j2vqkaai9ff5</span><br><span class="line">COMMAND PID  USER      FD  TYPE DEVICE SIZE/OFF NODE   NAME</span><br><span class="line">php-fpm 2769 http_demo 5uW REG  253,1  0        655415 sess_cdmtgg3noi8fb6j2vqkaai9ff5</span><br></pre></td></tr></table></figure><p><code>lsof</code>可以告知你当前持有文件锁的PID以及指令。<br>该session的文件锁会保持到脚本执行结束或者被主动移除（后面会讲到）。这是一个读写锁：任何对session读取都必须等到锁被释放之后。<br>锁本身并不是问题。它保护session文件中的数据，防止多个同时写入损毁数据或者覆盖之前的数据。<br>但是当第二个并发的PHP执行想要获取同一个PHP会话的时候，就会造成问题了。</p><table><thead><tr><th>Timing</th><th>script 1</th><th>Linux/Server</th><th>script 2</th></tr></thead><tbody><tr><td>0ms</td><td><code>session_start();</code></td><td>script1锁定(<code>flock</code>)文件/var/lib/php/session/sess_$identifier</td><td><code>session_start();</code>被调用，但是被锁阻塞。PHP等待锁被移除。</td></tr><tr><td>15ms</td><td>SQL查询，for循环，第三方API调用</td><td>文件锁保持不变。</td><td>脚本仍然在等待，啥都不做。</td></tr><tr><td>350ms</td><td>script1执行结束。</td><td>script1持有的文件锁被移除。</td><td>script2仍然在等待。</td></tr><tr><td>360ms</td><td></td><td>script2得到新的文件锁。</td><td>script2现在可以执行它的SQL查询，for循环…</td></tr><tr><td>700ms</td><td></td><td>script2持有的文件锁被移除。</td><td>script2执行结束。</td></tr></tbody></table><p>解释一下上面的表格：</p><ul><li>当2个PHP文件同时想要开始一个会话时，只有一个能赢且获得锁。另一个则需要等待。</li><li>当它等待的时候，不会做任何事情：<code>session_start()</code>阻塞了之后动作的执行。</li><li>一旦第一个脚本的锁被移除，第二个脚本在获得锁的同时就可以向后继续执行了。</li></ul><p><strong>在绝大多数场景下，这都使得PHP对于同一个用户来说，表现得像是一系列同步脚本：一个执行完成后执行下一个，没有平行的请求。即使你使用AJAX调用这些PHP脚本也无济于事。</strong><br>所以，刚才两个脚本没能同时在350ms左右的时间执行完毕，第一个脚本350ms执行完毕，而第一个脚本则消耗两倍的时长执行了700ms，因为它得等第一个脚本先执行完。</p><h2 id="可选的session处理器：redis，memcache，mysql"><a href="#可选的session处理器：redis，memcache，mysql" class="headerlink" title="可选的session处理器：redis，memcache，mysql"></a>可选的session处理器：redis，memcache，mysql</h2><p>如果你在寻求一个快速的解决方案，觉得“我只需要把session保存在memcached里”，那么你会失望的。默认的memcached配置使用了与之前描述相同的、安全的逻辑：只要有一个PHP使用了sessions那它们就会阻塞。<br>如果你正在使用PHP的memcached扩展，你可以将<code>memcached.sess_locking</code>设置为“off”，来避免session锁。该配置项的默认值是“on”，与普通的session处理器一样会阻塞。<br>如果你在使用redis，那么你是幸运的，因为redis的session处理器还没有支持锁功能。用redis作为session存储后端，是没有锁的。<br>如果你在使用MySQL作为session后端存储，你会有一个自己的实现：没有一个PHP扩展实现了使用MySQL作为session存储的功能。在你的PHP代码中会有一个函数<a href="http://php.net/manual/en/function.session-set-save-handler.php" target="_blank" rel="noopener">session_set_save_handler()</a>申明了负责session数据读取和写入的类或者方法。也就是说你的代码实现决定了session是否会产生阻塞。</p><h2 id="PHP-session锁：想要解决的问题"><a href="#PHP-session锁：想要解决的问题" class="headerlink" title="PHP session锁：想要解决的问题"></a>PHP session锁：想要解决的问题</h2><p>我对于session锁行为的看法看起过于负面了，但实际上我只是提醒你注意它的行为方式。其实锁的存在也它好的一面。<br>想象以下没有“session锁”的场景，当两个脚本同时处理同一个session数据时，可能引发错误：</p><table><thead><tr><th>Timing</th><th>script 1</th><th>script 2</th></tr></thead><tbody><tr><td>0ms</td><td><code>session_start();</code>session数据被读入到$_SESSION变量中</td><td>1session数据被读入到$_SESSION变量中</td><td></td></tr><tr><td>15ms</td><td>脚本1写入session数据：<code>$_SESSION[&#39;payment_id&#39;] = 1;</code></td><td>脚本2写入session数据：<code>$_SESSION[&#39;payment_id&#39;] = 5;</code></td></tr><tr><td>350ms</td><td><code>sleep(1);</code></td><td>脚本结束，保存session数据</td></tr><tr><td>450ms</td><td>脚本结束，保存session数据</td></tr></tbody></table><blockquote><p>session中的数据值应该是多少？<br>应当是脚本1的所保存的值。因为脚本2所保存的值被脚本1最后所保存的值覆盖了。</p></blockquote><p><strong>这是一个非常尴尬，而且又很难排查的并发问题。session锁可以防止这种情况发生。</strong><br>绝大多数情况下，这是写session数据时才会碰到的问题。如果你有一个PHP脚本只是读取session数据（大多数ajax请求都是），你可以安全地对数据进行多次读取。<br>另一方面，如果你有一个长时间运行的脚本，它读取了session数据并且还会修改session数据，而另一个脚本开始执行并且读取到了旧的过时数据 — 这也可能使你的应用出错。</p><h2 id="关闭PHP的会话锁：PHP-5-x-和-PHP-7"><a href="#关闭PHP的会话锁：PHP-5-x-和-PHP-7" class="headerlink" title="关闭PHP的会话锁：PHP 5.x 和 PHP 7"></a>关闭PHP的会话锁：PHP 5.x 和 PHP 7</h2><p>PHP中有一个方法叫做<code>session_write_close()</code>。它的功能如其名：写入session数据，关闭session文件，从而解除了session锁。你在PHP代码中，可以这样使用。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">&lt;?php</span><br><span class="line">// This works in PHP 5.x and PHP 7</span><br><span class="line">session_start();</span><br><span class="line"></span><br><span class="line">$_SESSION[&apos;something&apos;] = &apos;foo&apos;;</span><br><span class="line">$_SESSION[&apos;yolo&apos;] = &apos;swag&apos;;</span><br><span class="line"></span><br><span class="line">session_write_close();</span><br><span class="line"></span><br><span class="line">// Do the rest of your PHP execution below</span><br></pre></td></tr></table></figure><p>上面的示例代码先开启了session（将session数据读到\$_SESSION中），然后写入数据再解除锁。接下来，它就再也不能写入这个session文件了。如果接下来该脚本还在继续操作$_SESSION变量，那么这些变化都不会被保存下来。<br>从PHP 7开始，在调用<code>session_start()</code>的时候你可设置额外的选项。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">&lt;?php</span><br><span class="line">session_start([</span><br><span class="line">  &apos;read_and_close&apos; =&gt; true</span><br><span class="line">]);</span><br><span class="line">?&gt;</span><br></pre></td></tr></table></figure><p>以上语法等同于：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">&lt;?php</span><br><span class="line">session_start();</span><br><span class="line"></span><br><span class="line">session_write_close();</span><br><span class="line">?&gt;</span><br></pre></td></tr></table></figure><p>它先读取了session数据，然后立刻释放了锁，这样就不会阻塞其它脚本了。</p>]]></content>
      
      
      <categories>
          
          <category> PHP </category>
          
      </categories>
      
      
        <tags>
            
            <tag> PHP </tag>
            
            <tag> Ajax </tag>
            
            <tag> SESSION </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>PHP获取环境变量</title>
      <link href="/posts/44810/"/>
      <url>/posts/44810/</url>
      
        <content type="html"><![CDATA[<h1 id="起因"><a href="#起因" class="headerlink" title="起因"></a>起因</h1><p>使用PHP的exec等函数与：Linux进行交互是很常见的方式，但是有时候发现，在终端里面通过命令行模式运行的代码可行，放到网站上去访问就出问题了，这里主要是因为在通过Nginx调起PHP-FPM的时候，会存在一些参数的配置问题下面就简单介绍一下这两种方式。</p><a id="more"></a><h1 id="解决-PHP-FPM模式"><a href="#解决-PHP-FPM模式" class="headerlink" title="解决-PHP-FPM模式"></a>解决-PHP-FPM模式</h1><ol><li><p>通过Nginx传递</p><p>如在nginx的配置里设置：<br><code>fastcgi_param  ENV_XXX  123456;</code><br>每次页面请求nginx都会将此变量传递给php，php可以通过getenv函数或$_SERVER全局变量获得。 </p></li><li><p>通过PHP-FPM配置传递</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">; Clear environment in FPM workers</span><br><span class="line">; Prevents arbitrary environment variables from reaching FPM worker processes</span><br><span class="line">; by clearing the environment in workers before env vars specified in this</span><br><span class="line">; pool configuration are added.</span><br><span class="line">; Setting to &quot;no&quot; will make all environment variables available to PHP code</span><br><span class="line">; via getenv(), _ENV and _SERVER.</span><br><span class="line">; Default Value: yes </span><br><span class="line">; clear_env = no</span><br><span class="line"></span><br><span class="line">; Pass environment variables like LD_LIBRARY_PATH. All $VARIABLEs are taken from</span><br><span class="line">; the current environment.</span><br><span class="line">; Default Value: clean env </span><br><span class="line">;env[HOSTNAME] = $HOSTNAME</span><br><span class="line">env[PATH] = /usr/local/bin:/usr/bin:/bin:/usr/local/sbin</span><br><span class="line">;env[TMP] = /tmp</span><br><span class="line">;env[TMPDIR] = /tmp</span><br><span class="line">;env[TEMP] = /tmp</span><br></pre></td></tr></table></figure><p>上面是php-fpm.conf（包括php-fpm.d/<a href="http://www.conf）里面关于环境变量的配置，在里面有一个`clear_env`的参数配置，这个默认是*yes*，而他的含义就是会把Linux上设置的环境变量给清空，这样的设置也是基于安全角度来考虑，我们此时把这个值设置为*no*即可，即" target="_blank" rel="noopener">www.conf）里面关于环境变量的配置，在里面有一个`clear_env`的参数配置，这个默认是*yes*，而他的含义就是会把Linux上设置的环境变量给清空，这样的设置也是基于安全角度来考虑，我们此时把这个值设置为*no*即可，即</a></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">clear_env = no</span><br></pre></td></tr></table></figure><p>在下面的配置中有一个<code>env[PATH]</code>的参数配置，这里也可以满足我们设置环境变量的需求</p><p>​</p><h1 id="解决-命令行模式"><a href="#解决-命令行模式" class="headerlink" title="解决-命令行模式"></a>解决-命令行模式</h1><p>命令行模式限制较少，可以通过getenv函数或$_SERVER全局变量获取对当前执行用户有效的系统环境变量，同样要注意sudo的限制</p></li></ol>]]></content>
      
      
      <categories>
          
          <category> PHP </category>
          
      </categories>
      
      
        <tags>
            
            <tag> PHP </tag>
            
            <tag> Linux </tag>
            
            <tag> Nginx </tag>
            
            <tag> php-fpm </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>使用redis-dump对redis的数据进行导入导出</title>
      <link href="/posts/55761/"/>
      <url>/posts/55761/</url>
      
        <content type="html"><![CDATA[<h1 id="起因"><a href="#起因" class="headerlink" title="起因"></a>起因</h1><p>Redis虽然可以进行aof和rdb的备份，但是总是用起来没有MySQL对数据的管理感觉顺手，便产生了使用第三方来进行数据管理的想法以及实现。</p><a id="more"></a><h1 id="安装Ruby"><a href="#安装Ruby" class="headerlink" title="安装Ruby"></a>安装Ruby</h1><p>Redis-dump的安装依赖Ruby较高版本，yum源里面的Ruby版本较低，所以这里使用<code>rvm</code>进行安装</p><ol><li><p>安装<code>RVM</code></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">gpg --keyserver hkp://keys.gnupg.net --recv-keys 409B6B1796C275462A1703113804BB82D39DC0E3 7D2BAF1CF37B13E2069D6956105BD0E739499BDB</span><br><span class="line">\curl -sSL https://get.rvm.io | bash -s stable</span><br></pre></td></tr></table></figure></li><li><p>使用<code>RVM</code> 安装<code>Ruby</code></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">rvm install ruby</span><br></pre></td></tr></table></figure></li></ol><h1 id="安装redis-dump"><a href="#安装redis-dump" class="headerlink" title="安装redis-dump"></a>安装redis-dump</h1><p>直接使用<code>Ruby</code>的<code>gem</code>包管理直接安装即可</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">gem install redis-dump</span><br></pre></td></tr></table></figure><h1 id="使用redis-dump"><a href="#使用redis-dump" class="headerlink" title="使用redis-dump"></a>使用redis-dump</h1><ol><li><p>导出</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">redis-dump -u :password@xxx.xxx.xxx.xxx:6379 &gt; redis.json</span><br></pre></td></tr></table></figure></li><li><p>导入</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">redis-load -u :password@localhost &lt; redis.json</span><br></pre></td></tr></table></figure></li><li><p>更多</p><p>更多可参考官方使用手册</p><p><a href="http://delanotes.com/redis-dump/" target="_blank" rel="noopener">http://delanotes.com/redis-dump/</a></p></li></ol>]]></content>
      
      
      <categories>
          
          <category> Redis </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Linux </tag>
            
            <tag> Redis </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Windows上传ZIP文件到Linux下，解压乱码处理</title>
      <link href="/posts/35688/"/>
      <url>/posts/35688/</url>
      
        <content type="html"><![CDATA[<h1 id="起因"><a href="#起因" class="headerlink" title="起因"></a>起因</h1><p>作为码农，从windows上上传文件一般都会避免中文命名，都知道会有编码的问题，但是这个问题是不可逃避的。</p><p>近期，我给PM做一个产品原型的管理页面的时候，这个问题便不可避免的发生了。</p><a id="more"></a><h1 id="处理"><a href="#处理" class="headerlink" title="处理"></a>处理</h1><p>Linux下解压ZIP文件，主要依靠<code>unzip</code>这个命令，通过<code>-h</code>查看帮助后，发现<code>unzip</code>有个·<code>-O -I</code>这两个参数（ps: 如果没有，请升级到最新版本）</p><p>对于这两个参数的解释如下</p><blockquote><p>  -O CHARSET  specify a character encoding for DOS, Windows and OS/2 archives<br>  -I CHARSET  specify a character encoding for UNIX and other archives</p></blockquote><p>由上可知，我们这里使用<code>-O</code>应该就可以避免编码问题了</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">unzip -O gbk filename.zip</span><br></pre></td></tr></table></figure><h1 id="扩展问题-PHP下处理"><a href="#扩展问题-PHP下处理" class="headerlink" title="扩展问题-PHP下处理"></a>扩展问题-PHP下处理</h1><p>在Linux终端下，处理上述文件已经没有问题了，接下来肯定要考虑使用PHP来进行处理了。</p><p>php有一个ZipArchiv 解压缩类，但是我并没有找到针对编码的处理方式，所以无奈还是通过<code>exec</code>等命令来处理。<strong>注意：</strong> 如果你的php脚本是通过php-fpm来调度执行而不是php-cli直接执行的话，php-fpm的配置文件<em>php-fpm.conf</em>或<em>php-fpm.d/<a href="http://www.conf" target="_blank" rel="noopener">www.conf</a></em>里面会有环境变量的设置，这里要注意php-fpm的环境变量里面的<em>LANG</em>的值与Linux的设置的相同，不然还是会存在乱码的问题。</p>]]></content>
      
      
      <categories>
          
          <category> Debug </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Linux </tag>
            
            <tag> Debug </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Munin安装及监控-报警配置</title>
      <link href="/posts/25813/"/>
      <url>/posts/25813/</url>
      
        <content type="html"><![CDATA[<p>在完成<a href="https://tyloafer.github.io/2017/12/09/Munin监控安装及配置/">《Munin安装及监控》</a>之后，另一个功能-报警就被提上日程了，苦苦查看官方文档之后，发现也仅仅是介绍了有这个报警的功能。</p><a id="more"></a><h1 id="Command配置"><a href="#Command配置" class="headerlink" title="Command配置"></a>Command配置</h1><p>在<em>munin.conf</em> 有个配置是 <em>contact.anotheruser.command</em>， 而本篇文章的报警也是基于这个命令实现的，先贴一个示例</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">contact.munin.command mail -s &quot;Munin notification&quot; test@163.com</span><br></pre></td></tr></table></figure><p>可以看出，其中anotheruser是我们在监控的时候的，自己定义的一个用户，这个后面会介绍。</p><p>这里的 <em>mail -s</em> 是调用Linux终端的 mail 命令来发送邮件， 具体配置可参见<a href="https://tyloafer.github.io/2017/12/03/mail/">《Linux下使用mail发送邮件》</a>, 当然这里的命令也可以随便写，只要能在终端执行即可，例</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">contact.munin.command /usr/sbin/php /home/test.php</span><br></pre></td></tr></table></figure><h1 id="用户配置"><a href="#用户配置" class="headerlink" title="用户配置"></a>用户配置</h1><p>接着上面埋下的一个疑问，就是command前面的user，我怎么知道应该写哪个user，先贴一下我的一个memory的配置，这个配置时<em>plugin-conf.d/</em> 下面的<em>memory</em> 的配置</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">[memory]</span><br><span class="line">    user munin</span><br><span class="line">    env.swap_warning 80% </span><br><span class="line">    env.swap_critical 90% </span><br><span class="line">    env.active_warning 80% </span><br><span class="line">    env.cached_warning 80% </span><br><span class="line">    env.active_critical 90% </span><br><span class="line">    env.cached_critical 90% </span><br><span class="line">    env.apps_warning 80% </span><br><span class="line">    env.apps_critical 90% </span><br><span class="line">    env.cache_warning 80% </span><br><span class="line">    env.cache_critical 90%</span><br></pre></td></tr></table></figure><p>其实，user是我们配置的第一行指定的，这个munin在执行的时候，如果检测memory达到告警值的时候，就去找这个配置的user，然后执行相应的command</p><h1 id="建议"><a href="#建议" class="headerlink" title="建议"></a>建议</h1><p>Munin的监控插件是使用perl和python来写的，没事可以多看看插件源码，可以对监控的设置会有一个更加清晰的认知，同时也可以尝试自己用脚本语言写一下，练练手。</p>]]></content>
      
      
      <categories>
          
          <category> Linux </category>
          
      </categories>
      
      
        <tags>
            
            <tag> munin </tag>
            
            <tag> Linux </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Linux下mail发送邮件8015错误</title>
      <link href="/posts/58415/"/>
      <url>/posts/58415/</url>
      
        <content type="html"><![CDATA[<h1 id="起因"><a href="#起因" class="headerlink" title="起因"></a>起因</h1><p>在上上篇文章<a href="https://tyloafer.github.io/2017/12/03/mail/">Linux下使用mail发送邮件</a>中介绍了如何在linux下通过mail发送邮件，然而在后来我使用的过程中，却发现报错了</p><blockquote><p>Error initializing NSS: Unknown error -8015.</p></blockquote><a id="more"></a><h1 id="分析"><a href="#分析" class="headerlink" title="分析"></a>分析</h1><p>出现这个原因，主要是因为我监控系统需要用到，但监系统的执行用户和属组肯定不是root，但是我安装及配置的时候是使用root，同时，我在使用root用户发送邮件的时候却并没有这个错误。此上，基本确定应该是文件权限的问题了。</p><p>查看配置的时候，发现使用smtps发送的时候需要配置证书，也即下面一段</p><blockquote><p>set nss-config-dir=/etc/mail/.certs    # SSL证书保存位置，稍后个人制作</p></blockquote><h1 id="解决办法"><a href="#解决办法" class="headerlink" title="解决办法"></a>解决办法</h1><p>赋予其他用户 nss-config-dir下面文件的写的权限即可，如果感觉不安全，给予其他用户 你使用的 证书 写的权限即可</p><blockquote><p>chmod +r /etc/mail/.certs -R</p></blockquote>]]></content>
      
      
      <categories>
          
          <category> Linux </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Linux </tag>
            
            <tag> mail </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>PHP如何读取大文件</title>
      <link href="/posts/63198/"/>
      <url>/posts/63198/</url>
      
        <content type="html"><![CDATA[<h1 id="起因"><a href="#起因" class="headerlink" title="起因"></a>起因</h1><p>这是偶然间看到的一篇文章，感觉收获颇丰，故转载。转载自<a href="https://www.luyuqiang.com/how-php-read-a-large-file" target="_blank" rel="noopener">芦雨强的网络日志</a></p><h1 id="干货分割线"><a href="#干货分割线" class="headerlink" title="干货分割线"></a>干货分割线</h1><p>作为一个PHP开发者，我们经常需要关注内存管理。PHP引擎在我们运行脚本之后做了很好的清理工作，短周期执行的web服务器模型意味着即使是烂代码也不会长时间影响。</p><a id="more"></a><p>我们很少需要走出舒适的边界–比如我们尝试在一个小的VPS上为创建一个大项目运行Composer，或者当我们在小服务器上读取一个大文件。</p><p>这是后续将在本教程中呈现的问题。</p><p>教程代码可以在<a href="https://github.com/sitepoint-editors/sitepoint-performant-reading-of-big-files-in-php" target="_blank" rel="noopener">github</a>找到</p><h1 id="衡量成功"><a href="#衡量成功" class="headerlink" title="衡量成功"></a>衡量成功</h1><p>确定我们完善代码的唯一方式是把烂代码和修正过的代码进行比较。换句话说，我们不知道它是否是解决办法，除非我们知道它帮了多少。</p><p>有两个我们需要关心的指标。第一个是CPU的使用。我们想要过程快或者慢？第二个是内存的使用。脚本运行使用了多少内存？这些通常是成反比的-意味着我们可以在看CPU的使用时候，不看内存的使用，反之亦然。</p><p>在一个异步程序模型中（比如多进程或者多线程的PHP应用），CPU和内存使用都需要谨慎考虑的。在传统PHP架构中，当它们中的哪个达到服务器极限的时候通常就会有问题。</p><p>在PHP中测量CPU使用不切实际。如果你关注，可以考虑在Ubuntu或者MacOs中使用top命令。Windows可以考虑安装一个linux子系统，你就可以在Ubuntu上使用top。</p><p>这个教程的目的是测量内存使用。我们将看到「传统」脚本中内存的使用情况，之后将会优化并且测量，最后我希望你可以做一个学习后的选择。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">//php.net文档中格式化字节的方法</span><br><span class="line">memory_get_peak_usage();</span><br><span class="line"></span><br><span class="line">function formatBytes($bytes, $precision = 2) &#123;</span><br><span class="line">    $units = array(&apos;b&apos;, &apos;kb&apos;, &apos;mb&apos;, &apos;gb&apos;, &apos;tb&apos;);</span><br><span class="line"></span><br><span class="line">    $bytes = max($bytes, 0);</span><br><span class="line">    $pow = floor(($bytes ? log($bytes) : 0) / log(1024));</span><br><span class="line">    $pow = min($pow, count($units) - 1);</span><br><span class="line"></span><br><span class="line">    $bytes /= (1 &lt;&lt; (10 * $pow));</span><br><span class="line"></span><br><span class="line">    return round($bytes, $precision) . &apos; &apos; . $units[$pow];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>我们将会在脚本的最后使用这个函数，因此可以在第一时间看到哪个脚本使用了更多的内存。</p><h1 id="选项"><a href="#选项" class="headerlink" title="选项"></a>选项</h1><p>我们可以采取很多高效读取文件方法。但是有两种常用的场景。我们可以先读取后处理数据，然后输出处理后的数据或者执行其他操作。我们可能也想要转换一个数据流而不用获取数据。</p><p>对于第一种情况，我们读取一个文件，然后每一万行创建一个独立的队列进程。我们需要至少把一万行放到在内存中，然后把他们发送到队列管理器。</p><p>对于第二种情况，我们压缩一个特别大的API响应。我们不在乎它说什么，但我们需要确保它是以压缩形式备份的。</p><p>两种情况下，我们都需要读取大文件，只不过一个关注数据一个不关注。让我们探索这些选项吧。。。</p><h1 id="一行一行读文件"><a href="#一行一行读文件" class="headerlink" title="一行一行读文件"></a>一行一行读文件</h1><p>有很多处理文件的函数。让我们使用一个简单明了的文件读取：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">// from memory.php</span><br><span class="line"></span><br><span class="line">function formatBytes($bytes, $precision = 2) &#123;</span><br><span class="line">    $units = array(&apos;b&apos;, &apos;kb&apos;, &apos;mb&apos;, &apos;gb&apos;, &apos;tb&apos;);</span><br><span class="line"></span><br><span class="line">    $bytes = max($bytes, 0);</span><br><span class="line">    $pow = floor(($bytes ? log($bytes) : 0) / log(1024));</span><br><span class="line">    $pow = min($pow, count($units) - 1);</span><br><span class="line"></span><br><span class="line">    $bytes /= (1 &lt;&lt; (10 * $pow));</span><br><span class="line"></span><br><span class="line">    return round($bytes, $precision) . &apos; &apos; . $units[$pow];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">print formatBytes(memory_get_peak_usage());</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">// from reading-files-line-by-line-1.php</span><br><span class="line"></span><br><span class="line">function readTheFile($path) &#123;</span><br><span class="line">    $lines = [];</span><br><span class="line">    $handle = fopen($path, &apos;r&apos;);</span><br><span class="line"></span><br><span class="line">    while(!feof($handle)) &#123;</span><br><span class="line">        $lines[] = trim(fgets($handle));</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    fclose($handle);</span><br><span class="line">    return $lines;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">readTheFile(&apos;shakespeare.txt&apos;);</span><br><span class="line"></span><br><span class="line">require &apos;memory.php&apos;;</span><br></pre></td></tr></table></figure><p>我们正在读取一个包含莎士比亚全集的文本文件。文本文件大约5.5MB，消耗了12.8MB的内存。现在，让我们使用生成器来读取每一行：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">// from reading-files-line-by-line-2.php</span><br><span class="line"></span><br><span class="line">function readTheFile($path) &#123;</span><br><span class="line">    $handle = fopen($path, &apos;r&apos;);</span><br><span class="line"></span><br><span class="line">    while(!feof($handle)) &#123;</span><br><span class="line">        yield trim(fgets($handle));</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    fclose($handle);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">readTheFile(&apos;shakespeare.txt&apos;);</span><br><span class="line"></span><br><span class="line">require &apos;memory.php&apos;;</span><br></pre></td></tr></table></figure><p>这个文本文件同样大小，但是消耗了393KB的内存。这也说明不了什么，除非我们使用读取的数据做一些事。假设我们把文档以每两个空行分成小片段。就像：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">// from reading-files-line-by-line-3.php</span><br><span class="line"></span><br><span class="line">$iterator = readTheFile(&apos;shakespeare.txt&apos;);</span><br><span class="line"></span><br><span class="line">$buffer = &apos;&apos;;</span><br><span class="line"></span><br><span class="line">foreach ($iterator as $iteration) &#123;</span><br><span class="line">    preg_match(&apos;/\n&#123;3&#125;/&apos;, $buffer, $matches);</span><br><span class="line"></span><br><span class="line">    if (count($matches)) &#123;</span><br><span class="line">        print &apos;.&apos;;</span><br><span class="line">        $buffer = &apos;&apos;;</span><br><span class="line">    &#125; else &#123;</span><br><span class="line">        $buffer .= $iteration . PHP_EOL;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">require &apos;memory.php&apos;;</span><br></pre></td></tr></table></figure><p>猜一下我们现在用了多少内存？尽管我们把文档分割成了1216个片段，我们却只用了458KB的内存，意外吗？鉴于生成器的性质，我们内存消耗最大的是需要在循环中存储最大文本块的内存。在这种情况下，最大的块是101,985个字符。</p><p>我已经写了<a href="https://www.sitepoint.com/memory-performance-boosts-with-generators-and-nikiciter/" target="_blank" rel="noopener">使用生成器的性能提升</a>和<a href="https://github.com/nikic/iter" target="_blank" rel="noopener">Nikita Popov的生成器库</a>，所以你想要了解更多就去看吧。</p><p>生成器也有其他用法，但对读取大文件有很明显的性能提升。如果我们需要去处理数据，生成器也是最好的方式。</p><h1 id="文件间的管道输送"><a href="#文件间的管道输送" class="headerlink" title="文件间的管道输送"></a>文件间的管道输送</h1><p>在某些情况下，我们不需要处理数据，而是把一个文件的数据传递到另一个文件。这通常被叫做管道输送（大概因为我们只看到了两头，没看到管道内。。。当然它不是透明的）。我们可以通过使用流方法获取它们。写了个从一个文件传递到另一个的脚本，方便我们可以测量内存使用：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">// from piping-files-1.php</span><br><span class="line"></span><br><span class="line">file_put_contents(</span><br><span class="line">    &apos;piping-files-1.txt&apos;, file_get_contents(&apos;shakespeare.txt&apos;)</span><br><span class="line">);</span><br><span class="line"></span><br><span class="line">require &apos;memory.php&apos;;</span><br></pre></td></tr></table></figure><p>不出意外地，这个脚本使用比文件的拷贝更多的内存。这是因为它不得不读取、把文本内容放到内存中，然后写入到一个新文件。对于小文件还好。但是当我们处理一个大文件，就不妙了。。。</p><p>让我们使用流的方式从一个文件传递到另一个（或者叫管道输送）</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">// from piping-files-2.php</span><br><span class="line"></span><br><span class="line">$handle1 = fopen(&apos;shakespeare.txt&apos;, &apos;r&apos;);</span><br><span class="line">$handle2 = fopen(&apos;piping-files-2.txt&apos;, &apos;w&apos;);</span><br><span class="line"></span><br><span class="line">stream_copy_to_stream($handle1, $handle2);</span><br><span class="line"></span><br><span class="line">fclose($handle1);</span><br><span class="line">fclose($handle2);</span><br><span class="line"></span><br><span class="line">require &apos;memory.php&apos;;</span><br></pre></td></tr></table></figure><p>这段代码很奇怪。我们打开两个文件的句柄，第一个使用读模式，第二使用写模式。然后我们从第一个复制到第二个。然后关闭两个文件的句柄。是不是惊喜到你了，内存只使用了393KB。</p><p>这看起来是不是很熟悉。不就是我们使用生成器的代码一行一行读取然后存储吗？这是因为第二个变量使用fgets指定每行读取多少字节（默认-1或者直到一个新行）</p><p>stream_copy_to_stream的第三个参数是完全相同的参数（具有完全相同的默认值）。stream_copy_to_stream正在读取一个流，一次一行，并将其写入另一个流。 它跳过了生成器产生值的部分，因为我们不需要使用该值。</p><p>管道输送这些文本对我们来说没用，所以让我们仔细思考一下其他可能的例子。假设我们想要从CDN输出一个图像，重定向应用的路由。代码如下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">// from piping-files-3.php</span><br><span class="line"></span><br><span class="line">file_put_contents(</span><br><span class="line">    &apos;piping-files-3.jpeg&apos;, file_get_contents(</span><br><span class="line">        &apos;https://github.com/assertchris/uploads/raw/master/rick.jpg&apos;</span><br><span class="line">    )</span><br><span class="line">);</span><br><span class="line"></span><br><span class="line">// ...or write this straight to stdout, if we don&apos;t need the memory info</span><br><span class="line"></span><br><span class="line">require &apos;memory.php&apos;;</span><br></pre></td></tr></table></figure><p>我们可以使用以上代码解决一个应用的路由问题。但我们想从CDN获取而不是把文件存储在本地文件系统中。我们可能使用更优雅的（像<a href="http://docs.guzzlephp.org/en/stable/" target="_blank" rel="noopener">Guzzle</a>）替代file_get_contents，但是效果一样。</p><p>图片的内存使用大约581KB。现在，我们试着使用流替代？</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">// from piping-files-4.php</span><br><span class="line"></span><br><span class="line">$handle1 = fopen(</span><br><span class="line">    &apos;https://github.com/assertchris/uploads/raw/master/rick.jpg&apos;, &apos;r&apos;</span><br><span class="line">);</span><br><span class="line"></span><br><span class="line">$handle2 = fopen(</span><br><span class="line">    &apos;piping-files-4.jpeg&apos;, &apos;w&apos;</span><br><span class="line">);</span><br><span class="line"></span><br><span class="line">// ...or write this straight to stdout, if we don&apos;t need the memory info</span><br><span class="line"></span><br><span class="line">stream_copy_to_stream($handle1, $handle2);</span><br><span class="line"></span><br><span class="line">fclose($handle1);</span><br><span class="line">fclose($handle2);</span><br><span class="line"></span><br><span class="line">require &apos;memory.php&apos;;</span><br></pre></td></tr></table></figure><p>内存使用会略少（400KB），但是结果却一样。如果我们需要更多的内存信息，我们可以打印到standard output。事实上，PHP为实现这个提供了简单的方法。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">$handle1 = fopen(</span><br><span class="line">    &apos;https://github.com/assertchris/uploads/raw/master/rick.jpg&apos;, &apos;r&apos;</span><br><span class="line">);</span><br><span class="line"></span><br><span class="line">$handle2 = fopen(</span><br><span class="line">    &apos;php://stdout&apos;, &apos;w&apos;</span><br><span class="line">);</span><br><span class="line"></span><br><span class="line">stream_copy_to_stream($handle1, $handle2);</span><br><span class="line"></span><br><span class="line">fclose($handle1);</span><br><span class="line">fclose($handle2);</span><br><span class="line"></span><br><span class="line">// require &apos;memory.php&apos;;</span><br></pre></td></tr></table></figure><h1 id="其他流"><a href="#其他流" class="headerlink" title="其他流"></a>其他流</h1><p>有一些其他流我们可以管道传递、读、或者写：</p><ul><li>php://stdin (只读)</li><li>php://stderr (只写, 像 php://stdout)</li><li>php://input (只读) 获取原请求体</li><li>php://output (只写) 可以写到缓冲区</li><li>php://memory 和 php://temp (读写)存储临时数据的地方。php://temp不同的是以文件存储，php://memory存储在内存</li></ul><h1 id="过滤器"><a href="#过滤器" class="headerlink" title="过滤器"></a>过滤器</h1><p>还有一个使用流的技巧叫过滤器。它们是中间步骤，提供管理流而不暴露给我们的功能。设想一下我们想要压缩莎士比亚.txt。可能会使用Zip扩展：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">// from filters-1.php</span><br><span class="line"></span><br><span class="line">$zip = new ZipArchive();</span><br><span class="line">$filename = &apos;filters-1.zip&apos;;</span><br><span class="line"></span><br><span class="line">$zip-&gt;open($filename, ZipArchive::CREATE);</span><br><span class="line">$zip-&gt;addFromString(&apos;shakespeare.txt&apos;, file_get_contents(&apos;shakespeare.txt&apos;));</span><br><span class="line">$zip-&gt;close();</span><br><span class="line"></span><br><span class="line">require &apos;memory.php&apos;;</span><br></pre></td></tr></table></figure><p>整洁的代码，但是却消耗了10.75MB。我们使用过滤器改进：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">// from filters-2.php</span><br><span class="line"></span><br><span class="line">$handle1 = fopen(</span><br><span class="line">    &apos;php://filter/zlib.deflate/resource=shakespeare.txt&apos;, &apos;r&apos;</span><br><span class="line">);</span><br><span class="line"></span><br><span class="line">$handle2 = fopen(</span><br><span class="line">    &apos;filters-2.deflated&apos;, &apos;w&apos;</span><br><span class="line">);</span><br><span class="line"></span><br><span class="line">stream_copy_to_stream($handle1, $handle2);</span><br><span class="line"></span><br><span class="line">fclose($handle1);</span><br><span class="line">fclose($handle2);</span><br><span class="line"></span><br><span class="line">require &apos;memory.php&apos;;</span><br></pre></td></tr></table></figure><p>可以看到使用php://filter/zlib.defalte的过滤器来压缩资源。我们可以把一个压缩后的数据管道传递到另一个文件。内存消耗896KB。</p><p>我知道这不是同一个格式，或者使用zip压缩更好。但是你不得不怀疑：如果你选择不同的格式可以节省掉12倍的内存，何乐而不为呢？</p><p>可以通过另一个zlib的解压缩过滤器解压文件：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">// from filters-2.php</span><br><span class="line"></span><br><span class="line">file_get_contents(</span><br><span class="line">    &apos;php://filter/zlib.inflate/resource=filters-2.deflated&apos;</span><br><span class="line">);</span><br></pre></td></tr></table></figure><p>流已经在<a href="https://www.sitepoint.com/%EF%BB%BFunderstanding-streams-in-php/" target="_blank" rel="noopener">理解PHP中的流</a> 和 <a href="https://www.sitepoint.com/using-php-streams-effectively/" target="_blank" rel="noopener">PHP流与效率</a>中大量提及。如果你想要了解更多，点开看看。</p><h1 id="自定义流"><a href="#自定义流" class="headerlink" title="自定义流"></a>自定义流</h1><p>fopen和file_get_contents有他们自己的默认设置，但是可以完全的自定义。为了方便理解，自己创建一个新的流：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line">// from creating-contexts-1.php</span><br><span class="line"></span><br><span class="line">$data = join(&apos;&amp;&apos;, [</span><br><span class="line">    &apos;twitter=assertchris&apos;,</span><br><span class="line">]);</span><br><span class="line"></span><br><span class="line">$headers = join(&apos;\r\n&apos;, [</span><br><span class="line">    &apos;Content-type: application/x-www-form-urlencoded&apos;,</span><br><span class="line">    &apos;Content-length: &apos; . strlen($data),</span><br><span class="line">]);</span><br><span class="line"></span><br><span class="line">$options = [</span><br><span class="line">    &apos;http&apos; =&gt; [</span><br><span class="line">        &apos;method&apos; =&gt; &apos;POST&apos;,</span><br><span class="line">        &apos;header&apos;=&gt; $headers,</span><br><span class="line">        &apos;content&apos; =&gt; $data,</span><br><span class="line">    ],</span><br><span class="line">];</span><br><span class="line"></span><br><span class="line">$context = stream_content_create($options);</span><br><span class="line"></span><br><span class="line">$handle = fopen(&apos;https://example.com/register&apos;, &apos;r&apos;, false, $context);</span><br><span class="line">$response = stream_get_contents($handle);</span><br><span class="line"></span><br><span class="line">fclose($handle);</span><br></pre></td></tr></table></figure><p>在这个例子中，我们尝试向API发出POST请求。API端是安全的，但是仍需要使用http上下文属性（用于http和http）。我们设置一些头并且打开API文件句柄。考虑到安全，我们以只读方式打开。</p><p>可以自定义很多东西，所以如果你想了解更多，最好查看<a href="https://php.net/function.stream-context-create" target="_blank" rel="noopener">文档</a>。</p><h1 id="自定义协议的过滤器"><a href="#自定义协议的过滤器" class="headerlink" title="自定义协议的过滤器"></a>自定义协议的过滤器</h1><p>在本文结束之前，来谈谈自定义协议。 如果你看<a href="https://php.net/manual/en/class.streamwrapper.php" target="_blank" rel="noopener">文档</a>，你可以找到一个示例类来实现：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line">Protocol &#123;</span><br><span class="line">    public resource $context;</span><br><span class="line">    public construct ( void )</span><br><span class="line">    public destruct ( void )</span><br><span class="line">    public bool dir_closedir ( void )</span><br><span class="line">    public bool dir_opendir ( string $path , int $options )</span><br><span class="line">    public string dir_readdir ( void )</span><br><span class="line">    public bool dir_rewinddir ( void )</span><br><span class="line">    public bool mkdir ( string $path , int $mode , int $options )</span><br><span class="line">    public bool rename ( string $path_from , string $path_to )</span><br><span class="line">    public bool rmdir ( string $path , int $options )</span><br><span class="line">    public resource stream_cast ( int $cast_as )</span><br><span class="line">    public void stream_close ( void )</span><br><span class="line">    public bool stream_eof ( void )</span><br><span class="line">    public bool stream_flush ( void )</span><br><span class="line">    public bool stream_lock ( int $operation )</span><br><span class="line">    public bool stream_metadata ( string $path , int $option , mixed $value )</span><br><span class="line">    public bool stream_open ( string $path , string $mode , int $options ,</span><br><span class="line">        string &amp;$opened_path )</span><br><span class="line">    public string stream_read ( int $count )</span><br><span class="line">    public bool stream_seek ( int $offset , int $whence = SEEK_SET )</span><br><span class="line">    public bool stream_set_option ( int $option , int $arg1 , int $arg2 )</span><br><span class="line">    public array stream_stat ( void )</span><br><span class="line">    public int stream_tell ( void )</span><br><span class="line">    public bool stream_truncate ( int $new_size )</span><br><span class="line">    public int stream_write ( string $data )</span><br><span class="line">    public bool unlink ( string $path )</span><br><span class="line">    public array url_stat ( string $path , int $flags )</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>我们不打算实现在教程中，因为我认为这是值得的自己完成过程。需要做很多工作，但是一旦这个工作完成，可以很容易地注册的流包装：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">if (in_array(&apos;highlight-names&apos;, stream_get_wrappers())) &#123;</span><br><span class="line">    stream_wrapper_unregister(&apos;highlight-names&apos;);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">stream_wrapper_register(&apos;highlight-names&apos;, &apos;HighlightNamesProtocol&apos;);</span><br><span class="line"></span><br><span class="line">$highlighted = file_get_contents(&apos;highlight-names://story.txt&apos;);</span><br></pre></td></tr></table></figure><p>类似地，可以自己创建一个自定义流过滤器。文档有一个过滤器类的例子：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">Filter &#123;</span><br><span class="line">    public $filtername;</span><br><span class="line">    public $params</span><br><span class="line">    public int filter ( resource $in , resource $out , int &amp;$consumed ,</span><br><span class="line">        bool $closing )</span><br><span class="line">    public void onClose ( void )</span><br><span class="line">    public bool onCreate ( void )</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>很容易注册：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">$handle = fopen(&apos;story.txt&apos;, &apos;w+&apos;);</span><br><span class="line">stream_filter_append($handle, &apos;highlight-names&apos;, STREAM_FILTER_READ);</span><br></pre></td></tr></table></figure><p>高亮名字过滤器需要去匹配新的过滤器类的过滤器名属性。也可以在php：//filter/highligh-names/resource=story.txt字符串中使用自定义过滤器。定义过滤器比定义协议要容易得多。 其中一个原因是协议需要处理目录操作，而过滤器只需处理每个数据块。</p><p>如果你有强烈的进取心，鼓励你编写协议的过滤器。如果你可以将过滤器应用于stream_copy_to_stream操作，那么即使处理大容量的大文件，你的应用程序内存也不会超阈值。 试着编写一个调整图像大小的过滤器或加密应用程序的过滤器。</p><h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><p>尽管这不是我们经常处理的问题，在读取大文件时也很容易陷入困境。在异步应用中，当我们不注意内存使用时，很容易就把整个服务搞挂。</p><p>这个教程希望给你讲解一些新想法（或者唤醒你的记忆），以便你能在读、写大文件时想得更多。当开始熟练掌握流和生成器后，停止使用像file_get_contents函数：一些莫名其妙问题就在程序中消失了。这就是意义所在！</p><h1 id="声明"><a href="#声明" class="headerlink" title="声明"></a>声明</h1><p>本文转载自<a href="https://www.luyuqiang.com/how-php-read-a-large-file" target="_blank" rel="noopener">芦雨强的网络日志</a></p>]]></content>
      
      
      <categories>
          
          <category> PHP </category>
          
      </categories>
      
      
        <tags>
            
            <tag> PHP </tag>
            
            <tag> 优化 </tag>
            
            <tag> 大文件 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>file_get_contents使用SSL连接报错</title>
      <link href="/posts/55399/"/>
      <url>/posts/55399/</url>
      
        <content type="html"><![CDATA[<h1 id="分析"><a href="#分析" class="headerlink" title="分析"></a>分析</h1><p>在使用file_get_contents的时候，有时候获取受信任的https的内容是正常的，但是遇到一些不受信任的https连接，就会报错，主要原因还是不受信任的https大部分是自制证书或者已过期等等，检测证书的时候没通过。</p><p>既然知道了原因，那不让他验证ssl不就可以了。</p><a id="more"></a><h1 id="处理"><a href="#处理" class="headerlink" title="处理"></a>处理</h1><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">string file_get_contents ( string $filename [, bool $use_include_path = false [, resource $context [, int $offset = -1 [, int $maxlen ]]]] )</span><br></pre></td></tr></table></figure><p>上述是<em>file_get_contents()</em> 函数的文档，第三参数可以设置一些头信息等，就如同使用curl一样，我们在头部添加一下信息就可以不验证ssl了</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">&quot;ssl&quot;=&gt;array(</span><br><span class="line">  &quot;verify_peer&quot;=&gt;false,</span><br><span class="line">  &quot;verify_peer_name&quot;=&gt;false,</span><br><span class="line">),</span><br></pre></td></tr></table></figure><p>完整使用用例如下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">&lt;?php</span><br><span class="line">$opts = [</span><br><span class="line">    &quot;ssl&quot; =&gt; [</span><br><span class="line">        &quot;verify_peer&quot;=&gt;false,</span><br><span class="line">        &quot;verify_peer_name&quot;=&gt;false,</span><br><span class="line">    ],</span><br><span class="line">];</span><br><span class="line">$context = stream_context_create($opts);</span><br><span class="line">$response = file_get_contents(&quot;https://tyloafer.github.io/2018/12/03/mail/&quot;, false, $context);</span><br></pre></td></tr></table></figure><h1 id="扩展"><a href="#扩展" class="headerlink" title="扩展"></a>扩展</h1><p>官方实例中有如下用法：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">&lt;?php</span><br><span class="line">// Create a stream</span><br><span class="line">$opts = array(</span><br><span class="line">  &apos;http&apos;=&gt;array(</span><br><span class="line">    &apos;method&apos;=&gt;&quot;GET&quot;,</span><br><span class="line">    &apos;header&apos;=&gt;&quot;Accept-language: en\r\n&quot; .</span><br><span class="line">              &quot;Cookie: foo=bar\r\n&quot;</span><br><span class="line">  )</span><br><span class="line">);</span><br><span class="line"></span><br><span class="line">$context = stream_context_create($opts);</span><br><span class="line"></span><br><span class="line">// Open the file using the HTTP headers set above</span><br><span class="line">$file = file_get_contents(&apos;http://www.example.com/&apos;, false, $context);</span><br></pre></td></tr></table></figure><p>也就是说 其实我们可以在第三个参数中这是header、cookie、params等信息，这样就可以跟curl一样模拟post和get请求了。用例就不详述了，各位猿们自行探索吧。</p>]]></content>
      
      
      <categories>
          
          <category> PHP </category>
          
      </categories>
      
      
        <tags>
            
            <tag> PHP </tag>
            
            <tag> Debug </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Munin安装及监控</title>
      <link href="/posts/62852/"/>
      <url>/posts/62852/</url>
      
        <content type="html"><![CDATA[<h1 id="安装munin"><a href="#安装munin" class="headerlink" title="安装munin"></a>安装munin</h1><ol><li><p>通过yum安装munin munin-node httpd</p><pre><code>yum -y install munin munin-node httpd</code></pre><a id="more"></a></li><li><p>修改配置文件/etc/munin/munin.conf </p> <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">dbdir /data/www/html/munin/databases // 数据库存放地址 </span><br><span class="line">htmldir /data/www/html/munin/html //页面存放地址</span><br><span class="line">logdir /data/www/html/munin/log // 日志存放地址 </span><br><span class="line">rundir /var/run/munin // 运行时pid存放地址 </span><br><span class="line"></span><br><span class="line"># Where to look for the HTML templates </span><br><span class="line"># </span><br><span class="line">tmpldir /etc/munin/templates </span><br><span class="line"></span><br><span class="line"># a simple host tree </span><br><span class="line">[localhost] </span><br><span class="line">    address 127.0.0.1 </span><br><span class="line">    use_node_name yes</span><br></pre></td></tr></table></figure></li><li><p>创建存放地址并修改权限<br>​      </p><pre><code>mkdir /data/www/html/munin/databases /data/www/html/munin/html /data/www/html/munin/logchown munin:munin /data/www/html/munin -R</code></pre></li></ol><ol start="3"><li><p>启动munin-node<br>​      </p><pre><code>service munin-node start</code></pre><p>查看配置中htmldir的路径下是否生成了HTML等静态文件，如没有，请执行下面命令   </p><pre><code>su munin --shell=/bin/bashmunin-cron</code></pre></li><li><p>访问静态页面的存放地址即可查看,此处没有单独配置域名，所以直接访问http://域名/munin/html/即可</p></li></ol><h1 id="利用cgi动态绘制图形"><a href="#利用cgi动态绘制图形" class="headerlink" title="利用cgi动态绘制图形"></a>利用cgi动态绘制图形</h1><pre><code>yum -y install  spawn-fcgi # 安装绘图的cgispawn-fcgi -s /var/run/munin/fastcgi-graph.sock    -u munin -g munin /var/www/cgi-bin/munin-cgi-graph # 启动进程，这里的sock的路径可自定义，后期需要在nginx中进行配置</code></pre><p>综上将fcgi安装启动完成，下面将fcgi整合到nginx中进行动态的绘制图片</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">location ^~ /munin-cgi/munin-cgi-graph/ &#123;</span><br><span class="line">    root /data/www/html</span><br><span class="line">    fastcgi_split_path_info ^(/munin-cgi/munin-cgi-graph)(.*);</span><br><span class="line">    fastcgi_param PATH_INFO $fastcgi_path_info;</span><br><span class="line">    fastcgi_pass unix:/var/run/munin/fastcgi-graph.sock;</span><br><span class="line">    include fastcgi_params;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="监控nginx"><a href="#监控nginx" class="headerlink" title="监控nginx"></a>监控nginx</h1><p>监控nginx其实是利用了nginx的<em>http_stub_status_module</em>m模块来获取nginx的请求和状态。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">my $URL = exists $ENV&#123;&apos;url&apos;&#125; ? $ENV&#123;&apos;url&apos;&#125; : &quot;http://localhost/nginx_status&quot;;                   </span><br><span class="line">my $port = exists $ENV&#123;&apos;port&apos;&#125; ? $ENV&#123;&apos;port&apos;&#125; : &quot;80&quot;;                                           </span><br><span class="line">                                                                                                </span><br><span class="line">if ( exists $ARGV[0] and $ARGV[0] eq &quot;autoconf&quot; )                                               </span><br><span class="line">&#123;</span><br><span class="line">    if ($ret)&#123;</span><br><span class="line">        print &quot;no ($ret)\n&quot;;</span><br><span class="line">        exit 0;</span><br><span class="line">    &#125;</span><br><span class="line">    my $ua = LWP::UserAgent-&gt;new(timeout =&gt; 30,</span><br><span class="line">            agent =&gt; sprintf(&quot;munin/%s (libwww-perl/%s)&quot;,    $Munin::Common::Defaults::MUNIN_VERSION, $LWP::VERSION));     </span><br><span class="line">    my $response = $ua-&gt;request(HTTP::Request-&gt;new(&apos;GET&apos;,$URL));</span><br><span class="line">    unless ($response-&gt;is_success and $response-&gt;content =~ /server/im)</span><br><span class="line">    &#123;</span><br><span class="line">        print &quot;no (no nginx status on $URL)\n&quot;;</span><br><span class="line">        exit 0;</span><br><span class="line">    &#125;</span><br><span class="line">    else</span><br><span class="line">    &#123;</span><br><span class="line">        print &quot;yes\n&quot;;</span><br><span class="line">        exit 0;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>这是nginx_request模块的源码，通过上面可以看出，其实这个程序是去请求里面的url，从而获得nginx的一些状态<br>接下来我们看一下官方nginx的配置<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">server &#123;</span><br><span class="line">      listen 80;</span><br><span class="line">      server_name localhost;</span><br><span class="line">      location /nginx_status &#123;</span><br><span class="line">              stub_status on;</span><br><span class="line">              access_log   off;</span><br><span class="line">              allow 127.0.0.1;</span><br><span class="line">              deny all;</span><br><span class="line">      &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>综上，整体思路可以理清：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">graph LR</span><br><span class="line">munin发起请求--&gt;nginx获取请求</span><br><span class="line">nginx获取请求--&gt;nginx解析请求,启动stu_status模块</span><br></pre></td></tr></table></figure><p>所以，只要将官方的nginx配置加入到nginx.conf中即可，但是，在此我遇到了一个问题，通过curl访问这<em>个<a href="https://localhost/nginx_status" target="_blank" rel="noopener">https://localhost/nginx_status</a></em> 返回的是</p><pre><code>curl: (7) Failed connect to localhost:80; Connection refused</code></pre><p>但是访问127.0.0.1却是可以的，我的配置如下</p><p><strong>nginx.conf</strong><br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">server &#123;</span><br><span class="line">      listen 80;</span><br><span class="line">      server_name 127.0.0.1;</span><br><span class="line">      location /nginx_status &#123;</span><br><span class="line">              stub_status on;</span><br><span class="line">              access_log   off;</span><br><span class="line">              allow 127.0.0.1;</span><br><span class="line">              deny all;</span><br><span class="line">      &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p><strong>nginx_request</strong><br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">my $URL = exists $ENV&#123;&apos;url&apos;&#125; ? $ENV&#123;&apos;url&apos;&#125; : &quot;http://127.0.0.1/nginx_status&quot;;                   </span><br><span class="line">my $port = exists $ENV&#123;&apos;port&apos;&#125; ? $ENV&#123;&apos;port&apos;&#125; : &quot;80&quot;;                                           </span><br><span class="line">                                                                                                </span><br><span class="line">if ( exists $ARGV[0] and $ARGV[0] eq &quot;autoconf&quot; )                                               </span><br><span class="line">&#123;</span><br><span class="line">    if ($ret)&#123;</span><br><span class="line">        print &quot;no ($ret)\n&quot;;</span><br><span class="line">        exit 0;</span><br><span class="line">    &#125;</span><br><span class="line">    my $ua = LWP::UserAgent-&gt;new(timeout =&gt; 30,</span><br><span class="line">            agent =&gt; sprintf(&quot;munin/%s (libwww-perl/%s)&quot;, $Munin::Common::Defaults::MUNIN_VERSION, $LWP::VERSION));     </span><br><span class="line">    my $response = $ua-&gt;request(HTTP::Request-&gt;new(&apos;GET&apos;,$URL));</span><br><span class="line">    unless ($response-&gt;is_success and $response-&gt;content =~ /server/im)</span><br><span class="line">    &#123;</span><br><span class="line">        print &quot;no (no nginx status on $URL)\n&quot;;</span><br><span class="line">        exit 0;</span><br><span class="line">    &#125;</span><br><span class="line">    else</span><br><span class="line">    &#123;</span><br><span class="line">        print &quot;yes\n&quot;;</span><br><span class="line">        exit 0;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>检查模块是否正常<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">munin-node-configure |grep nginx</span><br><span class="line">nginx_request | yes |  </span><br><span class="line">nginx_status | yes |</span><br></pre></td></tr></table></figure></p><h1 id="监控Redis"><a href="#监控Redis" class="headerlink" title="监控Redis"></a>监控Redis</h1><ol><li><p>首先下载munin redis的第三方插件</p><pre><code>git clone https://github.com/bpineau/redis-munin</code></pre></li><li><p>将git下载的redis-munin中的<em>redis_</em>更名，更改为redis_<em>IP</em>_<em>PORT</em>, eg. <em>redis_127.0.0.1_6379</em></p></li><li><p>加载redis插件</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ln -sf /path/to/redis_*IP*_*PORT* /etc/munin/plugins/</span><br></pre></td></tr></table></figure></li><li><p>在/etc/munin/conf.d中添加redis，创建munin的redis配置文件</p><pre><code>[redis_*]   user root     //在这里要root用户   env.host 127.0.0.1   env.port 6379</code></pre></li><li><p>测试redis插件</p><pre><code>munin-run redis</code></pre></li><li><p>重启munin</p><pre><code>service munin-node restart</code></pre><p>​     </p><h1 id="监控php-fpm"><a href="#监控php-fpm" class="headerlink" title="监控php-fpm"></a>监控php-fpm</h1></li><li><p>首先开启php-fpm的状态</p><blockquote><p>vim /etc/php-fpm.d/<a href="http://www.conf" target="_blank" rel="noopener">www.conf</a></p><p>pm.status_path = /status     //把前面注释去掉 </p><p>kill -USR2 <code>cat /run/php-fpm/php-fpm.pid</code>  // 平滑重启php-fpm，线上建议此用法</p></blockquote></li><li><p>修改nginx配置</p><blockquote><p>在上面监控nginx的server下的location下面添加一个location配置</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">&gt; location ~ ^/(status|ping)$ &#123;</span><br><span class="line">&gt; include fastcgi_params;</span><br><span class="line">&gt; fastcgi_pass 127.0.0.1:9000;</span><br><span class="line">&gt; fastcgi_param SCRIPT_FILENAME $fastcgi_script_name;  </span><br><span class="line">&gt; allow 127.0.0.1;</span><br><span class="line">&gt; deny all;</span><br><span class="line">&gt; &#125;</span><br><span class="line">&gt;</span><br></pre></td></tr></table></figure></blockquote></li><li><p>重启nginx</p></li><li><p>通过curl访问，检测配置是否正确</p><pre><code>curl -v http://127.0.0.1/status</code></pre></li><li><p>下载munin-phpfpm的插件</p><pre><code>git clone https://github.com/tjstein/php5-fpm-munin-plugins</code></pre></li><li><p>建立phpfpm相关插件的软链</p><pre><code>ln -s /etc/munin/thirdPlugins/php5-fpm-munin-plugins/phpfpm_* /etc/munin/plugins/</code></pre></li><li><p>编辑phpfpm的配置文件</p><blockquote><p>vim /et/munin/conf.d/phpfpm</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">&gt; [phpfpm*]</span><br><span class="line">&gt; env.url http://127.0.01/status</span><br><span class="line">&gt; env.ports 80</span><br><span class="line">&gt;</span><br></pre></td></tr></table></figure></blockquote></li><li><p>测试phpfpm插件</p><blockquote><p>munin-run phpfpm_connections<br>munin-run phpfpm_memory</p></blockquote></li></ol><h1 id="监控MySQL"><a href="#监控MySQL" class="headerlink" title="监控MySQL"></a>监控MySQL</h1><p>munin本身自带的MySQL监控信息太少，所以我们这里选择第三方的munin MySQL插件</p><ol><li><p>安装第三方MySQL插件所需的依赖</p><pre><code>yum -y install yum install perl-Cache-Cache perl-IPC-ShareLite perl-DBD-MySQL perl-Module-Pluggable</code></pre></li><li><p>下载源码包</p><pre><code>git clone https://github.com/kjellm/munin-mysql</code></pre></li><li><p>编辑下载下来的源码包里面的<em>Makefile</em></p><blockquote><p>修改第四行的代码 <em>PLUGIN_DIR:=/usr/local/share/munin/plugins</em></p><pre><code>PLUGIN_DIR:=/usr/share/munin/plugins</code></pre><p>修改第四十五行的代码 <em>$(MUNIN_NODE) restart</em></p><pre><code>service munin-node restart</code></pre><p>​</p></blockquote></li><li><p>编辑<em>mysql.conf</em></p><blockquote><p>注释第十一行<em>env.mysqlconnection DBI:mysql:mysql</em>并删除第九行<em>env.mysqlconnection DBI:mysql:mysql;host=localhost;port=3306</em>的注释</p><p>按照mysql的配置分别填写host port user password</p></blockquote></li><li><p>在当前路径下执行编译脚本<br>​      </p><pre><code>make install</code></pre></li><li><p>检测MySQL插件是否正常安装</p><pre><code>munin-run mysql</code></pre></li></ol><h1 id="重新生成HTML文件"><a href="#重新生成HTML文件" class="headerlink" title="重新生成HTML文件"></a>重新生成HTML文件</h1><p>综上所有步骤完成后，重启<em>munin-node</em>发现页面上还是没有MySQL，redis，phpfpm的相关内容，这时需要通过<strong>munin-cron</strong>脚本来重新生成HTML文件</p><blockquote><p>su - munin –shell=/bin/bash<br>munin-cron</p></blockquote><h1 id="Nginx添加认证模块及禁用缓存"><a href="#Nginx添加认证模块及禁用缓存" class="headerlink" title="Nginx添加认证模块及禁用缓存"></a>Nginx添加认证模块及禁用缓存</h1><p>我们在浏览时发现，很多地方HTML会被浏览器缓存，导致很多时候需要强制刷新才能看到最新的图片，这是我们需要在nginx中禁止缓存来处理</p><p>我们利用Nginx的<em>ngx_http_auth_basic_module</em>来做用户验证以保证信息的安全</p><p>上面我们为了动态的生成图片，在nginx中做了解析，<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">location ^~ /munin-cgi/munin-cgi-graph/ &#123;</span><br><span class="line">    root /data/www/html</span><br><span class="line">    fastcgi_split_path_info ^(/munin-cgi/munin-cgi-graph)(.*);</span><br><span class="line">    fastcgi_param PATH_INFO $fastcgi_path_info;</span><br><span class="line">    fastcgi_pass unix:/var/run/munin/fastcgi-graph.sock;</span><br><span class="line">    include fastcgi_params;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>在做权限认证的时候，我们首先需要生成一个用户名和密码，以供nginx使用<br>​<br>        printf “munin:$(openssl passwd -crypt 123456)\n” &gt;&gt; /etc/munin/httppwd</p><p>在这段代码的上面添加权限认证及进行缓存，通知修改一下这段解析禁止缓存<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">#munin 下面的文件不缓存</span><br><span class="line">location ~ /munin/html &#123;</span><br><span class="line">    root /data/www/html;</span><br><span class="line">    expires -1;</span><br><span class="line">    add_header Cache-Control no-store;</span><br><span class="line">    index index.html;</span><br><span class="line">    auth_basic &quot;User Auth&quot;;</span><br><span class="line">    auth_basic_user_file /etc/munin/httppwd;</span><br><span class="line">    autoindex on;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line">#munin 监控动态画图</span><br><span class="line">location ^~ /munin-cgi/munin-cgi-graph/ &#123;</span><br><span class="line">    root /data/www/html;</span><br><span class="line">    add_header Cache-Control no-store;</span><br><span class="line">    fastcgi_split_path_info ^(/munin-cgi/munin-cgi-graph)(.*);</span><br><span class="line">    fastcgi_param PATH_INFO $fastcgi_path_info;</span><br><span class="line">    fastcgi_pass unix:/var/run/munin/fastcgi-graph.sock;</span><br><span class="line">    include fastcgi_params;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>]]></content>
      
      
      <categories>
          
          <category> Linux </category>
          
      </categories>
      
      
        <tags>
            
            <tag> munin </tag>
            
            <tag> Linux </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Linux下使用mail发送邮件</title>
      <link href="/posts/47206/"/>
      <url>/posts/47206/</url>
      
        <content type="html"><![CDATA[<p>近期在做监控的时候，需要通过命令行来发送邮件。普通邮件通过25端口发送，简单配置一下即可，但是我们的邮件服务器并不支持普通的smtp邮件发送，仅仅支持smtps发送邮件，这就需要证书验证了，我们在这里通过自制证书并忽略验证来通过smtps发送邮件</p><a id="more"></a><h1 id="mailx"><a href="#mailx" class="headerlink" title="mailx"></a>mailx</h1><h2 id="安装mailx"><a href="#安装mailx" class="headerlink" title="安装mailx"></a>安装mailx</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">yum -y install mailx</span><br></pre></td></tr></table></figure><h2 id="配置mailx（smtps-465端口）"><a href="#配置mailx（smtps-465端口）" class="headerlink" title="配置mailx（smtps - 465端口）"></a>配置mailx（smtps - 465端口）</h2><p>编辑/etc/mail.rc，并添加上以下内容</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">set from=username@hostname.com         # 这里是发件人的邮箱地址</span><br><span class="line">set smtp=smtps://smtp_hostname:465   # 这里设置发件服务器的ssl地址,例：smtps://smtp.163.com:465</span><br><span class="line">set nss-config-dir=/etc/mail/.certs    # SSL证书保存位置，稍后个人制作</span><br><span class="line">set ssl-verify=ignore                  # 表示不对ssl的证书进行验证</span><br><span class="line">set smtp-auth-user=username@hostname.com  # 邮箱验证用户名，一般同邮箱地址</span><br><span class="line">set smtp-auth-password=password        # 邮箱验证密码</span><br><span class="line">set smtp-auth=login                    # 认证方式</span><br></pre></td></tr></table></figure><h2 id="配置mailx（smtp-25端口）"><a href="#配置mailx（smtp-25端口）" class="headerlink" title="配置mailx（smtp - 25端口）"></a>配置mailx（smtp - 25端口）</h2><p>smtp的发送方式相对于smtps的发送方式的配置要简单需要，因为不需要ssl验证，所以也就不需要自制证书，配置完下面部分后即可使用</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">set from=username@hostname.com         # 这里是发件人的邮箱地址</span><br><span class="line">set smtp=smtp_hostname                # 这里设置发件服务器的ssl地址,例：smtp.163.com</span><br><span class="line">set smtp-auth-user=username@hostname.com  # 邮箱验证用户名，一般同邮箱地址</span><br><span class="line">set smtp-auth-password=password        # 邮箱验证密码</span><br><span class="line">set smtp-auth=login                    # 认证方式</span><br></pre></td></tr></table></figure><h1 id="证书制作"><a href="#证书制作" class="headerlink" title="证书制作"></a>证书制作</h1><p>首先创建一个目录保存证书，然后创建证书和密钥的数据库</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">$ mkdir .certs</span><br><span class="line">$ certutil -N -d .certs</span><br></pre></td></tr></table></figure><p>然后从邮箱服务器获取证书，并导入到本地数据库（将hostname修改成对应的邮箱主机）</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">$ echo -n | openssl s_client -connect smtp_hostname:465 | sed -ne &apos;/-BEGIN CERTIFICATE-/,/-END CERTIFICATE-/p&apos; &gt; .certs/hostname.crt</span><br><span class="line">$ certutil -A -n &quot;Google Internet Authority&quot; -t &quot;C,,&quot; -d .certs -i .certs/hostname.crt</span><br></pre></td></tr></table></figure><h1 id="发送邮件"><a href="#发送邮件" class="headerlink" title="发送邮件"></a>发送邮件</h1><p>执行一下命令即可发送邮件</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">$ mail -s &quot;test&quot; keven518@163.com </span><br><span class="line">this is test email</span><br><span class="line">crtl+d</span><br></pre></td></tr></table></figure><p>crtl+d结束输入 或者执行 <code>man mailx</code>查看帮助文档</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ Error in certificate: Peer&apos;s certificate issuer is not recognized.</span><br></pre></td></tr></table></figure><p>上述错误直接无视即可</p>]]></content>
      
      
      <categories>
          
          <category> Linux </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Linux </tag>
            
            <tag> mail </tag>
            
        </tags>
      
    </entry>
    
    
  
  
</search>
